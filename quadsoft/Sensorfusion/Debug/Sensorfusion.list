
Sensorfusion.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00023818  080001a0  080001a0  000011a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000a80  080239b8  080239b8  000249b8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08024438  08024438  00026530  2**0
                  CONTENTS
  4 .ARM          00000008  08024438  08024438  00025438  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08024440  08024440  00026530  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08024440  08024440  00025440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08024444  08024444  00025444  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000530  20000000  08024448  00026000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001f30  20000530  08024978  00026530  2**3
                  ALLOC
 10 ._user_heap_stack 00008200  20002460  08024978  00027460  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00026530  2**0
                  CONTENTS, READONLY
 12 .debug_info   0003dab5  00000000  00000000  00026560  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000061ae  00000000  00000000  00064015  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00003700  00000000  00000000  0006a1c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00002a99  00000000  00000000  0006d8c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  000203f7  00000000  00000000  00070361  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0003244d  00000000  00000000  00090758  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000bcb12  00000000  00000000  000c2ba5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000093  00000000  00000000  0017f6b7  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0001072c  00000000  00000000  0017f74c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000056  00000000  00000000  0018fe78  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	@ (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	@ (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	@ (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000530 	.word	0x20000530
 80001bc:	00000000 	.word	0x00000000
 80001c0:	080239a0 	.word	0x080239a0

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	@ (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	@ (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	@ (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000534 	.word	0x20000534
 80001dc:	080239a0 	.word	0x080239a0

080001e0 <memchr>:
 80001e0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80001e4:	2a10      	cmp	r2, #16
 80001e6:	db2b      	blt.n	8000240 <memchr+0x60>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	d008      	beq.n	8000200 <memchr+0x20>
 80001ee:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001f2:	3a01      	subs	r2, #1
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d02d      	beq.n	8000254 <memchr+0x74>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	b342      	cbz	r2, 8000250 <memchr+0x70>
 80001fe:	d1f6      	bne.n	80001ee <memchr+0xe>
 8000200:	b4f0      	push	{r4, r5, r6, r7}
 8000202:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000206:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800020a:	f022 0407 	bic.w	r4, r2, #7
 800020e:	f07f 0700 	mvns.w	r7, #0
 8000212:	2300      	movs	r3, #0
 8000214:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000218:	3c08      	subs	r4, #8
 800021a:	ea85 0501 	eor.w	r5, r5, r1
 800021e:	ea86 0601 	eor.w	r6, r6, r1
 8000222:	fa85 f547 	uadd8	r5, r5, r7
 8000226:	faa3 f587 	sel	r5, r3, r7
 800022a:	fa86 f647 	uadd8	r6, r6, r7
 800022e:	faa5 f687 	sel	r6, r5, r7
 8000232:	b98e      	cbnz	r6, 8000258 <memchr+0x78>
 8000234:	d1ee      	bne.n	8000214 <memchr+0x34>
 8000236:	bcf0      	pop	{r4, r5, r6, r7}
 8000238:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800023c:	f002 0207 	and.w	r2, r2, #7
 8000240:	b132      	cbz	r2, 8000250 <memchr+0x70>
 8000242:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000246:	3a01      	subs	r2, #1
 8000248:	ea83 0301 	eor.w	r3, r3, r1
 800024c:	b113      	cbz	r3, 8000254 <memchr+0x74>
 800024e:	d1f8      	bne.n	8000242 <memchr+0x62>
 8000250:	2000      	movs	r0, #0
 8000252:	4770      	bx	lr
 8000254:	3801      	subs	r0, #1
 8000256:	4770      	bx	lr
 8000258:	2d00      	cmp	r5, #0
 800025a:	bf06      	itte	eq
 800025c:	4635      	moveq	r5, r6
 800025e:	3803      	subeq	r0, #3
 8000260:	3807      	subne	r0, #7
 8000262:	f015 0f01 	tst.w	r5, #1
 8000266:	d107      	bne.n	8000278 <memchr+0x98>
 8000268:	3001      	adds	r0, #1
 800026a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800026e:	bf02      	ittt	eq
 8000270:	3001      	addeq	r0, #1
 8000272:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000276:	3001      	addeq	r0, #1
 8000278:	bcf0      	pop	{r4, r5, r6, r7}
 800027a:	3801      	subs	r0, #1
 800027c:	4770      	bx	lr
 800027e:	bf00      	nop

08000280 <strlen>:
 8000280:	4603      	mov	r3, r0
 8000282:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000286:	2a00      	cmp	r2, #0
 8000288:	d1fb      	bne.n	8000282 <strlen+0x2>
 800028a:	1a18      	subs	r0, r3, r0
 800028c:	3801      	subs	r0, #1
 800028e:	4770      	bx	lr

08000290 <__aeabi_drsub>:
 8000290:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8000294:	e002      	b.n	800029c <__adddf3>
 8000296:	bf00      	nop

08000298 <__aeabi_dsub>:
 8000298:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

0800029c <__adddf3>:
 800029c:	b530      	push	{r4, r5, lr}
 800029e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002a2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002a6:	ea94 0f05 	teq	r4, r5
 80002aa:	bf08      	it	eq
 80002ac:	ea90 0f02 	teqeq	r0, r2
 80002b0:	bf1f      	itttt	ne
 80002b2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002b6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002ba:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002be:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002c2:	f000 80e2 	beq.w	800048a <__adddf3+0x1ee>
 80002c6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ca:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ce:	bfb8      	it	lt
 80002d0:	426d      	neglt	r5, r5
 80002d2:	dd0c      	ble.n	80002ee <__adddf3+0x52>
 80002d4:	442c      	add	r4, r5
 80002d6:	ea80 0202 	eor.w	r2, r0, r2
 80002da:	ea81 0303 	eor.w	r3, r1, r3
 80002de:	ea82 0000 	eor.w	r0, r2, r0
 80002e2:	ea83 0101 	eor.w	r1, r3, r1
 80002e6:	ea80 0202 	eor.w	r2, r0, r2
 80002ea:	ea81 0303 	eor.w	r3, r1, r3
 80002ee:	2d36      	cmp	r5, #54	@ 0x36
 80002f0:	bf88      	it	hi
 80002f2:	bd30      	pophi	{r4, r5, pc}
 80002f4:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80002f8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80002fc:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000300:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000304:	d002      	beq.n	800030c <__adddf3+0x70>
 8000306:	4240      	negs	r0, r0
 8000308:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800030c:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 8000310:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000314:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000318:	d002      	beq.n	8000320 <__adddf3+0x84>
 800031a:	4252      	negs	r2, r2
 800031c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000320:	ea94 0f05 	teq	r4, r5
 8000324:	f000 80a7 	beq.w	8000476 <__adddf3+0x1da>
 8000328:	f1a4 0401 	sub.w	r4, r4, #1
 800032c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000330:	db0d      	blt.n	800034e <__adddf3+0xb2>
 8000332:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000336:	fa22 f205 	lsr.w	r2, r2, r5
 800033a:	1880      	adds	r0, r0, r2
 800033c:	f141 0100 	adc.w	r1, r1, #0
 8000340:	fa03 f20e 	lsl.w	r2, r3, lr
 8000344:	1880      	adds	r0, r0, r2
 8000346:	fa43 f305 	asr.w	r3, r3, r5
 800034a:	4159      	adcs	r1, r3
 800034c:	e00e      	b.n	800036c <__adddf3+0xd0>
 800034e:	f1a5 0520 	sub.w	r5, r5, #32
 8000352:	f10e 0e20 	add.w	lr, lr, #32
 8000356:	2a01      	cmp	r2, #1
 8000358:	fa03 fc0e 	lsl.w	ip, r3, lr
 800035c:	bf28      	it	cs
 800035e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000362:	fa43 f305 	asr.w	r3, r3, r5
 8000366:	18c0      	adds	r0, r0, r3
 8000368:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800036c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000370:	d507      	bpl.n	8000382 <__adddf3+0xe6>
 8000372:	f04f 0e00 	mov.w	lr, #0
 8000376:	f1dc 0c00 	rsbs	ip, ip, #0
 800037a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800037e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000382:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000386:	d31b      	bcc.n	80003c0 <__adddf3+0x124>
 8000388:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 800038c:	d30c      	bcc.n	80003a8 <__adddf3+0x10c>
 800038e:	0849      	lsrs	r1, r1, #1
 8000390:	ea5f 0030 	movs.w	r0, r0, rrx
 8000394:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000398:	f104 0401 	add.w	r4, r4, #1
 800039c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003a0:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 80003a4:	f080 809a 	bcs.w	80004dc <__adddf3+0x240>
 80003a8:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 80003ac:	bf08      	it	eq
 80003ae:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003b2:	f150 0000 	adcs.w	r0, r0, #0
 80003b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003ba:	ea41 0105 	orr.w	r1, r1, r5
 80003be:	bd30      	pop	{r4, r5, pc}
 80003c0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003c4:	4140      	adcs	r0, r0
 80003c6:	eb41 0101 	adc.w	r1, r1, r1
 80003ca:	3c01      	subs	r4, #1
 80003cc:	bf28      	it	cs
 80003ce:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80003d2:	d2e9      	bcs.n	80003a8 <__adddf3+0x10c>
 80003d4:	f091 0f00 	teq	r1, #0
 80003d8:	bf04      	itt	eq
 80003da:	4601      	moveq	r1, r0
 80003dc:	2000      	moveq	r0, #0
 80003de:	fab1 f381 	clz	r3, r1
 80003e2:	bf08      	it	eq
 80003e4:	3320      	addeq	r3, #32
 80003e6:	f1a3 030b 	sub.w	r3, r3, #11
 80003ea:	f1b3 0220 	subs.w	r2, r3, #32
 80003ee:	da0c      	bge.n	800040a <__adddf3+0x16e>
 80003f0:	320c      	adds	r2, #12
 80003f2:	dd08      	ble.n	8000406 <__adddf3+0x16a>
 80003f4:	f102 0c14 	add.w	ip, r2, #20
 80003f8:	f1c2 020c 	rsb	r2, r2, #12
 80003fc:	fa01 f00c 	lsl.w	r0, r1, ip
 8000400:	fa21 f102 	lsr.w	r1, r1, r2
 8000404:	e00c      	b.n	8000420 <__adddf3+0x184>
 8000406:	f102 0214 	add.w	r2, r2, #20
 800040a:	bfd8      	it	le
 800040c:	f1c2 0c20 	rsble	ip, r2, #32
 8000410:	fa01 f102 	lsl.w	r1, r1, r2
 8000414:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000418:	bfdc      	itt	le
 800041a:	ea41 010c 	orrle.w	r1, r1, ip
 800041e:	4090      	lslle	r0, r2
 8000420:	1ae4      	subs	r4, r4, r3
 8000422:	bfa2      	ittt	ge
 8000424:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000428:	4329      	orrge	r1, r5
 800042a:	bd30      	popge	{r4, r5, pc}
 800042c:	ea6f 0404 	mvn.w	r4, r4
 8000430:	3c1f      	subs	r4, #31
 8000432:	da1c      	bge.n	800046e <__adddf3+0x1d2>
 8000434:	340c      	adds	r4, #12
 8000436:	dc0e      	bgt.n	8000456 <__adddf3+0x1ba>
 8000438:	f104 0414 	add.w	r4, r4, #20
 800043c:	f1c4 0220 	rsb	r2, r4, #32
 8000440:	fa20 f004 	lsr.w	r0, r0, r4
 8000444:	fa01 f302 	lsl.w	r3, r1, r2
 8000448:	ea40 0003 	orr.w	r0, r0, r3
 800044c:	fa21 f304 	lsr.w	r3, r1, r4
 8000450:	ea45 0103 	orr.w	r1, r5, r3
 8000454:	bd30      	pop	{r4, r5, pc}
 8000456:	f1c4 040c 	rsb	r4, r4, #12
 800045a:	f1c4 0220 	rsb	r2, r4, #32
 800045e:	fa20 f002 	lsr.w	r0, r0, r2
 8000462:	fa01 f304 	lsl.w	r3, r1, r4
 8000466:	ea40 0003 	orr.w	r0, r0, r3
 800046a:	4629      	mov	r1, r5
 800046c:	bd30      	pop	{r4, r5, pc}
 800046e:	fa21 f004 	lsr.w	r0, r1, r4
 8000472:	4629      	mov	r1, r5
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f094 0f00 	teq	r4, #0
 800047a:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800047e:	bf06      	itte	eq
 8000480:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000484:	3401      	addeq	r4, #1
 8000486:	3d01      	subne	r5, #1
 8000488:	e74e      	b.n	8000328 <__adddf3+0x8c>
 800048a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800048e:	bf18      	it	ne
 8000490:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000494:	d029      	beq.n	80004ea <__adddf3+0x24e>
 8000496:	ea94 0f05 	teq	r4, r5
 800049a:	bf08      	it	eq
 800049c:	ea90 0f02 	teqeq	r0, r2
 80004a0:	d005      	beq.n	80004ae <__adddf3+0x212>
 80004a2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004a6:	bf04      	itt	eq
 80004a8:	4619      	moveq	r1, r3
 80004aa:	4610      	moveq	r0, r2
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	ea91 0f03 	teq	r1, r3
 80004b2:	bf1e      	ittt	ne
 80004b4:	2100      	movne	r1, #0
 80004b6:	2000      	movne	r0, #0
 80004b8:	bd30      	popne	{r4, r5, pc}
 80004ba:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004be:	d105      	bne.n	80004cc <__adddf3+0x230>
 80004c0:	0040      	lsls	r0, r0, #1
 80004c2:	4149      	adcs	r1, r1
 80004c4:	bf28      	it	cs
 80004c6:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 80004ca:	bd30      	pop	{r4, r5, pc}
 80004cc:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80004d0:	bf3c      	itt	cc
 80004d2:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80004d6:	bd30      	popcc	{r4, r5, pc}
 80004d8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80004dc:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80004e0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80004e4:	f04f 0000 	mov.w	r0, #0
 80004e8:	bd30      	pop	{r4, r5, pc}
 80004ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ee:	bf1a      	itte	ne
 80004f0:	4619      	movne	r1, r3
 80004f2:	4610      	movne	r0, r2
 80004f4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80004f8:	bf1c      	itt	ne
 80004fa:	460b      	movne	r3, r1
 80004fc:	4602      	movne	r2, r0
 80004fe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000502:	bf06      	itte	eq
 8000504:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000508:	ea91 0f03 	teqeq	r1, r3
 800050c:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 8000510:	bd30      	pop	{r4, r5, pc}
 8000512:	bf00      	nop

08000514 <__aeabi_ui2d>:
 8000514:	f090 0f00 	teq	r0, #0
 8000518:	bf04      	itt	eq
 800051a:	2100      	moveq	r1, #0
 800051c:	4770      	bxeq	lr
 800051e:	b530      	push	{r4, r5, lr}
 8000520:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000524:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000528:	f04f 0500 	mov.w	r5, #0
 800052c:	f04f 0100 	mov.w	r1, #0
 8000530:	e750      	b.n	80003d4 <__adddf3+0x138>
 8000532:	bf00      	nop

08000534 <__aeabi_i2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000548:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 800054c:	bf48      	it	mi
 800054e:	4240      	negmi	r0, r0
 8000550:	f04f 0100 	mov.w	r1, #0
 8000554:	e73e      	b.n	80003d4 <__adddf3+0x138>
 8000556:	bf00      	nop

08000558 <__aeabi_f2d>:
 8000558:	0042      	lsls	r2, r0, #1
 800055a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800055e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000562:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000566:	bf1f      	itttt	ne
 8000568:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 800056c:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8000570:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000574:	4770      	bxne	lr
 8000576:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 800057a:	bf08      	it	eq
 800057c:	4770      	bxeq	lr
 800057e:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 8000582:	bf04      	itt	eq
 8000584:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000588:	4770      	bxeq	lr
 800058a:	b530      	push	{r4, r5, lr}
 800058c:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8000590:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000594:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000598:	e71c      	b.n	80003d4 <__adddf3+0x138>
 800059a:	bf00      	nop

0800059c <__aeabi_ul2d>:
 800059c:	ea50 0201 	orrs.w	r2, r0, r1
 80005a0:	bf08      	it	eq
 80005a2:	4770      	bxeq	lr
 80005a4:	b530      	push	{r4, r5, lr}
 80005a6:	f04f 0500 	mov.w	r5, #0
 80005aa:	e00a      	b.n	80005c2 <__aeabi_l2d+0x16>

080005ac <__aeabi_l2d>:
 80005ac:	ea50 0201 	orrs.w	r2, r0, r1
 80005b0:	bf08      	it	eq
 80005b2:	4770      	bxeq	lr
 80005b4:	b530      	push	{r4, r5, lr}
 80005b6:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 80005ba:	d502      	bpl.n	80005c2 <__aeabi_l2d+0x16>
 80005bc:	4240      	negs	r0, r0
 80005be:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005c2:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80005c6:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80005ca:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005ce:	f43f aed8 	beq.w	8000382 <__adddf3+0xe6>
 80005d2:	f04f 0203 	mov.w	r2, #3
 80005d6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005da:	bf18      	it	ne
 80005dc:	3203      	addne	r2, #3
 80005de:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005e2:	bf18      	it	ne
 80005e4:	3203      	addne	r2, #3
 80005e6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80005ea:	f1c2 0320 	rsb	r3, r2, #32
 80005ee:	fa00 fc03 	lsl.w	ip, r0, r3
 80005f2:	fa20 f002 	lsr.w	r0, r0, r2
 80005f6:	fa01 fe03 	lsl.w	lr, r1, r3
 80005fa:	ea40 000e 	orr.w	r0, r0, lr
 80005fe:	fa21 f102 	lsr.w	r1, r1, r2
 8000602:	4414      	add	r4, r2
 8000604:	e6bd      	b.n	8000382 <__adddf3+0xe6>
 8000606:	bf00      	nop

08000608 <__aeabi_dmul>:
 8000608:	b570      	push	{r4, r5, r6, lr}
 800060a:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 800060e:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8000612:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000616:	bf1d      	ittte	ne
 8000618:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800061c:	ea94 0f0c 	teqne	r4, ip
 8000620:	ea95 0f0c 	teqne	r5, ip
 8000624:	f000 f8de 	bleq	80007e4 <__aeabi_dmul+0x1dc>
 8000628:	442c      	add	r4, r5
 800062a:	ea81 0603 	eor.w	r6, r1, r3
 800062e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000632:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000636:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800063a:	bf18      	it	ne
 800063c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000640:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000644:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000648:	d038      	beq.n	80006bc <__aeabi_dmul+0xb4>
 800064a:	fba0 ce02 	umull	ip, lr, r0, r2
 800064e:	f04f 0500 	mov.w	r5, #0
 8000652:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000656:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 800065a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800065e:	f04f 0600 	mov.w	r6, #0
 8000662:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000666:	f09c 0f00 	teq	ip, #0
 800066a:	bf18      	it	ne
 800066c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000670:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 8000674:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8000678:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 800067c:	d204      	bcs.n	8000688 <__aeabi_dmul+0x80>
 800067e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000682:	416d      	adcs	r5, r5
 8000684:	eb46 0606 	adc.w	r6, r6, r6
 8000688:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800068c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000690:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000694:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000698:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800069c:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 80006a0:	bf88      	it	hi
 80006a2:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 80006a6:	d81e      	bhi.n	80006e6 <__aeabi_dmul+0xde>
 80006a8:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 80006ac:	bf08      	it	eq
 80006ae:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006b2:	f150 0000 	adcs.w	r0, r0, #0
 80006b6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006ba:	bd70      	pop	{r4, r5, r6, pc}
 80006bc:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 80006c0:	ea46 0101 	orr.w	r1, r6, r1
 80006c4:	ea40 0002 	orr.w	r0, r0, r2
 80006c8:	ea81 0103 	eor.w	r1, r1, r3
 80006cc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006d0:	bfc2      	ittt	gt
 80006d2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006d6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006da:	bd70      	popgt	{r4, r5, r6, pc}
 80006dc:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80006e0:	f04f 0e00 	mov.w	lr, #0
 80006e4:	3c01      	subs	r4, #1
 80006e6:	f300 80ab 	bgt.w	8000840 <__aeabi_dmul+0x238>
 80006ea:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 80006ee:	bfde      	ittt	le
 80006f0:	2000      	movle	r0, #0
 80006f2:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 80006f6:	bd70      	pople	{r4, r5, r6, pc}
 80006f8:	f1c4 0400 	rsb	r4, r4, #0
 80006fc:	3c20      	subs	r4, #32
 80006fe:	da35      	bge.n	800076c <__aeabi_dmul+0x164>
 8000700:	340c      	adds	r4, #12
 8000702:	dc1b      	bgt.n	800073c <__aeabi_dmul+0x134>
 8000704:	f104 0414 	add.w	r4, r4, #20
 8000708:	f1c4 0520 	rsb	r5, r4, #32
 800070c:	fa00 f305 	lsl.w	r3, r0, r5
 8000710:	fa20 f004 	lsr.w	r0, r0, r4
 8000714:	fa01 f205 	lsl.w	r2, r1, r5
 8000718:	ea40 0002 	orr.w	r0, r0, r2
 800071c:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 8000720:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000724:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000728:	fa21 f604 	lsr.w	r6, r1, r4
 800072c:	eb42 0106 	adc.w	r1, r2, r6
 8000730:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000734:	bf08      	it	eq
 8000736:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800073a:	bd70      	pop	{r4, r5, r6, pc}
 800073c:	f1c4 040c 	rsb	r4, r4, #12
 8000740:	f1c4 0520 	rsb	r5, r4, #32
 8000744:	fa00 f304 	lsl.w	r3, r0, r4
 8000748:	fa20 f005 	lsr.w	r0, r0, r5
 800074c:	fa01 f204 	lsl.w	r2, r1, r4
 8000750:	ea40 0002 	orr.w	r0, r0, r2
 8000754:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000758:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800075c:	f141 0100 	adc.w	r1, r1, #0
 8000760:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000764:	bf08      	it	eq
 8000766:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800076a:	bd70      	pop	{r4, r5, r6, pc}
 800076c:	f1c4 0520 	rsb	r5, r4, #32
 8000770:	fa00 f205 	lsl.w	r2, r0, r5
 8000774:	ea4e 0e02 	orr.w	lr, lr, r2
 8000778:	fa20 f304 	lsr.w	r3, r0, r4
 800077c:	fa01 f205 	lsl.w	r2, r1, r5
 8000780:	ea43 0302 	orr.w	r3, r3, r2
 8000784:	fa21 f004 	lsr.w	r0, r1, r4
 8000788:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800078c:	fa21 f204 	lsr.w	r2, r1, r4
 8000790:	ea20 0002 	bic.w	r0, r0, r2
 8000794:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000798:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800079c:	bf08      	it	eq
 800079e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007a2:	bd70      	pop	{r4, r5, r6, pc}
 80007a4:	f094 0f00 	teq	r4, #0
 80007a8:	d10f      	bne.n	80007ca <__aeabi_dmul+0x1c2>
 80007aa:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 80007ae:	0040      	lsls	r0, r0, #1
 80007b0:	eb41 0101 	adc.w	r1, r1, r1
 80007b4:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 80007b8:	bf08      	it	eq
 80007ba:	3c01      	subeq	r4, #1
 80007bc:	d0f7      	beq.n	80007ae <__aeabi_dmul+0x1a6>
 80007be:	ea41 0106 	orr.w	r1, r1, r6
 80007c2:	f095 0f00 	teq	r5, #0
 80007c6:	bf18      	it	ne
 80007c8:	4770      	bxne	lr
 80007ca:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 80007ce:	0052      	lsls	r2, r2, #1
 80007d0:	eb43 0303 	adc.w	r3, r3, r3
 80007d4:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 80007d8:	bf08      	it	eq
 80007da:	3d01      	subeq	r5, #1
 80007dc:	d0f7      	beq.n	80007ce <__aeabi_dmul+0x1c6>
 80007de:	ea43 0306 	orr.w	r3, r3, r6
 80007e2:	4770      	bx	lr
 80007e4:	ea94 0f0c 	teq	r4, ip
 80007e8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80007ec:	bf18      	it	ne
 80007ee:	ea95 0f0c 	teqne	r5, ip
 80007f2:	d00c      	beq.n	800080e <__aeabi_dmul+0x206>
 80007f4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007f8:	bf18      	it	ne
 80007fa:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007fe:	d1d1      	bne.n	80007a4 <__aeabi_dmul+0x19c>
 8000800:	ea81 0103 	eor.w	r1, r1, r3
 8000804:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000808:	f04f 0000 	mov.w	r0, #0
 800080c:	bd70      	pop	{r4, r5, r6, pc}
 800080e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000812:	bf06      	itte	eq
 8000814:	4610      	moveq	r0, r2
 8000816:	4619      	moveq	r1, r3
 8000818:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800081c:	d019      	beq.n	8000852 <__aeabi_dmul+0x24a>
 800081e:	ea94 0f0c 	teq	r4, ip
 8000822:	d102      	bne.n	800082a <__aeabi_dmul+0x222>
 8000824:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000828:	d113      	bne.n	8000852 <__aeabi_dmul+0x24a>
 800082a:	ea95 0f0c 	teq	r5, ip
 800082e:	d105      	bne.n	800083c <__aeabi_dmul+0x234>
 8000830:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000834:	bf1c      	itt	ne
 8000836:	4610      	movne	r0, r2
 8000838:	4619      	movne	r1, r3
 800083a:	d10a      	bne.n	8000852 <__aeabi_dmul+0x24a>
 800083c:	ea81 0103 	eor.w	r1, r1, r3
 8000840:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000844:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000848:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800084c:	f04f 0000 	mov.w	r0, #0
 8000850:	bd70      	pop	{r4, r5, r6, pc}
 8000852:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000856:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 800085a:	bd70      	pop	{r4, r5, r6, pc}

0800085c <__aeabi_ddiv>:
 800085c:	b570      	push	{r4, r5, r6, lr}
 800085e:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000862:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8000866:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800086a:	bf1d      	ittte	ne
 800086c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000870:	ea94 0f0c 	teqne	r4, ip
 8000874:	ea95 0f0c 	teqne	r5, ip
 8000878:	f000 f8a7 	bleq	80009ca <__aeabi_ddiv+0x16e>
 800087c:	eba4 0405 	sub.w	r4, r4, r5
 8000880:	ea81 0e03 	eor.w	lr, r1, r3
 8000884:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000888:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800088c:	f000 8088 	beq.w	80009a0 <__aeabi_ddiv+0x144>
 8000890:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000894:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 8000898:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800089c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008a0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008a4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008a8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008ac:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008b0:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 80008b4:	429d      	cmp	r5, r3
 80008b6:	bf08      	it	eq
 80008b8:	4296      	cmpeq	r6, r2
 80008ba:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 80008be:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 80008c2:	d202      	bcs.n	80008ca <__aeabi_ddiv+0x6e>
 80008c4:	085b      	lsrs	r3, r3, #1
 80008c6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ca:	1ab6      	subs	r6, r6, r2
 80008cc:	eb65 0503 	sbc.w	r5, r5, r3
 80008d0:	085b      	lsrs	r3, r3, #1
 80008d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008d6:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 80008da:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 80008de:	ebb6 0e02 	subs.w	lr, r6, r2
 80008e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008e6:	bf22      	ittt	cs
 80008e8:	1ab6      	subcs	r6, r6, r2
 80008ea:	4675      	movcs	r5, lr
 80008ec:	ea40 000c 	orrcs.w	r0, r0, ip
 80008f0:	085b      	lsrs	r3, r3, #1
 80008f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008fe:	bf22      	ittt	cs
 8000900:	1ab6      	subcs	r6, r6, r2
 8000902:	4675      	movcs	r5, lr
 8000904:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000908:	085b      	lsrs	r3, r3, #1
 800090a:	ea4f 0232 	mov.w	r2, r2, rrx
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000938:	ea55 0e06 	orrs.w	lr, r5, r6
 800093c:	d018      	beq.n	8000970 <__aeabi_ddiv+0x114>
 800093e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000942:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000946:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800094a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800094e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000952:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000956:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800095a:	d1c0      	bne.n	80008de <__aeabi_ddiv+0x82>
 800095c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000960:	d10b      	bne.n	800097a <__aeabi_ddiv+0x11e>
 8000962:	ea41 0100 	orr.w	r1, r1, r0
 8000966:	f04f 0000 	mov.w	r0, #0
 800096a:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 800096e:	e7b6      	b.n	80008de <__aeabi_ddiv+0x82>
 8000970:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000974:	bf04      	itt	eq
 8000976:	4301      	orreq	r1, r0
 8000978:	2000      	moveq	r0, #0
 800097a:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 800097e:	bf88      	it	hi
 8000980:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000984:	f63f aeaf 	bhi.w	80006e6 <__aeabi_dmul+0xde>
 8000988:	ebb5 0c03 	subs.w	ip, r5, r3
 800098c:	bf04      	itt	eq
 800098e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000992:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000996:	f150 0000 	adcs.w	r0, r0, #0
 800099a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800099e:	bd70      	pop	{r4, r5, r6, pc}
 80009a0:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 80009a4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009a8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009ac:	bfc2      	ittt	gt
 80009ae:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009b2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009b6:	bd70      	popgt	{r4, r5, r6, pc}
 80009b8:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80009bc:	f04f 0e00 	mov.w	lr, #0
 80009c0:	3c01      	subs	r4, #1
 80009c2:	e690      	b.n	80006e6 <__aeabi_dmul+0xde>
 80009c4:	ea45 0e06 	orr.w	lr, r5, r6
 80009c8:	e68d      	b.n	80006e6 <__aeabi_dmul+0xde>
 80009ca:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009ce:	ea94 0f0c 	teq	r4, ip
 80009d2:	bf08      	it	eq
 80009d4:	ea95 0f0c 	teqeq	r5, ip
 80009d8:	f43f af3b 	beq.w	8000852 <__aeabi_dmul+0x24a>
 80009dc:	ea94 0f0c 	teq	r4, ip
 80009e0:	d10a      	bne.n	80009f8 <__aeabi_ddiv+0x19c>
 80009e2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009e6:	f47f af34 	bne.w	8000852 <__aeabi_dmul+0x24a>
 80009ea:	ea95 0f0c 	teq	r5, ip
 80009ee:	f47f af25 	bne.w	800083c <__aeabi_dmul+0x234>
 80009f2:	4610      	mov	r0, r2
 80009f4:	4619      	mov	r1, r3
 80009f6:	e72c      	b.n	8000852 <__aeabi_dmul+0x24a>
 80009f8:	ea95 0f0c 	teq	r5, ip
 80009fc:	d106      	bne.n	8000a0c <__aeabi_ddiv+0x1b0>
 80009fe:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a02:	f43f aefd 	beq.w	8000800 <__aeabi_dmul+0x1f8>
 8000a06:	4610      	mov	r0, r2
 8000a08:	4619      	mov	r1, r3
 8000a0a:	e722      	b.n	8000852 <__aeabi_dmul+0x24a>
 8000a0c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a10:	bf18      	it	ne
 8000a12:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a16:	f47f aec5 	bne.w	80007a4 <__aeabi_dmul+0x19c>
 8000a1a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a1e:	f47f af0d 	bne.w	800083c <__aeabi_dmul+0x234>
 8000a22:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a26:	f47f aeeb 	bne.w	8000800 <__aeabi_dmul+0x1f8>
 8000a2a:	e712      	b.n	8000852 <__aeabi_dmul+0x24a>

08000a2c <__gedf2>:
 8000a2c:	f04f 3cff 	mov.w	ip, #4294967295	@ 0xffffffff
 8000a30:	e006      	b.n	8000a40 <__cmpdf2+0x4>
 8000a32:	bf00      	nop

08000a34 <__ledf2>:
 8000a34:	f04f 0c01 	mov.w	ip, #1
 8000a38:	e002      	b.n	8000a40 <__cmpdf2+0x4>
 8000a3a:	bf00      	nop

08000a3c <__cmpdf2>:
 8000a3c:	f04f 0c01 	mov.w	ip, #1
 8000a40:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a44:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a48:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a4c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a50:	bf18      	it	ne
 8000a52:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a56:	d01b      	beq.n	8000a90 <__cmpdf2+0x54>
 8000a58:	b001      	add	sp, #4
 8000a5a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a5e:	bf0c      	ite	eq
 8000a60:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a64:	ea91 0f03 	teqne	r1, r3
 8000a68:	bf02      	ittt	eq
 8000a6a:	ea90 0f02 	teqeq	r0, r2
 8000a6e:	2000      	moveq	r0, #0
 8000a70:	4770      	bxeq	lr
 8000a72:	f110 0f00 	cmn.w	r0, #0
 8000a76:	ea91 0f03 	teq	r1, r3
 8000a7a:	bf58      	it	pl
 8000a7c:	4299      	cmppl	r1, r3
 8000a7e:	bf08      	it	eq
 8000a80:	4290      	cmpeq	r0, r2
 8000a82:	bf2c      	ite	cs
 8000a84:	17d8      	asrcs	r0, r3, #31
 8000a86:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000a8a:	f040 0001 	orr.w	r0, r0, #1
 8000a8e:	4770      	bx	lr
 8000a90:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a94:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a98:	d102      	bne.n	8000aa0 <__cmpdf2+0x64>
 8000a9a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000a9e:	d107      	bne.n	8000ab0 <__cmpdf2+0x74>
 8000aa0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000aa4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000aa8:	d1d6      	bne.n	8000a58 <__cmpdf2+0x1c>
 8000aaa:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000aae:	d0d3      	beq.n	8000a58 <__cmpdf2+0x1c>
 8000ab0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000ab4:	4770      	bx	lr
 8000ab6:	bf00      	nop

08000ab8 <__aeabi_cdrcmple>:
 8000ab8:	4684      	mov	ip, r0
 8000aba:	4610      	mov	r0, r2
 8000abc:	4662      	mov	r2, ip
 8000abe:	468c      	mov	ip, r1
 8000ac0:	4619      	mov	r1, r3
 8000ac2:	4663      	mov	r3, ip
 8000ac4:	e000      	b.n	8000ac8 <__aeabi_cdcmpeq>
 8000ac6:	bf00      	nop

08000ac8 <__aeabi_cdcmpeq>:
 8000ac8:	b501      	push	{r0, lr}
 8000aca:	f7ff ffb7 	bl	8000a3c <__cmpdf2>
 8000ace:	2800      	cmp	r0, #0
 8000ad0:	bf48      	it	mi
 8000ad2:	f110 0f00 	cmnmi.w	r0, #0
 8000ad6:	bd01      	pop	{r0, pc}

08000ad8 <__aeabi_dcmpeq>:
 8000ad8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000adc:	f7ff fff4 	bl	8000ac8 <__aeabi_cdcmpeq>
 8000ae0:	bf0c      	ite	eq
 8000ae2:	2001      	moveq	r0, #1
 8000ae4:	2000      	movne	r0, #0
 8000ae6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000aea:	bf00      	nop

08000aec <__aeabi_dcmplt>:
 8000aec:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000af0:	f7ff ffea 	bl	8000ac8 <__aeabi_cdcmpeq>
 8000af4:	bf34      	ite	cc
 8000af6:	2001      	movcc	r0, #1
 8000af8:	2000      	movcs	r0, #0
 8000afa:	f85d fb08 	ldr.w	pc, [sp], #8
 8000afe:	bf00      	nop

08000b00 <__aeabi_dcmple>:
 8000b00:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b04:	f7ff ffe0 	bl	8000ac8 <__aeabi_cdcmpeq>
 8000b08:	bf94      	ite	ls
 8000b0a:	2001      	movls	r0, #1
 8000b0c:	2000      	movhi	r0, #0
 8000b0e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b12:	bf00      	nop

08000b14 <__aeabi_dcmpge>:
 8000b14:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b18:	f7ff ffce 	bl	8000ab8 <__aeabi_cdrcmple>
 8000b1c:	bf94      	ite	ls
 8000b1e:	2001      	movls	r0, #1
 8000b20:	2000      	movhi	r0, #0
 8000b22:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b26:	bf00      	nop

08000b28 <__aeabi_dcmpgt>:
 8000b28:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b2c:	f7ff ffc4 	bl	8000ab8 <__aeabi_cdrcmple>
 8000b30:	bf34      	ite	cc
 8000b32:	2001      	movcc	r0, #1
 8000b34:	2000      	movcs	r0, #0
 8000b36:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b3a:	bf00      	nop

08000b3c <__aeabi_dcmpun>:
 8000b3c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b40:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b44:	d102      	bne.n	8000b4c <__aeabi_dcmpun+0x10>
 8000b46:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b4a:	d10a      	bne.n	8000b62 <__aeabi_dcmpun+0x26>
 8000b4c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b50:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b54:	d102      	bne.n	8000b5c <__aeabi_dcmpun+0x20>
 8000b56:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b5a:	d102      	bne.n	8000b62 <__aeabi_dcmpun+0x26>
 8000b5c:	f04f 0000 	mov.w	r0, #0
 8000b60:	4770      	bx	lr
 8000b62:	f04f 0001 	mov.w	r0, #1
 8000b66:	4770      	bx	lr

08000b68 <__aeabi_d2iz>:
 8000b68:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b6c:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8000b70:	d215      	bcs.n	8000b9e <__aeabi_d2iz+0x36>
 8000b72:	d511      	bpl.n	8000b98 <__aeabi_d2iz+0x30>
 8000b74:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8000b78:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b7c:	d912      	bls.n	8000ba4 <__aeabi_d2iz+0x3c>
 8000b7e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b82:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8000b86:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000b8a:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000b8e:	fa23 f002 	lsr.w	r0, r3, r2
 8000b92:	bf18      	it	ne
 8000b94:	4240      	negne	r0, r0
 8000b96:	4770      	bx	lr
 8000b98:	f04f 0000 	mov.w	r0, #0
 8000b9c:	4770      	bx	lr
 8000b9e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000ba2:	d105      	bne.n	8000bb0 <__aeabi_d2iz+0x48>
 8000ba4:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
 8000ba8:	bf08      	it	eq
 8000baa:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
 8000bae:	4770      	bx	lr
 8000bb0:	f04f 0000 	mov.w	r0, #0
 8000bb4:	4770      	bx	lr
 8000bb6:	bf00      	nop

08000bb8 <__aeabi_d2uiz>:
 8000bb8:	004a      	lsls	r2, r1, #1
 8000bba:	d211      	bcs.n	8000be0 <__aeabi_d2uiz+0x28>
 8000bbc:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8000bc0:	d211      	bcs.n	8000be6 <__aeabi_d2uiz+0x2e>
 8000bc2:	d50d      	bpl.n	8000be0 <__aeabi_d2uiz+0x28>
 8000bc4:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8000bc8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000bcc:	d40e      	bmi.n	8000bec <__aeabi_d2uiz+0x34>
 8000bce:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000bd2:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8000bd6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000bda:	fa23 f002 	lsr.w	r0, r3, r2
 8000bde:	4770      	bx	lr
 8000be0:	f04f 0000 	mov.w	r0, #0
 8000be4:	4770      	bx	lr
 8000be6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000bea:	d102      	bne.n	8000bf2 <__aeabi_d2uiz+0x3a>
 8000bec:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8000bf0:	4770      	bx	lr
 8000bf2:	f04f 0000 	mov.w	r0, #0
 8000bf6:	4770      	bx	lr

08000bf8 <__aeabi_d2f>:
 8000bf8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000bfc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000c00:	bf24      	itt	cs
 8000c02:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000c06:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000c0a:	d90d      	bls.n	8000c28 <__aeabi_d2f+0x30>
 8000c0c:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000c10:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000c14:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000c18:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000c1c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000c20:	bf08      	it	eq
 8000c22:	f020 0001 	biceq.w	r0, r0, #1
 8000c26:	4770      	bx	lr
 8000c28:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000c2c:	d121      	bne.n	8000c72 <__aeabi_d2f+0x7a>
 8000c2e:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000c32:	bfbc      	itt	lt
 8000c34:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000c38:	4770      	bxlt	lr
 8000c3a:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000c3e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000c42:	f1c2 0218 	rsb	r2, r2, #24
 8000c46:	f1c2 0c20 	rsb	ip, r2, #32
 8000c4a:	fa10 f30c 	lsls.w	r3, r0, ip
 8000c4e:	fa20 f002 	lsr.w	r0, r0, r2
 8000c52:	bf18      	it	ne
 8000c54:	f040 0001 	orrne.w	r0, r0, #1
 8000c58:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c5c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000c60:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000c64:	ea40 000c 	orr.w	r0, r0, ip
 8000c68:	fa23 f302 	lsr.w	r3, r3, r2
 8000c6c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000c70:	e7cc      	b.n	8000c0c <__aeabi_d2f+0x14>
 8000c72:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000c76:	d107      	bne.n	8000c88 <__aeabi_d2f+0x90>
 8000c78:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000c7c:	bf1e      	ittt	ne
 8000c7e:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000c82:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000c86:	4770      	bxne	lr
 8000c88:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000c8c:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000c90:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000c94:	4770      	bx	lr
 8000c96:	bf00      	nop

08000c98 <__aeabi_uldivmod>:
 8000c98:	b953      	cbnz	r3, 8000cb0 <__aeabi_uldivmod+0x18>
 8000c9a:	b94a      	cbnz	r2, 8000cb0 <__aeabi_uldivmod+0x18>
 8000c9c:	2900      	cmp	r1, #0
 8000c9e:	bf08      	it	eq
 8000ca0:	2800      	cmpeq	r0, #0
 8000ca2:	bf1c      	itt	ne
 8000ca4:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
 8000ca8:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
 8000cac:	f000 b96a 	b.w	8000f84 <__aeabi_idiv0>
 8000cb0:	f1ad 0c08 	sub.w	ip, sp, #8
 8000cb4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000cb8:	f000 f806 	bl	8000cc8 <__udivmoddi4>
 8000cbc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000cc0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000cc4:	b004      	add	sp, #16
 8000cc6:	4770      	bx	lr

08000cc8 <__udivmoddi4>:
 8000cc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000ccc:	9d08      	ldr	r5, [sp, #32]
 8000cce:	460c      	mov	r4, r1
 8000cd0:	2b00      	cmp	r3, #0
 8000cd2:	d14e      	bne.n	8000d72 <__udivmoddi4+0xaa>
 8000cd4:	4694      	mov	ip, r2
 8000cd6:	458c      	cmp	ip, r1
 8000cd8:	4686      	mov	lr, r0
 8000cda:	fab2 f282 	clz	r2, r2
 8000cde:	d962      	bls.n	8000da6 <__udivmoddi4+0xde>
 8000ce0:	b14a      	cbz	r2, 8000cf6 <__udivmoddi4+0x2e>
 8000ce2:	f1c2 0320 	rsb	r3, r2, #32
 8000ce6:	4091      	lsls	r1, r2
 8000ce8:	fa20 f303 	lsr.w	r3, r0, r3
 8000cec:	fa0c fc02 	lsl.w	ip, ip, r2
 8000cf0:	4319      	orrs	r1, r3
 8000cf2:	fa00 fe02 	lsl.w	lr, r0, r2
 8000cf6:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000cfa:	fa1f f68c 	uxth.w	r6, ip
 8000cfe:	fbb1 f4f7 	udiv	r4, r1, r7
 8000d02:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000d06:	fb07 1114 	mls	r1, r7, r4, r1
 8000d0a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000d0e:	fb04 f106 	mul.w	r1, r4, r6
 8000d12:	4299      	cmp	r1, r3
 8000d14:	d90a      	bls.n	8000d2c <__udivmoddi4+0x64>
 8000d16:	eb1c 0303 	adds.w	r3, ip, r3
 8000d1a:	f104 30ff 	add.w	r0, r4, #4294967295	@ 0xffffffff
 8000d1e:	f080 8112 	bcs.w	8000f46 <__udivmoddi4+0x27e>
 8000d22:	4299      	cmp	r1, r3
 8000d24:	f240 810f 	bls.w	8000f46 <__udivmoddi4+0x27e>
 8000d28:	3c02      	subs	r4, #2
 8000d2a:	4463      	add	r3, ip
 8000d2c:	1a59      	subs	r1, r3, r1
 8000d2e:	fa1f f38e 	uxth.w	r3, lr
 8000d32:	fbb1 f0f7 	udiv	r0, r1, r7
 8000d36:	fb07 1110 	mls	r1, r7, r0, r1
 8000d3a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000d3e:	fb00 f606 	mul.w	r6, r0, r6
 8000d42:	429e      	cmp	r6, r3
 8000d44:	d90a      	bls.n	8000d5c <__udivmoddi4+0x94>
 8000d46:	eb1c 0303 	adds.w	r3, ip, r3
 8000d4a:	f100 31ff 	add.w	r1, r0, #4294967295	@ 0xffffffff
 8000d4e:	f080 80fc 	bcs.w	8000f4a <__udivmoddi4+0x282>
 8000d52:	429e      	cmp	r6, r3
 8000d54:	f240 80f9 	bls.w	8000f4a <__udivmoddi4+0x282>
 8000d58:	4463      	add	r3, ip
 8000d5a:	3802      	subs	r0, #2
 8000d5c:	1b9b      	subs	r3, r3, r6
 8000d5e:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000d62:	2100      	movs	r1, #0
 8000d64:	b11d      	cbz	r5, 8000d6e <__udivmoddi4+0xa6>
 8000d66:	40d3      	lsrs	r3, r2
 8000d68:	2200      	movs	r2, #0
 8000d6a:	e9c5 3200 	strd	r3, r2, [r5]
 8000d6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d72:	428b      	cmp	r3, r1
 8000d74:	d905      	bls.n	8000d82 <__udivmoddi4+0xba>
 8000d76:	b10d      	cbz	r5, 8000d7c <__udivmoddi4+0xb4>
 8000d78:	e9c5 0100 	strd	r0, r1, [r5]
 8000d7c:	2100      	movs	r1, #0
 8000d7e:	4608      	mov	r0, r1
 8000d80:	e7f5      	b.n	8000d6e <__udivmoddi4+0xa6>
 8000d82:	fab3 f183 	clz	r1, r3
 8000d86:	2900      	cmp	r1, #0
 8000d88:	d146      	bne.n	8000e18 <__udivmoddi4+0x150>
 8000d8a:	42a3      	cmp	r3, r4
 8000d8c:	d302      	bcc.n	8000d94 <__udivmoddi4+0xcc>
 8000d8e:	4290      	cmp	r0, r2
 8000d90:	f0c0 80f0 	bcc.w	8000f74 <__udivmoddi4+0x2ac>
 8000d94:	1a86      	subs	r6, r0, r2
 8000d96:	eb64 0303 	sbc.w	r3, r4, r3
 8000d9a:	2001      	movs	r0, #1
 8000d9c:	2d00      	cmp	r5, #0
 8000d9e:	d0e6      	beq.n	8000d6e <__udivmoddi4+0xa6>
 8000da0:	e9c5 6300 	strd	r6, r3, [r5]
 8000da4:	e7e3      	b.n	8000d6e <__udivmoddi4+0xa6>
 8000da6:	2a00      	cmp	r2, #0
 8000da8:	f040 8090 	bne.w	8000ecc <__udivmoddi4+0x204>
 8000dac:	eba1 040c 	sub.w	r4, r1, ip
 8000db0:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000db4:	fa1f f78c 	uxth.w	r7, ip
 8000db8:	2101      	movs	r1, #1
 8000dba:	fbb4 f6f8 	udiv	r6, r4, r8
 8000dbe:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000dc2:	fb08 4416 	mls	r4, r8, r6, r4
 8000dc6:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000dca:	fb07 f006 	mul.w	r0, r7, r6
 8000dce:	4298      	cmp	r0, r3
 8000dd0:	d908      	bls.n	8000de4 <__udivmoddi4+0x11c>
 8000dd2:	eb1c 0303 	adds.w	r3, ip, r3
 8000dd6:	f106 34ff 	add.w	r4, r6, #4294967295	@ 0xffffffff
 8000dda:	d202      	bcs.n	8000de2 <__udivmoddi4+0x11a>
 8000ddc:	4298      	cmp	r0, r3
 8000dde:	f200 80cd 	bhi.w	8000f7c <__udivmoddi4+0x2b4>
 8000de2:	4626      	mov	r6, r4
 8000de4:	1a1c      	subs	r4, r3, r0
 8000de6:	fa1f f38e 	uxth.w	r3, lr
 8000dea:	fbb4 f0f8 	udiv	r0, r4, r8
 8000dee:	fb08 4410 	mls	r4, r8, r0, r4
 8000df2:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000df6:	fb00 f707 	mul.w	r7, r0, r7
 8000dfa:	429f      	cmp	r7, r3
 8000dfc:	d908      	bls.n	8000e10 <__udivmoddi4+0x148>
 8000dfe:	eb1c 0303 	adds.w	r3, ip, r3
 8000e02:	f100 34ff 	add.w	r4, r0, #4294967295	@ 0xffffffff
 8000e06:	d202      	bcs.n	8000e0e <__udivmoddi4+0x146>
 8000e08:	429f      	cmp	r7, r3
 8000e0a:	f200 80b0 	bhi.w	8000f6e <__udivmoddi4+0x2a6>
 8000e0e:	4620      	mov	r0, r4
 8000e10:	1bdb      	subs	r3, r3, r7
 8000e12:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000e16:	e7a5      	b.n	8000d64 <__udivmoddi4+0x9c>
 8000e18:	f1c1 0620 	rsb	r6, r1, #32
 8000e1c:	408b      	lsls	r3, r1
 8000e1e:	fa22 f706 	lsr.w	r7, r2, r6
 8000e22:	431f      	orrs	r7, r3
 8000e24:	fa20 fc06 	lsr.w	ip, r0, r6
 8000e28:	fa04 f301 	lsl.w	r3, r4, r1
 8000e2c:	ea43 030c 	orr.w	r3, r3, ip
 8000e30:	40f4      	lsrs	r4, r6
 8000e32:	fa00 f801 	lsl.w	r8, r0, r1
 8000e36:	0c38      	lsrs	r0, r7, #16
 8000e38:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8000e3c:	fbb4 fef0 	udiv	lr, r4, r0
 8000e40:	fa1f fc87 	uxth.w	ip, r7
 8000e44:	fb00 441e 	mls	r4, r0, lr, r4
 8000e48:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000e4c:	fb0e f90c 	mul.w	r9, lr, ip
 8000e50:	45a1      	cmp	r9, r4
 8000e52:	fa02 f201 	lsl.w	r2, r2, r1
 8000e56:	d90a      	bls.n	8000e6e <__udivmoddi4+0x1a6>
 8000e58:	193c      	adds	r4, r7, r4
 8000e5a:	f10e 3aff 	add.w	sl, lr, #4294967295	@ 0xffffffff
 8000e5e:	f080 8084 	bcs.w	8000f6a <__udivmoddi4+0x2a2>
 8000e62:	45a1      	cmp	r9, r4
 8000e64:	f240 8081 	bls.w	8000f6a <__udivmoddi4+0x2a2>
 8000e68:	f1ae 0e02 	sub.w	lr, lr, #2
 8000e6c:	443c      	add	r4, r7
 8000e6e:	eba4 0409 	sub.w	r4, r4, r9
 8000e72:	fa1f f983 	uxth.w	r9, r3
 8000e76:	fbb4 f3f0 	udiv	r3, r4, r0
 8000e7a:	fb00 4413 	mls	r4, r0, r3, r4
 8000e7e:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000e82:	fb03 fc0c 	mul.w	ip, r3, ip
 8000e86:	45a4      	cmp	ip, r4
 8000e88:	d907      	bls.n	8000e9a <__udivmoddi4+0x1d2>
 8000e8a:	193c      	adds	r4, r7, r4
 8000e8c:	f103 30ff 	add.w	r0, r3, #4294967295	@ 0xffffffff
 8000e90:	d267      	bcs.n	8000f62 <__udivmoddi4+0x29a>
 8000e92:	45a4      	cmp	ip, r4
 8000e94:	d965      	bls.n	8000f62 <__udivmoddi4+0x29a>
 8000e96:	3b02      	subs	r3, #2
 8000e98:	443c      	add	r4, r7
 8000e9a:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000e9e:	fba0 9302 	umull	r9, r3, r0, r2
 8000ea2:	eba4 040c 	sub.w	r4, r4, ip
 8000ea6:	429c      	cmp	r4, r3
 8000ea8:	46ce      	mov	lr, r9
 8000eaa:	469c      	mov	ip, r3
 8000eac:	d351      	bcc.n	8000f52 <__udivmoddi4+0x28a>
 8000eae:	d04e      	beq.n	8000f4e <__udivmoddi4+0x286>
 8000eb0:	b155      	cbz	r5, 8000ec8 <__udivmoddi4+0x200>
 8000eb2:	ebb8 030e 	subs.w	r3, r8, lr
 8000eb6:	eb64 040c 	sbc.w	r4, r4, ip
 8000eba:	fa04 f606 	lsl.w	r6, r4, r6
 8000ebe:	40cb      	lsrs	r3, r1
 8000ec0:	431e      	orrs	r6, r3
 8000ec2:	40cc      	lsrs	r4, r1
 8000ec4:	e9c5 6400 	strd	r6, r4, [r5]
 8000ec8:	2100      	movs	r1, #0
 8000eca:	e750      	b.n	8000d6e <__udivmoddi4+0xa6>
 8000ecc:	f1c2 0320 	rsb	r3, r2, #32
 8000ed0:	fa20 f103 	lsr.w	r1, r0, r3
 8000ed4:	fa0c fc02 	lsl.w	ip, ip, r2
 8000ed8:	fa24 f303 	lsr.w	r3, r4, r3
 8000edc:	4094      	lsls	r4, r2
 8000ede:	430c      	orrs	r4, r1
 8000ee0:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000ee4:	fa00 fe02 	lsl.w	lr, r0, r2
 8000ee8:	fa1f f78c 	uxth.w	r7, ip
 8000eec:	fbb3 f0f8 	udiv	r0, r3, r8
 8000ef0:	fb08 3110 	mls	r1, r8, r0, r3
 8000ef4:	0c23      	lsrs	r3, r4, #16
 8000ef6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000efa:	fb00 f107 	mul.w	r1, r0, r7
 8000efe:	4299      	cmp	r1, r3
 8000f00:	d908      	bls.n	8000f14 <__udivmoddi4+0x24c>
 8000f02:	eb1c 0303 	adds.w	r3, ip, r3
 8000f06:	f100 36ff 	add.w	r6, r0, #4294967295	@ 0xffffffff
 8000f0a:	d22c      	bcs.n	8000f66 <__udivmoddi4+0x29e>
 8000f0c:	4299      	cmp	r1, r3
 8000f0e:	d92a      	bls.n	8000f66 <__udivmoddi4+0x29e>
 8000f10:	3802      	subs	r0, #2
 8000f12:	4463      	add	r3, ip
 8000f14:	1a5b      	subs	r3, r3, r1
 8000f16:	b2a4      	uxth	r4, r4
 8000f18:	fbb3 f1f8 	udiv	r1, r3, r8
 8000f1c:	fb08 3311 	mls	r3, r8, r1, r3
 8000f20:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000f24:	fb01 f307 	mul.w	r3, r1, r7
 8000f28:	42a3      	cmp	r3, r4
 8000f2a:	d908      	bls.n	8000f3e <__udivmoddi4+0x276>
 8000f2c:	eb1c 0404 	adds.w	r4, ip, r4
 8000f30:	f101 36ff 	add.w	r6, r1, #4294967295	@ 0xffffffff
 8000f34:	d213      	bcs.n	8000f5e <__udivmoddi4+0x296>
 8000f36:	42a3      	cmp	r3, r4
 8000f38:	d911      	bls.n	8000f5e <__udivmoddi4+0x296>
 8000f3a:	3902      	subs	r1, #2
 8000f3c:	4464      	add	r4, ip
 8000f3e:	1ae4      	subs	r4, r4, r3
 8000f40:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8000f44:	e739      	b.n	8000dba <__udivmoddi4+0xf2>
 8000f46:	4604      	mov	r4, r0
 8000f48:	e6f0      	b.n	8000d2c <__udivmoddi4+0x64>
 8000f4a:	4608      	mov	r0, r1
 8000f4c:	e706      	b.n	8000d5c <__udivmoddi4+0x94>
 8000f4e:	45c8      	cmp	r8, r9
 8000f50:	d2ae      	bcs.n	8000eb0 <__udivmoddi4+0x1e8>
 8000f52:	ebb9 0e02 	subs.w	lr, r9, r2
 8000f56:	eb63 0c07 	sbc.w	ip, r3, r7
 8000f5a:	3801      	subs	r0, #1
 8000f5c:	e7a8      	b.n	8000eb0 <__udivmoddi4+0x1e8>
 8000f5e:	4631      	mov	r1, r6
 8000f60:	e7ed      	b.n	8000f3e <__udivmoddi4+0x276>
 8000f62:	4603      	mov	r3, r0
 8000f64:	e799      	b.n	8000e9a <__udivmoddi4+0x1d2>
 8000f66:	4630      	mov	r0, r6
 8000f68:	e7d4      	b.n	8000f14 <__udivmoddi4+0x24c>
 8000f6a:	46d6      	mov	lr, sl
 8000f6c:	e77f      	b.n	8000e6e <__udivmoddi4+0x1a6>
 8000f6e:	4463      	add	r3, ip
 8000f70:	3802      	subs	r0, #2
 8000f72:	e74d      	b.n	8000e10 <__udivmoddi4+0x148>
 8000f74:	4606      	mov	r6, r0
 8000f76:	4623      	mov	r3, r4
 8000f78:	4608      	mov	r0, r1
 8000f7a:	e70f      	b.n	8000d9c <__udivmoddi4+0xd4>
 8000f7c:	3e02      	subs	r6, #2
 8000f7e:	4463      	add	r3, ip
 8000f80:	e730      	b.n	8000de4 <__udivmoddi4+0x11c>
 8000f82:	bf00      	nop

08000f84 <__aeabi_idiv0>:
 8000f84:	4770      	bx	lr
 8000f86:	bf00      	nop

08000f88 <MX_MEMS_Init>:
static void DWT_Init(void);
static void DWT_Start(void);
static uint32_t DWT_Stop(void);

void MX_MEMS_Init(void)
{
 8000f88:	b580      	push	{r7, lr}
 8000f8a:	af00      	add	r7, sp, #0
//
  /* USER CODE END MEMS_Init_PreTreatment */

  /* Initialize the peripherals and the MEMS components */

  MX_DataLogFusion_Init();
 8000f8c:	f000 f81a 	bl	8000fc4 <MX_DataLogFusion_Init>

  /* USER CODE BEGIN MEMS_Init_PostTreatment */
//
  /* USER CODE END MEMS_Init_PostTreatment */
}
 8000f90:	bf00      	nop
 8000f92:	bd80      	pop	{r7, pc}

08000f94 <HAL_TIM_PeriodElapsedCallback>:
  * @param  htim pointer to a TIM_HandleTypeDef structure that contains
  *              the configuration information for TIM module.
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8000f94:	b480      	push	{r7}
 8000f96:	b083      	sub	sp, #12
 8000f98:	af00      	add	r7, sp, #0
 8000f9a:	6078      	str	r0, [r7, #4]
  if (htim->Instance == BSP_IP_TIM_Handle.Instance)
 8000f9c:	687b      	ldr	r3, [r7, #4]
 8000f9e:	681a      	ldr	r2, [r3, #0]
 8000fa0:	4b06      	ldr	r3, [pc, #24]	@ (8000fbc <HAL_TIM_PeriodElapsedCallback+0x28>)
 8000fa2:	681b      	ldr	r3, [r3, #0]
 8000fa4:	429a      	cmp	r2, r3
 8000fa6:	d102      	bne.n	8000fae <HAL_TIM_PeriodElapsedCallback+0x1a>
  {
    SensorReadRequest = 1;
 8000fa8:	4b05      	ldr	r3, [pc, #20]	@ (8000fc0 <HAL_TIM_PeriodElapsedCallback+0x2c>)
 8000faa:	2201      	movs	r2, #1
 8000fac:	701a      	strb	r2, [r3, #0]
  }
}
 8000fae:	bf00      	nop
 8000fb0:	370c      	adds	r7, #12
 8000fb2:	46bd      	mov	sp, r7
 8000fb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000fb8:	4770      	bx	lr
 8000fba:	bf00      	nop
 8000fbc:	20001bf8 	.word	0x20001bf8
 8000fc0:	20000dd0 	.word	0x20000dd0

08000fc4 <MX_DataLogFusion_Init>:
/**
  * @brief  Initialize the application
  * @retval None
  */
static void MX_DataLogFusion_Init(void)
{
 8000fc4:	b580      	push	{r7, lr}
 8000fc6:	b086      	sub	sp, #24
 8000fc8:	af00      	add	r7, sp, #0
  float ans_float;

  /* Initialize button */
  BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
 8000fca:	2101      	movs	r1, #1
 8000fcc:	2000      	movs	r0, #0
 8000fce:	f00d ffa9 	bl	800ef24 <BSP_PB_Init>

  /* Check what is the Push Button State when the button is not pressed. It can change across families */
  PushButtonState = (BSP_PB_GetState(BUTTON_KEY)) ?  0 : 1;
 8000fd2:	2000      	movs	r0, #0
 8000fd4:	f00d fffa 	bl	800efcc <BSP_PB_GetState>
 8000fd8:	4603      	mov	r3, r0
 8000fda:	2b00      	cmp	r3, #0
 8000fdc:	bf0c      	ite	eq
 8000fde:	2301      	moveq	r3, #1
 8000fe0:	2300      	movne	r3, #0
 8000fe2:	b2db      	uxtb	r3, r3
 8000fe4:	461a      	mov	r2, r3
 8000fe6:	4b32      	ldr	r3, [pc, #200]	@ (80010b0 <MX_DataLogFusion_Init+0xec>)
 8000fe8:	601a      	str	r2, [r3, #0]

  /* Initialize LED */
  BSP_LED_Init(LED2);
 8000fea:	2000      	movs	r0, #0
 8000fec:	f00d ff1a 	bl	800ee24 <BSP_LED_Init>

  /* Initialize Virtual COM Port */
  BSP_COM_Init(COM1);
 8000ff0:	2000      	movs	r0, #0
 8000ff2:	f00e f84d 	bl	800f090 <BSP_COM_Init>

  /* Initialize Timer */
  BSP_IP_TIM_Init();
 8000ff6:	f001 fc0d 	bl	8002814 <MX_TIM3_Init>

  /* Configure Timer to run with desired algorithm frequency */
  TIM_Config(ALGO_FREQ);
 8000ffa:	2064      	movs	r0, #100	@ 0x64
 8000ffc:	f000 f88e 	bl	800111c <TIM_Config>

  /* Initialize (disabled) sensors */
  Init_Sensors();
 8001000:	f000 f862 	bl	80010c8 <Init_Sensors>

  /* Sensor Fusion API initialization function */
  MotionFX_manager_init();
 8001004:	f000 f9a0 	bl	8001348 <MotionFX_manager_init>

  /* OPTIONAL */
  /* Get library version */
  MotionFX_manager_get_version(LibVersion, &LibVersionLen);
 8001008:	492a      	ldr	r1, [pc, #168]	@ (80010b4 <MX_DataLogFusion_Init+0xf0>)
 800100a:	482b      	ldr	r0, [pc, #172]	@ (80010b8 <MX_DataLogFusion_Init+0xf4>)
 800100c:	f000 fa24 	bl	8001458 <MotionFX_manager_get_version>

  /* Enable magnetometer calibration */
  MotionFX_manager_MagCal_start(ALGO_PERIOD);
 8001010:	200a      	movs	r0, #10
 8001012:	f000 fa31 	bl	8001478 <MotionFX_manager_MagCal_start>

  /* Test if calibration data are available */
  MFX_MagCal_output_t mag_cal_test;
  MotionFX_MagCal_getParams(&mag_cal_test);
 8001016:	1d3b      	adds	r3, r7, #4
 8001018:	4618      	mov	r0, r3
 800101a:	f01b fd45 	bl	801caa8 <MotionFX_MagCal_getParams>

  /* If calibration data are available load HI coefficients */
  if (mag_cal_test.cal_quality == MFX_MAGCALGOOD)
 800101e:	7c3b      	ldrb	r3, [r7, #16]
 8001020:	2b03      	cmp	r3, #3
 8001022:	d132      	bne.n	800108a <MX_DataLogFusion_Init+0xc6>
  {
    ans_float = (mag_cal_test.hi_bias[0] * FROM_UT50_TO_MGAUSS);
 8001024:	edd7 7a01 	vldr	s15, [r7, #4]
 8001028:	ed9f 7a24 	vldr	s14, [pc, #144]	@ 80010bc <MX_DataLogFusion_Init+0xf8>
 800102c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001030:	edc7 7a05 	vstr	s15, [r7, #20]
    MagOffset.x = (int32_t)ans_float;
 8001034:	edd7 7a05 	vldr	s15, [r7, #20]
 8001038:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800103c:	ee17 2a90 	vmov	r2, s15
 8001040:	4b1f      	ldr	r3, [pc, #124]	@ (80010c0 <MX_DataLogFusion_Init+0xfc>)
 8001042:	601a      	str	r2, [r3, #0]
    ans_float = (mag_cal_test.hi_bias[1] * FROM_UT50_TO_MGAUSS);
 8001044:	edd7 7a02 	vldr	s15, [r7, #8]
 8001048:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 80010bc <MX_DataLogFusion_Init+0xf8>
 800104c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001050:	edc7 7a05 	vstr	s15, [r7, #20]
    MagOffset.y = (int32_t)ans_float;
 8001054:	edd7 7a05 	vldr	s15, [r7, #20]
 8001058:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800105c:	ee17 2a90 	vmov	r2, s15
 8001060:	4b17      	ldr	r3, [pc, #92]	@ (80010c0 <MX_DataLogFusion_Init+0xfc>)
 8001062:	605a      	str	r2, [r3, #4]
    ans_float = (mag_cal_test.hi_bias[2] * FROM_UT50_TO_MGAUSS);
 8001064:	edd7 7a03 	vldr	s15, [r7, #12]
 8001068:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 80010bc <MX_DataLogFusion_Init+0xf8>
 800106c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001070:	edc7 7a05 	vstr	s15, [r7, #20]
    MagOffset.z = (int32_t)ans_float;
 8001074:	edd7 7a05 	vldr	s15, [r7, #20]
 8001078:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800107c:	ee17 2a90 	vmov	r2, s15
 8001080:	4b0f      	ldr	r3, [pc, #60]	@ (80010c0 <MX_DataLogFusion_Init+0xfc>)
 8001082:	609a      	str	r2, [r3, #8]

    MagCalStatus = 1;
 8001084:	4b0f      	ldr	r3, [pc, #60]	@ (80010c4 <MX_DataLogFusion_Init+0x100>)
 8001086:	2201      	movs	r2, #1
 8001088:	701a      	strb	r2, [r3, #0]
  }

  DWT_Init();
 800108a:	f000 f87b 	bl	8001184 <DWT_Init>

  BSP_LED_On(LED2);
 800108e:	2000      	movs	r0, #0
 8001090:	f00d feda 	bl	800ee48 <BSP_LED_On>
  HAL_Delay(500);
 8001094:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 8001098:	f00e f93c 	bl	800f314 <HAL_Delay>
  BSP_LED_Off(LED2);
 800109c:	2000      	movs	r0, #0
 800109e:	f00d fee9 	bl	800ee74 <BSP_LED_Off>

  /* Start receiving messages via DMA */
  UART_StartReceiveMsg();
 80010a2:	f000 f887 	bl	80011b4 <UART_StartReceiveMsg>
}
 80010a6:	bf00      	nop
 80010a8:	3718      	adds	r7, #24
 80010aa:	46bd      	mov	sp, r7
 80010ac:	bd80      	pop	{r7, pc}
 80010ae:	bf00      	nop
 80010b0:	20000f78 	.word	0x20000f78
 80010b4:	20000dcc 	.word	0x20000dcc
 80010b8:	20000da8 	.word	0x20000da8
 80010bc:	43fa0000 	.word	0x43fa0000
 80010c0:	20000f80 	.word	0x20000f80
 80010c4:	20000f8c 	.word	0x20000f8c

080010c8 <Init_Sensors>:
  * @brief  Initialize all sensors
  * @param  None
  * @retval None
  */
static void Init_Sensors(void)
{
 80010c8:	b580      	push	{r7, lr}
 80010ca:	af00      	add	r7, sp, #0
  BSP_SENSOR_ACC_Init();
 80010cc:	f000 f88a 	bl	80011e4 <BSP_SENSOR_ACC_Init>
  BSP_SENSOR_GYR_Init();
 80010d0:	f000 f890 	bl	80011f4 <BSP_SENSOR_GYR_Init>
  BSP_SENSOR_MAG_Init();
 80010d4:	f000 f896 	bl	8001204 <BSP_SENSOR_MAG_Init>
  BSP_SENSOR_PRESS_Init();
 80010d8:	f000 f89c 	bl	8001214 <BSP_SENSOR_PRESS_Init>
  BSP_SENSOR_TEMP_Init();
 80010dc:	f000 f8a2 	bl	8001224 <BSP_SENSOR_TEMP_Init>
  BSP_SENSOR_HUM_Init();
 80010e0:	f000 f8a8 	bl	8001234 <BSP_SENSOR_HUM_Init>

  BSP_SENSOR_ACC_SetOutputDataRate(ACC_ODR);
 80010e4:	ed9f 0a04 	vldr	s0, [pc, #16]	@ 80010f8 <Init_Sensors+0x30>
 80010e8:	f000 f8d3 	bl	8001292 <BSP_SENSOR_ACC_SetOutputDataRate>
  BSP_SENSOR_ACC_SetFullScale(ACC_FS);
 80010ec:	2004      	movs	r0, #4
 80010ee:	f000 f8df 	bl	80012b0 <BSP_SENSOR_ACC_SetFullScale>
}
 80010f2:	bf00      	nop
 80010f4:	bd80      	pop	{r7, pc}
 80010f6:	bf00      	nop
 80010f8:	42c80000 	.word	0x42c80000

080010fc <BSP_PB_Callback>:
  * @brief  BSP Push Button callback
  * @param  Button Specifies the pin connected EXTI line
  * @retval None.
  */
void BSP_PB_Callback(Button_TypeDef Button)
{
 80010fc:	b480      	push	{r7}
 80010fe:	b083      	sub	sp, #12
 8001100:	af00      	add	r7, sp, #0
 8001102:	4603      	mov	r3, r0
 8001104:	71fb      	strb	r3, [r7, #7]
  MagCalRequest = 1U;
 8001106:	4b04      	ldr	r3, [pc, #16]	@ (8001118 <BSP_PB_Callback+0x1c>)
 8001108:	2201      	movs	r2, #1
 800110a:	701a      	strb	r2, [r3, #0]
}
 800110c:	bf00      	nop
 800110e:	370c      	adds	r7, #12
 8001110:	46bd      	mov	sp, r7
 8001112:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001116:	4770      	bx	lr
 8001118:	20000f7c 	.word	0x20000f7c

0800111c <TIM_Config>:
  * @brief  Timer configuration
  * @param  Freq the desired Timer frequency
  * @retval None
  */
static void TIM_Config(uint32_t Freq)
{
 800111c:	b580      	push	{r7, lr}
 800111e:	b086      	sub	sp, #24
 8001120:	af00      	add	r7, sp, #0
 8001122:	6078      	str	r0, [r7, #4]
  const uint32_t tim_counter_clock = 2000; /* TIM counter clock 2 kHz */
 8001124:	f44f 63fa 	mov.w	r3, #2000	@ 0x7d0
 8001128:	617b      	str	r3, [r7, #20]
  uint32_t prescaler_value = (uint32_t)((SystemCoreClock / tim_counter_clock) - 1);
 800112a:	4b14      	ldr	r3, [pc, #80]	@ (800117c <TIM_Config+0x60>)
 800112c:	681a      	ldr	r2, [r3, #0]
 800112e:	697b      	ldr	r3, [r7, #20]
 8001130:	fbb2 f3f3 	udiv	r3, r2, r3
 8001134:	3b01      	subs	r3, #1
 8001136:	613b      	str	r3, [r7, #16]
  uint32_t period = (tim_counter_clock / Freq) - 1;
 8001138:	697a      	ldr	r2, [r7, #20]
 800113a:	687b      	ldr	r3, [r7, #4]
 800113c:	fbb2 f3f3 	udiv	r3, r2, r3
 8001140:	3b01      	subs	r3, #1
 8001142:	60fb      	str	r3, [r7, #12]

  BSP_IP_TIM_Handle.Init.Prescaler = prescaler_value;
 8001144:	4a0e      	ldr	r2, [pc, #56]	@ (8001180 <TIM_Config+0x64>)
 8001146:	693b      	ldr	r3, [r7, #16]
 8001148:	6053      	str	r3, [r2, #4]
  BSP_IP_TIM_Handle.Init.CounterMode = TIM_COUNTERMODE_UP;
 800114a:	4b0d      	ldr	r3, [pc, #52]	@ (8001180 <TIM_Config+0x64>)
 800114c:	2200      	movs	r2, #0
 800114e:	609a      	str	r2, [r3, #8]
  BSP_IP_TIM_Handle.Init.Period = period;
 8001150:	4a0b      	ldr	r2, [pc, #44]	@ (8001180 <TIM_Config+0x64>)
 8001152:	68fb      	ldr	r3, [r7, #12]
 8001154:	60d3      	str	r3, [r2, #12]
  BSP_IP_TIM_Handle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001156:	4b0a      	ldr	r3, [pc, #40]	@ (8001180 <TIM_Config+0x64>)
 8001158:	2200      	movs	r2, #0
 800115a:	611a      	str	r2, [r3, #16]
  BSP_IP_TIM_Handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800115c:	4b08      	ldr	r3, [pc, #32]	@ (8001180 <TIM_Config+0x64>)
 800115e:	2200      	movs	r2, #0
 8001160:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&BSP_IP_TIM_Handle) != HAL_OK)
 8001162:	4807      	ldr	r0, [pc, #28]	@ (8001180 <TIM_Config+0x64>)
 8001164:	f012 ffb0 	bl	80140c8 <HAL_TIM_Base_Init>
 8001168:	4603      	mov	r3, r0
 800116a:	2b00      	cmp	r3, #0
 800116c:	d001      	beq.n	8001172 <TIM_Config+0x56>
  {
    Error_Handler();
 800116e:	f004 fb8b 	bl	8005888 <Error_Handler>
  }
}
 8001172:	bf00      	nop
 8001174:	3718      	adds	r7, #24
 8001176:	46bd      	mov	sp, r7
 8001178:	bd80      	pop	{r7, pc}
 800117a:	bf00      	nop
 800117c:	20000144 	.word	0x20000144
 8001180:	20001bf8 	.word	0x20001bf8

08001184 <DWT_Init>:
  * @brief  Initialize DWT register for counting clock cycles purpose
  * @param  None
  * @retval None
  */
static void DWT_Init(void)
{
 8001184:	b480      	push	{r7}
 8001186:	af00      	add	r7, sp, #0
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001188:	4b08      	ldr	r3, [pc, #32]	@ (80011ac <DWT_Init+0x28>)
 800118a:	68db      	ldr	r3, [r3, #12]
 800118c:	4a07      	ldr	r2, [pc, #28]	@ (80011ac <DWT_Init+0x28>)
 800118e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001192:	60d3      	str	r3, [r2, #12]
  DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk; /* Disable counter */
 8001194:	4b06      	ldr	r3, [pc, #24]	@ (80011b0 <DWT_Init+0x2c>)
 8001196:	681b      	ldr	r3, [r3, #0]
 8001198:	4a05      	ldr	r2, [pc, #20]	@ (80011b0 <DWT_Init+0x2c>)
 800119a:	f023 0301 	bic.w	r3, r3, #1
 800119e:	6013      	str	r3, [r2, #0]
}
 80011a0:	bf00      	nop
 80011a2:	46bd      	mov	sp, r7
 80011a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80011a8:	4770      	bx	lr
 80011aa:	bf00      	nop
 80011ac:	e000edf0 	.word	0xe000edf0
 80011b0:	e0001000 	.word	0xe0001000

080011b4 <UART_StartReceiveMsg>:
  * @brief  Start receiving messages via DMA
  * @param  None
  * @retval None
  */
void UART_StartReceiveMsg(void)
{
 80011b4:	b580      	push	{r7, lr}
 80011b6:	af00      	add	r7, sp, #0
  hcom_uart[COM1].pRxBuffPtr = (uint8_t *)UartRxBuffer; /* MISRA C-2012 rule 11.8 violation for purpose */
 80011b8:	4b08      	ldr	r3, [pc, #32]	@ (80011dc <UART_StartReceiveMsg+0x28>)
 80011ba:	4a09      	ldr	r2, [pc, #36]	@ (80011e0 <UART_StartReceiveMsg+0x2c>)
 80011bc:	629a      	str	r2, [r3, #40]	@ 0x28
  hcom_uart[COM1].RxXferSize = UART_RxBufferSize;
 80011be:	4b07      	ldr	r3, [pc, #28]	@ (80011dc <UART_StartReceiveMsg+0x28>)
 80011c0:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80011c4:	859a      	strh	r2, [r3, #44]	@ 0x2c
  hcom_uart[COM1].ErrorCode = (uint32_t)HAL_UART_ERROR_NONE;
 80011c6:	4b05      	ldr	r3, [pc, #20]	@ (80011dc <UART_StartReceiveMsg+0x28>)
 80011c8:	2200      	movs	r2, #0
 80011ca:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Enable the DMA transfer for the receiver request by setting the DMAR bit
     in the UART CR3 register */
  /* MISRA C-2012 rule 11.8 violation for purpose */
  (void)HAL_UART_Receive_DMA(&hcom_uart[COM1], (uint8_t *)UartRxBuffer, UART_RxBufferSize);
 80011cc:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80011d0:	4903      	ldr	r1, [pc, #12]	@ (80011e0 <UART_StartReceiveMsg+0x2c>)
 80011d2:	4802      	ldr	r0, [pc, #8]	@ (80011dc <UART_StartReceiveMsg+0x28>)
 80011d4:	f014 f855 	bl	8015282 <HAL_UART_Receive_DMA>
}
 80011d8:	bf00      	nop
 80011da:	bd80      	pop	{r7, pc}
 80011dc:	200022c4 	.word	0x200022c4
 80011e0:	20000f90 	.word	0x20000f90

080011e4 <BSP_SENSOR_ACC_Init>:
  * @brief  Initializes accelerometer
  * @param  None
  * @retval None
  */
void BSP_SENSOR_ACC_Init(void)
{
 80011e4:	b580      	push	{r7, lr}
 80011e6:	af00      	add	r7, sp, #0
  (void)IKS4A1_MOTION_SENSOR_Init(IKS4A1_LSM6DSV16X_0, MOTION_ACCELERO);
 80011e8:	2102      	movs	r1, #2
 80011ea:	2001      	movs	r0, #1
 80011ec:	f00d f942 	bl	800e474 <IKS4A1_MOTION_SENSOR_Init>
}
 80011f0:	bf00      	nop
 80011f2:	bd80      	pop	{r7, pc}

080011f4 <BSP_SENSOR_GYR_Init>:
  * @brief  Initializes gyroscope
  * @param  None
  * @retval None
  */
void BSP_SENSOR_GYR_Init(void)
{
 80011f4:	b580      	push	{r7, lr}
 80011f6:	af00      	add	r7, sp, #0
  (void)IKS4A1_MOTION_SENSOR_Init(IKS4A1_LSM6DSV16X_0, MOTION_GYRO);
 80011f8:	2101      	movs	r1, #1
 80011fa:	2001      	movs	r0, #1
 80011fc:	f00d f93a 	bl	800e474 <IKS4A1_MOTION_SENSOR_Init>
}
 8001200:	bf00      	nop
 8001202:	bd80      	pop	{r7, pc}

08001204 <BSP_SENSOR_MAG_Init>:
  * @brief  Initializes magnetometer
  * @param  None
  * @retval None
  */
void BSP_SENSOR_MAG_Init(void)
{
 8001204:	b580      	push	{r7, lr}
 8001206:	af00      	add	r7, sp, #0
  (void)IKS4A1_MOTION_SENSOR_Init(IKS4A1_LIS2MDL_0, MOTION_MAGNETO);
 8001208:	2104      	movs	r1, #4
 800120a:	2000      	movs	r0, #0
 800120c:	f00d f932 	bl	800e474 <IKS4A1_MOTION_SENSOR_Init>
}
 8001210:	bf00      	nop
 8001212:	bd80      	pop	{r7, pc}

08001214 <BSP_SENSOR_PRESS_Init>:
  * @brief  Initializes pressure sensor
  * @param  None
  * @retval None
  */
void BSP_SENSOR_PRESS_Init(void)
{
 8001214:	b580      	push	{r7, lr}
 8001216:	af00      	add	r7, sp, #0
  (void)IKS4A1_ENV_SENSOR_Init(IKS4A1_LPS22DF_0, ENV_PRESSURE);
 8001218:	2102      	movs	r1, #2
 800121a:	2001      	movs	r0, #1
 800121c:	f00c fdc6 	bl	800ddac <IKS4A1_ENV_SENSOR_Init>
}
 8001220:	bf00      	nop
 8001222:	bd80      	pop	{r7, pc}

08001224 <BSP_SENSOR_TEMP_Init>:
  * @brief  Initializes temperature sensor
  * @param  None
  * @retval None
  */
void BSP_SENSOR_TEMP_Init(void)
{
 8001224:	b580      	push	{r7, lr}
 8001226:	af00      	add	r7, sp, #0
  (void)IKS4A1_ENV_SENSOR_Init(IKS4A1_STTS22H_0, ENV_TEMPERATURE);
 8001228:	2101      	movs	r1, #1
 800122a:	2000      	movs	r0, #0
 800122c:	f00c fdbe 	bl	800ddac <IKS4A1_ENV_SENSOR_Init>
}
 8001230:	bf00      	nop
 8001232:	bd80      	pop	{r7, pc}

08001234 <BSP_SENSOR_HUM_Init>:
  * @brief  Initializes humidity sensor
  * @param  None
  * @retval None
  */
void BSP_SENSOR_HUM_Init(void)
{
 8001234:	b580      	push	{r7, lr}
 8001236:	af00      	add	r7, sp, #0
  (void)IKS4A1_ENV_SENSOR_Init(IKS4A1_SHT40AD1B_0, ENV_HUMIDITY);
 8001238:	2104      	movs	r1, #4
 800123a:	2002      	movs	r0, #2
 800123c:	f00c fdb6 	bl	800ddac <IKS4A1_ENV_SENSOR_Init>
}
 8001240:	bf00      	nop
 8001242:	bd80      	pop	{r7, pc}

08001244 <BSP_SENSOR_ACC_GetAxes>:
  * @brief  Get accelerometer data
  * @param  Axes pointer to axes data structure
  * @retval None
  */
void BSP_SENSOR_ACC_GetAxes(IKS4A1_MOTION_SENSOR_Axes_t *Axes)
{
 8001244:	b580      	push	{r7, lr}
 8001246:	b082      	sub	sp, #8
 8001248:	af00      	add	r7, sp, #0
 800124a:	6078      	str	r0, [r7, #4]
  (void)IKS4A1_MOTION_SENSOR_GetAxes(IKS4A1_LSM6DSV16X_0, MOTION_ACCELERO, Axes);
 800124c:	687a      	ldr	r2, [r7, #4]
 800124e:	2102      	movs	r1, #2
 8001250:	2001      	movs	r0, #1
 8001252:	f00d fa41 	bl	800e6d8 <IKS4A1_MOTION_SENSOR_GetAxes>
}
 8001256:	bf00      	nop
 8001258:	3708      	adds	r7, #8
 800125a:	46bd      	mov	sp, r7
 800125c:	bd80      	pop	{r7, pc}

0800125e <BSP_SENSOR_GYR_GetAxes>:
  * @brief  Get gyroscope data
  * @param  Axes pointer to axes data structure
  * @retval None
  */
void BSP_SENSOR_GYR_GetAxes(IKS4A1_MOTION_SENSOR_Axes_t *Axes)
{
 800125e:	b580      	push	{r7, lr}
 8001260:	b082      	sub	sp, #8
 8001262:	af00      	add	r7, sp, #0
 8001264:	6078      	str	r0, [r7, #4]
  (void)IKS4A1_MOTION_SENSOR_GetAxes(IKS4A1_LSM6DSV16X_0, MOTION_GYRO, Axes);
 8001266:	687a      	ldr	r2, [r7, #4]
 8001268:	2101      	movs	r1, #1
 800126a:	2001      	movs	r0, #1
 800126c:	f00d fa34 	bl	800e6d8 <IKS4A1_MOTION_SENSOR_GetAxes>
}
 8001270:	bf00      	nop
 8001272:	3708      	adds	r7, #8
 8001274:	46bd      	mov	sp, r7
 8001276:	bd80      	pop	{r7, pc}

08001278 <BSP_SENSOR_MAG_GetAxes>:
  * @brief  Get magnetometer data
  * @param  Axes pointer to axes data structure
  * @retval None
  */
void BSP_SENSOR_MAG_GetAxes(IKS4A1_MOTION_SENSOR_Axes_t *Axes)
{
 8001278:	b580      	push	{r7, lr}
 800127a:	b082      	sub	sp, #8
 800127c:	af00      	add	r7, sp, #0
 800127e:	6078      	str	r0, [r7, #4]
  (void)IKS4A1_MOTION_SENSOR_GetAxes(IKS4A1_LIS2MDL_0, MOTION_MAGNETO, Axes);
 8001280:	687a      	ldr	r2, [r7, #4]
 8001282:	2104      	movs	r1, #4
 8001284:	2000      	movs	r0, #0
 8001286:	f00d fa27 	bl	800e6d8 <IKS4A1_MOTION_SENSOR_GetAxes>
}
 800128a:	bf00      	nop
 800128c:	3708      	adds	r7, #8
 800128e:	46bd      	mov	sp, r7
 8001290:	bd80      	pop	{r7, pc}

08001292 <BSP_SENSOR_ACC_SetOutputDataRate>:
  * @brief  Set output data rate for accelerometer
  * @param  Odr Output Data Rate value to be set
  * @retval None
  */
void BSP_SENSOR_ACC_SetOutputDataRate(float Odr)
{
 8001292:	b580      	push	{r7, lr}
 8001294:	b082      	sub	sp, #8
 8001296:	af00      	add	r7, sp, #0
 8001298:	ed87 0a01 	vstr	s0, [r7, #4]
  (void)IKS4A1_MOTION_SENSOR_SetOutputDataRate(IKS4A1_LSM6DSV16X_0, MOTION_ACCELERO, Odr);
 800129c:	ed97 0a01 	vldr	s0, [r7, #4]
 80012a0:	2102      	movs	r1, #2
 80012a2:	2001      	movs	r0, #1
 80012a4:	f00d fa5c 	bl	800e760 <IKS4A1_MOTION_SENSOR_SetOutputDataRate>
}
 80012a8:	bf00      	nop
 80012aa:	3708      	adds	r7, #8
 80012ac:	46bd      	mov	sp, r7
 80012ae:	bd80      	pop	{r7, pc}

080012b0 <BSP_SENSOR_ACC_SetFullScale>:
  * @brief  Set full scale for accelerometer
  * @param  Fullscale Fullscale value to be set
  * @retval None
  */
void BSP_SENSOR_ACC_SetFullScale(int32_t Fullscale)
{
 80012b0:	b580      	push	{r7, lr}
 80012b2:	b082      	sub	sp, #8
 80012b4:	af00      	add	r7, sp, #0
 80012b6:	6078      	str	r0, [r7, #4]
  (void)IKS4A1_MOTION_SENSOR_SetFullScale(IKS4A1_LSM6DSV16X_0, MOTION_ACCELERO, Fullscale);
 80012b8:	687a      	ldr	r2, [r7, #4]
 80012ba:	2102      	movs	r1, #2
 80012bc:	2001      	movs	r0, #1
 80012be:	f00d fa95 	bl	800e7ec <IKS4A1_MOTION_SENSOR_SetFullScale>
}
 80012c2:	bf00      	nop
 80012c4:	3708      	adds	r7, #8
 80012c6:	46bd      	mov	sp, r7
 80012c8:	bd80      	pop	{r7, pc}

080012ca <BSP_SENSOR_ACC_GetOrientation>:
  * @brief  Get accelerometer sensor orientation
  * @param  Orientation Pointer to sensor orientation
  * @retval None
  */
void BSP_SENSOR_ACC_GetOrientation(char *Orientation)
{
 80012ca:	b480      	push	{r7}
 80012cc:	b083      	sub	sp, #12
 80012ce:	af00      	add	r7, sp, #0
 80012d0:	6078      	str	r0, [r7, #4]
  Orientation[0] = 's';
 80012d2:	687b      	ldr	r3, [r7, #4]
 80012d4:	2273      	movs	r2, #115	@ 0x73
 80012d6:	701a      	strb	r2, [r3, #0]
  Orientation[1] = 'e';
 80012d8:	687b      	ldr	r3, [r7, #4]
 80012da:	3301      	adds	r3, #1
 80012dc:	2265      	movs	r2, #101	@ 0x65
 80012de:	701a      	strb	r2, [r3, #0]
  Orientation[2] = 'u';
 80012e0:	687b      	ldr	r3, [r7, #4]
 80012e2:	3302      	adds	r3, #2
 80012e4:	2275      	movs	r2, #117	@ 0x75
 80012e6:	701a      	strb	r2, [r3, #0]
}
 80012e8:	bf00      	nop
 80012ea:	370c      	adds	r7, #12
 80012ec:	46bd      	mov	sp, r7
 80012ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012f2:	4770      	bx	lr

080012f4 <BSP_SENSOR_GYR_GetOrientation>:
  * @brief  Get gyroscope sensor orientation
  * @param  Orientation Pointer to sensor orientation
  * @retval None
  */
void BSP_SENSOR_GYR_GetOrientation(char *Orientation)
{
 80012f4:	b480      	push	{r7}
 80012f6:	b083      	sub	sp, #12
 80012f8:	af00      	add	r7, sp, #0
 80012fa:	6078      	str	r0, [r7, #4]
  Orientation[0] = 's';
 80012fc:	687b      	ldr	r3, [r7, #4]
 80012fe:	2273      	movs	r2, #115	@ 0x73
 8001300:	701a      	strb	r2, [r3, #0]
  Orientation[1] = 'e';
 8001302:	687b      	ldr	r3, [r7, #4]
 8001304:	3301      	adds	r3, #1
 8001306:	2265      	movs	r2, #101	@ 0x65
 8001308:	701a      	strb	r2, [r3, #0]
  Orientation[2] = 'u';
 800130a:	687b      	ldr	r3, [r7, #4]
 800130c:	3302      	adds	r3, #2
 800130e:	2275      	movs	r2, #117	@ 0x75
 8001310:	701a      	strb	r2, [r3, #0]
}
 8001312:	bf00      	nop
 8001314:	370c      	adds	r7, #12
 8001316:	46bd      	mov	sp, r7
 8001318:	f85d 7b04 	ldr.w	r7, [sp], #4
 800131c:	4770      	bx	lr

0800131e <BSP_SENSOR_MAG_GetOrientation>:
  * @brief  Get magnetometer sensor orientation
  * @param  Orientation Pointer to sensor orientation
  * @retval None
  */
void BSP_SENSOR_MAG_GetOrientation(char *Orientation)
{
 800131e:	b480      	push	{r7}
 8001320:	b083      	sub	sp, #12
 8001322:	af00      	add	r7, sp, #0
 8001324:	6078      	str	r0, [r7, #4]
  Orientation[0] = 'n';
 8001326:	687b      	ldr	r3, [r7, #4]
 8001328:	226e      	movs	r2, #110	@ 0x6e
 800132a:	701a      	strb	r2, [r3, #0]
  Orientation[1] = 'e';
 800132c:	687b      	ldr	r3, [r7, #4]
 800132e:	3301      	adds	r3, #1
 8001330:	2265      	movs	r2, #101	@ 0x65
 8001332:	701a      	strb	r2, [r3, #0]
  Orientation[2] = 'u';
 8001334:	687b      	ldr	r3, [r7, #4]
 8001336:	3302      	adds	r3, #2
 8001338:	2275      	movs	r2, #117	@ 0x75
 800133a:	701a      	strb	r2, [r3, #0]
}
 800133c:	bf00      	nop
 800133e:	370c      	adds	r7, #12
 8001340:	46bd      	mov	sp, r7
 8001342:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001346:	4770      	bx	lr

08001348 <MotionFX_manager_init>:
 * @brief  Initialize the MotionFX engine
 * @param  None
 * @retval None
 */
void MotionFX_manager_init(void)
{
 8001348:	b580      	push	{r7, lr}
 800134a:	af00      	add	r7, sp, #0
  if (STATE_SIZE < MotionFX_GetStateSize())
 800134c:	f01b f834 	bl	801c3b8 <MotionFX_GetStateSize>
 8001350:	4603      	mov	r3, r0
 8001352:	f5b3 6f18 	cmp.w	r3, #2432	@ 0x980
 8001356:	d901      	bls.n	800135c <MotionFX_manager_init+0x14>
    Error_Handler();
 8001358:	f004 fa96 	bl	8005888 <Error_Handler>

  MotionFX_initialize((MFXState_t *)mfxstate);
 800135c:	482a      	ldr	r0, [pc, #168]	@ (8001408 <MotionFX_manager_init+0xc0>)
 800135e:	f01b f82f 	bl	801c3c0 <MotionFX_initialize>

  MotionFX_getKnobs(mfxstate, ipKnobs);
 8001362:	4b2a      	ldr	r3, [pc, #168]	@ (800140c <MotionFX_manager_init+0xc4>)
 8001364:	681b      	ldr	r3, [r3, #0]
 8001366:	4619      	mov	r1, r3
 8001368:	4827      	ldr	r0, [pc, #156]	@ (8001408 <MotionFX_manager_init+0xc0>)
 800136a:	f01b f92f 	bl	801c5cc <MotionFX_getKnobs>

  strcpy(ipKnobs->acc_orientation, "NED");
 800136e:	4b27      	ldr	r3, [pc, #156]	@ (800140c <MotionFX_manager_init+0xc4>)
 8001370:	681b      	ldr	r3, [r3, #0]
 8001372:	331d      	adds	r3, #29
 8001374:	4a26      	ldr	r2, [pc, #152]	@ (8001410 <MotionFX_manager_init+0xc8>)
 8001376:	6810      	ldr	r0, [r2, #0]
 8001378:	6018      	str	r0, [r3, #0]
  strcpy(ipKnobs->gyro_orientation, "NED");
 800137a:	4b24      	ldr	r3, [pc, #144]	@ (800140c <MotionFX_manager_init+0xc4>)
 800137c:	681b      	ldr	r3, [r3, #0]
 800137e:	3321      	adds	r3, #33	@ 0x21
 8001380:	4a23      	ldr	r2, [pc, #140]	@ (8001410 <MotionFX_manager_init+0xc8>)
 8001382:	6810      	ldr	r0, [r2, #0]
 8001384:	6018      	str	r0, [r3, #0]
  strcpy(ipKnobs->mag_orientation, "NED");
 8001386:	4b21      	ldr	r3, [pc, #132]	@ (800140c <MotionFX_manager_init+0xc4>)
 8001388:	681b      	ldr	r3, [r3, #0]
 800138a:	3325      	adds	r3, #37	@ 0x25
 800138c:	4a20      	ldr	r2, [pc, #128]	@ (8001410 <MotionFX_manager_init+0xc8>)
 800138e:	6810      	ldr	r0, [r2, #0]
 8001390:	6018      	str	r0, [r3, #0]

  BSP_SENSOR_ACC_GetOrientation(ipKnobs->acc_orientation);
 8001392:	4b1e      	ldr	r3, [pc, #120]	@ (800140c <MotionFX_manager_init+0xc4>)
 8001394:	681b      	ldr	r3, [r3, #0]
 8001396:	331d      	adds	r3, #29
 8001398:	4618      	mov	r0, r3
 800139a:	f7ff ff96 	bl	80012ca <BSP_SENSOR_ACC_GetOrientation>
  BSP_SENSOR_GYR_GetOrientation(ipKnobs->gyro_orientation);
 800139e:	4b1b      	ldr	r3, [pc, #108]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013a0:	681b      	ldr	r3, [r3, #0]
 80013a2:	3321      	adds	r3, #33	@ 0x21
 80013a4:	4618      	mov	r0, r3
 80013a6:	f7ff ffa5 	bl	80012f4 <BSP_SENSOR_GYR_GetOrientation>
  BSP_SENSOR_MAG_GetOrientation(ipKnobs->mag_orientation);
 80013aa:	4b18      	ldr	r3, [pc, #96]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013ac:	681b      	ldr	r3, [r3, #0]
 80013ae:	3325      	adds	r3, #37	@ 0x25
 80013b0:	4618      	mov	r0, r3
 80013b2:	f7ff ffb4 	bl	800131e <BSP_SENSOR_MAG_GetOrientation>

  ipKnobs->gbias_acc_th_sc = GBIAS_ACC_TH_SC;
 80013b6:	4b15      	ldr	r3, [pc, #84]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013b8:	681b      	ldr	r3, [r3, #0]
 80013ba:	4a16      	ldr	r2, [pc, #88]	@ (8001414 <MotionFX_manager_init+0xcc>)
 80013bc:	615a      	str	r2, [r3, #20]
  ipKnobs->gbias_gyro_th_sc = GBIAS_GYRO_TH_SC;
 80013be:	4b13      	ldr	r3, [pc, #76]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013c0:	681b      	ldr	r3, [r3, #0]
 80013c2:	4a15      	ldr	r2, [pc, #84]	@ (8001418 <MotionFX_manager_init+0xd0>)
 80013c4:	619a      	str	r2, [r3, #24]
  ipKnobs->gbias_mag_th_sc = GBIAS_MAG_TH_SC;
 80013c6:	4b11      	ldr	r3, [pc, #68]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013c8:	681b      	ldr	r3, [r3, #0]
 80013ca:	4a14      	ldr	r2, [pc, #80]	@ (800141c <MotionFX_manager_init+0xd4>)
 80013cc:	611a      	str	r2, [r3, #16]

  ipKnobs->output_type = MFX_ENGINE_OUTPUT_NED;
 80013ce:	4b0f      	ldr	r3, [pc, #60]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013d0:	681b      	ldr	r3, [r3, #0]
 80013d2:	2200      	movs	r2, #0
 80013d4:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
  ipKnobs->LMode = 1;
 80013d8:	4b0c      	ldr	r3, [pc, #48]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013da:	681b      	ldr	r3, [r3, #0]
 80013dc:	2201      	movs	r2, #1
 80013de:	731a      	strb	r2, [r3, #12]
  ipKnobs->modx = DECIMATION;
 80013e0:	4b0a      	ldr	r3, [pc, #40]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013e2:	681b      	ldr	r3, [r3, #0]
 80013e4:	2201      	movs	r2, #1
 80013e6:	771a      	strb	r2, [r3, #28]

  MotionFX_setKnobs(mfxstate, ipKnobs);
 80013e8:	4b08      	ldr	r3, [pc, #32]	@ (800140c <MotionFX_manager_init+0xc4>)
 80013ea:	681b      	ldr	r3, [r3, #0]
 80013ec:	4619      	mov	r1, r3
 80013ee:	4806      	ldr	r0, [pc, #24]	@ (8001408 <MotionFX_manager_init+0xc0>)
 80013f0:	f01b f8a0 	bl	801c534 <MotionFX_setKnobs>

  MotionFX_enable_6X(mfxstate, MFX_ENGINE_DISABLE);
 80013f4:	2100      	movs	r1, #0
 80013f6:	4804      	ldr	r0, [pc, #16]	@ (8001408 <MotionFX_manager_init+0xc0>)
 80013f8:	f01b f926 	bl	801c648 <MotionFX_enable_6X>
  MotionFX_enable_9X(mfxstate, MFX_ENGINE_DISABLE);
 80013fc:	2100      	movs	r1, #0
 80013fe:	4802      	ldr	r0, [pc, #8]	@ (8001408 <MotionFX_manager_init+0xc0>)
 8001400:	f01b f942 	bl	801c688 <MotionFX_enable_9X>
}
 8001404:	bf00      	nop
 8001406:	bd80      	pop	{r7, pc}
 8001408:	200011c0 	.word	0x200011c0
 800140c:	20000004 	.word	0x20000004
 8001410:	080239b8 	.word	0x080239b8
 8001414:	3ac88a48 	.word	0x3ac88a48
 8001418:	3b83126f 	.word	0x3b83126f
 800141c:	3b449ba6 	.word	0x3b449ba6

08001420 <MotionFX_manager_run>:
 * @param  data_out Structure containing output data
 * @param  delta_time Delta time
 * @retval None
 */
void MotionFX_manager_run(MFX_input_t *data_in, MFX_output_t *data_out, float delta_time)
{
 8001420:	b580      	push	{r7, lr}
 8001422:	b086      	sub	sp, #24
 8001424:	af02      	add	r7, sp, #8
 8001426:	60f8      	str	r0, [r7, #12]
 8001428:	60b9      	str	r1, [r7, #8]
 800142a:	ed87 0a01 	vstr	s0, [r7, #4]
  MotionFX_propagate(mfxstate, data_out, data_in, &delta_time);
 800142e:	1d3b      	adds	r3, r7, #4
 8001430:	68fa      	ldr	r2, [r7, #12]
 8001432:	68b9      	ldr	r1, [r7, #8]
 8001434:	4807      	ldr	r0, [pc, #28]	@ (8001454 <MotionFX_manager_run+0x34>)
 8001436:	f01b f957 	bl	801c6e8 <MotionFX_propagate>
  MotionFX_update(mfxstate, data_out, data_in, &delta_time, NULL);
 800143a:	1d3b      	adds	r3, r7, #4
 800143c:	2200      	movs	r2, #0
 800143e:	9200      	str	r2, [sp, #0]
 8001440:	68fa      	ldr	r2, [r7, #12]
 8001442:	68b9      	ldr	r1, [r7, #8]
 8001444:	4803      	ldr	r0, [pc, #12]	@ (8001454 <MotionFX_manager_run+0x34>)
 8001446:	f01b f93f 	bl	801c6c8 <MotionFX_update>
}
 800144a:	bf00      	nop
 800144c:	3710      	adds	r7, #16
 800144e:	46bd      	mov	sp, r7
 8001450:	bd80      	pop	{r7, pc}
 8001452:	bf00      	nop
 8001454:	200011c0 	.word	0x200011c0

08001458 <MotionFX_manager_get_version>:
 * @param  version  Library version string (must be array of 35 char)
 * @param  length  Library version string length
 * @retval None
 */
void MotionFX_manager_get_version(char *version, int *length)
{
 8001458:	b580      	push	{r7, lr}
 800145a:	b082      	sub	sp, #8
 800145c:	af00      	add	r7, sp, #0
 800145e:	6078      	str	r0, [r7, #4]
 8001460:	6039      	str	r1, [r7, #0]
  *length = (int)MotionFX_GetLibVersion(version);
 8001462:	6878      	ldr	r0, [r7, #4]
 8001464:	f01b fb66 	bl	801cb34 <MotionFX_GetLibVersion>
 8001468:	4603      	mov	r3, r0
 800146a:	461a      	mov	r2, r3
 800146c:	683b      	ldr	r3, [r7, #0]
 800146e:	601a      	str	r2, [r3, #0]
}
 8001470:	bf00      	nop
 8001472:	3708      	adds	r7, #8
 8001474:	46bd      	mov	sp, r7
 8001476:	bd80      	pop	{r7, pc}

08001478 <MotionFX_manager_MagCal_start>:
 * @brief  Start magnetometer calibration
 * @param  None
 * @retval None
 */
void MotionFX_manager_MagCal_start(int sampletime)
{
 8001478:	b580      	push	{r7, lr}
 800147a:	b082      	sub	sp, #8
 800147c:	af00      	add	r7, sp, #0
 800147e:	6078      	str	r0, [r7, #4]
  MotionFX_MagCal_init(sampletime, 1);
 8001480:	2101      	movs	r1, #1
 8001482:	6878      	ldr	r0, [r7, #4]
 8001484:	f01b fa80 	bl	801c988 <MotionFX_MagCal_init>
}
 8001488:	bf00      	nop
 800148a:	3708      	adds	r7, #8
 800148c:	46bd      	mov	sp, r7
 800148e:	bd80      	pop	{r7, pc}

08001490 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001490:	b480      	push	{r7}
 8001492:	b083      	sub	sp, #12
 8001494:	af00      	add	r7, sp, #0
 8001496:	4603      	mov	r3, r0
 8001498:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800149a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800149e:	2b00      	cmp	r3, #0
 80014a0:	db0b      	blt.n	80014ba <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80014a2:	79fb      	ldrb	r3, [r7, #7]
 80014a4:	f003 021f 	and.w	r2, r3, #31
 80014a8:	4907      	ldr	r1, [pc, #28]	@ (80014c8 <__NVIC_EnableIRQ+0x38>)
 80014aa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80014ae:	095b      	lsrs	r3, r3, #5
 80014b0:	2001      	movs	r0, #1
 80014b2:	fa00 f202 	lsl.w	r2, r0, r2
 80014b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 80014ba:	bf00      	nop
 80014bc:	370c      	adds	r7, #12
 80014be:	46bd      	mov	sp, r7
 80014c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014c4:	4770      	bx	lr
 80014c6:	bf00      	nop
 80014c8:	e000e100 	.word	0xe000e100

080014cc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80014cc:	b480      	push	{r7}
 80014ce:	b083      	sub	sp, #12
 80014d0:	af00      	add	r7, sp, #0
 80014d2:	4603      	mov	r3, r0
 80014d4:	6039      	str	r1, [r7, #0]
 80014d6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80014d8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80014dc:	2b00      	cmp	r3, #0
 80014de:	db0a      	blt.n	80014f6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80014e0:	683b      	ldr	r3, [r7, #0]
 80014e2:	b2da      	uxtb	r2, r3
 80014e4:	490c      	ldr	r1, [pc, #48]	@ (8001518 <__NVIC_SetPriority+0x4c>)
 80014e6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80014ea:	0112      	lsls	r2, r2, #4
 80014ec:	b2d2      	uxtb	r2, r2
 80014ee:	440b      	add	r3, r1
 80014f0:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80014f4:	e00a      	b.n	800150c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80014f6:	683b      	ldr	r3, [r7, #0]
 80014f8:	b2da      	uxtb	r2, r3
 80014fa:	4908      	ldr	r1, [pc, #32]	@ (800151c <__NVIC_SetPriority+0x50>)
 80014fc:	79fb      	ldrb	r3, [r7, #7]
 80014fe:	f003 030f 	and.w	r3, r3, #15
 8001502:	3b04      	subs	r3, #4
 8001504:	0112      	lsls	r2, r2, #4
 8001506:	b2d2      	uxtb	r2, r2
 8001508:	440b      	add	r3, r1
 800150a:	761a      	strb	r2, [r3, #24]
}
 800150c:	bf00      	nop
 800150e:	370c      	adds	r7, #12
 8001510:	46bd      	mov	sp, r7
 8001512:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001516:	4770      	bx	lr
 8001518:	e000e100 	.word	0xe000e100
 800151c:	e000ed00 	.word	0xe000ed00

08001520 <LL_AHB1_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
 8001520:	b480      	push	{r7}
 8001522:	b085      	sub	sp, #20
 8001524:	af00      	add	r7, sp, #0
 8001526:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 8001528:	4b08      	ldr	r3, [pc, #32]	@ (800154c <LL_AHB1_GRP1_EnableClock+0x2c>)
 800152a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800152c:	4907      	ldr	r1, [pc, #28]	@ (800154c <LL_AHB1_GRP1_EnableClock+0x2c>)
 800152e:	687b      	ldr	r3, [r7, #4]
 8001530:	4313      	orrs	r3, r2
 8001532:	630b      	str	r3, [r1, #48]	@ 0x30
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8001534:	4b05      	ldr	r3, [pc, #20]	@ (800154c <LL_AHB1_GRP1_EnableClock+0x2c>)
 8001536:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001538:	687b      	ldr	r3, [r7, #4]
 800153a:	4013      	ands	r3, r2
 800153c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800153e:	68fb      	ldr	r3, [r7, #12]
}
 8001540:	bf00      	nop
 8001542:	3714      	adds	r7, #20
 8001544:	46bd      	mov	sp, r7
 8001546:	f85d 7b04 	ldr.w	r7, [sp], #4
 800154a:	4770      	bx	lr
 800154c:	40023800 	.word	0x40023800

08001550 <LL_APB1_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 8001550:	b480      	push	{r7}
 8001552:	b085      	sub	sp, #20
 8001554:	af00      	add	r7, sp, #0
 8001556:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
 8001558:	4b08      	ldr	r3, [pc, #32]	@ (800157c <LL_APB1_GRP1_EnableClock+0x2c>)
 800155a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800155c:	4907      	ldr	r1, [pc, #28]	@ (800157c <LL_APB1_GRP1_EnableClock+0x2c>)
 800155e:	687b      	ldr	r3, [r7, #4]
 8001560:	4313      	orrs	r3, r2
 8001562:	640b      	str	r3, [r1, #64]	@ 0x40
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8001564:	4b05      	ldr	r3, [pc, #20]	@ (800157c <LL_APB1_GRP1_EnableClock+0x2c>)
 8001566:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8001568:	687b      	ldr	r3, [r7, #4]
 800156a:	4013      	ands	r3, r2
 800156c:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800156e:	68fb      	ldr	r3, [r7, #12]
}
 8001570:	bf00      	nop
 8001572:	3714      	adds	r7, #20
 8001574:	46bd      	mov	sp, r7
 8001576:	f85d 7b04 	ldr.w	r7, [sp], #4
 800157a:	4770      	bx	lr
 800157c:	40023800 	.word	0x40023800

08001580 <LL_GPIO_SetPinMode>:
  *         @arg @ref LL_GPIO_MODE_ALTERNATE
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
 8001580:	b480      	push	{r7}
 8001582:	b08b      	sub	sp, #44	@ 0x2c
 8001584:	af00      	add	r7, sp, #0
 8001586:	60f8      	str	r0, [r7, #12]
 8001588:	60b9      	str	r1, [r7, #8]
 800158a:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 800158c:	68fb      	ldr	r3, [r7, #12]
 800158e:	681a      	ldr	r2, [r3, #0]
 8001590:	68bb      	ldr	r3, [r7, #8]
 8001592:	617b      	str	r3, [r7, #20]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001594:	697b      	ldr	r3, [r7, #20]
 8001596:	fa93 f3a3 	rbit	r3, r3
 800159a:	613b      	str	r3, [r7, #16]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 800159c:	693b      	ldr	r3, [r7, #16]
 800159e:	61bb      	str	r3, [r7, #24]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 80015a0:	69bb      	ldr	r3, [r7, #24]
 80015a2:	2b00      	cmp	r3, #0
 80015a4:	d101      	bne.n	80015aa <LL_GPIO_SetPinMode+0x2a>
  {
    return 32U;
 80015a6:	2320      	movs	r3, #32
 80015a8:	e003      	b.n	80015b2 <LL_GPIO_SetPinMode+0x32>
  }
  return __builtin_clz(value);
 80015aa:	69bb      	ldr	r3, [r7, #24]
 80015ac:	fab3 f383 	clz	r3, r3
 80015b0:	b2db      	uxtb	r3, r3
 80015b2:	005b      	lsls	r3, r3, #1
 80015b4:	2103      	movs	r1, #3
 80015b6:	fa01 f303 	lsl.w	r3, r1, r3
 80015ba:	43db      	mvns	r3, r3
 80015bc:	401a      	ands	r2, r3
 80015be:	68bb      	ldr	r3, [r7, #8]
 80015c0:	623b      	str	r3, [r7, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80015c2:	6a3b      	ldr	r3, [r7, #32]
 80015c4:	fa93 f3a3 	rbit	r3, r3
 80015c8:	61fb      	str	r3, [r7, #28]
  return result;
 80015ca:	69fb      	ldr	r3, [r7, #28]
 80015cc:	627b      	str	r3, [r7, #36]	@ 0x24
  if (value == 0U)
 80015ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80015d0:	2b00      	cmp	r3, #0
 80015d2:	d101      	bne.n	80015d8 <LL_GPIO_SetPinMode+0x58>
    return 32U;
 80015d4:	2320      	movs	r3, #32
 80015d6:	e003      	b.n	80015e0 <LL_GPIO_SetPinMode+0x60>
  return __builtin_clz(value);
 80015d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80015da:	fab3 f383 	clz	r3, r3
 80015de:	b2db      	uxtb	r3, r3
 80015e0:	005b      	lsls	r3, r3, #1
 80015e2:	6879      	ldr	r1, [r7, #4]
 80015e4:	fa01 f303 	lsl.w	r3, r1, r3
 80015e8:	431a      	orrs	r2, r3
 80015ea:	68fb      	ldr	r3, [r7, #12]
 80015ec:	601a      	str	r2, [r3, #0]
}
 80015ee:	bf00      	nop
 80015f0:	372c      	adds	r7, #44	@ 0x2c
 80015f2:	46bd      	mov	sp, r7
 80015f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80015f8:	4770      	bx	lr

080015fa <LL_GPIO_SetPinOutputType>:
  *         @arg @ref LL_GPIO_OUTPUT_PUSHPULL
  *         @arg @ref LL_GPIO_OUTPUT_OPENDRAIN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinOutputType(GPIO_TypeDef *GPIOx, uint32_t PinMask, uint32_t OutputType)
{
 80015fa:	b480      	push	{r7}
 80015fc:	b085      	sub	sp, #20
 80015fe:	af00      	add	r7, sp, #0
 8001600:	60f8      	str	r0, [r7, #12]
 8001602:	60b9      	str	r1, [r7, #8]
 8001604:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8001606:	68fb      	ldr	r3, [r7, #12]
 8001608:	685a      	ldr	r2, [r3, #4]
 800160a:	68bb      	ldr	r3, [r7, #8]
 800160c:	43db      	mvns	r3, r3
 800160e:	401a      	ands	r2, r3
 8001610:	68bb      	ldr	r3, [r7, #8]
 8001612:	6879      	ldr	r1, [r7, #4]
 8001614:	fb01 f303 	mul.w	r3, r1, r3
 8001618:	431a      	orrs	r2, r3
 800161a:	68fb      	ldr	r3, [r7, #12]
 800161c:	605a      	str	r2, [r3, #4]
}
 800161e:	bf00      	nop
 8001620:	3714      	adds	r7, #20
 8001622:	46bd      	mov	sp, r7
 8001624:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001628:	4770      	bx	lr

0800162a <LL_GPIO_SetPinSpeed>:
  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
 800162a:	b480      	push	{r7}
 800162c:	b08b      	sub	sp, #44	@ 0x2c
 800162e:	af00      	add	r7, sp, #0
 8001630:	60f8      	str	r0, [r7, #12]
 8001632:	60b9      	str	r1, [r7, #8]
 8001634:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8001636:	68fb      	ldr	r3, [r7, #12]
 8001638:	689a      	ldr	r2, [r3, #8]
 800163a:	68bb      	ldr	r3, [r7, #8]
 800163c:	617b      	str	r3, [r7, #20]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800163e:	697b      	ldr	r3, [r7, #20]
 8001640:	fa93 f3a3 	rbit	r3, r3
 8001644:	613b      	str	r3, [r7, #16]
  return result;
 8001646:	693b      	ldr	r3, [r7, #16]
 8001648:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 800164a:	69bb      	ldr	r3, [r7, #24]
 800164c:	2b00      	cmp	r3, #0
 800164e:	d101      	bne.n	8001654 <LL_GPIO_SetPinSpeed+0x2a>
    return 32U;
 8001650:	2320      	movs	r3, #32
 8001652:	e003      	b.n	800165c <LL_GPIO_SetPinSpeed+0x32>
  return __builtin_clz(value);
 8001654:	69bb      	ldr	r3, [r7, #24]
 8001656:	fab3 f383 	clz	r3, r3
 800165a:	b2db      	uxtb	r3, r3
 800165c:	005b      	lsls	r3, r3, #1
 800165e:	2103      	movs	r1, #3
 8001660:	fa01 f303 	lsl.w	r3, r1, r3
 8001664:	43db      	mvns	r3, r3
 8001666:	401a      	ands	r2, r3
 8001668:	68bb      	ldr	r3, [r7, #8]
 800166a:	623b      	str	r3, [r7, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800166c:	6a3b      	ldr	r3, [r7, #32]
 800166e:	fa93 f3a3 	rbit	r3, r3
 8001672:	61fb      	str	r3, [r7, #28]
  return result;
 8001674:	69fb      	ldr	r3, [r7, #28]
 8001676:	627b      	str	r3, [r7, #36]	@ 0x24
  if (value == 0U)
 8001678:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800167a:	2b00      	cmp	r3, #0
 800167c:	d101      	bne.n	8001682 <LL_GPIO_SetPinSpeed+0x58>
    return 32U;
 800167e:	2320      	movs	r3, #32
 8001680:	e003      	b.n	800168a <LL_GPIO_SetPinSpeed+0x60>
  return __builtin_clz(value);
 8001682:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001684:	fab3 f383 	clz	r3, r3
 8001688:	b2db      	uxtb	r3, r3
 800168a:	005b      	lsls	r3, r3, #1
 800168c:	6879      	ldr	r1, [r7, #4]
 800168e:	fa01 f303 	lsl.w	r3, r1, r3
 8001692:	431a      	orrs	r2, r3
 8001694:	68fb      	ldr	r3, [r7, #12]
 8001696:	609a      	str	r2, [r3, #8]
             (Speed << (POSITION_VAL(Pin) * 2U)));
}
 8001698:	bf00      	nop
 800169a:	372c      	adds	r7, #44	@ 0x2c
 800169c:	46bd      	mov	sp, r7
 800169e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016a2:	4770      	bx	lr

080016a4 <LL_GPIO_SetPinPull>:
  *         @arg @ref LL_GPIO_PULL_UP
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
 80016a4:	b480      	push	{r7}
 80016a6:	b08b      	sub	sp, #44	@ 0x2c
 80016a8:	af00      	add	r7, sp, #0
 80016aa:	60f8      	str	r0, [r7, #12]
 80016ac:	60b9      	str	r1, [r7, #8]
 80016ae:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80016b0:	68fb      	ldr	r3, [r7, #12]
 80016b2:	68da      	ldr	r2, [r3, #12]
 80016b4:	68bb      	ldr	r3, [r7, #8]
 80016b6:	617b      	str	r3, [r7, #20]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80016b8:	697b      	ldr	r3, [r7, #20]
 80016ba:	fa93 f3a3 	rbit	r3, r3
 80016be:	613b      	str	r3, [r7, #16]
  return result;
 80016c0:	693b      	ldr	r3, [r7, #16]
 80016c2:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 80016c4:	69bb      	ldr	r3, [r7, #24]
 80016c6:	2b00      	cmp	r3, #0
 80016c8:	d101      	bne.n	80016ce <LL_GPIO_SetPinPull+0x2a>
    return 32U;
 80016ca:	2320      	movs	r3, #32
 80016cc:	e003      	b.n	80016d6 <LL_GPIO_SetPinPull+0x32>
  return __builtin_clz(value);
 80016ce:	69bb      	ldr	r3, [r7, #24]
 80016d0:	fab3 f383 	clz	r3, r3
 80016d4:	b2db      	uxtb	r3, r3
 80016d6:	005b      	lsls	r3, r3, #1
 80016d8:	2103      	movs	r1, #3
 80016da:	fa01 f303 	lsl.w	r3, r1, r3
 80016de:	43db      	mvns	r3, r3
 80016e0:	401a      	ands	r2, r3
 80016e2:	68bb      	ldr	r3, [r7, #8]
 80016e4:	623b      	str	r3, [r7, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80016e6:	6a3b      	ldr	r3, [r7, #32]
 80016e8:	fa93 f3a3 	rbit	r3, r3
 80016ec:	61fb      	str	r3, [r7, #28]
  return result;
 80016ee:	69fb      	ldr	r3, [r7, #28]
 80016f0:	627b      	str	r3, [r7, #36]	@ 0x24
  if (value == 0U)
 80016f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80016f4:	2b00      	cmp	r3, #0
 80016f6:	d101      	bne.n	80016fc <LL_GPIO_SetPinPull+0x58>
    return 32U;
 80016f8:	2320      	movs	r3, #32
 80016fa:	e003      	b.n	8001704 <LL_GPIO_SetPinPull+0x60>
  return __builtin_clz(value);
 80016fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80016fe:	fab3 f383 	clz	r3, r3
 8001702:	b2db      	uxtb	r3, r3
 8001704:	005b      	lsls	r3, r3, #1
 8001706:	6879      	ldr	r1, [r7, #4]
 8001708:	fa01 f303 	lsl.w	r3, r1, r3
 800170c:	431a      	orrs	r2, r3
 800170e:	68fb      	ldr	r3, [r7, #12]
 8001710:	60da      	str	r2, [r3, #12]
}
 8001712:	bf00      	nop
 8001714:	372c      	adds	r7, #44	@ 0x2c
 8001716:	46bd      	mov	sp, r7
 8001718:	f85d 7b04 	ldr.w	r7, [sp], #4
 800171c:	4770      	bx	lr

0800171e <LL_GPIO_SetAFPin_0_7>:
  *         @arg @ref LL_GPIO_AF_14
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
 800171e:	b480      	push	{r7}
 8001720:	b08b      	sub	sp, #44	@ 0x2c
 8001722:	af00      	add	r7, sp, #0
 8001724:	60f8      	str	r0, [r7, #12]
 8001726:	60b9      	str	r1, [r7, #8]
 8001728:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 800172a:	68fb      	ldr	r3, [r7, #12]
 800172c:	6a1a      	ldr	r2, [r3, #32]
 800172e:	68bb      	ldr	r3, [r7, #8]
 8001730:	617b      	str	r3, [r7, #20]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001732:	697b      	ldr	r3, [r7, #20]
 8001734:	fa93 f3a3 	rbit	r3, r3
 8001738:	613b      	str	r3, [r7, #16]
  return result;
 800173a:	693b      	ldr	r3, [r7, #16]
 800173c:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 800173e:	69bb      	ldr	r3, [r7, #24]
 8001740:	2b00      	cmp	r3, #0
 8001742:	d101      	bne.n	8001748 <LL_GPIO_SetAFPin_0_7+0x2a>
    return 32U;
 8001744:	2320      	movs	r3, #32
 8001746:	e003      	b.n	8001750 <LL_GPIO_SetAFPin_0_7+0x32>
  return __builtin_clz(value);
 8001748:	69bb      	ldr	r3, [r7, #24]
 800174a:	fab3 f383 	clz	r3, r3
 800174e:	b2db      	uxtb	r3, r3
 8001750:	009b      	lsls	r3, r3, #2
 8001752:	210f      	movs	r1, #15
 8001754:	fa01 f303 	lsl.w	r3, r1, r3
 8001758:	43db      	mvns	r3, r3
 800175a:	401a      	ands	r2, r3
 800175c:	68bb      	ldr	r3, [r7, #8]
 800175e:	623b      	str	r3, [r7, #32]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001760:	6a3b      	ldr	r3, [r7, #32]
 8001762:	fa93 f3a3 	rbit	r3, r3
 8001766:	61fb      	str	r3, [r7, #28]
  return result;
 8001768:	69fb      	ldr	r3, [r7, #28]
 800176a:	627b      	str	r3, [r7, #36]	@ 0x24
  if (value == 0U)
 800176c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800176e:	2b00      	cmp	r3, #0
 8001770:	d101      	bne.n	8001776 <LL_GPIO_SetAFPin_0_7+0x58>
    return 32U;
 8001772:	2320      	movs	r3, #32
 8001774:	e003      	b.n	800177e <LL_GPIO_SetAFPin_0_7+0x60>
  return __builtin_clz(value);
 8001776:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001778:	fab3 f383 	clz	r3, r3
 800177c:	b2db      	uxtb	r3, r3
 800177e:	009b      	lsls	r3, r3, #2
 8001780:	6879      	ldr	r1, [r7, #4]
 8001782:	fa01 f303 	lsl.w	r3, r1, r3
 8001786:	431a      	orrs	r2, r3
 8001788:	68fb      	ldr	r3, [r7, #12]
 800178a:	621a      	str	r2, [r3, #32]
             (Alternate << (POSITION_VAL(Pin) * 4U)));
}
 800178c:	bf00      	nop
 800178e:	372c      	adds	r7, #44	@ 0x2c
 8001790:	46bd      	mov	sp, r7
 8001792:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001796:	4770      	bx	lr

08001798 <LL_GPIO_ResetOutputPin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
 8001798:	b480      	push	{r7}
 800179a:	b083      	sub	sp, #12
 800179c:	af00      	add	r7, sp, #0
 800179e:	6078      	str	r0, [r7, #4]
 80017a0:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 80017a2:	683b      	ldr	r3, [r7, #0]
 80017a4:	041a      	lsls	r2, r3, #16
 80017a6:	687b      	ldr	r3, [r7, #4]
 80017a8:	619a      	str	r2, [r3, #24]
}
 80017aa:	bf00      	nop
 80017ac:	370c      	adds	r7, #12
 80017ae:	46bd      	mov	sp, r7
 80017b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017b4:	4770      	bx	lr

080017b6 <LL_GPIO_TogglePin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
 80017b6:	b480      	push	{r7}
 80017b8:	b085      	sub	sp, #20
 80017ba:	af00      	add	r7, sp, #0
 80017bc:	6078      	str	r0, [r7, #4]
 80017be:	6039      	str	r1, [r7, #0]
  uint32_t odr = READ_REG(GPIOx->ODR);
 80017c0:	687b      	ldr	r3, [r7, #4]
 80017c2:	695b      	ldr	r3, [r3, #20]
 80017c4:	60fb      	str	r3, [r7, #12]
  WRITE_REG(GPIOx->BSRR, ((odr & PinMask) << 16u) | (~odr & PinMask));
 80017c6:	68fa      	ldr	r2, [r7, #12]
 80017c8:	683b      	ldr	r3, [r7, #0]
 80017ca:	4013      	ands	r3, r2
 80017cc:	041a      	lsls	r2, r3, #16
 80017ce:	68fb      	ldr	r3, [r7, #12]
 80017d0:	43d9      	mvns	r1, r3
 80017d2:	683b      	ldr	r3, [r7, #0]
 80017d4:	400b      	ands	r3, r1
 80017d6:	431a      	orrs	r2, r3
 80017d8:	687b      	ldr	r3, [r7, #4]
 80017da:	619a      	str	r2, [r3, #24]
}
 80017dc:	bf00      	nop
 80017de:	3714      	adds	r7, #20
 80017e0:	46bd      	mov	sp, r7
 80017e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017e6:	4770      	bx	lr

080017e8 <LL_USART_Enable>:
  * @rmtoll CR1          UE            LL_USART_Enable
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_Enable(USART_TypeDef *USARTx)
{
 80017e8:	b480      	push	{r7}
 80017ea:	b083      	sub	sp, #12
 80017ec:	af00      	add	r7, sp, #0
 80017ee:	6078      	str	r0, [r7, #4]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 80017f0:	687b      	ldr	r3, [r7, #4]
 80017f2:	68db      	ldr	r3, [r3, #12]
 80017f4:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
 80017f8:	687b      	ldr	r3, [r7, #4]
 80017fa:	60da      	str	r2, [r3, #12]
}
 80017fc:	bf00      	nop
 80017fe:	370c      	adds	r7, #12
 8001800:	46bd      	mov	sp, r7
 8001802:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001806:	4770      	bx	lr

08001808 <LL_USART_SetTransferDirection>:
  *         @arg @ref LL_USART_DIRECTION_TX
  *         @arg @ref LL_USART_DIRECTION_TX_RX
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetTransferDirection(USART_TypeDef *USARTx, uint32_t TransferDirection)
{
 8001808:	b480      	push	{r7}
 800180a:	b089      	sub	sp, #36	@ 0x24
 800180c:	af00      	add	r7, sp, #0
 800180e:	6078      	str	r0, [r7, #4]
 8001810:	6039      	str	r1, [r7, #0]
  ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8001812:	687b      	ldr	r3, [r7, #4]
 8001814:	330c      	adds	r3, #12
 8001816:	60fb      	str	r3, [r7, #12]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001818:	68fb      	ldr	r3, [r7, #12]
 800181a:	e853 3f00 	ldrex	r3, [r3]
 800181e:	60bb      	str	r3, [r7, #8]
   return(result);
 8001820:	68bb      	ldr	r3, [r7, #8]
 8001822:	f023 030c 	bic.w	r3, r3, #12
 8001826:	683a      	ldr	r2, [r7, #0]
 8001828:	4313      	orrs	r3, r2
 800182a:	61fb      	str	r3, [r7, #28]
 800182c:	687b      	ldr	r3, [r7, #4]
 800182e:	330c      	adds	r3, #12
 8001830:	69fa      	ldr	r2, [r7, #28]
 8001832:	61ba      	str	r2, [r7, #24]
 8001834:	617b      	str	r3, [r7, #20]
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001836:	6979      	ldr	r1, [r7, #20]
 8001838:	69ba      	ldr	r2, [r7, #24]
 800183a:	e841 2300 	strex	r3, r2, [r1]
 800183e:	613b      	str	r3, [r7, #16]
   return(result);
 8001840:	693b      	ldr	r3, [r7, #16]
 8001842:	2b00      	cmp	r3, #0
 8001844:	d1e5      	bne.n	8001812 <LL_USART_SetTransferDirection+0xa>
}
 8001846:	bf00      	nop
 8001848:	bf00      	nop
 800184a:	3724      	adds	r7, #36	@ 0x24
 800184c:	46bd      	mov	sp, r7
 800184e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001852:	4770      	bx	lr

08001854 <LL_USART_ConfigCharacter>:
  *         @arg @ref LL_USART_STOPBITS_2
  * @retval None
  */
__STATIC_INLINE void LL_USART_ConfigCharacter(USART_TypeDef *USARTx, uint32_t DataWidth, uint32_t Parity,
                                              uint32_t StopBits)
{
 8001854:	b480      	push	{r7}
 8001856:	b085      	sub	sp, #20
 8001858:	af00      	add	r7, sp, #0
 800185a:	60f8      	str	r0, [r7, #12]
 800185c:	60b9      	str	r1, [r7, #8]
 800185e:	607a      	str	r2, [r7, #4]
 8001860:	603b      	str	r3, [r7, #0]
  MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 8001862:	68fb      	ldr	r3, [r7, #12]
 8001864:	68db      	ldr	r3, [r3, #12]
 8001866:	f423 52b0 	bic.w	r2, r3, #5632	@ 0x1600
 800186a:	6879      	ldr	r1, [r7, #4]
 800186c:	68bb      	ldr	r3, [r7, #8]
 800186e:	430b      	orrs	r3, r1
 8001870:	431a      	orrs	r2, r3
 8001872:	68fb      	ldr	r3, [r7, #12]
 8001874:	60da      	str	r2, [r3, #12]
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8001876:	68fb      	ldr	r3, [r7, #12]
 8001878:	691b      	ldr	r3, [r3, #16]
 800187a:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
 800187e:	683b      	ldr	r3, [r7, #0]
 8001880:	431a      	orrs	r2, r3
 8001882:	68fb      	ldr	r3, [r7, #12]
 8001884:	611a      	str	r2, [r3, #16]
}
 8001886:	bf00      	nop
 8001888:	3714      	adds	r7, #20
 800188a:	46bd      	mov	sp, r7
 800188c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001890:	4770      	bx	lr
	...

08001894 <LL_USART_SetBaudRate>:
  * @param  BaudRate Baud Rate
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
                                          uint32_t BaudRate)
{
 8001894:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8001898:	b0c0      	sub	sp, #256	@ 0x100
 800189a:	af00      	add	r7, sp, #0
 800189c:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
 80018a0:	f8c7 10f8 	str.w	r1, [r7, #248]	@ 0xf8
 80018a4:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
 80018a8:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
  if (OverSampling == LL_USART_OVERSAMPLING_8)
 80018ac:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80018b0:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80018b4:	f040 810c 	bne.w	8001ad0 <LL_USART_SetBaudRate+0x23c>
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 80018b8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 80018bc:	2200      	movs	r2, #0
 80018be:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 80018c2:	f8c7 20ec 	str.w	r2, [r7, #236]	@ 0xec
 80018c6:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	@ 0xe8
 80018ca:	4622      	mov	r2, r4
 80018cc:	462b      	mov	r3, r5
 80018ce:	1891      	adds	r1, r2, r2
 80018d0:	6639      	str	r1, [r7, #96]	@ 0x60
 80018d2:	415b      	adcs	r3, r3
 80018d4:	667b      	str	r3, [r7, #100]	@ 0x64
 80018d6:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 80018da:	4621      	mov	r1, r4
 80018dc:	eb12 0801 	adds.w	r8, r2, r1
 80018e0:	4629      	mov	r1, r5
 80018e2:	eb43 0901 	adc.w	r9, r3, r1
 80018e6:	f04f 0200 	mov.w	r2, #0
 80018ea:	f04f 0300 	mov.w	r3, #0
 80018ee:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 80018f2:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 80018f6:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 80018fa:	4690      	mov	r8, r2
 80018fc:	4699      	mov	r9, r3
 80018fe:	4623      	mov	r3, r4
 8001900:	eb18 0303 	adds.w	r3, r8, r3
 8001904:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8001908:	462b      	mov	r3, r5
 800190a:	eb49 0303 	adc.w	r3, r9, r3
 800190e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8001912:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8001916:	2200      	movs	r2, #0
 8001918:	469a      	mov	sl, r3
 800191a:	4693      	mov	fp, r2
 800191c:	eb1a 030a 	adds.w	r3, sl, sl
 8001920:	65bb      	str	r3, [r7, #88]	@ 0x58
 8001922:	eb4b 030b 	adc.w	r3, fp, fp
 8001926:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8001928:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 800192c:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
 8001930:	f7ff f9b2 	bl	8000c98 <__aeabi_uldivmod>
 8001934:	4602      	mov	r2, r0
 8001936:	460b      	mov	r3, r1
 8001938:	4b64      	ldr	r3, [pc, #400]	@ (8001acc <LL_USART_SetBaudRate+0x238>)
 800193a:	fba3 2302 	umull	r2, r3, r3, r2
 800193e:	095b      	lsrs	r3, r3, #5
 8001940:	b29b      	uxth	r3, r3
 8001942:	011b      	lsls	r3, r3, #4
 8001944:	b29c      	uxth	r4, r3
 8001946:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 800194a:	2200      	movs	r2, #0
 800194c:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 8001950:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
 8001954:	e9d7 8936 	ldrd	r8, r9, [r7, #216]	@ 0xd8
 8001958:	4642      	mov	r2, r8
 800195a:	464b      	mov	r3, r9
 800195c:	1891      	adds	r1, r2, r2
 800195e:	6539      	str	r1, [r7, #80]	@ 0x50
 8001960:	415b      	adcs	r3, r3
 8001962:	657b      	str	r3, [r7, #84]	@ 0x54
 8001964:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 8001968:	4641      	mov	r1, r8
 800196a:	1851      	adds	r1, r2, r1
 800196c:	64b9      	str	r1, [r7, #72]	@ 0x48
 800196e:	4649      	mov	r1, r9
 8001970:	414b      	adcs	r3, r1
 8001972:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8001974:	f04f 0200 	mov.w	r2, #0
 8001978:	f04f 0300 	mov.w	r3, #0
 800197c:	e9d7 ab12 	ldrd	sl, fp, [r7, #72]	@ 0x48
 8001980:	4659      	mov	r1, fp
 8001982:	00cb      	lsls	r3, r1, #3
 8001984:	4651      	mov	r1, sl
 8001986:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 800198a:	4651      	mov	r1, sl
 800198c:	00ca      	lsls	r2, r1, #3
 800198e:	4610      	mov	r0, r2
 8001990:	4619      	mov	r1, r3
 8001992:	4603      	mov	r3, r0
 8001994:	4642      	mov	r2, r8
 8001996:	189b      	adds	r3, r3, r2
 8001998:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 800199c:	464b      	mov	r3, r9
 800199e:	460a      	mov	r2, r1
 80019a0:	eb42 0303 	adc.w	r3, r2, r3
 80019a4:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 80019a8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80019ac:	2200      	movs	r2, #0
 80019ae:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80019b2:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
 80019b6:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 80019ba:	460b      	mov	r3, r1
 80019bc:	18db      	adds	r3, r3, r3
 80019be:	643b      	str	r3, [r7, #64]	@ 0x40
 80019c0:	4613      	mov	r3, r2
 80019c2:	eb42 0303 	adc.w	r3, r2, r3
 80019c6:	647b      	str	r3, [r7, #68]	@ 0x44
 80019c8:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80019cc:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
 80019d0:	f7ff f962 	bl	8000c98 <__aeabi_uldivmod>
 80019d4:	4602      	mov	r2, r0
 80019d6:	460b      	mov	r3, r1
 80019d8:	4611      	mov	r1, r2
 80019da:	4b3c      	ldr	r3, [pc, #240]	@ (8001acc <LL_USART_SetBaudRate+0x238>)
 80019dc:	fba3 2301 	umull	r2, r3, r3, r1
 80019e0:	095b      	lsrs	r3, r3, #5
 80019e2:	2264      	movs	r2, #100	@ 0x64
 80019e4:	fb02 f303 	mul.w	r3, r2, r3
 80019e8:	1acb      	subs	r3, r1, r3
 80019ea:	00db      	lsls	r3, r3, #3
 80019ec:	f103 0232 	add.w	r2, r3, #50	@ 0x32
 80019f0:	4b36      	ldr	r3, [pc, #216]	@ (8001acc <LL_USART_SetBaudRate+0x238>)
 80019f2:	fba3 2302 	umull	r2, r3, r3, r2
 80019f6:	095b      	lsrs	r3, r3, #5
 80019f8:	b29b      	uxth	r3, r3
 80019fa:	005b      	lsls	r3, r3, #1
 80019fc:	b29b      	uxth	r3, r3
 80019fe:	f403 73f8 	and.w	r3, r3, #496	@ 0x1f0
 8001a02:	b29b      	uxth	r3, r3
 8001a04:	4423      	add	r3, r4
 8001a06:	b29c      	uxth	r4, r3
 8001a08:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8001a0c:	2200      	movs	r2, #0
 8001a0e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8001a12:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
 8001a16:	e9d7 8930 	ldrd	r8, r9, [r7, #192]	@ 0xc0
 8001a1a:	4642      	mov	r2, r8
 8001a1c:	464b      	mov	r3, r9
 8001a1e:	1891      	adds	r1, r2, r2
 8001a20:	63b9      	str	r1, [r7, #56]	@ 0x38
 8001a22:	415b      	adcs	r3, r3
 8001a24:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8001a26:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8001a2a:	4641      	mov	r1, r8
 8001a2c:	1851      	adds	r1, r2, r1
 8001a2e:	6339      	str	r1, [r7, #48]	@ 0x30
 8001a30:	4649      	mov	r1, r9
 8001a32:	414b      	adcs	r3, r1
 8001a34:	637b      	str	r3, [r7, #52]	@ 0x34
 8001a36:	f04f 0200 	mov.w	r2, #0
 8001a3a:	f04f 0300 	mov.w	r3, #0
 8001a3e:	e9d7 ab0c 	ldrd	sl, fp, [r7, #48]	@ 0x30
 8001a42:	4659      	mov	r1, fp
 8001a44:	00cb      	lsls	r3, r1, #3
 8001a46:	4651      	mov	r1, sl
 8001a48:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8001a4c:	4651      	mov	r1, sl
 8001a4e:	00ca      	lsls	r2, r1, #3
 8001a50:	4610      	mov	r0, r2
 8001a52:	4619      	mov	r1, r3
 8001a54:	4603      	mov	r3, r0
 8001a56:	4642      	mov	r2, r8
 8001a58:	189b      	adds	r3, r3, r2
 8001a5a:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8001a5e:	464b      	mov	r3, r9
 8001a60:	460a      	mov	r2, r1
 8001a62:	eb42 0303 	adc.w	r3, r2, r3
 8001a66:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8001a6a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8001a6e:	2200      	movs	r2, #0
 8001a70:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 8001a74:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
 8001a78:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 8001a7c:	460b      	mov	r3, r1
 8001a7e:	18db      	adds	r3, r3, r3
 8001a80:	62bb      	str	r3, [r7, #40]	@ 0x28
 8001a82:	4613      	mov	r3, r2
 8001a84:	eb42 0303 	adc.w	r3, r2, r3
 8001a88:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8001a8a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8001a8e:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
 8001a92:	f7ff f901 	bl	8000c98 <__aeabi_uldivmod>
 8001a96:	4602      	mov	r2, r0
 8001a98:	460b      	mov	r3, r1
 8001a9a:	4b0c      	ldr	r3, [pc, #48]	@ (8001acc <LL_USART_SetBaudRate+0x238>)
 8001a9c:	fba3 1302 	umull	r1, r3, r3, r2
 8001aa0:	095b      	lsrs	r3, r3, #5
 8001aa2:	2164      	movs	r1, #100	@ 0x64
 8001aa4:	fb01 f303 	mul.w	r3, r1, r3
 8001aa8:	1ad3      	subs	r3, r2, r3
 8001aaa:	00db      	lsls	r3, r3, #3
 8001aac:	3332      	adds	r3, #50	@ 0x32
 8001aae:	4a07      	ldr	r2, [pc, #28]	@ (8001acc <LL_USART_SetBaudRate+0x238>)
 8001ab0:	fba2 2303 	umull	r2, r3, r2, r3
 8001ab4:	095b      	lsrs	r3, r3, #5
 8001ab6:	b29b      	uxth	r3, r3
 8001ab8:	f003 0307 	and.w	r3, r3, #7
 8001abc:	b29b      	uxth	r3, r3
 8001abe:	4423      	add	r3, r4
 8001ac0:	b29b      	uxth	r3, r3
 8001ac2:	461a      	mov	r2, r3
 8001ac4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8001ac8:	609a      	str	r2, [r3, #8]
  }
  else
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
  }
}
 8001aca:	e108      	b.n	8001cde <LL_USART_SetBaudRate+0x44a>
 8001acc:	51eb851f 	.word	0x51eb851f
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 8001ad0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8001ad4:	2200      	movs	r2, #0
 8001ad6:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 8001ada:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
 8001ade:	e9d7 892a 	ldrd	r8, r9, [r7, #168]	@ 0xa8
 8001ae2:	4642      	mov	r2, r8
 8001ae4:	464b      	mov	r3, r9
 8001ae6:	1891      	adds	r1, r2, r2
 8001ae8:	6239      	str	r1, [r7, #32]
 8001aea:	415b      	adcs	r3, r3
 8001aec:	627b      	str	r3, [r7, #36]	@ 0x24
 8001aee:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8001af2:	4641      	mov	r1, r8
 8001af4:	1854      	adds	r4, r2, r1
 8001af6:	4649      	mov	r1, r9
 8001af8:	eb43 0501 	adc.w	r5, r3, r1
 8001afc:	f04f 0200 	mov.w	r2, #0
 8001b00:	f04f 0300 	mov.w	r3, #0
 8001b04:	00eb      	lsls	r3, r5, #3
 8001b06:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8001b0a:	00e2      	lsls	r2, r4, #3
 8001b0c:	4614      	mov	r4, r2
 8001b0e:	461d      	mov	r5, r3
 8001b10:	4643      	mov	r3, r8
 8001b12:	18e3      	adds	r3, r4, r3
 8001b14:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8001b18:	464b      	mov	r3, r9
 8001b1a:	eb45 0303 	adc.w	r3, r5, r3
 8001b1e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 8001b22:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8001b26:	2200      	movs	r2, #0
 8001b28:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 8001b2c:	f8c7 209c 	str.w	r2, [r7, #156]	@ 0x9c
 8001b30:	f04f 0200 	mov.w	r2, #0
 8001b34:	f04f 0300 	mov.w	r3, #0
 8001b38:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
 8001b3c:	4629      	mov	r1, r5
 8001b3e:	008b      	lsls	r3, r1, #2
 8001b40:	4621      	mov	r1, r4
 8001b42:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 8001b46:	4621      	mov	r1, r4
 8001b48:	008a      	lsls	r2, r1, #2
 8001b4a:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
 8001b4e:	f7ff f8a3 	bl	8000c98 <__aeabi_uldivmod>
 8001b52:	4602      	mov	r2, r0
 8001b54:	460b      	mov	r3, r1
 8001b56:	4b65      	ldr	r3, [pc, #404]	@ (8001cec <LL_USART_SetBaudRate+0x458>)
 8001b58:	fba3 2302 	umull	r2, r3, r3, r2
 8001b5c:	095b      	lsrs	r3, r3, #5
 8001b5e:	b29b      	uxth	r3, r3
 8001b60:	011b      	lsls	r3, r3, #4
 8001b62:	b29c      	uxth	r4, r3
 8001b64:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8001b68:	2200      	movs	r2, #0
 8001b6a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8001b6e:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 8001b72:	e9d7 8924 	ldrd	r8, r9, [r7, #144]	@ 0x90
 8001b76:	4642      	mov	r2, r8
 8001b78:	464b      	mov	r3, r9
 8001b7a:	1891      	adds	r1, r2, r2
 8001b7c:	61b9      	str	r1, [r7, #24]
 8001b7e:	415b      	adcs	r3, r3
 8001b80:	61fb      	str	r3, [r7, #28]
 8001b82:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8001b86:	4641      	mov	r1, r8
 8001b88:	1851      	adds	r1, r2, r1
 8001b8a:	6139      	str	r1, [r7, #16]
 8001b8c:	4649      	mov	r1, r9
 8001b8e:	414b      	adcs	r3, r1
 8001b90:	617b      	str	r3, [r7, #20]
 8001b92:	f04f 0200 	mov.w	r2, #0
 8001b96:	f04f 0300 	mov.w	r3, #0
 8001b9a:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 8001b9e:	4659      	mov	r1, fp
 8001ba0:	00cb      	lsls	r3, r1, #3
 8001ba2:	4651      	mov	r1, sl
 8001ba4:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8001ba8:	4651      	mov	r1, sl
 8001baa:	00ca      	lsls	r2, r1, #3
 8001bac:	4610      	mov	r0, r2
 8001bae:	4619      	mov	r1, r3
 8001bb0:	4603      	mov	r3, r0
 8001bb2:	4642      	mov	r2, r8
 8001bb4:	189b      	adds	r3, r3, r2
 8001bb6:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8001bba:	464b      	mov	r3, r9
 8001bbc:	460a      	mov	r2, r1
 8001bbe:	eb42 0303 	adc.w	r3, r2, r3
 8001bc2:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8001bc6:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8001bca:	2200      	movs	r2, #0
 8001bcc:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8001bd0:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84
 8001bd4:	f04f 0200 	mov.w	r2, #0
 8001bd8:	f04f 0300 	mov.w	r3, #0
 8001bdc:	e9d7 8920 	ldrd	r8, r9, [r7, #128]	@ 0x80
 8001be0:	4649      	mov	r1, r9
 8001be2:	008b      	lsls	r3, r1, #2
 8001be4:	4641      	mov	r1, r8
 8001be6:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 8001bea:	4641      	mov	r1, r8
 8001bec:	008a      	lsls	r2, r1, #2
 8001bee:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
 8001bf2:	f7ff f851 	bl	8000c98 <__aeabi_uldivmod>
 8001bf6:	4602      	mov	r2, r0
 8001bf8:	460b      	mov	r3, r1
 8001bfa:	4611      	mov	r1, r2
 8001bfc:	4b3b      	ldr	r3, [pc, #236]	@ (8001cec <LL_USART_SetBaudRate+0x458>)
 8001bfe:	fba3 2301 	umull	r2, r3, r3, r1
 8001c02:	095b      	lsrs	r3, r3, #5
 8001c04:	2264      	movs	r2, #100	@ 0x64
 8001c06:	fb02 f303 	mul.w	r3, r2, r3
 8001c0a:	1acb      	subs	r3, r1, r3
 8001c0c:	011b      	lsls	r3, r3, #4
 8001c0e:	3332      	adds	r3, #50	@ 0x32
 8001c10:	4a36      	ldr	r2, [pc, #216]	@ (8001cec <LL_USART_SetBaudRate+0x458>)
 8001c12:	fba2 2303 	umull	r2, r3, r2, r3
 8001c16:	095b      	lsrs	r3, r3, #5
 8001c18:	b29b      	uxth	r3, r3
 8001c1a:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8001c1e:	b29b      	uxth	r3, r3
 8001c20:	4423      	add	r3, r4
 8001c22:	b29c      	uxth	r4, r3
 8001c24:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8001c28:	2200      	movs	r2, #0
 8001c2a:	67bb      	str	r3, [r7, #120]	@ 0x78
 8001c2c:	67fa      	str	r2, [r7, #124]	@ 0x7c
 8001c2e:	e9d7 891e 	ldrd	r8, r9, [r7, #120]	@ 0x78
 8001c32:	4642      	mov	r2, r8
 8001c34:	464b      	mov	r3, r9
 8001c36:	1891      	adds	r1, r2, r2
 8001c38:	60b9      	str	r1, [r7, #8]
 8001c3a:	415b      	adcs	r3, r3
 8001c3c:	60fb      	str	r3, [r7, #12]
 8001c3e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8001c42:	4641      	mov	r1, r8
 8001c44:	1851      	adds	r1, r2, r1
 8001c46:	6039      	str	r1, [r7, #0]
 8001c48:	4649      	mov	r1, r9
 8001c4a:	414b      	adcs	r3, r1
 8001c4c:	607b      	str	r3, [r7, #4]
 8001c4e:	f04f 0200 	mov.w	r2, #0
 8001c52:	f04f 0300 	mov.w	r3, #0
 8001c56:	e9d7 ab00 	ldrd	sl, fp, [r7]
 8001c5a:	4659      	mov	r1, fp
 8001c5c:	00cb      	lsls	r3, r1, #3
 8001c5e:	4651      	mov	r1, sl
 8001c60:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8001c64:	4651      	mov	r1, sl
 8001c66:	00ca      	lsls	r2, r1, #3
 8001c68:	4610      	mov	r0, r2
 8001c6a:	4619      	mov	r1, r3
 8001c6c:	4603      	mov	r3, r0
 8001c6e:	4642      	mov	r2, r8
 8001c70:	189b      	adds	r3, r3, r2
 8001c72:	673b      	str	r3, [r7, #112]	@ 0x70
 8001c74:	464b      	mov	r3, r9
 8001c76:	460a      	mov	r2, r1
 8001c78:	eb42 0303 	adc.w	r3, r2, r3
 8001c7c:	677b      	str	r3, [r7, #116]	@ 0x74
 8001c7e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8001c82:	2200      	movs	r2, #0
 8001c84:	66bb      	str	r3, [r7, #104]	@ 0x68
 8001c86:	66fa      	str	r2, [r7, #108]	@ 0x6c
 8001c88:	f04f 0200 	mov.w	r2, #0
 8001c8c:	f04f 0300 	mov.w	r3, #0
 8001c90:	e9d7 891a 	ldrd	r8, r9, [r7, #104]	@ 0x68
 8001c94:	4649      	mov	r1, r9
 8001c96:	008b      	lsls	r3, r1, #2
 8001c98:	4641      	mov	r1, r8
 8001c9a:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 8001c9e:	4641      	mov	r1, r8
 8001ca0:	008a      	lsls	r2, r1, #2
 8001ca2:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
 8001ca6:	f7fe fff7 	bl	8000c98 <__aeabi_uldivmod>
 8001caa:	4602      	mov	r2, r0
 8001cac:	460b      	mov	r3, r1
 8001cae:	4b0f      	ldr	r3, [pc, #60]	@ (8001cec <LL_USART_SetBaudRate+0x458>)
 8001cb0:	fba3 1302 	umull	r1, r3, r3, r2
 8001cb4:	095b      	lsrs	r3, r3, #5
 8001cb6:	2164      	movs	r1, #100	@ 0x64
 8001cb8:	fb01 f303 	mul.w	r3, r1, r3
 8001cbc:	1ad3      	subs	r3, r2, r3
 8001cbe:	011b      	lsls	r3, r3, #4
 8001cc0:	3332      	adds	r3, #50	@ 0x32
 8001cc2:	4a0a      	ldr	r2, [pc, #40]	@ (8001cec <LL_USART_SetBaudRate+0x458>)
 8001cc4:	fba2 2303 	umull	r2, r3, r2, r3
 8001cc8:	095b      	lsrs	r3, r3, #5
 8001cca:	b29b      	uxth	r3, r3
 8001ccc:	f003 030f 	and.w	r3, r3, #15
 8001cd0:	b29b      	uxth	r3, r3
 8001cd2:	4423      	add	r3, r4
 8001cd4:	b29b      	uxth	r3, r3
 8001cd6:	461a      	mov	r2, r3
 8001cd8:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8001cdc:	609a      	str	r2, [r3, #8]
}
 8001cde:	bf00      	nop
 8001ce0:	f507 7780 	add.w	r7, r7, #256	@ 0x100
 8001ce4:	46bd      	mov	sp, r7
 8001ce6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8001cea:	bf00      	nop
 8001cec:	51eb851f 	.word	0x51eb851f

08001cf0 <LL_USART_EnableIT_RXNE>:
  * @rmtoll CR1          RXNEIE        LL_USART_EnableIT_RXNE
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
{
 8001cf0:	b480      	push	{r7}
 8001cf2:	b089      	sub	sp, #36	@ 0x24
 8001cf4:	af00      	add	r7, sp, #0
 8001cf6:	6078      	str	r0, [r7, #4]
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 8001cf8:	687b      	ldr	r3, [r7, #4]
 8001cfa:	330c      	adds	r3, #12
 8001cfc:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001cfe:	68fb      	ldr	r3, [r7, #12]
 8001d00:	e853 3f00 	ldrex	r3, [r3]
 8001d04:	60bb      	str	r3, [r7, #8]
   return(result);
 8001d06:	68bb      	ldr	r3, [r7, #8]
 8001d08:	f043 0320 	orr.w	r3, r3, #32
 8001d0c:	61fb      	str	r3, [r7, #28]
 8001d0e:	687b      	ldr	r3, [r7, #4]
 8001d10:	330c      	adds	r3, #12
 8001d12:	69fa      	ldr	r2, [r7, #28]
 8001d14:	61ba      	str	r2, [r7, #24]
 8001d16:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001d18:	6979      	ldr	r1, [r7, #20]
 8001d1a:	69ba      	ldr	r2, [r7, #24]
 8001d1c:	e841 2300 	strex	r3, r2, [r1]
 8001d20:	613b      	str	r3, [r7, #16]
   return(result);
 8001d22:	693b      	ldr	r3, [r7, #16]
 8001d24:	2b00      	cmp	r3, #0
 8001d26:	d1e7      	bne.n	8001cf8 <LL_USART_EnableIT_RXNE+0x8>
}
 8001d28:	bf00      	nop
 8001d2a:	bf00      	nop
 8001d2c:	3724      	adds	r7, #36	@ 0x24
 8001d2e:	46bd      	mov	sp, r7
 8001d30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d34:	4770      	bx	lr

08001d36 <LL_USART_EnableIT_ERROR>:
  * @rmtoll CR3          EIE           LL_USART_EnableIT_ERROR
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableIT_ERROR(USART_TypeDef *USARTx)
{
 8001d36:	b480      	push	{r7}
 8001d38:	b089      	sub	sp, #36	@ 0x24
 8001d3a:	af00      	add	r7, sp, #0
 8001d3c:	6078      	str	r0, [r7, #4]
  ATOMIC_SET_BIT(USARTx->CR3, USART_CR3_EIE);
 8001d3e:	687b      	ldr	r3, [r7, #4]
 8001d40:	3314      	adds	r3, #20
 8001d42:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8001d44:	68fb      	ldr	r3, [r7, #12]
 8001d46:	e853 3f00 	ldrex	r3, [r3]
 8001d4a:	60bb      	str	r3, [r7, #8]
   return(result);
 8001d4c:	68bb      	ldr	r3, [r7, #8]
 8001d4e:	f043 0301 	orr.w	r3, r3, #1
 8001d52:	61fb      	str	r3, [r7, #28]
 8001d54:	687b      	ldr	r3, [r7, #4]
 8001d56:	3314      	adds	r3, #20
 8001d58:	69fa      	ldr	r2, [r7, #28]
 8001d5a:	61ba      	str	r2, [r7, #24]
 8001d5c:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8001d5e:	6979      	ldr	r1, [r7, #20]
 8001d60:	69ba      	ldr	r2, [r7, #24]
 8001d62:	e841 2300 	strex	r3, r2, [r1]
 8001d66:	613b      	str	r3, [r7, #16]
   return(result);
 8001d68:	693b      	ldr	r3, [r7, #16]
 8001d6a:	2b00      	cmp	r3, #0
 8001d6c:	d1e7      	bne.n	8001d3e <LL_USART_EnableIT_ERROR+0x8>
}
 8001d6e:	bf00      	nop
 8001d70:	bf00      	nop
 8001d72:	3724      	adds	r7, #36	@ 0x24
 8001d74:	46bd      	mov	sp, r7
 8001d76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d7a:	4770      	bx	lr

08001d7c <LL_USART_ReceiveData8>:
  * @rmtoll DR           DR            LL_USART_ReceiveData8
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(const USART_TypeDef *USARTx)
{
 8001d7c:	b480      	push	{r7}
 8001d7e:	b083      	sub	sp, #12
 8001d80:	af00      	add	r7, sp, #0
 8001d82:	6078      	str	r0, [r7, #4]
  return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 8001d84:	687b      	ldr	r3, [r7, #4]
 8001d86:	685b      	ldr	r3, [r3, #4]
 8001d88:	b2db      	uxtb	r3, r3
}
 8001d8a:	4618      	mov	r0, r3
 8001d8c:	370c      	adds	r7, #12
 8001d8e:	46bd      	mov	sp, r7
 8001d90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d94:	4770      	bx	lr

08001d96 <LL_USART_TransmitData8>:
  * @param  USARTx USART Instance
  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
  * @retval None
  */
__STATIC_INLINE void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
{
 8001d96:	b480      	push	{r7}
 8001d98:	b083      	sub	sp, #12
 8001d9a:	af00      	add	r7, sp, #0
 8001d9c:	6078      	str	r0, [r7, #4]
 8001d9e:	460b      	mov	r3, r1
 8001da0:	70fb      	strb	r3, [r7, #3]
  USARTx->DR = Value;
 8001da2:	78fa      	ldrb	r2, [r7, #3]
 8001da4:	687b      	ldr	r3, [r7, #4]
 8001da6:	605a      	str	r2, [r3, #4]
}
 8001da8:	bf00      	nop
 8001daa:	370c      	adds	r7, #12
 8001dac:	46bd      	mov	sp, r7
 8001dae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001db2:	4770      	bx	lr

08001db4 <normQuaternion>:

// UART
char buffer[50];


double normQuaternion(Quaternion q) {
 8001db4:	b5b0      	push	{r4, r5, r7, lr}
 8001db6:	b088      	sub	sp, #32
 8001db8:	af00      	add	r7, sp, #0
 8001dba:	eeb0 4a40 	vmov.f32	s8, s0
 8001dbe:	eef0 4a60 	vmov.f32	s9, s1
 8001dc2:	eeb0 5a41 	vmov.f32	s10, s2
 8001dc6:	eef0 5a61 	vmov.f32	s11, s3
 8001dca:	eeb0 6a42 	vmov.f32	s12, s4
 8001dce:	eef0 6a62 	vmov.f32	s13, s5
 8001dd2:	eeb0 7a43 	vmov.f32	s14, s6
 8001dd6:	eef0 7a63 	vmov.f32	s15, s7
 8001dda:	ed87 4b00 	vstr	d4, [r7]
 8001dde:	ed87 5b02 	vstr	d5, [r7, #8]
 8001de2:	ed87 6b04 	vstr	d6, [r7, #16]
 8001de6:	ed87 7b06 	vstr	d7, [r7, #24]
	return sqrt(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z);
 8001dea:	e9d7 0100 	ldrd	r0, r1, [r7]
 8001dee:	e9d7 2300 	ldrd	r2, r3, [r7]
 8001df2:	f7fe fc09 	bl	8000608 <__aeabi_dmul>
 8001df6:	4602      	mov	r2, r0
 8001df8:	460b      	mov	r3, r1
 8001dfa:	4614      	mov	r4, r2
 8001dfc:	461d      	mov	r5, r3
 8001dfe:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8001e02:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8001e06:	f7fe fbff 	bl	8000608 <__aeabi_dmul>
 8001e0a:	4602      	mov	r2, r0
 8001e0c:	460b      	mov	r3, r1
 8001e0e:	4620      	mov	r0, r4
 8001e10:	4629      	mov	r1, r5
 8001e12:	f7fe fa43 	bl	800029c <__adddf3>
 8001e16:	4602      	mov	r2, r0
 8001e18:	460b      	mov	r3, r1
 8001e1a:	4614      	mov	r4, r2
 8001e1c:	461d      	mov	r5, r3
 8001e1e:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8001e22:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8001e26:	f7fe fbef 	bl	8000608 <__aeabi_dmul>
 8001e2a:	4602      	mov	r2, r0
 8001e2c:	460b      	mov	r3, r1
 8001e2e:	4620      	mov	r0, r4
 8001e30:	4629      	mov	r1, r5
 8001e32:	f7fe fa33 	bl	800029c <__adddf3>
 8001e36:	4602      	mov	r2, r0
 8001e38:	460b      	mov	r3, r1
 8001e3a:	4614      	mov	r4, r2
 8001e3c:	461d      	mov	r5, r3
 8001e3e:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 8001e42:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8001e46:	f7fe fbdf 	bl	8000608 <__aeabi_dmul>
 8001e4a:	4602      	mov	r2, r0
 8001e4c:	460b      	mov	r3, r1
 8001e4e:	4620      	mov	r0, r4
 8001e50:	4629      	mov	r1, r5
 8001e52:	f7fe fa23 	bl	800029c <__adddf3>
 8001e56:	4602      	mov	r2, r0
 8001e58:	460b      	mov	r3, r1
 8001e5a:	ec43 2b17 	vmov	d7, r2, r3
 8001e5e:	eeb0 0a47 	vmov.f32	s0, s14
 8001e62:	eef0 0a67 	vmov.f32	s1, s15
 8001e66:	f01d fbeb 	bl	801f640 <sqrt>
 8001e6a:	eeb0 7a40 	vmov.f32	s14, s0
 8001e6e:	eef0 7a60 	vmov.f32	s15, s1
}
 8001e72:	eeb0 0a47 	vmov.f32	s0, s14
 8001e76:	eef0 0a67 	vmov.f32	s1, s15
 8001e7a:	3720      	adds	r7, #32
 8001e7c:	46bd      	mov	sp, r7
 8001e7e:	bdb0      	pop	{r4, r5, r7, pc}

08001e80 <inverseQuaternion>:

Quaternion inverseQuaternion(Quaternion q) {
 8001e80:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8001e84:	b09a      	sub	sp, #104	@ 0x68
 8001e86:	af00      	add	r7, sp, #0
 8001e88:	eeb0 4a40 	vmov.f32	s8, s0
 8001e8c:	eef0 4a60 	vmov.f32	s9, s1
 8001e90:	eeb0 5a41 	vmov.f32	s10, s2
 8001e94:	eef0 5a61 	vmov.f32	s11, s3
 8001e98:	eeb0 6a42 	vmov.f32	s12, s4
 8001e9c:	eef0 6a62 	vmov.f32	s13, s5
 8001ea0:	eeb0 7a43 	vmov.f32	s14, s6
 8001ea4:	eef0 7a63 	vmov.f32	s15, s7
 8001ea8:	ed87 4b08 	vstr	d4, [r7, #32]
 8001eac:	ed87 5b0a 	vstr	d5, [r7, #40]	@ 0x28
 8001eb0:	ed87 6b0c 	vstr	d6, [r7, #48]	@ 0x30
 8001eb4:	ed87 7b0e 	vstr	d7, [r7, #56]	@ 0x38
	double norm = normQuaternion(q);
 8001eb8:	ed97 4b08 	vldr	d4, [r7, #32]
 8001ebc:	ed97 5b0a 	vldr	d5, [r7, #40]	@ 0x28
 8001ec0:	ed97 6b0c 	vldr	d6, [r7, #48]	@ 0x30
 8001ec4:	ed97 7b0e 	vldr	d7, [r7, #56]	@ 0x38
 8001ec8:	eeb0 0a44 	vmov.f32	s0, s8
 8001ecc:	eef0 0a64 	vmov.f32	s1, s9
 8001ed0:	eeb0 1a45 	vmov.f32	s2, s10
 8001ed4:	eef0 1a65 	vmov.f32	s3, s11
 8001ed8:	eeb0 2a46 	vmov.f32	s4, s12
 8001edc:	eef0 2a66 	vmov.f32	s5, s13
 8001ee0:	eeb0 3a47 	vmov.f32	s6, s14
 8001ee4:	eef0 3a67 	vmov.f32	s7, s15
 8001ee8:	f7ff ff64 	bl	8001db4 <normQuaternion>
 8001eec:	ed87 0b18 	vstr	d0, [r7, #96]	@ 0x60
	q.w =  q.w / norm;
 8001ef0:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8001ef4:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8001ef8:	f7fe fcb0 	bl	800085c <__aeabi_ddiv>
 8001efc:	4602      	mov	r2, r0
 8001efe:	460b      	mov	r3, r1
 8001f00:	e9c7 2308 	strd	r2, r3, [r7, #32]
	q.x = -q.x / norm;
 8001f04:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8001f08:	4692      	mov	sl, r2
 8001f0a:	f083 4b00 	eor.w	fp, r3, #2147483648	@ 0x80000000
 8001f0e:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8001f12:	4650      	mov	r0, sl
 8001f14:	4659      	mov	r1, fp
 8001f16:	f7fe fca1 	bl	800085c <__aeabi_ddiv>
 8001f1a:	4602      	mov	r2, r0
 8001f1c:	460b      	mov	r3, r1
 8001f1e:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
	q.y = -q.y / norm;
 8001f22:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8001f26:	4690      	mov	r8, r2
 8001f28:	f083 4900 	eor.w	r9, r3, #2147483648	@ 0x80000000
 8001f2c:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8001f30:	4640      	mov	r0, r8
 8001f32:	4649      	mov	r1, r9
 8001f34:	f7fe fc92 	bl	800085c <__aeabi_ddiv>
 8001f38:	4602      	mov	r2, r0
 8001f3a:	460b      	mov	r3, r1
 8001f3c:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
	q.z = -q.z / norm;
 8001f40:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8001f44:	4614      	mov	r4, r2
 8001f46:	f083 4500 	eor.w	r5, r3, #2147483648	@ 0x80000000
 8001f4a:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8001f4e:	4620      	mov	r0, r4
 8001f50:	4629      	mov	r1, r5
 8001f52:	f7fe fc83 	bl	800085c <__aeabi_ddiv>
 8001f56:	4602      	mov	r2, r0
 8001f58:	460b      	mov	r3, r1
 8001f5a:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
	return q;
 8001f5e:	f107 0440 	add.w	r4, r7, #64	@ 0x40
 8001f62:	f107 0520 	add.w	r5, r7, #32
 8001f66:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8001f68:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8001f6a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8001f6e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8001f72:	e9d7 8910 	ldrd	r8, r9, [r7, #64]	@ 0x40
 8001f76:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
 8001f7a:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 8001f7e:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 8001f82:	ec49 8b14 	vmov	d4, r8, r9
 8001f86:	ec45 4b15 	vmov	d5, r4, r5
 8001f8a:	ec41 0b16 	vmov	d6, r0, r1
 8001f8e:	ec43 2b17 	vmov	d7, r2, r3
}
 8001f92:	eeb0 0a44 	vmov.f32	s0, s8
 8001f96:	eef0 0a64 	vmov.f32	s1, s9
 8001f9a:	eeb0 1a45 	vmov.f32	s2, s10
 8001f9e:	eef0 1a65 	vmov.f32	s3, s11
 8001fa2:	eeb0 2a46 	vmov.f32	s4, s12
 8001fa6:	eef0 2a66 	vmov.f32	s5, s13
 8001faa:	eeb0 3a47 	vmov.f32	s6, s14
 8001fae:	eef0 3a67 	vmov.f32	s7, s15
 8001fb2:	3768      	adds	r7, #104	@ 0x68
 8001fb4:	46bd      	mov	sp, r7
 8001fb6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08001fba <scaleQuaternion>:

Quaternion scaleQuaternion(Quaternion q, double scalar) {
 8001fba:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8001fbe:	b09a      	sub	sp, #104	@ 0x68
 8001fc0:	af00      	add	r7, sp, #0
 8001fc2:	eeb0 5a41 	vmov.f32	s10, s2
 8001fc6:	eef0 5a61 	vmov.f32	s11, s3
 8001fca:	eeb0 6a42 	vmov.f32	s12, s4
 8001fce:	eef0 6a62 	vmov.f32	s13, s5
 8001fd2:	eeb0 7a43 	vmov.f32	s14, s6
 8001fd6:	eef0 7a63 	vmov.f32	s15, s7
 8001fda:	ed87 4b08 	vstr	d4, [r7, #32]
 8001fde:	ed87 0b0a 	vstr	d0, [r7, #40]	@ 0x28
 8001fe2:	ed87 5b0c 	vstr	d5, [r7, #48]	@ 0x30
 8001fe6:	ed87 6b0e 	vstr	d6, [r7, #56]	@ 0x38
 8001fea:	ed87 7b10 	vstr	d7, [r7, #64]	@ 0x40
	q.w = scalar * q.w;
 8001fee:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8001ff2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8001ff6:	f7fe fb07 	bl	8000608 <__aeabi_dmul>
 8001ffa:	4602      	mov	r2, r0
 8001ffc:	460b      	mov	r3, r1
 8001ffe:	e9c7 230a 	strd	r2, r3, [r7, #40]	@ 0x28
	q.x = scalar * q.x;
 8002002:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
 8002006:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800200a:	f7fe fafd 	bl	8000608 <__aeabi_dmul>
 800200e:	4602      	mov	r2, r0
 8002010:	460b      	mov	r3, r1
 8002012:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
	q.y = scalar * q.y;
 8002016:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 800201a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800201e:	f7fe faf3 	bl	8000608 <__aeabi_dmul>
 8002022:	4602      	mov	r2, r0
 8002024:	460b      	mov	r3, r1
 8002026:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
	q.z = scalar * q.z;
 800202a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 800202e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8002032:	f7fe fae9 	bl	8000608 <__aeabi_dmul>
 8002036:	4602      	mov	r2, r0
 8002038:	460b      	mov	r3, r1
 800203a:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
	return q;
 800203e:	f107 0448 	add.w	r4, r7, #72	@ 0x48
 8002042:	f107 0528 	add.w	r5, r7, #40	@ 0x28
 8002046:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002048:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800204a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 800204e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8002052:	e9d7 8912 	ldrd	r8, r9, [r7, #72]	@ 0x48
 8002056:	e9d7 4514 	ldrd	r4, r5, [r7, #80]	@ 0x50
 800205a:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 800205e:	e9d7 2318 	ldrd	r2, r3, [r7, #96]	@ 0x60
 8002062:	ec49 8b14 	vmov	d4, r8, r9
 8002066:	ec45 4b15 	vmov	d5, r4, r5
 800206a:	ec41 0b16 	vmov	d6, r0, r1
 800206e:	ec43 2b17 	vmov	d7, r2, r3
}
 8002072:	eeb0 0a44 	vmov.f32	s0, s8
 8002076:	eef0 0a64 	vmov.f32	s1, s9
 800207a:	eeb0 1a45 	vmov.f32	s2, s10
 800207e:	eef0 1a65 	vmov.f32	s3, s11
 8002082:	eeb0 2a46 	vmov.f32	s4, s12
 8002086:	eef0 2a66 	vmov.f32	s5, s13
 800208a:	eeb0 3a47 	vmov.f32	s6, s14
 800208e:	eef0 3a67 	vmov.f32	s7, s15
 8002092:	3768      	adds	r7, #104	@ 0x68
 8002094:	46bd      	mov	sp, r7
 8002096:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

0800209a <kreuzproduktQuaternion>:

Quaternion kreuzproduktQuaternion(Quaternion q1, Quaternion q2) {
 800209a:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800209e:	b0a8      	sub	sp, #160	@ 0xa0
 80020a0:	af00      	add	r7, sp, #0
 80020a2:	ed87 0b10 	vstr	d0, [r7, #64]	@ 0x40
 80020a6:	ed87 1b12 	vstr	d1, [r7, #72]	@ 0x48
 80020aa:	ed87 2b14 	vstr	d2, [r7, #80]	@ 0x50
 80020ae:	ed87 3b16 	vstr	d3, [r7, #88]	@ 0x58
 80020b2:	ed87 4b08 	vstr	d4, [r7, #32]
 80020b6:	ed87 5b0a 	vstr	d5, [r7, #40]	@ 0x28
 80020ba:	ed87 6b0c 	vstr	d6, [r7, #48]	@ 0x30
 80020be:	ed87 7b0e 	vstr	d7, [r7, #56]	@ 0x38
	Quaternion returnQuaternion;
	returnQuaternion.w = (
		q1.w * q2.w -
 80020c2:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 80020c6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80020ca:	f7fe fa9d 	bl	8000608 <__aeabi_dmul>
 80020ce:	4602      	mov	r2, r0
 80020d0:	460b      	mov	r3, r1
 80020d2:	4614      	mov	r4, r2
 80020d4:	461d      	mov	r5, r3
		q1.x * q2.x -
 80020d6:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 80020da:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80020de:	f7fe fa93 	bl	8000608 <__aeabi_dmul>
 80020e2:	4602      	mov	r2, r0
 80020e4:	460b      	mov	r3, r1
		q1.w * q2.w -
 80020e6:	4620      	mov	r0, r4
 80020e8:	4629      	mov	r1, r5
 80020ea:	f7fe f8d5 	bl	8000298 <__aeabi_dsub>
 80020ee:	4602      	mov	r2, r0
 80020f0:	460b      	mov	r3, r1
 80020f2:	4614      	mov	r4, r2
 80020f4:	461d      	mov	r5, r3
		q1.y * q2.y -
 80020f6:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 80020fa:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 80020fe:	f7fe fa83 	bl	8000608 <__aeabi_dmul>
 8002102:	4602      	mov	r2, r0
 8002104:	460b      	mov	r3, r1
		q1.x * q2.x -
 8002106:	4620      	mov	r0, r4
 8002108:	4629      	mov	r1, r5
 800210a:	f7fe f8c5 	bl	8000298 <__aeabi_dsub>
 800210e:	4602      	mov	r2, r0
 8002110:	460b      	mov	r3, r1
 8002112:	4614      	mov	r4, r2
 8002114:	461d      	mov	r5, r3
		q1.z * q2.z
 8002116:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 800211a:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 800211e:	f7fe fa73 	bl	8000608 <__aeabi_dmul>
 8002122:	4602      	mov	r2, r0
 8002124:	460b      	mov	r3, r1
		q1.y * q2.y -
 8002126:	4620      	mov	r0, r4
 8002128:	4629      	mov	r1, r5
 800212a:	f7fe f8b5 	bl	8000298 <__aeabi_dsub>
 800212e:	4602      	mov	r2, r0
 8002130:	460b      	mov	r3, r1
	returnQuaternion.w = (
 8002132:	e9c7 2318 	strd	r2, r3, [r7, #96]	@ 0x60
	);
	returnQuaternion.x = (
		q1.x * q2.w +
 8002136:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 800213a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800213e:	f7fe fa63 	bl	8000608 <__aeabi_dmul>
 8002142:	4602      	mov	r2, r0
 8002144:	460b      	mov	r3, r1
 8002146:	4614      	mov	r4, r2
 8002148:	461d      	mov	r5, r3
		q1.w * q2.x -
 800214a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 800214e:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8002152:	f7fe fa59 	bl	8000608 <__aeabi_dmul>
 8002156:	4602      	mov	r2, r0
 8002158:	460b      	mov	r3, r1
		q1.x * q2.w +
 800215a:	4620      	mov	r0, r4
 800215c:	4629      	mov	r1, r5
 800215e:	f7fe f89d 	bl	800029c <__adddf3>
 8002162:	4602      	mov	r2, r0
 8002164:	460b      	mov	r3, r1
 8002166:	4614      	mov	r4, r2
 8002168:	461d      	mov	r5, r3
		q1.z * q2.y +
 800216a:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 800216e:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 8002172:	f7fe fa49 	bl	8000608 <__aeabi_dmul>
 8002176:	4602      	mov	r2, r0
 8002178:	460b      	mov	r3, r1
		q1.w * q2.x -
 800217a:	4620      	mov	r0, r4
 800217c:	4629      	mov	r1, r5
 800217e:	f7fe f88b 	bl	8000298 <__aeabi_dsub>
 8002182:	4602      	mov	r2, r0
 8002184:	460b      	mov	r3, r1
 8002186:	4614      	mov	r4, r2
 8002188:	461d      	mov	r5, r3
		q1.y * q2.z
 800218a:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 800218e:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8002192:	f7fe fa39 	bl	8000608 <__aeabi_dmul>
 8002196:	4602      	mov	r2, r0
 8002198:	460b      	mov	r3, r1
		q1.z * q2.y +
 800219a:	4620      	mov	r0, r4
 800219c:	4629      	mov	r1, r5
 800219e:	f7fe f87d 	bl	800029c <__adddf3>
 80021a2:	4602      	mov	r2, r0
 80021a4:	460b      	mov	r3, r1
	returnQuaternion.x = (
 80021a6:	e9c7 231a 	strd	r2, r3, [r7, #104]	@ 0x68
	);
	returnQuaternion.y = (
		q1.y * q2.w +
 80021aa:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 80021ae:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 80021b2:	f7fe fa29 	bl	8000608 <__aeabi_dmul>
 80021b6:	4602      	mov	r2, r0
 80021b8:	460b      	mov	r3, r1
 80021ba:	4614      	mov	r4, r2
 80021bc:	461d      	mov	r5, r3
		q1.z * q2.x +
 80021be:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 80021c2:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 80021c6:	f7fe fa1f 	bl	8000608 <__aeabi_dmul>
 80021ca:	4602      	mov	r2, r0
 80021cc:	460b      	mov	r3, r1
		q1.y * q2.w +
 80021ce:	4620      	mov	r0, r4
 80021d0:	4629      	mov	r1, r5
 80021d2:	f7fe f863 	bl	800029c <__adddf3>
 80021d6:	4602      	mov	r2, r0
 80021d8:	460b      	mov	r3, r1
 80021da:	4614      	mov	r4, r2
 80021dc:	461d      	mov	r5, r3
		q1.w * q2.y -
 80021de:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 80021e2:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 80021e6:	f7fe fa0f 	bl	8000608 <__aeabi_dmul>
 80021ea:	4602      	mov	r2, r0
 80021ec:	460b      	mov	r3, r1
		q1.z * q2.x +
 80021ee:	4620      	mov	r0, r4
 80021f0:	4629      	mov	r1, r5
 80021f2:	f7fe f853 	bl	800029c <__adddf3>
 80021f6:	4602      	mov	r2, r0
 80021f8:	460b      	mov	r3, r1
 80021fa:	4614      	mov	r4, r2
 80021fc:	461d      	mov	r5, r3
		q1.x * q2.z
 80021fe:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8002202:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8002206:	f7fe f9ff 	bl	8000608 <__aeabi_dmul>
 800220a:	4602      	mov	r2, r0
 800220c:	460b      	mov	r3, r1
		q1.w * q2.y -
 800220e:	4620      	mov	r0, r4
 8002210:	4629      	mov	r1, r5
 8002212:	f7fe f841 	bl	8000298 <__aeabi_dsub>
 8002216:	4602      	mov	r2, r0
 8002218:	460b      	mov	r3, r1
	returnQuaternion.y = (
 800221a:	e9c7 231c 	strd	r2, r3, [r7, #112]	@ 0x70
	);
	returnQuaternion.z = (
		q1.z * q2.w -
 800221e:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 8002222:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8002226:	f7fe f9ef 	bl	8000608 <__aeabi_dmul>
 800222a:	4602      	mov	r2, r0
 800222c:	460b      	mov	r3, r1
 800222e:	4614      	mov	r4, r2
 8002230:	461d      	mov	r5, r3
		q1.y * q2.x +
 8002232:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 8002236:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 800223a:	f7fe f9e5 	bl	8000608 <__aeabi_dmul>
 800223e:	4602      	mov	r2, r0
 8002240:	460b      	mov	r3, r1
		q1.z * q2.w -
 8002242:	4620      	mov	r0, r4
 8002244:	4629      	mov	r1, r5
 8002246:	f7fe f827 	bl	8000298 <__aeabi_dsub>
 800224a:	4602      	mov	r2, r0
 800224c:	460b      	mov	r3, r1
 800224e:	4614      	mov	r4, r2
 8002250:	461d      	mov	r5, r3
		q1.x * q2.y +
 8002252:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8002256:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	@ 0x30
 800225a:	f7fe f9d5 	bl	8000608 <__aeabi_dmul>
 800225e:	4602      	mov	r2, r0
 8002260:	460b      	mov	r3, r1
		q1.y * q2.x +
 8002262:	4620      	mov	r0, r4
 8002264:	4629      	mov	r1, r5
 8002266:	f7fe f819 	bl	800029c <__adddf3>
 800226a:	4602      	mov	r2, r0
 800226c:	460b      	mov	r3, r1
 800226e:	4614      	mov	r4, r2
 8002270:	461d      	mov	r5, r3
		q1.w * q2.z
 8002272:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 8002276:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 800227a:	f7fe f9c5 	bl	8000608 <__aeabi_dmul>
 800227e:	4602      	mov	r2, r0
 8002280:	460b      	mov	r3, r1
		q1.x * q2.y +
 8002282:	4620      	mov	r0, r4
 8002284:	4629      	mov	r1, r5
 8002286:	f7fe f809 	bl	800029c <__adddf3>
 800228a:	4602      	mov	r2, r0
 800228c:	460b      	mov	r3, r1
	returnQuaternion.z = (
 800228e:	e9c7 231e 	strd	r2, r3, [r7, #120]	@ 0x78
	);
	return returnQuaternion;
 8002292:	f107 0480 	add.w	r4, r7, #128	@ 0x80
 8002296:	f107 0560 	add.w	r5, r7, #96	@ 0x60
 800229a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800229c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800229e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80022a2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80022a6:	e9d7 8920 	ldrd	r8, r9, [r7, #128]	@ 0x80
 80022aa:	e9d7 4522 	ldrd	r4, r5, [r7, #136]	@ 0x88
 80022ae:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
 80022b2:	e9d7 2326 	ldrd	r2, r3, [r7, #152]	@ 0x98
 80022b6:	ec49 8b14 	vmov	d4, r8, r9
 80022ba:	ec45 4b15 	vmov	d5, r4, r5
 80022be:	ec41 0b16 	vmov	d6, r0, r1
 80022c2:	ec43 2b17 	vmov	d7, r2, r3
}
 80022c6:	eeb0 0a44 	vmov.f32	s0, s8
 80022ca:	eef0 0a64 	vmov.f32	s1, s9
 80022ce:	eeb0 1a45 	vmov.f32	s2, s10
 80022d2:	eef0 1a65 	vmov.f32	s3, s11
 80022d6:	eeb0 2a46 	vmov.f32	s4, s12
 80022da:	eef0 2a66 	vmov.f32	s5, s13
 80022de:	eeb0 3a47 	vmov.f32	s6, s14
 80022e2:	eef0 3a67 	vmov.f32	s7, s15
 80022e6:	37a0      	adds	r7, #160	@ 0xa0
 80022e8:	46bd      	mov	sp, r7
 80022ea:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

080022f0 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80022f0:	b580      	push	{r7, lr}
 80022f2:	b082      	sub	sp, #8
 80022f4:	af00      	add	r7, sp, #0
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
 80022f6:	f00c ff9b 	bl	800f230 <HAL_Init>
	// MotionFX_manager_init();

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();
 80022fa:	f000 f8bb 	bl	8002474 <SystemClock_Config>
	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
 80022fe:	f000 fad7 	bl	80028b0 <MX_GPIO_Init>
	MX_CRC_Init();
 8002302:	f000 f923 	bl	800254c <MX_CRC_Init>
	MX_TIM3_Init();
 8002306:	f000 fa85 	bl	8002814 <MX_TIM3_Init>
	MX_RTC_Init();
 800230a:	f000 f933 	bl	8002574 <MX_RTC_Init>
	MX_TIM1_Init();
 800230e:	f000 f98b 	bl	8002628 <MX_TIM1_Init>
	MX_TIM2_Init();
 8002312:	f000 fa31 	bl	8002778 <MX_TIM2_Init>
	MX_MEMS_Init();
 8002316:	f7fe fe37 	bl	8000f88 <MX_MEMS_Init>
	/* USER CODE BEGIN 2 */
	MX_USART2_UART_Init();
 800231a:	f000 fb13 	bl	8002944 <MX_USART2_UART_Init>

	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
 800231e:	2100      	movs	r1, #0
 8002320:	484d      	ldr	r0, [pc, #308]	@ (8002458 <main+0x168>)
 8002322:	f011 ffcb 	bl	80142bc <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
 8002326:	2104      	movs	r1, #4
 8002328:	484b      	ldr	r0, [pc, #300]	@ (8002458 <main+0x168>)
 800232a:	f011 ffc7 	bl	80142bc <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
 800232e:	2108      	movs	r1, #8
 8002330:	4849      	ldr	r0, [pc, #292]	@ (8002458 <main+0x168>)
 8002332:	f011 ffc3 	bl	80142bc <HAL_TIM_PWM_Start>
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);
 8002336:	210c      	movs	r1, #12
 8002338:	4847      	ldr	r0, [pc, #284]	@ (8002458 <main+0x168>)
 800233a:	f011 ffbf 	bl	80142bc <HAL_TIM_PWM_Start>

	pegel = 0.0;
 800233e:	4b47      	ldr	r3, [pc, #284]	@ (800245c <main+0x16c>)
 8002340:	f04f 0200 	mov.w	r2, #0
 8002344:	601a      	str	r2, [r3, #0]

		while (pegel < (1.0f)) {
 8002346:	e04d      	b.n	80023e4 <main+0xf4>
			if (regleran) {
 8002348:	4b45      	ldr	r3, [pc, #276]	@ (8002460 <main+0x170>)
 800234a:	781b      	ldrb	r3, [r3, #0]
 800234c:	2b00      	cmp	r3, #0
 800234e:	d054      	beq.n	80023fa <main+0x10a>
				pegel += 0.001;
 8002350:	4b42      	ldr	r3, [pc, #264]	@ (800245c <main+0x16c>)
 8002352:	681b      	ldr	r3, [r3, #0]
 8002354:	4618      	mov	r0, r3
 8002356:	f7fe f8ff 	bl	8000558 <__aeabi_f2d>
 800235a:	a33d      	add	r3, pc, #244	@ (adr r3, 8002450 <main+0x160>)
 800235c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002360:	f7fd ff9c 	bl	800029c <__adddf3>
 8002364:	4602      	mov	r2, r0
 8002366:	460b      	mov	r3, r1
 8002368:	4610      	mov	r0, r2
 800236a:	4619      	mov	r1, r3
 800236c:	f7fe fc44 	bl	8000bf8 <__aeabi_d2f>
 8002370:	4603      	mov	r3, r0
 8002372:	4a3a      	ldr	r2, [pc, #232]	@ (800245c <main+0x16c>)
 8002374:	6013      	str	r3, [r2, #0]
			} else {
				break;
			}
			HAL_Delay(100);
 8002376:	2064      	movs	r0, #100	@ 0x64
 8002378:	f00c ffcc 	bl	800f314 <HAL_Delay>

			TIM1->CCR1 = pegel * 30259;
 800237c:	4b37      	ldr	r3, [pc, #220]	@ (800245c <main+0x16c>)
 800237e:	edd3 7a00 	vldr	s15, [r3]
 8002382:	ed9f 7a38 	vldr	s14, [pc, #224]	@ 8002464 <main+0x174>
 8002386:	ee67 7a87 	vmul.f32	s15, s15, s14
 800238a:	4b37      	ldr	r3, [pc, #220]	@ (8002468 <main+0x178>)
 800238c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8002390:	ee17 2a90 	vmov	r2, s15
 8002394:	635a      	str	r2, [r3, #52]	@ 0x34
			TIM1->CCR2 = pegel * 30259;
 8002396:	4b31      	ldr	r3, [pc, #196]	@ (800245c <main+0x16c>)
 8002398:	edd3 7a00 	vldr	s15, [r3]
 800239c:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 8002464 <main+0x174>
 80023a0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80023a4:	4b30      	ldr	r3, [pc, #192]	@ (8002468 <main+0x178>)
 80023a6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80023aa:	ee17 2a90 	vmov	r2, s15
 80023ae:	639a      	str	r2, [r3, #56]	@ 0x38
			TIM1->CCR3 = pegel * 30259;
 80023b0:	4b2a      	ldr	r3, [pc, #168]	@ (800245c <main+0x16c>)
 80023b2:	edd3 7a00 	vldr	s15, [r3]
 80023b6:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 8002464 <main+0x174>
 80023ba:	ee67 7a87 	vmul.f32	s15, s15, s14
 80023be:	4b2a      	ldr	r3, [pc, #168]	@ (8002468 <main+0x178>)
 80023c0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80023c4:	ee17 2a90 	vmov	r2, s15
 80023c8:	63da      	str	r2, [r3, #60]	@ 0x3c
			TIM1->CCR4 = pegel * 30259;
 80023ca:	4b24      	ldr	r3, [pc, #144]	@ (800245c <main+0x16c>)
 80023cc:	edd3 7a00 	vldr	s15, [r3]
 80023d0:	ed9f 7a24 	vldr	s14, [pc, #144]	@ 8002464 <main+0x174>
 80023d4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80023d8:	4b23      	ldr	r3, [pc, #140]	@ (8002468 <main+0x178>)
 80023da:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80023de:	ee17 2a90 	vmov	r2, s15
 80023e2:	641a      	str	r2, [r3, #64]	@ 0x40
		while (pegel < (1.0f)) {
 80023e4:	4b1d      	ldr	r3, [pc, #116]	@ (800245c <main+0x16c>)
 80023e6:	edd3 7a00 	vldr	s15, [r3]
 80023ea:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80023ee:	eef4 7ac7 	vcmpe.f32	s15, s14
 80023f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023f6:	d4a7      	bmi.n	8002348 <main+0x58>
 80023f8:	e000      	b.n	80023fc <main+0x10c>
				break;
 80023fa:	bf00      	nop
		}

	TIM1->CCR1 = 0.0;
 80023fc:	4b1a      	ldr	r3, [pc, #104]	@ (8002468 <main+0x178>)
 80023fe:	2200      	movs	r2, #0
 8002400:	635a      	str	r2, [r3, #52]	@ 0x34
	TIM1->CCR2 = 0.0;
 8002402:	4b19      	ldr	r3, [pc, #100]	@ (8002468 <main+0x178>)
 8002404:	2200      	movs	r2, #0
 8002406:	639a      	str	r2, [r3, #56]	@ 0x38
	TIM1->CCR3 = 0.0;
 8002408:	4b17      	ldr	r3, [pc, #92]	@ (8002468 <main+0x178>)
 800240a:	2200      	movs	r2, #0
 800240c:	63da      	str	r2, [r3, #60]	@ 0x3c
	TIM1->CCR4 = 0.0;
 800240e:	4b16      	ldr	r3, [pc, #88]	@ (8002468 <main+0x178>)
 8002410:	2200      	movs	r2, #0
 8002412:	641a      	str	r2, [r3, #64]	@ 0x40
	DWT_Start();
 8002414:	f003 f9fe 	bl	8005814 <DWT_Start>

	// HAL_TIM_Base_Start_IT(&htim2);
	HAL_TIM_Base_Start(&htim2);
 8002418:	4814      	ldr	r0, [pc, #80]	@ (800246c <main+0x17c>)
 800241a:	f011 fea5 	bl	8014168 <HAL_TIM_Base_Start>

	timer_val = __HAL_TIM_GET_COUNTER(&htim2);
 800241e:	4b13      	ldr	r3, [pc, #76]	@ (800246c <main+0x17c>)
 8002420:	681b      	ldr	r3, [r3, #0]
 8002422:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002424:	80fb      	strh	r3, [r7, #6]

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		if (__HAL_TIM_GET_COUNTER(&htim2) - timer_val >= 20)
 8002426:	4b11      	ldr	r3, [pc, #68]	@ (800246c <main+0x17c>)
 8002428:	681b      	ldr	r3, [r3, #0]
 800242a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800242c:	88fb      	ldrh	r3, [r7, #6]
 800242e:	1ad3      	subs	r3, r2, r3
 8002430:	2b13      	cmp	r3, #19
 8002432:	d9f8      	bls.n	8002426 <main+0x136>
		{
			timer_val = __HAL_TIM_GET_COUNTER(&htim2);
 8002434:	4b0d      	ldr	r3, [pc, #52]	@ (800246c <main+0x17c>)
 8002436:	681b      	ldr	r3, [r3, #0]
 8002438:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800243a:	80fb      	strh	r3, [r7, #6]
			regelschritt();
 800243c:	f000 fb98 	bl	8002b70 <regelschritt>
			LL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN);
 8002440:	2120      	movs	r1, #32
 8002442:	480b      	ldr	r0, [pc, #44]	@ (8002470 <main+0x180>)
 8002444:	f7ff f9b7 	bl	80017b6 <LL_GPIO_TogglePin>
		if (__HAL_TIM_GET_COUNTER(&htim2) - timer_val >= 20)
 8002448:	e7ed      	b.n	8002426 <main+0x136>
 800244a:	bf00      	nop
 800244c:	f3af 8000 	nop.w
 8002450:	d2f1a9fc 	.word	0xd2f1a9fc
 8002454:	3f50624d 	.word	0x3f50624d
 8002458:	20001b68 	.word	0x20001b68
 800245c:	20000010 	.word	0x20000010
 8002460:	20001c91 	.word	0x20001c91
 8002464:	46ec6600 	.word	0x46ec6600
 8002468:	40010000 	.word	0x40010000
 800246c:	20001bb0 	.word	0x20001bb0
 8002470:	40020000 	.word	0x40020000

08002474 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8002474:	b580      	push	{r7, lr}
 8002476:	b094      	sub	sp, #80	@ 0x50
 8002478:	af00      	add	r7, sp, #0
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800247a:	f107 0320 	add.w	r3, r7, #32
 800247e:	2230      	movs	r2, #48	@ 0x30
 8002480:	2100      	movs	r1, #0
 8002482:	4618      	mov	r0, r3
 8002484:	f01b f8df 	bl	801d646 <memset>
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8002488:	f107 030c 	add.w	r3, r7, #12
 800248c:	2200      	movs	r2, #0
 800248e:	601a      	str	r2, [r3, #0]
 8002490:	605a      	str	r2, [r3, #4]
 8002492:	609a      	str	r2, [r3, #8]
 8002494:	60da      	str	r2, [r3, #12]
 8002496:	611a      	str	r2, [r3, #16]

	/** Configure the main internal regulator output voltage
	*/
	__HAL_RCC_PWR_CLK_ENABLE();
 8002498:	2300      	movs	r3, #0
 800249a:	60bb      	str	r3, [r7, #8]
 800249c:	4b29      	ldr	r3, [pc, #164]	@ (8002544 <SystemClock_Config+0xd0>)
 800249e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80024a0:	4a28      	ldr	r2, [pc, #160]	@ (8002544 <SystemClock_Config+0xd0>)
 80024a2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80024a6:	6413      	str	r3, [r2, #64]	@ 0x40
 80024a8:	4b26      	ldr	r3, [pc, #152]	@ (8002544 <SystemClock_Config+0xd0>)
 80024aa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80024ac:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80024b0:	60bb      	str	r3, [r7, #8]
 80024b2:	68bb      	ldr	r3, [r7, #8]
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80024b4:	2300      	movs	r3, #0
 80024b6:	607b      	str	r3, [r7, #4]
 80024b8:	4b23      	ldr	r3, [pc, #140]	@ (8002548 <SystemClock_Config+0xd4>)
 80024ba:	681b      	ldr	r3, [r3, #0]
 80024bc:	4a22      	ldr	r2, [pc, #136]	@ (8002548 <SystemClock_Config+0xd4>)
 80024be:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 80024c2:	6013      	str	r3, [r2, #0]
 80024c4:	4b20      	ldr	r3, [pc, #128]	@ (8002548 <SystemClock_Config+0xd4>)
 80024c6:	681b      	ldr	r3, [r3, #0]
 80024c8:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 80024cc:	607b      	str	r3, [r7, #4]
 80024ce:	687b      	ldr	r3, [r7, #4]

	/** Initializes the RCC Oscillators according to the specified parameters
	* in the RCC_OscInitTypeDef structure.
	*/
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
 80024d0:	230a      	movs	r3, #10
 80024d2:	623b      	str	r3, [r7, #32]
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80024d4:	2301      	movs	r3, #1
 80024d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 80024d8:	2310      	movs	r3, #16
 80024da:	633b      	str	r3, [r7, #48]	@ 0x30
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 80024dc:	2301      	movs	r3, #1
 80024de:	637b      	str	r3, [r7, #52]	@ 0x34
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80024e0:	2302      	movs	r3, #2
 80024e2:	63bb      	str	r3, [r7, #56]	@ 0x38
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 80024e4:	2300      	movs	r3, #0
 80024e6:	63fb      	str	r3, [r7, #60]	@ 0x3c
	RCC_OscInitStruct.PLL.PLLM = 8;
 80024e8:	2308      	movs	r3, #8
 80024ea:	643b      	str	r3, [r7, #64]	@ 0x40
	RCC_OscInitStruct.PLL.PLLN = 64;
 80024ec:	2340      	movs	r3, #64	@ 0x40
 80024ee:	647b      	str	r3, [r7, #68]	@ 0x44
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80024f0:	2302      	movs	r3, #2
 80024f2:	64bb      	str	r3, [r7, #72]	@ 0x48
	RCC_OscInitStruct.PLL.PLLQ = 4;
 80024f4:	2304      	movs	r3, #4
 80024f6:	64fb      	str	r3, [r7, #76]	@ 0x4c
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80024f8:	f107 0320 	add.w	r3, r7, #32
 80024fc:	4618      	mov	r0, r3
 80024fe:	f010 fe19 	bl	8013134 <HAL_RCC_OscConfig>
 8002502:	4603      	mov	r3, r0
 8002504:	2b00      	cmp	r3, #0
 8002506:	d001      	beq.n	800250c <SystemClock_Config+0x98>
	{
		Error_Handler();
 8002508:	f003 f9be 	bl	8005888 <Error_Handler>
	}

	/** Initializes the CPU, AHB and APB buses clocks
	*/
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800250c:	230f      	movs	r3, #15
 800250e:	60fb      	str	r3, [r7, #12]
							  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8002510:	2302      	movs	r3, #2
 8002512:	613b      	str	r3, [r7, #16]
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8002514:	2300      	movs	r3, #0
 8002516:	617b      	str	r3, [r7, #20]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV8;
 8002518:	f44f 53c0 	mov.w	r3, #6144	@ 0x1800
 800251c:	61bb      	str	r3, [r7, #24]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV8;
 800251e:	f44f 53c0 	mov.w	r3, #6144	@ 0x1800
 8002522:	61fb      	str	r3, [r7, #28]

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8002524:	f107 030c 	add.w	r3, r7, #12
 8002528:	2102      	movs	r1, #2
 800252a:	4618      	mov	r0, r3
 800252c:	f011 f87a 	bl	8013624 <HAL_RCC_ClockConfig>
 8002530:	4603      	mov	r3, r0
 8002532:	2b00      	cmp	r3, #0
 8002534:	d001      	beq.n	800253a <SystemClock_Config+0xc6>
	{
		Error_Handler();
 8002536:	f003 f9a7 	bl	8005888 <Error_Handler>
	}
}
 800253a:	bf00      	nop
 800253c:	3750      	adds	r7, #80	@ 0x50
 800253e:	46bd      	mov	sp, r7
 8002540:	bd80      	pop	{r7, pc}
 8002542:	bf00      	nop
 8002544:	40023800 	.word	0x40023800
 8002548:	40007000 	.word	0x40007000

0800254c <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 800254c:	b580      	push	{r7, lr}
 800254e:	af00      	add	r7, sp, #0
	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
 8002550:	4b06      	ldr	r3, [pc, #24]	@ (800256c <MX_CRC_Init+0x20>)
 8002552:	4a07      	ldr	r2, [pc, #28]	@ (8002570 <MX_CRC_Init+0x24>)
 8002554:	601a      	str	r2, [r3, #0]
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
 8002556:	4805      	ldr	r0, [pc, #20]	@ (800256c <MX_CRC_Init+0x20>)
 8002558:	f00d f843 	bl	800f5e2 <HAL_CRC_Init>
 800255c:	4603      	mov	r3, r0
 800255e:	2b00      	cmp	r3, #0
 8002560:	d001      	beq.n	8002566 <MX_CRC_Init+0x1a>
	{
		Error_Handler();
 8002562:	f003 f991 	bl	8005888 <Error_Handler>
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */

}
 8002566:	bf00      	nop
 8002568:	bd80      	pop	{r7, pc}
 800256a:	bf00      	nop
 800256c:	20001b40 	.word	0x20001b40
 8002570:	40023000 	.word	0x40023000

08002574 <MX_RTC_Init>:
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{
 8002574:	b580      	push	{r7, lr}
 8002576:	b086      	sub	sp, #24
 8002578:	af00      	add	r7, sp, #0

	/* USER CODE BEGIN RTC_Init 0 */

	/* USER CODE END RTC_Init 0 */

	RTC_TimeTypeDef sTime = {0};
 800257a:	1d3b      	adds	r3, r7, #4
 800257c:	2200      	movs	r2, #0
 800257e:	601a      	str	r2, [r3, #0]
 8002580:	605a      	str	r2, [r3, #4]
 8002582:	609a      	str	r2, [r3, #8]
 8002584:	60da      	str	r2, [r3, #12]
 8002586:	611a      	str	r2, [r3, #16]
	RTC_DateTypeDef sDate = {0};
 8002588:	2300      	movs	r3, #0
 800258a:	603b      	str	r3, [r7, #0]

	/* USER CODE END RTC_Init 1 */

	/** Initialize RTC Only
	*/
	hrtc.Instance = RTC;
 800258c:	4b24      	ldr	r3, [pc, #144]	@ (8002620 <MX_RTC_Init+0xac>)
 800258e:	4a25      	ldr	r2, [pc, #148]	@ (8002624 <MX_RTC_Init+0xb0>)
 8002590:	601a      	str	r2, [r3, #0]
	hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8002592:	4b23      	ldr	r3, [pc, #140]	@ (8002620 <MX_RTC_Init+0xac>)
 8002594:	2200      	movs	r2, #0
 8002596:	605a      	str	r2, [r3, #4]
	hrtc.Init.AsynchPrediv = 127;
 8002598:	4b21      	ldr	r3, [pc, #132]	@ (8002620 <MX_RTC_Init+0xac>)
 800259a:	227f      	movs	r2, #127	@ 0x7f
 800259c:	609a      	str	r2, [r3, #8]
	hrtc.Init.SynchPrediv = 255;
 800259e:	4b20      	ldr	r3, [pc, #128]	@ (8002620 <MX_RTC_Init+0xac>)
 80025a0:	22ff      	movs	r2, #255	@ 0xff
 80025a2:	60da      	str	r2, [r3, #12]
	hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 80025a4:	4b1e      	ldr	r3, [pc, #120]	@ (8002620 <MX_RTC_Init+0xac>)
 80025a6:	2200      	movs	r2, #0
 80025a8:	611a      	str	r2, [r3, #16]
	hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 80025aa:	4b1d      	ldr	r3, [pc, #116]	@ (8002620 <MX_RTC_Init+0xac>)
 80025ac:	2200      	movs	r2, #0
 80025ae:	615a      	str	r2, [r3, #20]
	hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 80025b0:	4b1b      	ldr	r3, [pc, #108]	@ (8002620 <MX_RTC_Init+0xac>)
 80025b2:	2200      	movs	r2, #0
 80025b4:	619a      	str	r2, [r3, #24]
	if (HAL_RTC_Init(&hrtc) != HAL_OK)
 80025b6:	481a      	ldr	r0, [pc, #104]	@ (8002620 <MX_RTC_Init+0xac>)
 80025b8:	f011 fb44 	bl	8013c44 <HAL_RTC_Init>
 80025bc:	4603      	mov	r3, r0
 80025be:	2b00      	cmp	r3, #0
 80025c0:	d001      	beq.n	80025c6 <MX_RTC_Init+0x52>
	{
		Error_Handler();
 80025c2:	f003 f961 	bl	8005888 <Error_Handler>

	/* USER CODE END Check_RTC_BKUP */

	/** Initialize RTC and set the Time and Date
	*/
	sTime.Hours = 0x0;
 80025c6:	2300      	movs	r3, #0
 80025c8:	713b      	strb	r3, [r7, #4]
	sTime.Minutes = 0x0;
 80025ca:	2300      	movs	r3, #0
 80025cc:	717b      	strb	r3, [r7, #5]
	sTime.Seconds = 0x0;
 80025ce:	2300      	movs	r3, #0
 80025d0:	71bb      	strb	r3, [r7, #6]
	sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 80025d2:	2300      	movs	r3, #0
 80025d4:	613b      	str	r3, [r7, #16]
	sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 80025d6:	2300      	movs	r3, #0
 80025d8:	617b      	str	r3, [r7, #20]
	if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 80025da:	1d3b      	adds	r3, r7, #4
 80025dc:	2201      	movs	r2, #1
 80025de:	4619      	mov	r1, r3
 80025e0:	480f      	ldr	r0, [pc, #60]	@ (8002620 <MX_RTC_Init+0xac>)
 80025e2:	f011 fbb2 	bl	8013d4a <HAL_RTC_SetTime>
 80025e6:	4603      	mov	r3, r0
 80025e8:	2b00      	cmp	r3, #0
 80025ea:	d001      	beq.n	80025f0 <MX_RTC_Init+0x7c>
	{
		Error_Handler();
 80025ec:	f003 f94c 	bl	8005888 <Error_Handler>
	}
	sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 80025f0:	2301      	movs	r3, #1
 80025f2:	703b      	strb	r3, [r7, #0]
	sDate.Month = RTC_MONTH_JANUARY;
 80025f4:	2301      	movs	r3, #1
 80025f6:	707b      	strb	r3, [r7, #1]
	sDate.Date = 0x1;
 80025f8:	2301      	movs	r3, #1
 80025fa:	70bb      	strb	r3, [r7, #2]
	sDate.Year = 0x0;
 80025fc:	2300      	movs	r3, #0
 80025fe:	70fb      	strb	r3, [r7, #3]

	if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
 8002600:	463b      	mov	r3, r7
 8002602:	2201      	movs	r2, #1
 8002604:	4619      	mov	r1, r3
 8002606:	4806      	ldr	r0, [pc, #24]	@ (8002620 <MX_RTC_Init+0xac>)
 8002608:	f011 fc39 	bl	8013e7e <HAL_RTC_SetDate>
 800260c:	4603      	mov	r3, r0
 800260e:	2b00      	cmp	r3, #0
 8002610:	d001      	beq.n	8002616 <MX_RTC_Init+0xa2>
	{
		Error_Handler();
 8002612:	f003 f939 	bl	8005888 <Error_Handler>
	}
	/* USER CODE BEGIN RTC_Init 2 */

	/* USER CODE END RTC_Init 2 */

}
 8002616:	bf00      	nop
 8002618:	3718      	adds	r7, #24
 800261a:	46bd      	mov	sp, r7
 800261c:	bd80      	pop	{r7, pc}
 800261e:	bf00      	nop
 8002620:	20001b48 	.word	0x20001b48
 8002624:	40002800 	.word	0x40002800

08002628 <MX_TIM1_Init>:
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{
 8002628:	b580      	push	{r7, lr}
 800262a:	b092      	sub	sp, #72	@ 0x48
 800262c:	af00      	add	r7, sp, #0

	/* USER CODE BEGIN TIM1_Init 0 */

	/* USER CODE END TIM1_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};
 800262e:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 8002632:	2200      	movs	r2, #0
 8002634:	601a      	str	r2, [r3, #0]
 8002636:	605a      	str	r2, [r3, #4]
	TIM_OC_InitTypeDef sConfigOC = {0};
 8002638:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800263c:	2200      	movs	r2, #0
 800263e:	601a      	str	r2, [r3, #0]
 8002640:	605a      	str	r2, [r3, #4]
 8002642:	609a      	str	r2, [r3, #8]
 8002644:	60da      	str	r2, [r3, #12]
 8002646:	611a      	str	r2, [r3, #16]
 8002648:	615a      	str	r2, [r3, #20]
 800264a:	619a      	str	r2, [r3, #24]
	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 800264c:	1d3b      	adds	r3, r7, #4
 800264e:	2220      	movs	r2, #32
 8002650:	2100      	movs	r1, #0
 8002652:	4618      	mov	r0, r3
 8002654:	f01a fff7 	bl	801d646 <memset>

	/* USER CODE BEGIN TIM1_Init 1 */

	/* USER CODE END TIM1_Init 1 */
	htim1.Instance = TIM1;
 8002658:	4b45      	ldr	r3, [pc, #276]	@ (8002770 <MX_TIM1_Init+0x148>)
 800265a:	4a46      	ldr	r2, [pc, #280]	@ (8002774 <MX_TIM1_Init+0x14c>)
 800265c:	601a      	str	r2, [r3, #0]
	htim1.Init.Prescaler = 8;
 800265e:	4b44      	ldr	r3, [pc, #272]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002660:	2208      	movs	r2, #8
 8002662:	605a      	str	r2, [r3, #4]
	htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8002664:	4b42      	ldr	r3, [pc, #264]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002666:	2200      	movs	r2, #0
 8002668:	609a      	str	r2, [r3, #8]
	htim1.Init.Period = 30259;
 800266a:	4b41      	ldr	r3, [pc, #260]	@ (8002770 <MX_TIM1_Init+0x148>)
 800266c:	f247 6233 	movw	r2, #30259	@ 0x7633
 8002670:	60da      	str	r2, [r3, #12]
	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8002672:	4b3f      	ldr	r3, [pc, #252]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002674:	2200      	movs	r2, #0
 8002676:	611a      	str	r2, [r3, #16]
	htim1.Init.RepetitionCounter = 0;
 8002678:	4b3d      	ldr	r3, [pc, #244]	@ (8002770 <MX_TIM1_Init+0x148>)
 800267a:	2200      	movs	r2, #0
 800267c:	615a      	str	r2, [r3, #20]
	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800267e:	4b3c      	ldr	r3, [pc, #240]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002680:	2200      	movs	r2, #0
 8002682:	619a      	str	r2, [r3, #24]
	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8002684:	483a      	ldr	r0, [pc, #232]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002686:	f011 fdc9 	bl	801421c <HAL_TIM_PWM_Init>
 800268a:	4603      	mov	r3, r0
 800268c:	2b00      	cmp	r3, #0
 800268e:	d001      	beq.n	8002694 <MX_TIM1_Init+0x6c>
	{
		Error_Handler();
 8002690:	f003 f8fa 	bl	8005888 <Error_Handler>
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8002694:	2300      	movs	r3, #0
 8002696:	643b      	str	r3, [r7, #64]	@ 0x40
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8002698:	2300      	movs	r3, #0
 800269a:	647b      	str	r3, [r7, #68]	@ 0x44
	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 800269c:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 80026a0:	4619      	mov	r1, r3
 80026a2:	4833      	ldr	r0, [pc, #204]	@ (8002770 <MX_TIM1_Init+0x148>)
 80026a4:	f012 fc34 	bl	8014f10 <HAL_TIMEx_MasterConfigSynchronization>
 80026a8:	4603      	mov	r3, r0
 80026aa:	2b00      	cmp	r3, #0
 80026ac:	d001      	beq.n	80026b2 <MX_TIM1_Init+0x8a>
	{
		Error_Handler();
 80026ae:	f003 f8eb 	bl	8005888 <Error_Handler>
	}
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80026b2:	2360      	movs	r3, #96	@ 0x60
 80026b4:	627b      	str	r3, [r7, #36]	@ 0x24
	sConfigOC.Pulse = 0;
 80026b6:	2300      	movs	r3, #0
 80026b8:	62bb      	str	r3, [r7, #40]	@ 0x28
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80026ba:	2300      	movs	r3, #0
 80026bc:	62fb      	str	r3, [r7, #44]	@ 0x2c
	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 80026be:	2300      	movs	r3, #0
 80026c0:	633b      	str	r3, [r7, #48]	@ 0x30
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80026c2:	2300      	movs	r3, #0
 80026c4:	637b      	str	r3, [r7, #52]	@ 0x34
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 80026c6:	2300      	movs	r3, #0
 80026c8:	63bb      	str	r3, [r7, #56]	@ 0x38
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 80026ca:	2300      	movs	r3, #0
 80026cc:	63fb      	str	r3, [r7, #60]	@ 0x3c
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80026ce:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80026d2:	2200      	movs	r2, #0
 80026d4:	4619      	mov	r1, r3
 80026d6:	4826      	ldr	r0, [pc, #152]	@ (8002770 <MX_TIM1_Init+0x148>)
 80026d8:	f011 ff90 	bl	80145fc <HAL_TIM_PWM_ConfigChannel>
 80026dc:	4603      	mov	r3, r0
 80026de:	2b00      	cmp	r3, #0
 80026e0:	d001      	beq.n	80026e6 <MX_TIM1_Init+0xbe>
	{
		Error_Handler();
 80026e2:	f003 f8d1 	bl	8005888 <Error_Handler>
	}
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80026e6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80026ea:	2204      	movs	r2, #4
 80026ec:	4619      	mov	r1, r3
 80026ee:	4820      	ldr	r0, [pc, #128]	@ (8002770 <MX_TIM1_Init+0x148>)
 80026f0:	f011 ff84 	bl	80145fc <HAL_TIM_PWM_ConfigChannel>
 80026f4:	4603      	mov	r3, r0
 80026f6:	2b00      	cmp	r3, #0
 80026f8:	d001      	beq.n	80026fe <MX_TIM1_Init+0xd6>
	{
		Error_Handler();
 80026fa:	f003 f8c5 	bl	8005888 <Error_Handler>
	}
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80026fe:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8002702:	2208      	movs	r2, #8
 8002704:	4619      	mov	r1, r3
 8002706:	481a      	ldr	r0, [pc, #104]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002708:	f011 ff78 	bl	80145fc <HAL_TIM_PWM_ConfigChannel>
 800270c:	4603      	mov	r3, r0
 800270e:	2b00      	cmp	r3, #0
 8002710:	d001      	beq.n	8002716 <MX_TIM1_Init+0xee>
	{
		Error_Handler();
 8002712:	f003 f8b9 	bl	8005888 <Error_Handler>
	}
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8002716:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800271a:	220c      	movs	r2, #12
 800271c:	4619      	mov	r1, r3
 800271e:	4814      	ldr	r0, [pc, #80]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002720:	f011 ff6c 	bl	80145fc <HAL_TIM_PWM_ConfigChannel>
 8002724:	4603      	mov	r3, r0
 8002726:	2b00      	cmp	r3, #0
 8002728:	d001      	beq.n	800272e <MX_TIM1_Init+0x106>
	{
		Error_Handler();
 800272a:	f003 f8ad 	bl	8005888 <Error_Handler>
	}
	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 800272e:	2300      	movs	r3, #0
 8002730:	607b      	str	r3, [r7, #4]
	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 8002732:	2300      	movs	r3, #0
 8002734:	60bb      	str	r3, [r7, #8]
	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 8002736:	2300      	movs	r3, #0
 8002738:	60fb      	str	r3, [r7, #12]
	sBreakDeadTimeConfig.DeadTime = 0;
 800273a:	2300      	movs	r3, #0
 800273c:	613b      	str	r3, [r7, #16]
	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 800273e:	2300      	movs	r3, #0
 8002740:	617b      	str	r3, [r7, #20]
	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8002742:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8002746:	61bb      	str	r3, [r7, #24]
	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8002748:	2300      	movs	r3, #0
 800274a:	623b      	str	r3, [r7, #32]
	if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 800274c:	1d3b      	adds	r3, r7, #4
 800274e:	4619      	mov	r1, r3
 8002750:	4807      	ldr	r0, [pc, #28]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002752:	f012 fc4b 	bl	8014fec <HAL_TIMEx_ConfigBreakDeadTime>
 8002756:	4603      	mov	r3, r0
 8002758:	2b00      	cmp	r3, #0
 800275a:	d001      	beq.n	8002760 <MX_TIM1_Init+0x138>
	{
		Error_Handler();
 800275c:	f003 f894 	bl	8005888 <Error_Handler>
	}
	/* USER CODE BEGIN TIM1_Init 2 */

	/* USER CODE END TIM1_Init 2 */
	HAL_TIM_MspPostInit(&htim1);
 8002760:	4803      	ldr	r0, [pc, #12]	@ (8002770 <MX_TIM1_Init+0x148>)
 8002762:	f003 f96b 	bl	8005a3c <HAL_TIM_MspPostInit>

}
 8002766:	bf00      	nop
 8002768:	3748      	adds	r7, #72	@ 0x48
 800276a:	46bd      	mov	sp, r7
 800276c:	bd80      	pop	{r7, pc}
 800276e:	bf00      	nop
 8002770:	20001b68 	.word	0x20001b68
 8002774:	40010000 	.word	0x40010000

08002778 <MX_TIM2_Init>:
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
 8002778:	b580      	push	{r7, lr}
 800277a:	b086      	sub	sp, #24
 800277c:	af00      	add	r7, sp, #0

	/* USER CODE BEGIN TIM2_Init 0 */

	/* USER CODE END TIM2_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800277e:	f107 0308 	add.w	r3, r7, #8
 8002782:	2200      	movs	r2, #0
 8002784:	601a      	str	r2, [r3, #0]
 8002786:	605a      	str	r2, [r3, #4]
 8002788:	609a      	str	r2, [r3, #8]
 800278a:	60da      	str	r2, [r3, #12]
	TIM_MasterConfigTypeDef sMasterConfig = {0};
 800278c:	463b      	mov	r3, r7
 800278e:	2200      	movs	r2, #0
 8002790:	601a      	str	r2, [r3, #0]
 8002792:	605a      	str	r2, [r3, #4]

	/* USER CODE BEGIN TIM2_Init 1 */

	/* USER CODE END TIM2_Init 1 */
	htim2.Instance = TIM2;
 8002794:	4b1e      	ldr	r3, [pc, #120]	@ (8002810 <MX_TIM2_Init+0x98>)
 8002796:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 800279a:	601a      	str	r2, [r3, #0]
	htim2.Init.Prescaler = 8000-1;
 800279c:	4b1c      	ldr	r3, [pc, #112]	@ (8002810 <MX_TIM2_Init+0x98>)
 800279e:	f641 723f 	movw	r2, #7999	@ 0x1f3f
 80027a2:	605a      	str	r2, [r3, #4]
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 80027a4:	4b1a      	ldr	r3, [pc, #104]	@ (8002810 <MX_TIM2_Init+0x98>)
 80027a6:	2200      	movs	r2, #0
 80027a8:	609a      	str	r2, [r3, #8]
	htim2.Init.Period = 65535;
 80027aa:	4b19      	ldr	r3, [pc, #100]	@ (8002810 <MX_TIM2_Init+0x98>)
 80027ac:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80027b0:	60da      	str	r2, [r3, #12]
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80027b2:	4b17      	ldr	r3, [pc, #92]	@ (8002810 <MX_TIM2_Init+0x98>)
 80027b4:	2200      	movs	r2, #0
 80027b6:	611a      	str	r2, [r3, #16]
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80027b8:	4b15      	ldr	r3, [pc, #84]	@ (8002810 <MX_TIM2_Init+0x98>)
 80027ba:	2200      	movs	r2, #0
 80027bc:	619a      	str	r2, [r3, #24]
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 80027be:	4814      	ldr	r0, [pc, #80]	@ (8002810 <MX_TIM2_Init+0x98>)
 80027c0:	f011 fc82 	bl	80140c8 <HAL_TIM_Base_Init>
 80027c4:	4603      	mov	r3, r0
 80027c6:	2b00      	cmp	r3, #0
 80027c8:	d001      	beq.n	80027ce <MX_TIM2_Init+0x56>
	{
		Error_Handler();
 80027ca:	f003 f85d 	bl	8005888 <Error_Handler>
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 80027ce:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80027d2:	60bb      	str	r3, [r7, #8]
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 80027d4:	f107 0308 	add.w	r3, r7, #8
 80027d8:	4619      	mov	r1, r3
 80027da:	480d      	ldr	r0, [pc, #52]	@ (8002810 <MX_TIM2_Init+0x98>)
 80027dc:	f011 ffd0 	bl	8014780 <HAL_TIM_ConfigClockSource>
 80027e0:	4603      	mov	r3, r0
 80027e2:	2b00      	cmp	r3, #0
 80027e4:	d001      	beq.n	80027ea <MX_TIM2_Init+0x72>
	{
		Error_Handler();
 80027e6:	f003 f84f 	bl	8005888 <Error_Handler>
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80027ea:	2300      	movs	r3, #0
 80027ec:	603b      	str	r3, [r7, #0]
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80027ee:	2300      	movs	r3, #0
 80027f0:	607b      	str	r3, [r7, #4]
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 80027f2:	463b      	mov	r3, r7
 80027f4:	4619      	mov	r1, r3
 80027f6:	4806      	ldr	r0, [pc, #24]	@ (8002810 <MX_TIM2_Init+0x98>)
 80027f8:	f012 fb8a 	bl	8014f10 <HAL_TIMEx_MasterConfigSynchronization>
 80027fc:	4603      	mov	r3, r0
 80027fe:	2b00      	cmp	r3, #0
 8002800:	d001      	beq.n	8002806 <MX_TIM2_Init+0x8e>
	{
		Error_Handler();
 8002802:	f003 f841 	bl	8005888 <Error_Handler>
	}
	/* USER CODE BEGIN TIM2_Init 2 */

	/* USER CODE END TIM2_Init 2 */

}
 8002806:	bf00      	nop
 8002808:	3718      	adds	r7, #24
 800280a:	46bd      	mov	sp, r7
 800280c:	bd80      	pop	{r7, pc}
 800280e:	bf00      	nop
 8002810:	20001bb0 	.word	0x20001bb0

08002814 <MX_TIM3_Init>:
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
void MX_TIM3_Init(void)
{
 8002814:	b580      	push	{r7, lr}
 8002816:	b086      	sub	sp, #24
 8002818:	af00      	add	r7, sp, #0

	/* USER CODE BEGIN TIM3_Init 0 */

	/* USER CODE END TIM3_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800281a:	f107 0308 	add.w	r3, r7, #8
 800281e:	2200      	movs	r2, #0
 8002820:	601a      	str	r2, [r3, #0]
 8002822:	605a      	str	r2, [r3, #4]
 8002824:	609a      	str	r2, [r3, #8]
 8002826:	60da      	str	r2, [r3, #12]
	TIM_MasterConfigTypeDef sMasterConfig = {0};
 8002828:	463b      	mov	r3, r7
 800282a:	2200      	movs	r2, #0
 800282c:	601a      	str	r2, [r3, #0]
 800282e:	605a      	str	r2, [r3, #4]

	/* USER CODE BEGIN TIM3_Init 1 */

	/* USER CODE END TIM3_Init 1 */
	htim3.Instance = TIM3;
 8002830:	4b1d      	ldr	r3, [pc, #116]	@ (80028a8 <MX_TIM3_Init+0x94>)
 8002832:	4a1e      	ldr	r2, [pc, #120]	@ (80028ac <MX_TIM3_Init+0x98>)
 8002834:	601a      	str	r2, [r3, #0]
	htim3.Init.Prescaler = 0;
 8002836:	4b1c      	ldr	r3, [pc, #112]	@ (80028a8 <MX_TIM3_Init+0x94>)
 8002838:	2200      	movs	r2, #0
 800283a:	605a      	str	r2, [r3, #4]
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 800283c:	4b1a      	ldr	r3, [pc, #104]	@ (80028a8 <MX_TIM3_Init+0x94>)
 800283e:	2200      	movs	r2, #0
 8002840:	609a      	str	r2, [r3, #8]
	htim3.Init.Period = 65536-1;
 8002842:	4b19      	ldr	r3, [pc, #100]	@ (80028a8 <MX_TIM3_Init+0x94>)
 8002844:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8002848:	60da      	str	r2, [r3, #12]
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800284a:	4b17      	ldr	r3, [pc, #92]	@ (80028a8 <MX_TIM3_Init+0x94>)
 800284c:	2200      	movs	r2, #0
 800284e:	611a      	str	r2, [r3, #16]
	htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8002850:	4b15      	ldr	r3, [pc, #84]	@ (80028a8 <MX_TIM3_Init+0x94>)
 8002852:	2200      	movs	r2, #0
 8002854:	619a      	str	r2, [r3, #24]
	if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8002856:	4814      	ldr	r0, [pc, #80]	@ (80028a8 <MX_TIM3_Init+0x94>)
 8002858:	f011 fc36 	bl	80140c8 <HAL_TIM_Base_Init>
 800285c:	4603      	mov	r3, r0
 800285e:	2b00      	cmp	r3, #0
 8002860:	d001      	beq.n	8002866 <MX_TIM3_Init+0x52>
	{
		Error_Handler();
 8002862:	f003 f811 	bl	8005888 <Error_Handler>
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8002866:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 800286a:	60bb      	str	r3, [r7, #8]
	if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 800286c:	f107 0308 	add.w	r3, r7, #8
 8002870:	4619      	mov	r1, r3
 8002872:	480d      	ldr	r0, [pc, #52]	@ (80028a8 <MX_TIM3_Init+0x94>)
 8002874:	f011 ff84 	bl	8014780 <HAL_TIM_ConfigClockSource>
 8002878:	4603      	mov	r3, r0
 800287a:	2b00      	cmp	r3, #0
 800287c:	d001      	beq.n	8002882 <MX_TIM3_Init+0x6e>
	{
		Error_Handler();
 800287e:	f003 f803 	bl	8005888 <Error_Handler>
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8002882:	2300      	movs	r3, #0
 8002884:	603b      	str	r3, [r7, #0]
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8002886:	2300      	movs	r3, #0
 8002888:	607b      	str	r3, [r7, #4]
	if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 800288a:	463b      	mov	r3, r7
 800288c:	4619      	mov	r1, r3
 800288e:	4806      	ldr	r0, [pc, #24]	@ (80028a8 <MX_TIM3_Init+0x94>)
 8002890:	f012 fb3e 	bl	8014f10 <HAL_TIMEx_MasterConfigSynchronization>
 8002894:	4603      	mov	r3, r0
 8002896:	2b00      	cmp	r3, #0
 8002898:	d001      	beq.n	800289e <MX_TIM3_Init+0x8a>
	{
		Error_Handler();
 800289a:	f002 fff5 	bl	8005888 <Error_Handler>
	}
	/* USER CODE BEGIN TIM3_Init 2 */
	/* USER CODE END TIM3_Init 2 */

}
 800289e:	bf00      	nop
 80028a0:	3718      	adds	r7, #24
 80028a2:	46bd      	mov	sp, r7
 80028a4:	bd80      	pop	{r7, pc}
 80028a6:	bf00      	nop
 80028a8:	20001bf8 	.word	0x20001bf8
 80028ac:	40000400 	.word	0x40000400

080028b0 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80028b0:	b580      	push	{r7, lr}
 80028b2:	b084      	sub	sp, #16
 80028b4:	af00      	add	r7, sp, #0
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
 80028b6:	2300      	movs	r3, #0
 80028b8:	60fb      	str	r3, [r7, #12]
 80028ba:	4b21      	ldr	r3, [pc, #132]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028bc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80028be:	4a20      	ldr	r2, [pc, #128]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028c0:	f043 0304 	orr.w	r3, r3, #4
 80028c4:	6313      	str	r3, [r2, #48]	@ 0x30
 80028c6:	4b1e      	ldr	r3, [pc, #120]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80028ca:	f003 0304 	and.w	r3, r3, #4
 80028ce:	60fb      	str	r3, [r7, #12]
 80028d0:	68fb      	ldr	r3, [r7, #12]
	__HAL_RCC_GPIOH_CLK_ENABLE();
 80028d2:	2300      	movs	r3, #0
 80028d4:	60bb      	str	r3, [r7, #8]
 80028d6:	4b1a      	ldr	r3, [pc, #104]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028d8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80028da:	4a19      	ldr	r2, [pc, #100]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028dc:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80028e0:	6313      	str	r3, [r2, #48]	@ 0x30
 80028e2:	4b17      	ldr	r3, [pc, #92]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028e4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80028e6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80028ea:	60bb      	str	r3, [r7, #8]
 80028ec:	68bb      	ldr	r3, [r7, #8]
	__HAL_RCC_GPIOA_CLK_ENABLE();
 80028ee:	2300      	movs	r3, #0
 80028f0:	607b      	str	r3, [r7, #4]
 80028f2:	4b13      	ldr	r3, [pc, #76]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80028f6:	4a12      	ldr	r2, [pc, #72]	@ (8002940 <MX_GPIO_Init+0x90>)
 80028f8:	f043 0301 	orr.w	r3, r3, #1
 80028fc:	6313      	str	r3, [r2, #48]	@ 0x30
 80028fe:	4b10      	ldr	r3, [pc, #64]	@ (8002940 <MX_GPIO_Init+0x90>)
 8002900:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002902:	f003 0301 	and.w	r3, r3, #1
 8002906:	607b      	str	r3, [r7, #4]
 8002908:	687b      	ldr	r3, [r7, #4]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 800290a:	2300      	movs	r3, #0
 800290c:	603b      	str	r3, [r7, #0]
 800290e:	4b0c      	ldr	r3, [pc, #48]	@ (8002940 <MX_GPIO_Init+0x90>)
 8002910:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002912:	4a0b      	ldr	r2, [pc, #44]	@ (8002940 <MX_GPIO_Init+0x90>)
 8002914:	f043 0302 	orr.w	r3, r3, #2
 8002918:	6313      	str	r3, [r2, #48]	@ 0x30
 800291a:	4b09      	ldr	r3, [pc, #36]	@ (8002940 <MX_GPIO_Init+0x90>)
 800291c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800291e:	f003 0302 	and.w	r3, r3, #2
 8002922:	603b      	str	r3, [r7, #0]
 8002924:	683b      	ldr	r3, [r7, #0]

	/* EXTI interrupt init*/
	HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
 8002926:	2200      	movs	r2, #0
 8002928:	2100      	movs	r1, #0
 800292a:	2028      	movs	r0, #40	@ 0x28
 800292c:	f00c fe15 	bl	800f55a <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8002930:	2028      	movs	r0, #40	@ 0x28
 8002932:	f00c fe2e 	bl	800f592 <HAL_NVIC_EnableIRQ>

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}
 8002936:	bf00      	nop
 8002938:	3710      	adds	r7, #16
 800293a:	46bd      	mov	sp, r7
 800293c:	bd80      	pop	{r7, pc}
 800293e:	bf00      	nop
 8002940:	40023800 	.word	0x40023800

08002944 <MX_USART2_UART_Init>:
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
 8002944:	b580      	push	{r7, lr}
 8002946:	af00      	add	r7, sp, #0

	/* USER CODE BEGIN USART2_Init 1 */
	/* (1) Enable GPIO clock and configures the USART pins *********************/

	/* Enable the peripheral clock of GPIO Port */
	USARTx_GPIO_CLK_ENABLE();
 8002948:	2001      	movs	r0, #1
 800294a:	f7fe fde9 	bl	8001520 <LL_AHB1_GRP1_EnableClock>

	/* Configure Tx Pin as : Alternate function, High Speed, Push pull, Pull up */
	LL_GPIO_SetPinMode(USARTx_TX_GPIO_PORT, USARTx_TX_PIN, LL_GPIO_MODE_ALTERNATE);
 800294e:	2202      	movs	r2, #2
 8002950:	2104      	movs	r1, #4
 8002952:	483d      	ldr	r0, [pc, #244]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 8002954:	f7fe fe14 	bl	8001580 <LL_GPIO_SetPinMode>
	USARTx_SET_TX_GPIO_AF();
 8002958:	2207      	movs	r2, #7
 800295a:	2104      	movs	r1, #4
 800295c:	483a      	ldr	r0, [pc, #232]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 800295e:	f7fe fede 	bl	800171e <LL_GPIO_SetAFPin_0_7>
	LL_GPIO_SetPinSpeed(USARTx_TX_GPIO_PORT, USARTx_TX_PIN, LL_GPIO_SPEED_FREQ_HIGH);
 8002962:	2202      	movs	r2, #2
 8002964:	2104      	movs	r1, #4
 8002966:	4838      	ldr	r0, [pc, #224]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 8002968:	f7fe fe5f 	bl	800162a <LL_GPIO_SetPinSpeed>
	LL_GPIO_SetPinOutputType(USARTx_TX_GPIO_PORT, USARTx_TX_PIN, LL_GPIO_OUTPUT_PUSHPULL);
 800296c:	2200      	movs	r2, #0
 800296e:	2104      	movs	r1, #4
 8002970:	4835      	ldr	r0, [pc, #212]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 8002972:	f7fe fe42 	bl	80015fa <LL_GPIO_SetPinOutputType>
	LL_GPIO_SetPinPull(USARTx_TX_GPIO_PORT, USARTx_TX_PIN, LL_GPIO_PULL_UP);
 8002976:	2201      	movs	r2, #1
 8002978:	2104      	movs	r1, #4
 800297a:	4833      	ldr	r0, [pc, #204]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 800297c:	f7fe fe92 	bl	80016a4 <LL_GPIO_SetPinPull>

	/* Configure Rx Pin as : Alternate function, High Speed, Push pull, Pull up */
	LL_GPIO_SetPinMode(USARTx_RX_GPIO_PORT, USARTx_RX_PIN, LL_GPIO_MODE_ALTERNATE);
 8002980:	2202      	movs	r2, #2
 8002982:	2108      	movs	r1, #8
 8002984:	4830      	ldr	r0, [pc, #192]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 8002986:	f7fe fdfb 	bl	8001580 <LL_GPIO_SetPinMode>
	USARTx_SET_RX_GPIO_AF();
 800298a:	2207      	movs	r2, #7
 800298c:	2108      	movs	r1, #8
 800298e:	482e      	ldr	r0, [pc, #184]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 8002990:	f7fe fec5 	bl	800171e <LL_GPIO_SetAFPin_0_7>
	LL_GPIO_SetPinSpeed(USARTx_RX_GPIO_PORT, USARTx_RX_PIN, LL_GPIO_SPEED_FREQ_HIGH);
 8002994:	2202      	movs	r2, #2
 8002996:	2108      	movs	r1, #8
 8002998:	482b      	ldr	r0, [pc, #172]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 800299a:	f7fe fe46 	bl	800162a <LL_GPIO_SetPinSpeed>
	LL_GPIO_SetPinOutputType(USARTx_RX_GPIO_PORT, USARTx_RX_PIN, LL_GPIO_OUTPUT_PUSHPULL);
 800299e:	2200      	movs	r2, #0
 80029a0:	2108      	movs	r1, #8
 80029a2:	4829      	ldr	r0, [pc, #164]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 80029a4:	f7fe fe29 	bl	80015fa <LL_GPIO_SetPinOutputType>
	LL_GPIO_SetPinPull(USARTx_RX_GPIO_PORT, USARTx_RX_PIN, LL_GPIO_PULL_UP);
 80029a8:	2201      	movs	r2, #1
 80029aa:	2108      	movs	r1, #8
 80029ac:	4826      	ldr	r0, [pc, #152]	@ (8002a48 <MX_USART2_UART_Init+0x104>)
 80029ae:	f7fe fe79 	bl	80016a4 <LL_GPIO_SetPinPull>

	/* (2) NVIC Configuration for USART interrupts */
	/*  - Set priority for USARTx_IRQn */
	/*  - Enable USARTx_IRQn */
	NVIC_SetPriority(USARTx_IRQn, 0);
 80029b2:	2100      	movs	r1, #0
 80029b4:	2026      	movs	r0, #38	@ 0x26
 80029b6:	f7fe fd89 	bl	80014cc <__NVIC_SetPriority>
	NVIC_EnableIRQ(USARTx_IRQn);
 80029ba:	2026      	movs	r0, #38	@ 0x26
 80029bc:	f7fe fd68 	bl	8001490 <__NVIC_EnableIRQ>

	/* (3) Enable USART peripheral clock and clock source ***********************/
	USARTx_CLK_ENABLE();
 80029c0:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
 80029c4:	f7fe fdc4 	bl	8001550 <LL_APB1_GRP1_EnableClock>
	/* Disable USART prior modifying configuration registers */
	/* Note: Commented as corresponding to Reset value */
	// LL_USART_Disable(USARTx_INSTANCE);

	/* TX/RX direction */
	LL_USART_SetTransferDirection(USARTx_INSTANCE, LL_USART_DIRECTION_TX_RX);
 80029c8:	210c      	movs	r1, #12
 80029ca:	4820      	ldr	r0, [pc, #128]	@ (8002a4c <MX_USART2_UART_Init+0x108>)
 80029cc:	f7fe ff1c 	bl	8001808 <LL_USART_SetTransferDirection>

	/* 8 data bit, 1 start bit, 1 stop bit, no parity */
	LL_USART_ConfigCharacter(USARTx_INSTANCE, LL_USART_DATAWIDTH_8B, LL_USART_PARITY_NONE, LL_USART_STOPBITS_1);
 80029d0:	2300      	movs	r3, #0
 80029d2:	2200      	movs	r2, #0
 80029d4:	2100      	movs	r1, #0
 80029d6:	481d      	ldr	r0, [pc, #116]	@ (8002a4c <MX_USART2_UART_Init+0x108>)
 80029d8:	f7fe ff3c 	bl	8001854 <LL_USART_ConfigCharacter>
	/* Ex :
	  Periphclk = LL_RCC_GetUSARTClockFreq(Instance); or LL_RCC_GetUARTClockFreq(Instance); depending on USART/UART instance

	  In this example, Peripheral Clock is expected to be equal to 100000000/APB_Div Hz => equal to SystemCoreClock/APB_Div
	*/
	LL_USART_SetBaudRate(USARTx_INSTANCE, SystemCoreClock/APB_Div, LL_USART_OVERSAMPLING_16, 115200);
 80029dc:	4b1c      	ldr	r3, [pc, #112]	@ (8002a50 <MX_USART2_UART_Init+0x10c>)
 80029de:	681b      	ldr	r3, [r3, #0]
 80029e0:	0859      	lsrs	r1, r3, #1
 80029e2:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
 80029e6:	2200      	movs	r2, #0
 80029e8:	4818      	ldr	r0, [pc, #96]	@ (8002a4c <MX_USART2_UART_Init+0x108>)
 80029ea:	f7fe ff53 	bl	8001894 <LL_USART_SetBaudRate>

	/* (5) Enable USART *********************************************************/
	LL_USART_Enable(USARTx_INSTANCE);
 80029ee:	4817      	ldr	r0, [pc, #92]	@ (8002a4c <MX_USART2_UART_Init+0x108>)
 80029f0:	f7fe fefa 	bl	80017e8 <LL_USART_Enable>

	/* Enable RXNE and Error interrupts */
	LL_USART_EnableIT_RXNE(USARTx_INSTANCE);
 80029f4:	4815      	ldr	r0, [pc, #84]	@ (8002a4c <MX_USART2_UART_Init+0x108>)
 80029f6:	f7ff f97b 	bl	8001cf0 <LL_USART_EnableIT_RXNE>
	LL_USART_EnableIT_ERROR(USARTx_INSTANCE);
 80029fa:	4814      	ldr	r0, [pc, #80]	@ (8002a4c <MX_USART2_UART_Init+0x108>)
 80029fc:	f7ff f99b 	bl	8001d36 <LL_USART_EnableIT_ERROR>

	/* USER CODE END USART2_Init 1 */
	huart2.Instance = USART2;
 8002a00:	4b14      	ldr	r3, [pc, #80]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a02:	4a12      	ldr	r2, [pc, #72]	@ (8002a4c <MX_USART2_UART_Init+0x108>)
 8002a04:	601a      	str	r2, [r3, #0]
	huart2.Init.BaudRate = 115200;
 8002a06:	4b13      	ldr	r3, [pc, #76]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a08:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 8002a0c:	605a      	str	r2, [r3, #4]
	huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8002a0e:	4b11      	ldr	r3, [pc, #68]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a10:	2200      	movs	r2, #0
 8002a12:	609a      	str	r2, [r3, #8]
	huart2.Init.StopBits = UART_STOPBITS_1;
 8002a14:	4b0f      	ldr	r3, [pc, #60]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a16:	2200      	movs	r2, #0
 8002a18:	60da      	str	r2, [r3, #12]
	huart2.Init.Parity = UART_PARITY_NONE;
 8002a1a:	4b0e      	ldr	r3, [pc, #56]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a1c:	2200      	movs	r2, #0
 8002a1e:	611a      	str	r2, [r3, #16]
	huart2.Init.Mode = UART_MODE_TX_RX;
 8002a20:	4b0c      	ldr	r3, [pc, #48]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a22:	220c      	movs	r2, #12
 8002a24:	615a      	str	r2, [r3, #20]
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8002a26:	4b0b      	ldr	r3, [pc, #44]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a28:	2200      	movs	r2, #0
 8002a2a:	619a      	str	r2, [r3, #24]
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8002a2c:	4b09      	ldr	r3, [pc, #36]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a2e:	2200      	movs	r2, #0
 8002a30:	61da      	str	r2, [r3, #28]
	if (HAL_UART_Init(&huart2) != HAL_OK)
 8002a32:	4808      	ldr	r0, [pc, #32]	@ (8002a54 <MX_USART2_UART_Init+0x110>)
 8002a34:	f012 fb40 	bl	80150b8 <HAL_UART_Init>
 8002a38:	4603      	mov	r3, r0
 8002a3a:	2b00      	cmp	r3, #0
 8002a3c:	d001      	beq.n	8002a42 <MX_USART2_UART_Init+0xfe>
	{
	Error_Handler();
 8002a3e:	f002 ff23 	bl	8005888 <Error_Handler>
	}
	/* USER CODE BEGIN USART2_Init 2 */

	/* USER CODE END USART2_Init 2 */

}
 8002a42:	bf00      	nop
 8002a44:	bd80      	pop	{r7, pc}
 8002a46:	bf00      	nop
 8002a48:	40020000 	.word	0x40020000
 8002a4c:	40004400 	.word	0x40004400
 8002a50:	20000144 	.word	0x20000144
 8002a54:	200022c4 	.word	0x200022c4

08002a58 <USART_CharReception_Callback>:


void USART_CharReception_Callback(void)
{
 8002a58:	b580      	push	{r7, lr}
 8002a5a:	b082      	sub	sp, #8
 8002a5c:	af00      	add	r7, sp, #0
__IO uint32_t received_char;

  /* Auslesen des Zeichens. RXNE flag wird gecleared durch das lesen des DR Registers */
  received_char = LL_USART_ReceiveData8(USARTx_INSTANCE);
 8002a5e:	483c      	ldr	r0, [pc, #240]	@ (8002b50 <USART_CharReception_Callback+0xf8>)
 8002a60:	f7ff f98c 	bl	8001d7c <LL_USART_ReceiveData8>
 8002a64:	4603      	mov	r3, r0
 8002a66:	607b      	str	r3, [r7, #4]

  if (received_char == '\r') {
 8002a68:	687b      	ldr	r3, [r7, #4]
 8002a6a:	2b0d      	cmp	r3, #13
 8002a6c:	d159      	bne.n	8002b22 <USART_CharReception_Callback+0xca>
	  rx_index = 0;
 8002a6e:	4b39      	ldr	r3, [pc, #228]	@ (8002b54 <USART_CharReception_Callback+0xfc>)
 8002a70:	2200      	movs	r2, #0
 8002a72:	701a      	strb	r2, [r3, #0]

	  joystick_schub = (100 * ((rx_buffer[0] - '0') - 1) + 10 * (rx_buffer[1] - '0') + (rx_buffer[2] - '0'));
 8002a74:	4b38      	ldr	r3, [pc, #224]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002a76:	781b      	ldrb	r3, [r3, #0]
 8002a78:	461a      	mov	r2, r3
 8002a7a:	0092      	lsls	r2, r2, #2
 8002a7c:	4413      	add	r3, r2
 8002a7e:	461a      	mov	r2, r3
 8002a80:	0091      	lsls	r1, r2, #2
 8002a82:	461a      	mov	r2, r3
 8002a84:	460b      	mov	r3, r1
 8002a86:	4413      	add	r3, r2
 8002a88:	009b      	lsls	r3, r3, #2
 8002a8a:	b2da      	uxtb	r2, r3
 8002a8c:	4b32      	ldr	r3, [pc, #200]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002a8e:	785b      	ldrb	r3, [r3, #1]
 8002a90:	4619      	mov	r1, r3
 8002a92:	0089      	lsls	r1, r1, #2
 8002a94:	440b      	add	r3, r1
 8002a96:	005b      	lsls	r3, r3, #1
 8002a98:	b2db      	uxtb	r3, r3
 8002a9a:	4413      	add	r3, r2
 8002a9c:	b2da      	uxtb	r2, r3
 8002a9e:	4b2e      	ldr	r3, [pc, #184]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002aa0:	789b      	ldrb	r3, [r3, #2]
 8002aa2:	4413      	add	r3, r2
 8002aa4:	b2db      	uxtb	r3, r3
 8002aa6:	3b34      	subs	r3, #52	@ 0x34
 8002aa8:	b2da      	uxtb	r2, r3
 8002aaa:	4b2c      	ldr	r3, [pc, #176]	@ (8002b5c <USART_CharReception_Callback+0x104>)
 8002aac:	701a      	strb	r2, [r3, #0]
	  joystick_nicken = ((100 * (rx_buffer[3] - '0') + 10 * (rx_buffer[4] - '0') + (rx_buffer[5] - '0')) - 500);
 8002aae:	4b2a      	ldr	r3, [pc, #168]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002ab0:	78db      	ldrb	r3, [r3, #3]
 8002ab2:	3b30      	subs	r3, #48	@ 0x30
 8002ab4:	2264      	movs	r2, #100	@ 0x64
 8002ab6:	fb02 f103 	mul.w	r1, r2, r3
 8002aba:	4b27      	ldr	r3, [pc, #156]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002abc:	791b      	ldrb	r3, [r3, #4]
 8002abe:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 8002ac2:	4613      	mov	r3, r2
 8002ac4:	009b      	lsls	r3, r3, #2
 8002ac6:	4413      	add	r3, r2
 8002ac8:	005b      	lsls	r3, r3, #1
 8002aca:	18ca      	adds	r2, r1, r3
 8002acc:	4b22      	ldr	r3, [pc, #136]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002ace:	795b      	ldrb	r3, [r3, #5]
 8002ad0:	3b30      	subs	r3, #48	@ 0x30
 8002ad2:	4413      	add	r3, r2
 8002ad4:	f5a3 73fa 	sub.w	r3, r3, #500	@ 0x1f4
 8002ad8:	4a21      	ldr	r2, [pc, #132]	@ (8002b60 <USART_CharReception_Callback+0x108>)
 8002ada:	6013      	str	r3, [r2, #0]
	  joystick_rollen = ((100 * (rx_buffer[6] - '0') + 10 * (rx_buffer[7] - '0') + (rx_buffer[8] - '0')) - 500);
 8002adc:	4b1e      	ldr	r3, [pc, #120]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002ade:	799b      	ldrb	r3, [r3, #6]
 8002ae0:	3b30      	subs	r3, #48	@ 0x30
 8002ae2:	2264      	movs	r2, #100	@ 0x64
 8002ae4:	fb02 f103 	mul.w	r1, r2, r3
 8002ae8:	4b1b      	ldr	r3, [pc, #108]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002aea:	79db      	ldrb	r3, [r3, #7]
 8002aec:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 8002af0:	4613      	mov	r3, r2
 8002af2:	009b      	lsls	r3, r3, #2
 8002af4:	4413      	add	r3, r2
 8002af6:	005b      	lsls	r3, r3, #1
 8002af8:	18ca      	adds	r2, r1, r3
 8002afa:	4b17      	ldr	r3, [pc, #92]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002afc:	7a1b      	ldrb	r3, [r3, #8]
 8002afe:	3b30      	subs	r3, #48	@ 0x30
 8002b00:	4413      	add	r3, r2
 8002b02:	f5a3 73fa 	sub.w	r3, r3, #500	@ 0x1f4
 8002b06:	4a17      	ldr	r2, [pc, #92]	@ (8002b64 <USART_CharReception_Callback+0x10c>)
 8002b08:	6013      	str	r3, [r2, #0]
	  regleran = rx_buffer[9] - '0';
 8002b0a:	4b13      	ldr	r3, [pc, #76]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002b0c:	7a5b      	ldrb	r3, [r3, #9]
 8002b0e:	3b30      	subs	r3, #48	@ 0x30
 8002b10:	b2da      	uxtb	r2, r3
 8002b12:	4b15      	ldr	r3, [pc, #84]	@ (8002b68 <USART_CharReception_Callback+0x110>)
 8002b14:	701a      	strb	r2, [r3, #0]
	  schubnur = rx_buffer[10] - '0';
 8002b16:	4b10      	ldr	r3, [pc, #64]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002b18:	7a9b      	ldrb	r3, [r3, #10]
 8002b1a:	3b30      	subs	r3, #48	@ 0x30
 8002b1c:	4a13      	ldr	r2, [pc, #76]	@ (8002b6c <USART_CharReception_Callback+0x114>)
 8002b1e:	6013      	str	r3, [r2, #0]
 8002b20:	e00c      	b.n	8002b3c <USART_CharReception_Callback+0xe4>
  } else {
	  rx_buffer[rx_index] = received_char;
 8002b22:	6879      	ldr	r1, [r7, #4]
 8002b24:	4b0b      	ldr	r3, [pc, #44]	@ (8002b54 <USART_CharReception_Callback+0xfc>)
 8002b26:	781b      	ldrb	r3, [r3, #0]
 8002b28:	461a      	mov	r2, r3
 8002b2a:	b2c9      	uxtb	r1, r1
 8002b2c:	4b0a      	ldr	r3, [pc, #40]	@ (8002b58 <USART_CharReception_Callback+0x100>)
 8002b2e:	5499      	strb	r1, [r3, r2]

	  rx_index += 1;
 8002b30:	4b08      	ldr	r3, [pc, #32]	@ (8002b54 <USART_CharReception_Callback+0xfc>)
 8002b32:	781b      	ldrb	r3, [r3, #0]
 8002b34:	3301      	adds	r3, #1
 8002b36:	b2da      	uxtb	r2, r3
 8002b38:	4b06      	ldr	r3, [pc, #24]	@ (8002b54 <USART_CharReception_Callback+0xfc>)
 8002b3a:	701a      	strb	r2, [r3, #0]
  }

  LL_USART_TransmitData8(USARTx_INSTANCE, received_char);
 8002b3c:	687b      	ldr	r3, [r7, #4]
 8002b3e:	b2db      	uxtb	r3, r3
 8002b40:	4619      	mov	r1, r3
 8002b42:	4803      	ldr	r0, [pc, #12]	@ (8002b50 <USART_CharReception_Callback+0xf8>)
 8002b44:	f7ff f927 	bl	8001d96 <LL_USART_TransmitData8>
}
 8002b48:	bf00      	nop
 8002b4a:	3708      	adds	r7, #8
 8002b4c:	46bd      	mov	sp, r7
 8002b4e:	bd80      	pop	{r7, pc}
 8002b50:	40004400 	.word	0x40004400
 8002b54:	20001c90 	.word	0x20001c90
 8002b58:	20001c70 	.word	0x20001c70
 8002b5c:	20001c64 	.word	0x20001c64
 8002b60:	20001c68 	.word	0x20001c68
 8002b64:	20001c6c 	.word	0x20001c6c
 8002b68:	20001c91 	.word	0x20001c91
 8002b6c:	20000140 	.word	0x20000140

08002b70 <regelschritt>:

// Regler
void regelschritt(void) {
 8002b70:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8002b74:	f5ad 7d12 	sub.w	sp, sp, #584	@ 0x248
 8002b78:	af00      	add	r7, sp, #0
	READ_ACCELEROMETER();
 8002b7a:	f002 fd9f 	bl	80056bc <READ_ACCELEROMETER>
	READ_GYRO();
 8002b7e:	f002 fdd3 	bl	8005728 <READ_GYRO>
	READ_MAG();
 8002b82:	f002 fe07 	bl	8005794 <READ_MAG>

	/* Convert angular velocity from [md/s] to [deg/s] */
	// Gieren (Uhrzeigersinn)
	data_in.gyro[0] = (float) GyrValue.x * FROM_MDPS_TO_DPS;
 8002b86:	4bbc      	ldr	r3, [pc, #752]	@ (8002e78 <regelschritt+0x308>)
 8002b88:	681b      	ldr	r3, [r3, #0]
 8002b8a:	ee07 3a90 	vmov	s15, r3
 8002b8e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002b92:	ed9f 7aba 	vldr	s14, [pc, #744]	@ 8002e7c <regelschritt+0x30c>
 8002b96:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002b9a:	4bb9      	ldr	r3, [pc, #740]	@ (8002e80 <regelschritt+0x310>)
 8002b9c:	edc3 7a06 	vstr	s15, [r3, #24]
	// Nicken (Nase nach unten ist negatives nicken)
	data_in.gyro[1] = (float) GyrValue.y * FROM_MDPS_TO_DPS;
 8002ba0:	4bb5      	ldr	r3, [pc, #724]	@ (8002e78 <regelschritt+0x308>)
 8002ba2:	685b      	ldr	r3, [r3, #4]
 8002ba4:	ee07 3a90 	vmov	s15, r3
 8002ba8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002bac:	ed9f 7ab3 	vldr	s14, [pc, #716]	@ 8002e7c <regelschritt+0x30c>
 8002bb0:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002bb4:	4bb2      	ldr	r3, [pc, #712]	@ (8002e80 <regelschritt+0x310>)
 8002bb6:	edc3 7a07 	vstr	s15, [r3, #28]
	// Rollen (Mit Blick von hinten im Uhrzeigersinn)
	data_in.gyro[2] = (float) GyrValue.z * FROM_MDPS_TO_DPS;
 8002bba:	4baf      	ldr	r3, [pc, #700]	@ (8002e78 <regelschritt+0x308>)
 8002bbc:	689b      	ldr	r3, [r3, #8]
 8002bbe:	ee07 3a90 	vmov	s15, r3
 8002bc2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002bc6:	ed9f 7aad 	vldr	s14, [pc, #692]	@ 8002e7c <regelschritt+0x30c>
 8002bca:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002bce:	4bac      	ldr	r3, [pc, #688]	@ (8002e80 <regelschritt+0x310>)
 8002bd0:	edc3 7a08 	vstr	s15, [r3, #32]

	// Norden in g
	data_in.acc[0] = (float) AccValue.x * FROM_MG_TO_G;
 8002bd4:	4bab      	ldr	r3, [pc, #684]	@ (8002e84 <regelschritt+0x314>)
 8002bd6:	681b      	ldr	r3, [r3, #0]
 8002bd8:	ee07 3a90 	vmov	s15, r3
 8002bdc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002be0:	ed9f 7aa6 	vldr	s14, [pc, #664]	@ 8002e7c <regelschritt+0x30c>
 8002be4:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002be8:	4ba5      	ldr	r3, [pc, #660]	@ (8002e80 <regelschritt+0x310>)
 8002bea:	edc3 7a03 	vstr	s15, [r3, #12]
	// Osten in g
	data_in.acc[1] = (float) AccValue.y * FROM_MG_TO_G;
 8002bee:	4ba5      	ldr	r3, [pc, #660]	@ (8002e84 <regelschritt+0x314>)
 8002bf0:	685b      	ldr	r3, [r3, #4]
 8002bf2:	ee07 3a90 	vmov	s15, r3
 8002bf6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002bfa:	ed9f 7aa0 	vldr	s14, [pc, #640]	@ 8002e7c <regelschritt+0x30c>
 8002bfe:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002c02:	4b9f      	ldr	r3, [pc, #636]	@ (8002e80 <regelschritt+0x310>)
 8002c04:	edc3 7a04 	vstr	s15, [r3, #16]
	// Oben in g
	data_in.acc[2] = (float) AccValue.z * FROM_MG_TO_G;
 8002c08:	4b9e      	ldr	r3, [pc, #632]	@ (8002e84 <regelschritt+0x314>)
 8002c0a:	689b      	ldr	r3, [r3, #8]
 8002c0c:	ee07 3a90 	vmov	s15, r3
 8002c10:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002c14:	ed9f 7a99 	vldr	s14, [pc, #612]	@ 8002e7c <regelschritt+0x30c>
 8002c18:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002c1c:	4b98      	ldr	r3, [pc, #608]	@ (8002e80 <regelschritt+0x310>)
 8002c1e:	edc3 7a05 	vstr	s15, [r3, #20]

	data_in.mag[0] = (float) MagValue.x * FROM_MGAUSS_TO_UT50;
 8002c22:	4b99      	ldr	r3, [pc, #612]	@ (8002e88 <regelschritt+0x318>)
 8002c24:	681b      	ldr	r3, [r3, #0]
 8002c26:	ee07 3a90 	vmov	s15, r3
 8002c2a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002c2e:	ed9f 7a97 	vldr	s14, [pc, #604]	@ 8002e8c <regelschritt+0x31c>
 8002c32:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002c36:	4b92      	ldr	r3, [pc, #584]	@ (8002e80 <regelschritt+0x310>)
 8002c38:	edc3 7a00 	vstr	s15, [r3]
	data_in.mag[1] = (float) MagValue.y * FROM_MGAUSS_TO_UT50;
 8002c3c:	4b92      	ldr	r3, [pc, #584]	@ (8002e88 <regelschritt+0x318>)
 8002c3e:	685b      	ldr	r3, [r3, #4]
 8002c40:	ee07 3a90 	vmov	s15, r3
 8002c44:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002c48:	ed9f 7a90 	vldr	s14, [pc, #576]	@ 8002e8c <regelschritt+0x31c>
 8002c4c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002c50:	4b8b      	ldr	r3, [pc, #556]	@ (8002e80 <regelschritt+0x310>)
 8002c52:	edc3 7a01 	vstr	s15, [r3, #4]
	data_in.mag[2] = (float) MagValue.z * FROM_MGAUSS_TO_UT50;
 8002c56:	4b8c      	ldr	r3, [pc, #560]	@ (8002e88 <regelschritt+0x318>)
 8002c58:	689b      	ldr	r3, [r3, #8]
 8002c5a:	ee07 3a90 	vmov	s15, r3
 8002c5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002c62:	ed9f 7a8a 	vldr	s14, [pc, #552]	@ 8002e8c <regelschritt+0x31c>
 8002c66:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002c6a:	4b85      	ldr	r3, [pc, #532]	@ (8002e80 <regelschritt+0x310>)
 8002c6c:	edc3 7a02 	vstr	s15, [r3, #8]

	delta_t_s = DWT_Stop() * 1e-6f;
 8002c70:	f002 fde2 	bl	8005838 <DWT_Stop>
 8002c74:	ee07 0a90 	vmov	s15, r0
 8002c78:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002c7c:	ed9f 7a84 	vldr	s14, [pc, #528]	@ 8002e90 <regelschritt+0x320>
 8002c80:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002c84:	ee17 0a90 	vmov	r0, s15
 8002c88:	f7fd fc66 	bl	8000558 <__aeabi_f2d>
 8002c8c:	4602      	mov	r2, r0
 8002c8e:	460b      	mov	r3, r1
 8002c90:	4980      	ldr	r1, [pc, #512]	@ (8002e94 <regelschritt+0x324>)
 8002c92:	e9c1 2300 	strd	r2, r3, [r1]
	DWT_Start();
 8002c96:	f002 fdbd 	bl	8005814 <DWT_Start>

	MotionFX_manager_run(fusionin, fusionout, 0.01f);
 8002c9a:	4b7f      	ldr	r3, [pc, #508]	@ (8002e98 <regelschritt+0x328>)
 8002c9c:	681a      	ldr	r2, [r3, #0]
 8002c9e:	4b7f      	ldr	r3, [pc, #508]	@ (8002e9c <regelschritt+0x32c>)
 8002ca0:	681b      	ldr	r3, [r3, #0]
 8002ca2:	ed9f 0a7f 	vldr	s0, [pc, #508]	@ 8002ea0 <regelschritt+0x330>
 8002ca6:	4619      	mov	r1, r3
 8002ca8:	4610      	mov	r0, r2
 8002caa:	f7fe fbb9 	bl	8001420 <MotionFX_manager_run>

	sollgeschwindigkeit.norden = joystick_nicken / 50.0f;
 8002cae:	4b7d      	ldr	r3, [pc, #500]	@ (8002ea4 <regelschritt+0x334>)
 8002cb0:	681b      	ldr	r3, [r3, #0]
 8002cb2:	ee07 3a90 	vmov	s15, r3
 8002cb6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002cba:	ed9f 7a7b 	vldr	s14, [pc, #492]	@ 8002ea8 <regelschritt+0x338>
 8002cbe:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8002cc2:	ee16 0a90 	vmov	r0, s13
 8002cc6:	f7fd fc47 	bl	8000558 <__aeabi_f2d>
 8002cca:	4602      	mov	r2, r0
 8002ccc:	460b      	mov	r3, r1
 8002cce:	4977      	ldr	r1, [pc, #476]	@ (8002eac <regelschritt+0x33c>)
 8002cd0:	e9c1 2300 	strd	r2, r3, [r1]
	sollgeschwindigkeit.osten = joystick_rollen / 50.0f;
 8002cd4:	4b76      	ldr	r3, [pc, #472]	@ (8002eb0 <regelschritt+0x340>)
 8002cd6:	681b      	ldr	r3, [r3, #0]
 8002cd8:	ee07 3a90 	vmov	s15, r3
 8002cdc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002ce0:	ed9f 7a71 	vldr	s14, [pc, #452]	@ 8002ea8 <regelschritt+0x338>
 8002ce4:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8002ce8:	ee16 0a90 	vmov	r0, s13
 8002cec:	f7fd fc34 	bl	8000558 <__aeabi_f2d>
 8002cf0:	4602      	mov	r2, r0
 8002cf2:	460b      	mov	r3, r1
 8002cf4:	496d      	ldr	r1, [pc, #436]	@ (8002eac <regelschritt+0x33c>)
 8002cf6:	e9c1 2302 	strd	r2, r3, [r1, #8]
	sollgeschwindigkeit.unten = -joystick_schub / 50.0f;
 8002cfa:	4b6e      	ldr	r3, [pc, #440]	@ (8002eb4 <regelschritt+0x344>)
 8002cfc:	781b      	ldrb	r3, [r3, #0]
 8002cfe:	425b      	negs	r3, r3
 8002d00:	ee07 3a90 	vmov	s15, r3
 8002d04:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002d08:	ed9f 7a67 	vldr	s14, [pc, #412]	@ 8002ea8 <regelschritt+0x338>
 8002d0c:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8002d10:	ee16 0a90 	vmov	r0, s13
 8002d14:	f7fd fc20 	bl	8000558 <__aeabi_f2d>
 8002d18:	4602      	mov	r2, r0
 8002d1a:	460b      	mov	r3, r1
 8002d1c:	4963      	ldr	r1, [pc, #396]	@ (8002eac <regelschritt+0x33c>)
 8002d1e:	e9c1 2304 	strd	r2, r3, [r1, #16]

	// [m/s]
	geschwindigkeit[NORDEN] += delta_t_s * fusionout->linear_acceleration[SENSOR_NORDEN] / 9.81f;
 8002d22:	4b65      	ldr	r3, [pc, #404]	@ (8002eb8 <regelschritt+0x348>)
 8002d24:	e9d3 4500 	ldrd	r4, r5, [r3]
 8002d28:	4b5c      	ldr	r3, [pc, #368]	@ (8002e9c <regelschritt+0x32c>)
 8002d2a:	681b      	ldr	r3, [r3, #0]
 8002d2c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8002d2e:	4618      	mov	r0, r3
 8002d30:	f7fd fc12 	bl	8000558 <__aeabi_f2d>
 8002d34:	4b57      	ldr	r3, [pc, #348]	@ (8002e94 <regelschritt+0x324>)
 8002d36:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002d3a:	f7fd fc65 	bl	8000608 <__aeabi_dmul>
 8002d3e:	4602      	mov	r2, r0
 8002d40:	460b      	mov	r3, r1
 8002d42:	4610      	mov	r0, r2
 8002d44:	4619      	mov	r1, r3
 8002d46:	a34a      	add	r3, pc, #296	@ (adr r3, 8002e70 <regelschritt+0x300>)
 8002d48:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002d4c:	f7fd fd86 	bl	800085c <__aeabi_ddiv>
 8002d50:	4602      	mov	r2, r0
 8002d52:	460b      	mov	r3, r1
 8002d54:	4620      	mov	r0, r4
 8002d56:	4629      	mov	r1, r5
 8002d58:	f7fd faa0 	bl	800029c <__adddf3>
 8002d5c:	4602      	mov	r2, r0
 8002d5e:	460b      	mov	r3, r1
 8002d60:	4610      	mov	r0, r2
 8002d62:	4619      	mov	r1, r3
 8002d64:	4b54      	ldr	r3, [pc, #336]	@ (8002eb8 <regelschritt+0x348>)
 8002d66:	e9c3 0100 	strd	r0, r1, [r3]
	// [m/s]
	geschwindigkeit[OSTEN] += delta_t_s * fusionout->linear_acceleration[SENSOR_WESTEN] / 9.81f;
 8002d6a:	4b53      	ldr	r3, [pc, #332]	@ (8002eb8 <regelschritt+0x348>)
 8002d6c:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8002d70:	4b4a      	ldr	r3, [pc, #296]	@ (8002e9c <regelschritt+0x32c>)
 8002d72:	681b      	ldr	r3, [r3, #0]
 8002d74:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002d76:	4618      	mov	r0, r3
 8002d78:	f7fd fbee 	bl	8000558 <__aeabi_f2d>
 8002d7c:	4b45      	ldr	r3, [pc, #276]	@ (8002e94 <regelschritt+0x324>)
 8002d7e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002d82:	f7fd fc41 	bl	8000608 <__aeabi_dmul>
 8002d86:	4602      	mov	r2, r0
 8002d88:	460b      	mov	r3, r1
 8002d8a:	4610      	mov	r0, r2
 8002d8c:	4619      	mov	r1, r3
 8002d8e:	a338      	add	r3, pc, #224	@ (adr r3, 8002e70 <regelschritt+0x300>)
 8002d90:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002d94:	f7fd fd62 	bl	800085c <__aeabi_ddiv>
 8002d98:	4602      	mov	r2, r0
 8002d9a:	460b      	mov	r3, r1
 8002d9c:	4620      	mov	r0, r4
 8002d9e:	4629      	mov	r1, r5
 8002da0:	f7fd fa7c 	bl	800029c <__adddf3>
 8002da4:	4602      	mov	r2, r0
 8002da6:	460b      	mov	r3, r1
 8002da8:	4610      	mov	r0, r2
 8002daa:	4619      	mov	r1, r3
 8002dac:	4b42      	ldr	r3, [pc, #264]	@ (8002eb8 <regelschritt+0x348>)
 8002dae:	e9c3 0102 	strd	r0, r1, [r3, #8]
	// [m/s]
	geschwindigkeit[UNTEN] += delta_t_s * fusionout->linear_acceleration[SENSOR_OBEN] / 9.81f;
 8002db2:	4b41      	ldr	r3, [pc, #260]	@ (8002eb8 <regelschritt+0x348>)
 8002db4:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
 8002db8:	4b38      	ldr	r3, [pc, #224]	@ (8002e9c <regelschritt+0x32c>)
 8002dba:	681b      	ldr	r3, [r3, #0]
 8002dbc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002dbe:	4618      	mov	r0, r3
 8002dc0:	f7fd fbca 	bl	8000558 <__aeabi_f2d>
 8002dc4:	4b33      	ldr	r3, [pc, #204]	@ (8002e94 <regelschritt+0x324>)
 8002dc6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002dca:	f7fd fc1d 	bl	8000608 <__aeabi_dmul>
 8002dce:	4602      	mov	r2, r0
 8002dd0:	460b      	mov	r3, r1
 8002dd2:	4610      	mov	r0, r2
 8002dd4:	4619      	mov	r1, r3
 8002dd6:	a326      	add	r3, pc, #152	@ (adr r3, 8002e70 <regelschritt+0x300>)
 8002dd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002ddc:	f7fd fd3e 	bl	800085c <__aeabi_ddiv>
 8002de0:	4602      	mov	r2, r0
 8002de2:	460b      	mov	r3, r1
 8002de4:	4620      	mov	r0, r4
 8002de6:	4629      	mov	r1, r5
 8002de8:	f7fd fa58 	bl	800029c <__adddf3>
 8002dec:	4602      	mov	r2, r0
 8002dee:	460b      	mov	r3, r1
 8002df0:	4610      	mov	r0, r2
 8002df2:	4619      	mov	r1, r3
 8002df4:	4b30      	ldr	r3, [pc, #192]	@ (8002eb8 <regelschritt+0x348>)
 8002df6:	e9c3 0104 	strd	r0, r1, [r3, #16]

	drehlage.w = fusionout->quaternion[QW];
 8002dfa:	4b28      	ldr	r3, [pc, #160]	@ (8002e9c <regelschritt+0x32c>)
 8002dfc:	681b      	ldr	r3, [r3, #0]
 8002dfe:	699b      	ldr	r3, [r3, #24]
 8002e00:	4618      	mov	r0, r3
 8002e02:	f7fd fba9 	bl	8000558 <__aeabi_f2d>
 8002e06:	4602      	mov	r2, r0
 8002e08:	460b      	mov	r3, r1
 8002e0a:	492c      	ldr	r1, [pc, #176]	@ (8002ebc <regelschritt+0x34c>)
 8002e0c:	e9c1 2300 	strd	r2, r3, [r1]
	drehlage.x = fusionout->quaternion[QX];
 8002e10:	4b22      	ldr	r3, [pc, #136]	@ (8002e9c <regelschritt+0x32c>)
 8002e12:	681b      	ldr	r3, [r3, #0]
 8002e14:	68db      	ldr	r3, [r3, #12]
 8002e16:	4618      	mov	r0, r3
 8002e18:	f7fd fb9e 	bl	8000558 <__aeabi_f2d>
 8002e1c:	4602      	mov	r2, r0
 8002e1e:	460b      	mov	r3, r1
 8002e20:	4926      	ldr	r1, [pc, #152]	@ (8002ebc <regelschritt+0x34c>)
 8002e22:	e9c1 2302 	strd	r2, r3, [r1, #8]
	drehlage.y = fusionout->quaternion[QY];
 8002e26:	4b1d      	ldr	r3, [pc, #116]	@ (8002e9c <regelschritt+0x32c>)
 8002e28:	681b      	ldr	r3, [r3, #0]
 8002e2a:	691b      	ldr	r3, [r3, #16]
 8002e2c:	4618      	mov	r0, r3
 8002e2e:	f7fd fb93 	bl	8000558 <__aeabi_f2d>
 8002e32:	4602      	mov	r2, r0
 8002e34:	460b      	mov	r3, r1
 8002e36:	4921      	ldr	r1, [pc, #132]	@ (8002ebc <regelschritt+0x34c>)
 8002e38:	e9c1 2304 	strd	r2, r3, [r1, #16]
	drehlage.z = fusionout->quaternion[QZ];
 8002e3c:	4b17      	ldr	r3, [pc, #92]	@ (8002e9c <regelschritt+0x32c>)
 8002e3e:	681b      	ldr	r3, [r3, #0]
 8002e40:	695b      	ldr	r3, [r3, #20]
 8002e42:	4618      	mov	r0, r3
 8002e44:	f7fd fb88 	bl	8000558 <__aeabi_f2d>
 8002e48:	4602      	mov	r2, r0
 8002e4a:	460b      	mov	r3, r1
 8002e4c:	491b      	ldr	r1, [pc, #108]	@ (8002ebc <regelschritt+0x34c>)
 8002e4e:	e9c1 2306 	strd	r2, r3, [r1, #24]
//			0.0f * fusionout->rotation[0] * 3.14f / 180.0f,
//			-fusionout->rotation[1] * 3.14f / 180.0f,
//			fusionout->rotation[2] * 3.14f / 180.0f
//	);

	if (drehlage.x != drehlage.x) {
 8002e52:	4b1a      	ldr	r3, [pc, #104]	@ (8002ebc <regelschritt+0x34c>)
 8002e54:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8002e58:	4b18      	ldr	r3, [pc, #96]	@ (8002ebc <regelschritt+0x34c>)
 8002e5a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8002e5e:	f7fd fe3b 	bl	8000ad8 <__aeabi_dcmpeq>
 8002e62:	4603      	mov	r3, r0
 8002e64:	2b00      	cmp	r3, #0
 8002e66:	d12b      	bne.n	8002ec0 <regelschritt+0x350>
		LED_Off();
 8002e68:	f002 fcca 	bl	8005800 <LED_Off>
 8002e6c:	e02c      	b.n	8002ec8 <regelschritt+0x358>
 8002e6e:	bf00      	nop
 8002e70:	60000000 	.word	0x60000000
 8002e74:	40239eb8 	.word	0x40239eb8
 8002e78:	20001c4c 	.word	0x20001c4c
 8002e7c:	3a83126f 	.word	0x3a83126f
 8002e80:	20001c94 	.word	0x20001c94
 8002e84:	20001c40 	.word	0x20001c40
 8002e88:	20001c58 	.word	0x20001c58
 8002e8c:	3b03126f 	.word	0x3b03126f
 8002e90:	358637bd 	.word	0x358637bd
 8002e94:	20001e98 	.word	0x20001e98
 8002e98:	20000014 	.word	0x20000014
 8002e9c:	20000018 	.word	0x20000018
 8002ea0:	3c23d70a 	.word	0x3c23d70a
 8002ea4:	20001c68 	.word	0x20001c68
 8002ea8:	42480000 	.word	0x42480000
 8002eac:	20001e28 	.word	0x20001e28
 8002eb0:	20001c6c 	.word	0x20001c6c
 8002eb4:	20001c64 	.word	0x20001c64
 8002eb8:	20001d10 	.word	0x20001d10
 8002ebc:	20001d28 	.word	0x20001d28
	} else {
		LL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN);
 8002ec0:	2120      	movs	r1, #32
 8002ec2:	48a9      	ldr	r0, [pc, #676]	@ (8003168 <regelschritt+0x5f8>)
 8002ec4:	f7fe fc77 	bl	80017b6 <LL_GPIO_TogglePin>
	}

	// Controller
	// Rollwinkel [deg/s]
	drehrate.rollen = (fusionout->rotation[2] - drehlage_tminus1.rollen) / delta_t_s;
 8002ec8:	4ba8      	ldr	r3, [pc, #672]	@ (800316c <regelschritt+0x5fc>)
 8002eca:	681b      	ldr	r3, [r3, #0]
 8002ecc:	689b      	ldr	r3, [r3, #8]
 8002ece:	4618      	mov	r0, r3
 8002ed0:	f7fd fb42 	bl	8000558 <__aeabi_f2d>
 8002ed4:	4ba6      	ldr	r3, [pc, #664]	@ (8003170 <regelschritt+0x600>)
 8002ed6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002eda:	f7fd f9dd 	bl	8000298 <__aeabi_dsub>
 8002ede:	4602      	mov	r2, r0
 8002ee0:	460b      	mov	r3, r1
 8002ee2:	4610      	mov	r0, r2
 8002ee4:	4619      	mov	r1, r3
 8002ee6:	4ba3      	ldr	r3, [pc, #652]	@ (8003174 <regelschritt+0x604>)
 8002ee8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002eec:	f7fd fcb6 	bl	800085c <__aeabi_ddiv>
 8002ef0:	4602      	mov	r2, r0
 8002ef2:	460b      	mov	r3, r1
 8002ef4:	4610      	mov	r0, r2
 8002ef6:	4619      	mov	r1, r3
 8002ef8:	4b9f      	ldr	r3, [pc, #636]	@ (8003178 <regelschritt+0x608>)
 8002efa:	e9c3 0100 	strd	r0, r1, [r3]
	// Nickwinkel [deg/s]
	drehrate.nicken = (fusionout->rotation[1] - drehlage_tminus1.nicken) / delta_t_s;
 8002efe:	4b9b      	ldr	r3, [pc, #620]	@ (800316c <regelschritt+0x5fc>)
 8002f00:	681b      	ldr	r3, [r3, #0]
 8002f02:	685b      	ldr	r3, [r3, #4]
 8002f04:	4618      	mov	r0, r3
 8002f06:	f7fd fb27 	bl	8000558 <__aeabi_f2d>
 8002f0a:	4b99      	ldr	r3, [pc, #612]	@ (8003170 <regelschritt+0x600>)
 8002f0c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8002f10:	f7fd f9c2 	bl	8000298 <__aeabi_dsub>
 8002f14:	4602      	mov	r2, r0
 8002f16:	460b      	mov	r3, r1
 8002f18:	4610      	mov	r0, r2
 8002f1a:	4619      	mov	r1, r3
 8002f1c:	4b95      	ldr	r3, [pc, #596]	@ (8003174 <regelschritt+0x604>)
 8002f1e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002f22:	f7fd fc9b 	bl	800085c <__aeabi_ddiv>
 8002f26:	4602      	mov	r2, r0
 8002f28:	460b      	mov	r3, r1
 8002f2a:	4610      	mov	r0, r2
 8002f2c:	4619      	mov	r1, r3
 8002f2e:	4b92      	ldr	r3, [pc, #584]	@ (8003178 <regelschritt+0x608>)
 8002f30:	e9c3 0102 	strd	r0, r1, [r3, #8]
	// Gierwinkel [deg/s]
	drehrate.gieren = 0.0f * data_in.gyro[0];
 8002f34:	4b91      	ldr	r3, [pc, #580]	@ (800317c <regelschritt+0x60c>)
 8002f36:	edd3 7a06 	vldr	s15, [r3, #24]
 8002f3a:	ed9f 7a91 	vldr	s14, [pc, #580]	@ 8003180 <regelschritt+0x610>
 8002f3e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002f42:	ee17 0a90 	vmov	r0, s15
 8002f46:	f7fd fb07 	bl	8000558 <__aeabi_f2d>
 8002f4a:	4602      	mov	r2, r0
 8002f4c:	460b      	mov	r3, r1
 8002f4e:	498a      	ldr	r1, [pc, #552]	@ (8003178 <regelschritt+0x608>)
 8002f50:	e9c1 2304 	strd	r2, r3, [r1, #16]

	drehlage_tminus1.rollen = fusionout->rotation[2];
 8002f54:	4b85      	ldr	r3, [pc, #532]	@ (800316c <regelschritt+0x5fc>)
 8002f56:	681b      	ldr	r3, [r3, #0]
 8002f58:	689b      	ldr	r3, [r3, #8]
 8002f5a:	4618      	mov	r0, r3
 8002f5c:	f7fd fafc 	bl	8000558 <__aeabi_f2d>
 8002f60:	4602      	mov	r2, r0
 8002f62:	460b      	mov	r3, r1
 8002f64:	4982      	ldr	r1, [pc, #520]	@ (8003170 <regelschritt+0x600>)
 8002f66:	e9c1 2300 	strd	r2, r3, [r1]
	drehlage_tminus1.nicken = fusionout->rotation[1];
 8002f6a:	4b80      	ldr	r3, [pc, #512]	@ (800316c <regelschritt+0x5fc>)
 8002f6c:	681b      	ldr	r3, [r3, #0]
 8002f6e:	685b      	ldr	r3, [r3, #4]
 8002f70:	4618      	mov	r0, r3
 8002f72:	f7fd faf1 	bl	8000558 <__aeabi_f2d>
 8002f76:	4602      	mov	r2, r0
 8002f78:	460b      	mov	r3, r1
 8002f7a:	497d      	ldr	r1, [pc, #500]	@ (8003170 <regelschritt+0x600>)
 8002f7c:	e9c1 2302 	strd	r2, r3, [r1, #8]

	omega_dot.rollen = 0.0f; // (drehrate.rollen - drehgeschwindigkeit_tminus1.rollen) / delta_t_s;
 8002f80:	4980      	ldr	r1, [pc, #512]	@ (8003184 <regelschritt+0x614>)
 8002f82:	f04f 0200 	mov.w	r2, #0
 8002f86:	f04f 0300 	mov.w	r3, #0
 8002f8a:	e9c1 2300 	strd	r2, r3, [r1]
	omega_dot.nicken = 0.0f; // (drehrate.nicken - drehgeschwindigkeit_tminus1.nicken) / delta_t_s;
 8002f8e:	497d      	ldr	r1, [pc, #500]	@ (8003184 <regelschritt+0x614>)
 8002f90:	f04f 0200 	mov.w	r2, #0
 8002f94:	f04f 0300 	mov.w	r3, #0
 8002f98:	e9c1 2302 	strd	r2, r3, [r1, #8]
	omega_dot.gieren = 0.0f;
 8002f9c:	4979      	ldr	r1, [pc, #484]	@ (8003184 <regelschritt+0x614>)
 8002f9e:	f04f 0200 	mov.w	r2, #0
 8002fa2:	f04f 0300 	mov.w	r3, #0
 8002fa6:	e9c1 2304 	strd	r2, r3, [r1, #16]

	drehgeschwindigkeit_tminus1.rollen = drehrate.rollen;
 8002faa:	4b73      	ldr	r3, [pc, #460]	@ (8003178 <regelschritt+0x608>)
 8002fac:	e9d3 2300 	ldrd	r2, r3, [r3]
 8002fb0:	4975      	ldr	r1, [pc, #468]	@ (8003188 <regelschritt+0x618>)
 8002fb2:	e9c1 2300 	strd	r2, r3, [r1]
	drehgeschwindigkeit_tminus1.nicken = drehrate.nicken;
 8002fb6:	4b70      	ldr	r3, [pc, #448]	@ (8003178 <regelschritt+0x608>)
 8002fb8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8002fbc:	4972      	ldr	r1, [pc, #456]	@ (8003188 <regelschritt+0x618>)
 8002fbe:	e9c1 2302 	strd	r2, r3, [r1, #8]


	// Geschwindigkeitsregler

	// m/s
	geschwindigkeitsfehler[UNTEN] = 0.0f; // sollgeschwindigkeit.unten - geschwindigkeit[UNTEN];
 8002fc2:	4972      	ldr	r1, [pc, #456]	@ (800318c <regelschritt+0x61c>)
 8002fc4:	f04f 0200 	mov.w	r2, #0
 8002fc8:	f04f 0300 	mov.w	r3, #0
 8002fcc:	e9c1 2304 	strd	r2, r3, [r1, #16]

	sollschub[UNTEN] = vel_p_gain[UNTEN] * geschwindigkeitsfehler[UNTEN] - vel_d_gain[UNTEN] * beschleunigung[UNTEN] + masse * (acc_setpoint[UNTEN] - gravitation_constant) + thr_int[UNTEN];
 8002fd0:	4b6f      	ldr	r3, [pc, #444]	@ (8003190 <regelschritt+0x620>)
 8002fd2:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8002fd6:	4b6d      	ldr	r3, [pc, #436]	@ (800318c <regelschritt+0x61c>)
 8002fd8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8002fdc:	f7fd fb14 	bl	8000608 <__aeabi_dmul>
 8002fe0:	4602      	mov	r2, r0
 8002fe2:	460b      	mov	r3, r1
 8002fe4:	4614      	mov	r4, r2
 8002fe6:	461d      	mov	r5, r3
 8002fe8:	4b6a      	ldr	r3, [pc, #424]	@ (8003194 <regelschritt+0x624>)
 8002fea:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8002fee:	4b6a      	ldr	r3, [pc, #424]	@ (8003198 <regelschritt+0x628>)
 8002ff0:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8002ff4:	f7fd fb08 	bl	8000608 <__aeabi_dmul>
 8002ff8:	4602      	mov	r2, r0
 8002ffa:	460b      	mov	r3, r1
 8002ffc:	4620      	mov	r0, r4
 8002ffe:	4629      	mov	r1, r5
 8003000:	f7fd f94a 	bl	8000298 <__aeabi_dsub>
 8003004:	4602      	mov	r2, r0
 8003006:	460b      	mov	r3, r1
 8003008:	4614      	mov	r4, r2
 800300a:	461d      	mov	r5, r3
 800300c:	4b63      	ldr	r3, [pc, #396]	@ (800319c <regelschritt+0x62c>)
 800300e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8003012:	4b63      	ldr	r3, [pc, #396]	@ (80031a0 <regelschritt+0x630>)
 8003014:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003018:	f7fd f93e 	bl	8000298 <__aeabi_dsub>
 800301c:	4602      	mov	r2, r0
 800301e:	460b      	mov	r3, r1
 8003020:	4610      	mov	r0, r2
 8003022:	4619      	mov	r1, r3
 8003024:	4b5f      	ldr	r3, [pc, #380]	@ (80031a4 <regelschritt+0x634>)
 8003026:	e9d3 2300 	ldrd	r2, r3, [r3]
 800302a:	f7fd faed 	bl	8000608 <__aeabi_dmul>
 800302e:	4602      	mov	r2, r0
 8003030:	460b      	mov	r3, r1
 8003032:	4620      	mov	r0, r4
 8003034:	4629      	mov	r1, r5
 8003036:	f7fd f931 	bl	800029c <__adddf3>
 800303a:	4602      	mov	r2, r0
 800303c:	460b      	mov	r3, r1
 800303e:	4610      	mov	r0, r2
 8003040:	4619      	mov	r1, r3
 8003042:	4b59      	ldr	r3, [pc, #356]	@ (80031a8 <regelschritt+0x638>)
 8003044:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003048:	f7fd f928 	bl	800029c <__adddf3>
 800304c:	4602      	mov	r2, r0
 800304e:	460b      	mov	r3, r1
 8003050:	4610      	mov	r0, r2
 8003052:	4619      	mov	r1, r3
 8003054:	4b55      	ldr	r3, [pc, #340]	@ (80031ac <regelschritt+0x63c>)
 8003056:	e9c3 0104 	strd	r0, r1, [r3, #16]

	double uMax = -0.4;
 800305a:	a341      	add	r3, pc, #260	@ (adr r3, 8003160 <regelschritt+0x5f0>)
 800305c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003060:	e9c7 2384 	strd	r2, r3, [r7, #528]	@ 0x210
	double uMin = -16 * gravitation_constant;
 8003064:	4b4e      	ldr	r3, [pc, #312]	@ (80031a0 <regelschritt+0x630>)
 8003066:	e9d3 0100 	ldrd	r0, r1, [r3]
 800306a:	f04f 0200 	mov.w	r2, #0
 800306e:	4b50      	ldr	r3, [pc, #320]	@ (80031b0 <regelschritt+0x640>)
 8003070:	f7fd faca 	bl	8000608 <__aeabi_dmul>
 8003074:	4602      	mov	r2, r0
 8003076:	460b      	mov	r3, r1
 8003078:	e9c7 2382 	strd	r2, r3, [r7, #520]	@ 0x208

	// sollschub[2] = thrust_z;
	if (sollschub[UNTEN] < uMin) {
 800307c:	4b4b      	ldr	r3, [pc, #300]	@ (80031ac <regelschritt+0x63c>)
 800307e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003082:	e9d7 0182 	ldrd	r0, r1, [r7, #520]	@ 0x208
 8003086:	f7fd fd4f 	bl	8000b28 <__aeabi_dcmpgt>
 800308a:	4603      	mov	r3, r0
 800308c:	2b00      	cmp	r3, #0
 800308e:	d004      	beq.n	800309a <regelschritt+0x52a>
		sollschub[UNTEN] = uMin;
 8003090:	4946      	ldr	r1, [pc, #280]	@ (80031ac <regelschritt+0x63c>)
 8003092:	e9d7 2382 	ldrd	r2, r3, [r7, #520]	@ 0x208
 8003096:	e9c1 2304 	strd	r2, r3, [r1, #16]
	}
	if (sollschub[UNTEN] > uMax) {
 800309a:	4b44      	ldr	r3, [pc, #272]	@ (80031ac <regelschritt+0x63c>)
 800309c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80030a0:	e9d7 0184 	ldrd	r0, r1, [r7, #528]	@ 0x210
 80030a4:	f7fd fd22 	bl	8000aec <__aeabi_dcmplt>
 80030a8:	4603      	mov	r3, r0
 80030aa:	2b00      	cmp	r3, #0
 80030ac:	d004      	beq.n	80030b8 <regelschritt+0x548>
		sollschub[UNTEN] = uMax;
 80030ae:	493f      	ldr	r1, [pc, #252]	@ (80031ac <regelschritt+0x63c>)
 80030b0:	e9d7 2384 	ldrd	r2, r3, [r7, #528]	@ 0x210
 80030b4:	e9c1 2304 	strd	r2, r3, [r1, #16]
	}

	// XY Velocity Control (Thrust in NE-direction)
	geschwindigkeitsfehler[NORDEN] = sollgeschwindigkeit.norden - geschwindigkeit[NORDEN];
 80030b8:	4b3e      	ldr	r3, [pc, #248]	@ (80031b4 <regelschritt+0x644>)
 80030ba:	e9d3 0100 	ldrd	r0, r1, [r3]
 80030be:	4b3e      	ldr	r3, [pc, #248]	@ (80031b8 <regelschritt+0x648>)
 80030c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80030c4:	f7fd f8e8 	bl	8000298 <__aeabi_dsub>
 80030c8:	4602      	mov	r2, r0
 80030ca:	460b      	mov	r3, r1
 80030cc:	4610      	mov	r0, r2
 80030ce:	4619      	mov	r1, r3
 80030d0:	4b2e      	ldr	r3, [pc, #184]	@ (800318c <regelschritt+0x61c>)
 80030d2:	e9c3 0100 	strd	r0, r1, [r3]
	geschwindigkeitsfehler[OSTEN] = sollgeschwindigkeit.osten - geschwindigkeit[OSTEN];
 80030d6:	4b37      	ldr	r3, [pc, #220]	@ (80031b4 <regelschritt+0x644>)
 80030d8:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80030dc:	4b36      	ldr	r3, [pc, #216]	@ (80031b8 <regelschritt+0x648>)
 80030de:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80030e2:	f7fd f8d9 	bl	8000298 <__aeabi_dsub>
 80030e6:	4602      	mov	r2, r0
 80030e8:	460b      	mov	r3, r1
 80030ea:	4610      	mov	r0, r2
 80030ec:	4619      	mov	r1, r3
 80030ee:	4b27      	ldr	r3, [pc, #156]	@ (800318c <regelschritt+0x61c>)
 80030f0:	e9c3 0102 	strd	r0, r1, [r3, #8]
	sollschub[X] = (
		vel_p_gain[NORDEN] * geschwindigkeitsfehler[NORDEN] -
 80030f4:	4b26      	ldr	r3, [pc, #152]	@ (8003190 <regelschritt+0x620>)
 80030f6:	e9d3 0100 	ldrd	r0, r1, [r3]
 80030fa:	4b24      	ldr	r3, [pc, #144]	@ (800318c <regelschritt+0x61c>)
 80030fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003100:	f7fd fa82 	bl	8000608 <__aeabi_dmul>
 8003104:	4602      	mov	r2, r0
 8003106:	460b      	mov	r3, r1
 8003108:	4614      	mov	r4, r2
 800310a:	461d      	mov	r5, r3
		vel_d_gain[NORDEN] *  beschleunigung[NORDEN] +
 800310c:	4b21      	ldr	r3, [pc, #132]	@ (8003194 <regelschritt+0x624>)
 800310e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003112:	4b21      	ldr	r3, [pc, #132]	@ (8003198 <regelschritt+0x628>)
 8003114:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003118:	f7fd fa76 	bl	8000608 <__aeabi_dmul>
 800311c:	4602      	mov	r2, r0
 800311e:	460b      	mov	r3, r1
		vel_p_gain[NORDEN] * geschwindigkeitsfehler[NORDEN] -
 8003120:	4620      	mov	r0, r4
 8003122:	4629      	mov	r1, r5
 8003124:	f7fd f8b8 	bl	8000298 <__aeabi_dsub>
 8003128:	4602      	mov	r2, r0
 800312a:	460b      	mov	r3, r1
 800312c:	4614      	mov	r4, r2
 800312e:	461d      	mov	r5, r3
		masse * acc_setpoint[NORDEN] +
 8003130:	4b1a      	ldr	r3, [pc, #104]	@ (800319c <regelschritt+0x62c>)
 8003132:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003136:	4b1b      	ldr	r3, [pc, #108]	@ (80031a4 <regelschritt+0x634>)
 8003138:	e9d3 2300 	ldrd	r2, r3, [r3]
 800313c:	f7fd fa64 	bl	8000608 <__aeabi_dmul>
 8003140:	4602      	mov	r2, r0
 8003142:	460b      	mov	r3, r1
		vel_d_gain[NORDEN] *  beschleunigung[NORDEN] +
 8003144:	4620      	mov	r0, r4
 8003146:	4629      	mov	r1, r5
 8003148:	f7fd f8a8 	bl	800029c <__adddf3>
 800314c:	4602      	mov	r2, r0
 800314e:	460b      	mov	r3, r1
 8003150:	4610      	mov	r0, r2
 8003152:	4619      	mov	r1, r3
		thr_int[NORDEN]
 8003154:	4b14      	ldr	r3, [pc, #80]	@ (80031a8 <regelschritt+0x638>)
 8003156:	e9d3 2300 	ldrd	r2, r3, [r3]
		masse * acc_setpoint[NORDEN] +
 800315a:	f7fd f89f 	bl	800029c <__adddf3>
 800315e:	e02d      	b.n	80031bc <regelschritt+0x64c>
 8003160:	9999999a 	.word	0x9999999a
 8003164:	bfd99999 	.word	0xbfd99999
 8003168:	40020000 	.word	0x40020000
 800316c:	20000018 	.word	0x20000018
 8003170:	20001ea0 	.word	0x20001ea0
 8003174:	20001e98 	.word	0x20001e98
 8003178:	20001eb8 	.word	0x20001eb8
 800317c:	20001c94 	.word	0x20001c94
 8003180:	00000000 	.word	0x00000000
 8003184:	20001ee8 	.word	0x20001ee8
 8003188:	20001ed0 	.word	0x20001ed0
 800318c:	20001fb8 	.word	0x20001fb8
 8003190:	200000b0 	.word	0x200000b0
 8003194:	200000c8 	.word	0x200000c8
 8003198:	20001cf8 	.word	0x20001cf8
 800319c:	20001e80 	.word	0x20001e80
 80031a0:	20000020 	.word	0x20000020
 80031a4:	20000028 	.word	0x20000028
 80031a8:	20001df0 	.word	0x20001df0
 80031ac:	20001e48 	.word	0x20001e48
 80031b0:	c0300000 	.word	0xc0300000
 80031b4:	20001e28 	.word	0x20001e28
 80031b8:	20001d10 	.word	0x20001d10
 80031bc:	4602      	mov	r2, r0
 80031be:	460b      	mov	r3, r1
 80031c0:	4610      	mov	r0, r2
 80031c2:	4619      	mov	r1, r3
	sollschub[X] = (
 80031c4:	4bc0      	ldr	r3, [pc, #768]	@ (80034c8 <regelschritt+0x958>)
 80031c6:	e9c3 0100 	strd	r0, r1, [r3]
	);
	sollschub[Y] = (
		vel_p_gain[OSTEN] * geschwindigkeitsfehler[OSTEN] -
 80031ca:	4bc0      	ldr	r3, [pc, #768]	@ (80034cc <regelschritt+0x95c>)
 80031cc:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80031d0:	4bbf      	ldr	r3, [pc, #764]	@ (80034d0 <regelschritt+0x960>)
 80031d2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80031d6:	f7fd fa17 	bl	8000608 <__aeabi_dmul>
 80031da:	4602      	mov	r2, r0
 80031dc:	460b      	mov	r3, r1
 80031de:	4614      	mov	r4, r2
 80031e0:	461d      	mov	r5, r3
		vel_d_gain[OSTEN] *  beschleunigung[OSTEN] +
 80031e2:	4bbc      	ldr	r3, [pc, #752]	@ (80034d4 <regelschritt+0x964>)
 80031e4:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80031e8:	4bbb      	ldr	r3, [pc, #748]	@ (80034d8 <regelschritt+0x968>)
 80031ea:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80031ee:	f7fd fa0b 	bl	8000608 <__aeabi_dmul>
 80031f2:	4602      	mov	r2, r0
 80031f4:	460b      	mov	r3, r1
		vel_p_gain[OSTEN] * geschwindigkeitsfehler[OSTEN] -
 80031f6:	4620      	mov	r0, r4
 80031f8:	4629      	mov	r1, r5
 80031fa:	f7fd f84d 	bl	8000298 <__aeabi_dsub>
 80031fe:	4602      	mov	r2, r0
 8003200:	460b      	mov	r3, r1
 8003202:	4614      	mov	r4, r2
 8003204:	461d      	mov	r5, r3
		masse * acc_setpoint[OSTEN] +
 8003206:	4bb5      	ldr	r3, [pc, #724]	@ (80034dc <regelschritt+0x96c>)
 8003208:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800320c:	4bb4      	ldr	r3, [pc, #720]	@ (80034e0 <regelschritt+0x970>)
 800320e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003212:	f7fd f9f9 	bl	8000608 <__aeabi_dmul>
 8003216:	4602      	mov	r2, r0
 8003218:	460b      	mov	r3, r1
		vel_d_gain[OSTEN] *  beschleunigung[OSTEN] +
 800321a:	4620      	mov	r0, r4
 800321c:	4629      	mov	r1, r5
 800321e:	f7fd f83d 	bl	800029c <__adddf3>
 8003222:	4602      	mov	r2, r0
 8003224:	460b      	mov	r3, r1
 8003226:	4610      	mov	r0, r2
 8003228:	4619      	mov	r1, r3
		thr_int[OSTEN]
 800322a:	4bae      	ldr	r3, [pc, #696]	@ (80034e4 <regelschritt+0x974>)
 800322c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
		masse * acc_setpoint[OSTEN] +
 8003230:	f7fd f834 	bl	800029c <__adddf3>
 8003234:	4602      	mov	r2, r0
 8003236:	460b      	mov	r3, r1
 8003238:	4610      	mov	r0, r2
 800323a:	4619      	mov	r1, r3
	sollschub[Y] = (
 800323c:	4ba2      	ldr	r3, [pc, #648]	@ (80034c8 <regelschritt+0x958>)
 800323e:	e9c3 0102 	strd	r0, r1, [r3, #8]
	);

	double thrust_max_xy_tilt = (
		abs(sollschub[UNTEN]) * tan(tiltMax)
 8003242:	4ba1      	ldr	r3, [pc, #644]	@ (80034c8 <regelschritt+0x958>)
 8003244:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003248:	4610      	mov	r0, r2
 800324a:	4619      	mov	r1, r3
 800324c:	f7fd fc8c 	bl	8000b68 <__aeabi_d2iz>
 8003250:	4603      	mov	r3, r0
 8003252:	2b00      	cmp	r3, #0
 8003254:	bfb8      	it	lt
 8003256:	425b      	neglt	r3, r3
 8003258:	4618      	mov	r0, r3
 800325a:	f7fd f96b 	bl	8000534 <__aeabi_i2d>
 800325e:	4604      	mov	r4, r0
 8003260:	460d      	mov	r5, r1
 8003262:	4ba1      	ldr	r3, [pc, #644]	@ (80034e8 <regelschritt+0x978>)
 8003264:	ed93 7b00 	vldr	d7, [r3]
 8003268:	eeb0 0a47 	vmov.f32	s0, s14
 800326c:	eef0 0a67 	vmov.f32	s1, s15
 8003270:	f01c fac2 	bl	801f7f8 <tan>
 8003274:	ec53 2b10 	vmov	r2, r3, d0
	double thrust_max_xy_tilt = (
 8003278:	4620      	mov	r0, r4
 800327a:	4629      	mov	r1, r5
 800327c:	f7fd f9c4 	bl	8000608 <__aeabi_dmul>
 8003280:	4602      	mov	r2, r0
 8003282:	460b      	mov	r3, r1
 8003284:	e9c7 2380 	strd	r2, r3, [r7, #512]	@ 0x200
	);
	double thrust_max_xy = sqrt(
		pow(maxThr, 2) -
 8003288:	4b98      	ldr	r3, [pc, #608]	@ (80034ec <regelschritt+0x97c>)
 800328a:	ed93 7b00 	vldr	d7, [r3]
 800328e:	ed9f 1b8c 	vldr	d1, [pc, #560]	@ 80034c0 <regelschritt+0x950>
 8003292:	eeb0 0a47 	vmov.f32	s0, s14
 8003296:	eef0 0a67 	vmov.f32	s1, s15
 800329a:	f01c f961 	bl	801f560 <pow>
 800329e:	ec55 4b10 	vmov	r4, r5, d0
		pow(sollschub[UNTEN], 2)
 80032a2:	4b89      	ldr	r3, [pc, #548]	@ (80034c8 <regelschritt+0x958>)
 80032a4:	ed93 7b04 	vldr	d7, [r3, #16]
 80032a8:	ed9f 1b85 	vldr	d1, [pc, #532]	@ 80034c0 <regelschritt+0x950>
 80032ac:	eeb0 0a47 	vmov.f32	s0, s14
 80032b0:	eef0 0a67 	vmov.f32	s1, s15
 80032b4:	f01c f954 	bl	801f560 <pow>
 80032b8:	ec53 2b10 	vmov	r2, r3, d0
	double thrust_max_xy = sqrt(
 80032bc:	4620      	mov	r0, r4
 80032be:	4629      	mov	r1, r5
 80032c0:	f7fc ffea 	bl	8000298 <__aeabi_dsub>
 80032c4:	4602      	mov	r2, r0
 80032c6:	460b      	mov	r3, r1
 80032c8:	ec43 2b17 	vmov	d7, r2, r3
 80032cc:	eeb0 0a47 	vmov.f32	s0, s14
 80032d0:	eef0 0a67 	vmov.f32	s1, s15
 80032d4:	f01c f9b4 	bl	801f640 <sqrt>
 80032d8:	ed87 0b90 	vstr	d0, [r7, #576]	@ 0x240
	);

	if (thrust_max_xy > thrust_max_xy_tilt) {
 80032dc:	e9d7 2380 	ldrd	r2, r3, [r7, #512]	@ 0x200
 80032e0:	e9d7 0190 	ldrd	r0, r1, [r7, #576]	@ 0x240
 80032e4:	f7fd fc20 	bl	8000b28 <__aeabi_dcmpgt>
 80032e8:	4603      	mov	r3, r0
 80032ea:	2b00      	cmp	r3, #0
 80032ec:	d003      	beq.n	80032f6 <regelschritt+0x786>
		thrust_max_xy = thrust_max_xy_tilt;
 80032ee:	e9d7 2380 	ldrd	r2, r3, [r7, #512]	@ 0x200
 80032f2:	e9c7 2390 	strd	r2, r3, [r7, #576]	@ 0x240
	}

	if (
		sollschub[NORDEN] * sollschub[NORDEN] + sollschub[OSTEN] * sollschub[OSTEN] >
 80032f6:	4b74      	ldr	r3, [pc, #464]	@ (80034c8 <regelschritt+0x958>)
 80032f8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80032fc:	4b72      	ldr	r3, [pc, #456]	@ (80034c8 <regelschritt+0x958>)
 80032fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003302:	f7fd f981 	bl	8000608 <__aeabi_dmul>
 8003306:	4602      	mov	r2, r0
 8003308:	460b      	mov	r3, r1
 800330a:	4614      	mov	r4, r2
 800330c:	461d      	mov	r5, r3
 800330e:	4b6e      	ldr	r3, [pc, #440]	@ (80034c8 <regelschritt+0x958>)
 8003310:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8003314:	4b6c      	ldr	r3, [pc, #432]	@ (80034c8 <regelschritt+0x958>)
 8003316:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800331a:	f7fd f975 	bl	8000608 <__aeabi_dmul>
 800331e:	4602      	mov	r2, r0
 8003320:	460b      	mov	r3, r1
 8003322:	4620      	mov	r0, r4
 8003324:	4629      	mov	r1, r5
 8003326:	f7fc ffb9 	bl	800029c <__adddf3>
 800332a:	4602      	mov	r2, r0
 800332c:	460b      	mov	r3, r1
 800332e:	4614      	mov	r4, r2
 8003330:	461d      	mov	r5, r3
		pow(thrust_max_xy, 2)) {
 8003332:	ed9f 1b63 	vldr	d1, [pc, #396]	@ 80034c0 <regelschritt+0x950>
 8003336:	ed97 0b90 	vldr	d0, [r7, #576]	@ 0x240
 800333a:	f01c f911 	bl	801f560 <pow>
 800333e:	ec53 2b10 	vmov	r2, r3, d0
	if (
 8003342:	4620      	mov	r0, r4
 8003344:	4629      	mov	r1, r5
 8003346:	f7fd fbef 	bl	8000b28 <__aeabi_dcmpgt>
 800334a:	4603      	mov	r3, r0
 800334c:	2b00      	cmp	r3, #0
 800334e:	d055      	beq.n	80033fc <regelschritt+0x88c>

		double mag = sqrt(
			pow(sollschub[NORDEN], 2) +
 8003350:	4b5d      	ldr	r3, [pc, #372]	@ (80034c8 <regelschritt+0x958>)
 8003352:	ed93 7b00 	vldr	d7, [r3]
 8003356:	ed9f 1b5a 	vldr	d1, [pc, #360]	@ 80034c0 <regelschritt+0x950>
 800335a:	eeb0 0a47 	vmov.f32	s0, s14
 800335e:	eef0 0a67 	vmov.f32	s1, s15
 8003362:	f01c f8fd 	bl	801f560 <pow>
 8003366:	ec55 4b10 	vmov	r4, r5, d0
			pow(sollschub[OSTEN], 2)
 800336a:	4b57      	ldr	r3, [pc, #348]	@ (80034c8 <regelschritt+0x958>)
 800336c:	ed93 7b02 	vldr	d7, [r3, #8]
 8003370:	ed9f 1b53 	vldr	d1, [pc, #332]	@ 80034c0 <regelschritt+0x950>
 8003374:	eeb0 0a47 	vmov.f32	s0, s14
 8003378:	eef0 0a67 	vmov.f32	s1, s15
 800337c:	f01c f8f0 	bl	801f560 <pow>
 8003380:	ec53 2b10 	vmov	r2, r3, d0
		double mag = sqrt(
 8003384:	4620      	mov	r0, r4
 8003386:	4629      	mov	r1, r5
 8003388:	f7fc ff88 	bl	800029c <__adddf3>
 800338c:	4602      	mov	r2, r0
 800338e:	460b      	mov	r3, r1
 8003390:	ec43 2b17 	vmov	d7, r2, r3
 8003394:	eeb0 0a47 	vmov.f32	s0, s14
 8003398:	eef0 0a67 	vmov.f32	s1, s15
 800339c:	f01c f950 	bl	801f640 <sqrt>
 80033a0:	ed87 0b7e 	vstr	d0, [r7, #504]	@ 0x1f8
		);

		sollschub[NORDEN] = (
			sollschub[NORDEN] * thrust_max_xy / mag
 80033a4:	4b48      	ldr	r3, [pc, #288]	@ (80034c8 <regelschritt+0x958>)
 80033a6:	e9d3 0100 	ldrd	r0, r1, [r3]
 80033aa:	e9d7 2390 	ldrd	r2, r3, [r7, #576]	@ 0x240
 80033ae:	f7fd f92b 	bl	8000608 <__aeabi_dmul>
 80033b2:	4602      	mov	r2, r0
 80033b4:	460b      	mov	r3, r1
 80033b6:	4610      	mov	r0, r2
 80033b8:	4619      	mov	r1, r3
 80033ba:	e9d7 237e 	ldrd	r2, r3, [r7, #504]	@ 0x1f8
 80033be:	f7fd fa4d 	bl	800085c <__aeabi_ddiv>
 80033c2:	4602      	mov	r2, r0
 80033c4:	460b      	mov	r3, r1
 80033c6:	4610      	mov	r0, r2
 80033c8:	4619      	mov	r1, r3
		sollschub[NORDEN] = (
 80033ca:	4b3f      	ldr	r3, [pc, #252]	@ (80034c8 <regelschritt+0x958>)
 80033cc:	e9c3 0100 	strd	r0, r1, [r3]
		);
		sollschub[OSTEN] = (
			sollschub[OSTEN] * thrust_max_xy / mag
 80033d0:	4b3d      	ldr	r3, [pc, #244]	@ (80034c8 <regelschritt+0x958>)
 80033d2:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80033d6:	e9d7 2390 	ldrd	r2, r3, [r7, #576]	@ 0x240
 80033da:	f7fd f915 	bl	8000608 <__aeabi_dmul>
 80033de:	4602      	mov	r2, r0
 80033e0:	460b      	mov	r3, r1
 80033e2:	4610      	mov	r0, r2
 80033e4:	4619      	mov	r1, r3
 80033e6:	e9d7 237e 	ldrd	r2, r3, [r7, #504]	@ 0x1f8
 80033ea:	f7fd fa37 	bl	800085c <__aeabi_ddiv>
 80033ee:	4602      	mov	r2, r0
 80033f0:	460b      	mov	r3, r1
 80033f2:	4610      	mov	r0, r2
 80033f4:	4619      	mov	r1, r3
		sollschub[OSTEN] = (
 80033f6:	4b34      	ldr	r3, [pc, #208]	@ (80034c8 <regelschritt+0x958>)
 80033f8:	e9c3 0102 	strd	r0, r1, [r3, #8]
	}

	// Use tracking Anti-Windup for NE-direction: during saturation, the integrator is used to unsaturate the output
	// see Anti-Reset Windup for PID controllers, L.Rundqwist, 1990

	geschwindigkeitsfehlerlimit.norden = geschwindigkeitsfehler[NORDEN] - (
 80033fc:	4b34      	ldr	r3, [pc, #208]	@ (80034d0 <regelschritt+0x960>)
 80033fe:	e9d3 4500 	ldrd	r4, r5, [r3]
		sollschub[NORDEN] - sollschub[NORDEN]
 8003402:	4b31      	ldr	r3, [pc, #196]	@ (80034c8 <regelschritt+0x958>)
 8003404:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003408:	4b2f      	ldr	r3, [pc, #188]	@ (80034c8 <regelschritt+0x958>)
 800340a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800340e:	f7fc ff43 	bl	8000298 <__aeabi_dsub>
 8003412:	4602      	mov	r2, r0
 8003414:	460b      	mov	r3, r1
 8003416:	4610      	mov	r0, r2
 8003418:	4619      	mov	r1, r3
		) * 2.0 / vel_p_gain[NORDEN];
 800341a:	4602      	mov	r2, r0
 800341c:	460b      	mov	r3, r1
 800341e:	f7fc ff3d 	bl	800029c <__adddf3>
 8003422:	4602      	mov	r2, r0
 8003424:	460b      	mov	r3, r1
 8003426:	4610      	mov	r0, r2
 8003428:	4619      	mov	r1, r3
 800342a:	4b28      	ldr	r3, [pc, #160]	@ (80034cc <regelschritt+0x95c>)
 800342c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003430:	f7fd fa14 	bl	800085c <__aeabi_ddiv>
 8003434:	4602      	mov	r2, r0
 8003436:	460b      	mov	r3, r1
	geschwindigkeitsfehlerlimit.norden = geschwindigkeitsfehler[NORDEN] - (
 8003438:	4620      	mov	r0, r4
 800343a:	4629      	mov	r1, r5
 800343c:	f7fc ff2c 	bl	8000298 <__aeabi_dsub>
 8003440:	4602      	mov	r2, r0
 8003442:	460b      	mov	r3, r1
 8003444:	4610      	mov	r0, r2
 8003446:	4619      	mov	r1, r3
 8003448:	4b29      	ldr	r3, [pc, #164]	@ (80034f0 <regelschritt+0x980>)
 800344a:	e9c3 0100 	strd	r0, r1, [r3]
	geschwindigkeitsfehlerlimit.osten = geschwindigkeitsfehler[OSTEN] - (
 800344e:	4b20      	ldr	r3, [pc, #128]	@ (80034d0 <regelschritt+0x960>)
 8003450:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
		sollschub[OSTEN] - sollschub[OSTEN]
 8003454:	4b1c      	ldr	r3, [pc, #112]	@ (80034c8 <regelschritt+0x958>)
 8003456:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800345a:	4b1b      	ldr	r3, [pc, #108]	@ (80034c8 <regelschritt+0x958>)
 800345c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003460:	f7fc ff1a 	bl	8000298 <__aeabi_dsub>
 8003464:	4602      	mov	r2, r0
 8003466:	460b      	mov	r3, r1
 8003468:	4610      	mov	r0, r2
 800346a:	4619      	mov	r1, r3
		) * 2.0 / vel_p_gain[OSTEN];
 800346c:	4602      	mov	r2, r0
 800346e:	460b      	mov	r3, r1
 8003470:	f7fc ff14 	bl	800029c <__adddf3>
 8003474:	4602      	mov	r2, r0
 8003476:	460b      	mov	r3, r1
 8003478:	4610      	mov	r0, r2
 800347a:	4619      	mov	r1, r3
 800347c:	4b13      	ldr	r3, [pc, #76]	@ (80034cc <regelschritt+0x95c>)
 800347e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003482:	f7fd f9eb 	bl	800085c <__aeabi_ddiv>
 8003486:	4602      	mov	r2, r0
 8003488:	460b      	mov	r3, r1
	geschwindigkeitsfehlerlimit.osten = geschwindigkeitsfehler[OSTEN] - (
 800348a:	4620      	mov	r0, r4
 800348c:	4629      	mov	r1, r5
 800348e:	f7fc ff03 	bl	8000298 <__aeabi_dsub>
 8003492:	4602      	mov	r2, r0
 8003494:	460b      	mov	r3, r1
 8003496:	4610      	mov	r0, r2
 8003498:	4619      	mov	r1, r3
 800349a:	4b15      	ldr	r3, [pc, #84]	@ (80034f0 <regelschritt+0x980>)
 800349c:	e9c3 0102 	strd	r0, r1, [r3, #8]

	double normsollschub = sqrt(
		sollschub[NORDEN] * sollschub[NORDEN] +
 80034a0:	4b09      	ldr	r3, [pc, #36]	@ (80034c8 <regelschritt+0x958>)
 80034a2:	e9d3 0100 	ldrd	r0, r1, [r3]
 80034a6:	4b08      	ldr	r3, [pc, #32]	@ (80034c8 <regelschritt+0x958>)
 80034a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80034ac:	f7fd f8ac 	bl	8000608 <__aeabi_dmul>
 80034b0:	4602      	mov	r2, r0
 80034b2:	460b      	mov	r3, r1
 80034b4:	4614      	mov	r4, r2
 80034b6:	461d      	mov	r5, r3
		sollschub[OSTEN] * sollschub[OSTEN] +
 80034b8:	4b03      	ldr	r3, [pc, #12]	@ (80034c8 <regelschritt+0x958>)
 80034ba:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80034be:	e019      	b.n	80034f4 <regelschritt+0x984>
 80034c0:	00000000 	.word	0x00000000
 80034c4:	40000000 	.word	0x40000000
 80034c8:	20001e48 	.word	0x20001e48
 80034cc:	200000b0 	.word	0x200000b0
 80034d0:	20001fb8 	.word	0x20001fb8
 80034d4:	200000c8 	.word	0x200000c8
 80034d8:	20001cf8 	.word	0x20001cf8
 80034dc:	20001e80 	.word	0x20001e80
 80034e0:	20000028 	.word	0x20000028
 80034e4:	20001df0 	.word	0x20001df0
 80034e8:	20000138 	.word	0x20000138
 80034ec:	20000130 	.word	0x20000130
 80034f0:	20001e10 	.word	0x20001e10
 80034f4:	4bb4      	ldr	r3, [pc, #720]	@ (80037c8 <regelschritt+0xc58>)
 80034f6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80034fa:	f7fd f885 	bl	8000608 <__aeabi_dmul>
 80034fe:	4602      	mov	r2, r0
 8003500:	460b      	mov	r3, r1
		sollschub[NORDEN] * sollschub[NORDEN] +
 8003502:	4620      	mov	r0, r4
 8003504:	4629      	mov	r1, r5
 8003506:	f7fc fec9 	bl	800029c <__adddf3>
 800350a:	4602      	mov	r2, r0
 800350c:	460b      	mov	r3, r1
 800350e:	4614      	mov	r4, r2
 8003510:	461d      	mov	r5, r3
		sollschub[UNTEN] * sollschub[UNTEN]
 8003512:	4bad      	ldr	r3, [pc, #692]	@ (80037c8 <regelschritt+0xc58>)
 8003514:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8003518:	4bab      	ldr	r3, [pc, #684]	@ (80037c8 <regelschritt+0xc58>)
 800351a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800351e:	f7fd f873 	bl	8000608 <__aeabi_dmul>
 8003522:	4602      	mov	r2, r0
 8003524:	460b      	mov	r3, r1
	double normsollschub = sqrt(
 8003526:	4620      	mov	r0, r4
 8003528:	4629      	mov	r1, r5
 800352a:	f7fc feb7 	bl	800029c <__adddf3>
 800352e:	4602      	mov	r2, r0
 8003530:	460b      	mov	r3, r1
 8003532:	ec43 2b17 	vmov	d7, r2, r3
 8003536:	eeb0 0a47 	vmov.f32	s0, s14
 800353a:	eef0 0a67 	vmov.f32	s1, s15
 800353e:	f01c f87f 	bl	801f640 <sqrt>
 8003542:	ed87 0b7c 	vstr	d0, [r7, #496]	@ 0x1f0
	);

	body_z[0] = -sollschub[0] / normsollschub;
 8003546:	4ba0      	ldr	r3, [pc, #640]	@ (80037c8 <regelschritt+0xc58>)
 8003548:	e9d3 2300 	ldrd	r2, r3, [r3]
 800354c:	4692      	mov	sl, r2
 800354e:	f083 4b00 	eor.w	fp, r3, #2147483648	@ 0x80000000
 8003552:	e9d7 237c 	ldrd	r2, r3, [r7, #496]	@ 0x1f0
 8003556:	4650      	mov	r0, sl
 8003558:	4659      	mov	r1, fp
 800355a:	f7fd f97f 	bl	800085c <__aeabi_ddiv>
 800355e:	4602      	mov	r2, r0
 8003560:	460b      	mov	r3, r1
 8003562:	4610      	mov	r0, r2
 8003564:	4619      	mov	r1, r3
 8003566:	4b99      	ldr	r3, [pc, #612]	@ (80037cc <regelschritt+0xc5c>)
 8003568:	e9c3 0100 	strd	r0, r1, [r3]
	body_z[1] = -sollschub[1] / normsollschub;
 800356c:	4b96      	ldr	r3, [pc, #600]	@ (80037c8 <regelschritt+0xc58>)
 800356e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003572:	f8c7 2088 	str.w	r2, [r7, #136]	@ 0x88
 8003576:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 800357a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 800357e:	e9d7 237c 	ldrd	r2, r3, [r7, #496]	@ 0x1f0
 8003582:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
 8003586:	f7fd f969 	bl	800085c <__aeabi_ddiv>
 800358a:	4602      	mov	r2, r0
 800358c:	460b      	mov	r3, r1
 800358e:	4610      	mov	r0, r2
 8003590:	4619      	mov	r1, r3
 8003592:	4b8e      	ldr	r3, [pc, #568]	@ (80037cc <regelschritt+0xc5c>)
 8003594:	e9c3 0102 	strd	r0, r1, [r3, #8]
	body_z[2] = -sollschub[2] / normsollschub;
 8003598:	4b8b      	ldr	r3, [pc, #556]	@ (80037c8 <regelschritt+0xc58>)
 800359a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800359e:	f8c7 2080 	str.w	r2, [r7, #128]	@ 0x80
 80035a2:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 80035a6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 80035aa:	e9d7 237c 	ldrd	r2, r3, [r7, #496]	@ 0x1f0
 80035ae:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
 80035b2:	f7fd f953 	bl	800085c <__aeabi_ddiv>
 80035b6:	4602      	mov	r2, r0
 80035b8:	460b      	mov	r3, r1
 80035ba:	4610      	mov	r0, r2
 80035bc:	4619      	mov	r1, r3
 80035be:	4b83      	ldr	r3, [pc, #524]	@ (80037cc <regelschritt+0xc5c>)
 80035c0:	e9c3 0104 	strd	r0, r1, [r3, #16]

	y_C[0] = -sin(yaw_setpoint);
 80035c4:	4b82      	ldr	r3, [pc, #520]	@ (80037d0 <regelschritt+0xc60>)
 80035c6:	ed93 7b00 	vldr	d7, [r3]
 80035ca:	eeb0 0a47 	vmov.f32	s0, s14
 80035ce:	eef0 0a67 	vmov.f32	s1, s15
 80035d2:	f01c f8bd 	bl	801f750 <sin>
 80035d6:	ec53 2b10 	vmov	r2, r3, d0
 80035da:	4690      	mov	r8, r2
 80035dc:	f083 4900 	eor.w	r9, r3, #2147483648	@ 0x80000000
 80035e0:	4b7c      	ldr	r3, [pc, #496]	@ (80037d4 <regelschritt+0xc64>)
 80035e2:	e9c3 8900 	strd	r8, r9, [r3]
	y_C[1] = cos(yaw_setpoint);
 80035e6:	4b7a      	ldr	r3, [pc, #488]	@ (80037d0 <regelschritt+0xc60>)
 80035e8:	ed93 7b00 	vldr	d7, [r3]
 80035ec:	eeb0 0a47 	vmov.f32	s0, s14
 80035f0:	eef0 0a67 	vmov.f32	s1, s15
 80035f4:	f01c f850 	bl	801f698 <cos>
 80035f8:	eeb0 7a40 	vmov.f32	s14, s0
 80035fc:	eef0 7a60 	vmov.f32	s15, s1
 8003600:	4b74      	ldr	r3, [pc, #464]	@ (80037d4 <regelschritt+0xc64>)
 8003602:	ed83 7b02 	vstr	d7, [r3, #8]
	y_C[2] = 0.0;
 8003606:	4973      	ldr	r1, [pc, #460]	@ (80037d4 <regelschritt+0xc64>)
 8003608:	f04f 0200 	mov.w	r2, #0
 800360c:	f04f 0300 	mov.w	r3, #0
 8003610:	e9c1 2304 	strd	r2, r3, [r1, #16]

	// Kreuzprodukt
	body_x[0] = y_C[1] * body_z[2] - y_C[2] * body_z[1];
 8003614:	4b6f      	ldr	r3, [pc, #444]	@ (80037d4 <regelschritt+0xc64>)
 8003616:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800361a:	4b6c      	ldr	r3, [pc, #432]	@ (80037cc <regelschritt+0xc5c>)
 800361c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003620:	f7fc fff2 	bl	8000608 <__aeabi_dmul>
 8003624:	4602      	mov	r2, r0
 8003626:	460b      	mov	r3, r1
 8003628:	4614      	mov	r4, r2
 800362a:	461d      	mov	r5, r3
 800362c:	4b69      	ldr	r3, [pc, #420]	@ (80037d4 <regelschritt+0xc64>)
 800362e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8003632:	4b66      	ldr	r3, [pc, #408]	@ (80037cc <regelschritt+0xc5c>)
 8003634:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003638:	f7fc ffe6 	bl	8000608 <__aeabi_dmul>
 800363c:	4602      	mov	r2, r0
 800363e:	460b      	mov	r3, r1
 8003640:	4620      	mov	r0, r4
 8003642:	4629      	mov	r1, r5
 8003644:	f7fc fe28 	bl	8000298 <__aeabi_dsub>
 8003648:	4602      	mov	r2, r0
 800364a:	460b      	mov	r3, r1
 800364c:	4610      	mov	r0, r2
 800364e:	4619      	mov	r1, r3
 8003650:	4b61      	ldr	r3, [pc, #388]	@ (80037d8 <regelschritt+0xc68>)
 8003652:	e9c3 0100 	strd	r0, r1, [r3]
	body_x[1] = y_C[2] * body_z[0] - y_C[0] * body_z[2];
 8003656:	4b5f      	ldr	r3, [pc, #380]	@ (80037d4 <regelschritt+0xc64>)
 8003658:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800365c:	4b5b      	ldr	r3, [pc, #364]	@ (80037cc <regelschritt+0xc5c>)
 800365e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003662:	f7fc ffd1 	bl	8000608 <__aeabi_dmul>
 8003666:	4602      	mov	r2, r0
 8003668:	460b      	mov	r3, r1
 800366a:	4614      	mov	r4, r2
 800366c:	461d      	mov	r5, r3
 800366e:	4b59      	ldr	r3, [pc, #356]	@ (80037d4 <regelschritt+0xc64>)
 8003670:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003674:	4b55      	ldr	r3, [pc, #340]	@ (80037cc <regelschritt+0xc5c>)
 8003676:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800367a:	f7fc ffc5 	bl	8000608 <__aeabi_dmul>
 800367e:	4602      	mov	r2, r0
 8003680:	460b      	mov	r3, r1
 8003682:	4620      	mov	r0, r4
 8003684:	4629      	mov	r1, r5
 8003686:	f7fc fe07 	bl	8000298 <__aeabi_dsub>
 800368a:	4602      	mov	r2, r0
 800368c:	460b      	mov	r3, r1
 800368e:	4610      	mov	r0, r2
 8003690:	4619      	mov	r1, r3
 8003692:	4b51      	ldr	r3, [pc, #324]	@ (80037d8 <regelschritt+0xc68>)
 8003694:	e9c3 0102 	strd	r0, r1, [r3, #8]
	body_x[2] = y_C[0] * body_z[1] - y_C[1] * body_z[0];
 8003698:	4b4e      	ldr	r3, [pc, #312]	@ (80037d4 <regelschritt+0xc64>)
 800369a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800369e:	4b4b      	ldr	r3, [pc, #300]	@ (80037cc <regelschritt+0xc5c>)
 80036a0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80036a4:	f7fc ffb0 	bl	8000608 <__aeabi_dmul>
 80036a8:	4602      	mov	r2, r0
 80036aa:	460b      	mov	r3, r1
 80036ac:	4614      	mov	r4, r2
 80036ae:	461d      	mov	r5, r3
 80036b0:	4b48      	ldr	r3, [pc, #288]	@ (80037d4 <regelschritt+0xc64>)
 80036b2:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80036b6:	4b45      	ldr	r3, [pc, #276]	@ (80037cc <regelschritt+0xc5c>)
 80036b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80036bc:	f7fc ffa4 	bl	8000608 <__aeabi_dmul>
 80036c0:	4602      	mov	r2, r0
 80036c2:	460b      	mov	r3, r1
 80036c4:	4620      	mov	r0, r4
 80036c6:	4629      	mov	r1, r5
 80036c8:	f7fc fde6 	bl	8000298 <__aeabi_dsub>
 80036cc:	4602      	mov	r2, r0
 80036ce:	460b      	mov	r3, r1
 80036d0:	4610      	mov	r0, r2
 80036d2:	4619      	mov	r1, r3
 80036d4:	4b40      	ldr	r3, [pc, #256]	@ (80037d8 <regelschritt+0xc68>)
 80036d6:	e9c3 0104 	strd	r0, r1, [r3, #16]

	double normBodyX = sqrt(
		body_x[0] * body_x[0] +
 80036da:	4b3f      	ldr	r3, [pc, #252]	@ (80037d8 <regelschritt+0xc68>)
 80036dc:	e9d3 0100 	ldrd	r0, r1, [r3]
 80036e0:	4b3d      	ldr	r3, [pc, #244]	@ (80037d8 <regelschritt+0xc68>)
 80036e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80036e6:	f7fc ff8f 	bl	8000608 <__aeabi_dmul>
 80036ea:	4602      	mov	r2, r0
 80036ec:	460b      	mov	r3, r1
 80036ee:	4614      	mov	r4, r2
 80036f0:	461d      	mov	r5, r3
		body_x[1] * body_x[1] +
 80036f2:	4b39      	ldr	r3, [pc, #228]	@ (80037d8 <regelschritt+0xc68>)
 80036f4:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80036f8:	4b37      	ldr	r3, [pc, #220]	@ (80037d8 <regelschritt+0xc68>)
 80036fa:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80036fe:	f7fc ff83 	bl	8000608 <__aeabi_dmul>
 8003702:	4602      	mov	r2, r0
 8003704:	460b      	mov	r3, r1
		body_x[0] * body_x[0] +
 8003706:	4620      	mov	r0, r4
 8003708:	4629      	mov	r1, r5
 800370a:	f7fc fdc7 	bl	800029c <__adddf3>
 800370e:	4602      	mov	r2, r0
 8003710:	460b      	mov	r3, r1
 8003712:	4614      	mov	r4, r2
 8003714:	461d      	mov	r5, r3
		body_x[2] * body_x[2]
 8003716:	4b30      	ldr	r3, [pc, #192]	@ (80037d8 <regelschritt+0xc68>)
 8003718:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800371c:	4b2e      	ldr	r3, [pc, #184]	@ (80037d8 <regelschritt+0xc68>)
 800371e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003722:	f7fc ff71 	bl	8000608 <__aeabi_dmul>
 8003726:	4602      	mov	r2, r0
 8003728:	460b      	mov	r3, r1
	double normBodyX = sqrt(
 800372a:	4620      	mov	r0, r4
 800372c:	4629      	mov	r1, r5
 800372e:	f7fc fdb5 	bl	800029c <__adddf3>
 8003732:	4602      	mov	r2, r0
 8003734:	460b      	mov	r3, r1
 8003736:	ec43 2b17 	vmov	d7, r2, r3
 800373a:	eeb0 0a47 	vmov.f32	s0, s14
 800373e:	eef0 0a67 	vmov.f32	s1, s15
 8003742:	f01b ff7d 	bl	801f640 <sqrt>
 8003746:	ed87 0b7a 	vstr	d0, [r7, #488]	@ 0x1e8
	);

	body_x[0] = body_x[0] / normBodyX;
 800374a:	4b23      	ldr	r3, [pc, #140]	@ (80037d8 <regelschritt+0xc68>)
 800374c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003750:	e9d7 237a 	ldrd	r2, r3, [r7, #488]	@ 0x1e8
 8003754:	f7fd f882 	bl	800085c <__aeabi_ddiv>
 8003758:	4602      	mov	r2, r0
 800375a:	460b      	mov	r3, r1
 800375c:	4610      	mov	r0, r2
 800375e:	4619      	mov	r1, r3
 8003760:	4b1d      	ldr	r3, [pc, #116]	@ (80037d8 <regelschritt+0xc68>)
 8003762:	e9c3 0100 	strd	r0, r1, [r3]
	body_x[1] = body_x[1] / normBodyX;
 8003766:	4b1c      	ldr	r3, [pc, #112]	@ (80037d8 <regelschritt+0xc68>)
 8003768:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800376c:	e9d7 237a 	ldrd	r2, r3, [r7, #488]	@ 0x1e8
 8003770:	f7fd f874 	bl	800085c <__aeabi_ddiv>
 8003774:	4602      	mov	r2, r0
 8003776:	460b      	mov	r3, r1
 8003778:	4610      	mov	r0, r2
 800377a:	4619      	mov	r1, r3
 800377c:	4b16      	ldr	r3, [pc, #88]	@ (80037d8 <regelschritt+0xc68>)
 800377e:	e9c3 0102 	strd	r0, r1, [r3, #8]
	body_x[2] = body_x[2] / normBodyX;
 8003782:	4b15      	ldr	r3, [pc, #84]	@ (80037d8 <regelschritt+0xc68>)
 8003784:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8003788:	e9d7 237a 	ldrd	r2, r3, [r7, #488]	@ 0x1e8
 800378c:	f7fd f866 	bl	800085c <__aeabi_ddiv>
 8003790:	4602      	mov	r2, r0
 8003792:	460b      	mov	r3, r1
 8003794:	4610      	mov	r0, r2
 8003796:	4619      	mov	r1, r3
 8003798:	4b0f      	ldr	r3, [pc, #60]	@ (80037d8 <regelschritt+0xc68>)
 800379a:	e9c3 0104 	strd	r0, r1, [r3, #16]

	body_y[0] = (
		body_z[1] * body_x[2] -
 800379e:	4b0b      	ldr	r3, [pc, #44]	@ (80037cc <regelschritt+0xc5c>)
 80037a0:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80037a4:	4b0c      	ldr	r3, [pc, #48]	@ (80037d8 <regelschritt+0xc68>)
 80037a6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80037aa:	f7fc ff2d 	bl	8000608 <__aeabi_dmul>
 80037ae:	4602      	mov	r2, r0
 80037b0:	460b      	mov	r3, r1
 80037b2:	4614      	mov	r4, r2
 80037b4:	461d      	mov	r5, r3
		body_z[2] * body_x[1]
 80037b6:	4b05      	ldr	r3, [pc, #20]	@ (80037cc <regelschritt+0xc5c>)
 80037b8:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80037bc:	4b06      	ldr	r3, [pc, #24]	@ (80037d8 <regelschritt+0xc68>)
 80037be:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80037c2:	f7fc ff21 	bl	8000608 <__aeabi_dmul>
 80037c6:	e009      	b.n	80037dc <regelschritt+0xc6c>
 80037c8:	20001e48 	.word	0x20001e48
 80037cc:	20001d78 	.word	0x20001d78
 80037d0:	20001e78 	.word	0x20001e78
 80037d4:	20001d90 	.word	0x20001d90
 80037d8:	20001d48 	.word	0x20001d48
 80037dc:	4602      	mov	r2, r0
 80037de:	460b      	mov	r3, r1
		body_z[1] * body_x[2] -
 80037e0:	4620      	mov	r0, r4
 80037e2:	4629      	mov	r1, r5
 80037e4:	f7fc fd58 	bl	8000298 <__aeabi_dsub>
 80037e8:	4602      	mov	r2, r0
 80037ea:	460b      	mov	r3, r1
 80037ec:	4610      	mov	r0, r2
 80037ee:	4619      	mov	r1, r3
	body_y[0] = (
 80037f0:	4b7b      	ldr	r3, [pc, #492]	@ (80039e0 <regelschritt+0xe70>)
 80037f2:	e9c3 0100 	strd	r0, r1, [r3]
	);
	body_y[1] = (
		body_z[2] * body_x[0] -
 80037f6:	4b7b      	ldr	r3, [pc, #492]	@ (80039e4 <regelschritt+0xe74>)
 80037f8:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80037fc:	4b7a      	ldr	r3, [pc, #488]	@ (80039e8 <regelschritt+0xe78>)
 80037fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003802:	f7fc ff01 	bl	8000608 <__aeabi_dmul>
 8003806:	4602      	mov	r2, r0
 8003808:	460b      	mov	r3, r1
 800380a:	4614      	mov	r4, r2
 800380c:	461d      	mov	r5, r3
		body_z[0] * body_x[2]
 800380e:	4b75      	ldr	r3, [pc, #468]	@ (80039e4 <regelschritt+0xe74>)
 8003810:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003814:	4b74      	ldr	r3, [pc, #464]	@ (80039e8 <regelschritt+0xe78>)
 8003816:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800381a:	f7fc fef5 	bl	8000608 <__aeabi_dmul>
 800381e:	4602      	mov	r2, r0
 8003820:	460b      	mov	r3, r1
		body_z[2] * body_x[0] -
 8003822:	4620      	mov	r0, r4
 8003824:	4629      	mov	r1, r5
 8003826:	f7fc fd37 	bl	8000298 <__aeabi_dsub>
 800382a:	4602      	mov	r2, r0
 800382c:	460b      	mov	r3, r1
 800382e:	4610      	mov	r0, r2
 8003830:	4619      	mov	r1, r3
	body_y[1] = (
 8003832:	4b6b      	ldr	r3, [pc, #428]	@ (80039e0 <regelschritt+0xe70>)
 8003834:	e9c3 0102 	strd	r0, r1, [r3, #8]
	);
	body_y[2] = (
		body_z[0] * body_x[1] -
 8003838:	4b6a      	ldr	r3, [pc, #424]	@ (80039e4 <regelschritt+0xe74>)
 800383a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800383e:	4b6a      	ldr	r3, [pc, #424]	@ (80039e8 <regelschritt+0xe78>)
 8003840:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003844:	f7fc fee0 	bl	8000608 <__aeabi_dmul>
 8003848:	4602      	mov	r2, r0
 800384a:	460b      	mov	r3, r1
 800384c:	4614      	mov	r4, r2
 800384e:	461d      	mov	r5, r3
		body_z[1] * body_x[0]
 8003850:	4b64      	ldr	r3, [pc, #400]	@ (80039e4 <regelschritt+0xe74>)
 8003852:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8003856:	4b64      	ldr	r3, [pc, #400]	@ (80039e8 <regelschritt+0xe78>)
 8003858:	e9d3 2300 	ldrd	r2, r3, [r3]
 800385c:	f7fc fed4 	bl	8000608 <__aeabi_dmul>
 8003860:	4602      	mov	r2, r0
 8003862:	460b      	mov	r3, r1
		body_z[0] * body_x[1] -
 8003864:	4620      	mov	r0, r4
 8003866:	4629      	mov	r1, r5
 8003868:	f7fc fd16 	bl	8000298 <__aeabi_dsub>
 800386c:	4602      	mov	r2, r0
 800386e:	460b      	mov	r3, r1
 8003870:	4610      	mov	r0, r2
 8003872:	4619      	mov	r1, r3
	body_y[2] = (
 8003874:	4b5a      	ldr	r3, [pc, #360]	@ (80039e0 <regelschritt+0xe70>)
 8003876:	e9c3 0104 	strd	r0, r1, [r3, #16]
	);

	double R_sp[3][3];

	// Desired rotation matrix
	R_sp[0][0] = body_x[0];
 800387a:	4b5b      	ldr	r3, [pc, #364]	@ (80039e8 <regelschritt+0xe78>)
 800387c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003880:	e9c7 235c 	strd	r2, r3, [r7, #368]	@ 0x170
	R_sp[1][0] = body_x[1];
 8003884:	4b58      	ldr	r3, [pc, #352]	@ (80039e8 <regelschritt+0xe78>)
 8003886:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800388a:	e9c7 2362 	strd	r2, r3, [r7, #392]	@ 0x188
	R_sp[2][0] = body_x[2];
 800388e:	4b56      	ldr	r3, [pc, #344]	@ (80039e8 <regelschritt+0xe78>)
 8003890:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003894:	e9c7 2368 	strd	r2, r3, [r7, #416]	@ 0x1a0

	R_sp[0][1] = body_y[0];
 8003898:	4b51      	ldr	r3, [pc, #324]	@ (80039e0 <regelschritt+0xe70>)
 800389a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800389e:	e9c7 235e 	strd	r2, r3, [r7, #376]	@ 0x178
	R_sp[1][1] = body_y[1];
 80038a2:	4b4f      	ldr	r3, [pc, #316]	@ (80039e0 <regelschritt+0xe70>)
 80038a4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80038a8:	e9c7 2364 	strd	r2, r3, [r7, #400]	@ 0x190
	R_sp[2][1] = body_y[2];
 80038ac:	4b4c      	ldr	r3, [pc, #304]	@ (80039e0 <regelschritt+0xe70>)
 80038ae:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80038b2:	e9c7 236a 	strd	r2, r3, [r7, #424]	@ 0x1a8

	R_sp[0][2] = body_z[0];
 80038b6:	4b4b      	ldr	r3, [pc, #300]	@ (80039e4 <regelschritt+0xe74>)
 80038b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80038bc:	e9c7 2360 	strd	r2, r3, [r7, #384]	@ 0x180
	R_sp[1][2] = body_z[1];
 80038c0:	4b48      	ldr	r3, [pc, #288]	@ (80039e4 <regelschritt+0xe74>)
 80038c2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80038c6:	e9c7 2366 	strd	r2, r3, [r7, #408]	@ 0x198
	R_sp[2][2] = body_z[2];
 80038ca:	4b46      	ldr	r3, [pc, #280]	@ (80039e4 <regelschritt+0xe74>)
 80038cc:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80038d0:	e9c7 236c 	strd	r2, r3, [r7, #432]	@ 0x1b0
	// RotToQuat(R_sp, q_target);

	// double quaternion_ganz[4];

	Quaternion quaternion_ganz;
	double tr = R_sp[0][0] + R_sp[1][1] + R_sp[2][2];
 80038d4:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
 80038d8:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 80038dc:	f7fc fcde 	bl	800029c <__adddf3>
 80038e0:	4602      	mov	r2, r0
 80038e2:	460b      	mov	r3, r1
 80038e4:	4610      	mov	r0, r2
 80038e6:	4619      	mov	r1, r3
 80038e8:	e9d7 236c 	ldrd	r2, r3, [r7, #432]	@ 0x1b0
 80038ec:	f7fc fcd6 	bl	800029c <__adddf3>
 80038f0:	4602      	mov	r2, r0
 80038f2:	460b      	mov	r3, r1
 80038f4:	e9c7 2378 	strd	r2, r3, [r7, #480]	@ 0x1e0
	double r, e0, e1, e2, e3;

	if (tr > R_sp[0][0] && tr > R_sp[1][1] && tr > R_sp[2][2]) {
 80038f8:	e9d7 235c 	ldrd	r2, r3, [r7, #368]	@ 0x170
 80038fc:	e9d7 0178 	ldrd	r0, r1, [r7, #480]	@ 0x1e0
 8003900:	f7fd f912 	bl	8000b28 <__aeabi_dcmpgt>
 8003904:	4603      	mov	r3, r0
 8003906:	2b00      	cmp	r3, #0
 8003908:	d076      	beq.n	80039f8 <regelschritt+0xe88>
 800390a:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 800390e:	e9d7 0178 	ldrd	r0, r1, [r7, #480]	@ 0x1e0
 8003912:	f7fd f909 	bl	8000b28 <__aeabi_dcmpgt>
 8003916:	4603      	mov	r3, r0
 8003918:	2b00      	cmp	r3, #0
 800391a:	d06d      	beq.n	80039f8 <regelschritt+0xe88>
 800391c:	e9d7 236c 	ldrd	r2, r3, [r7, #432]	@ 0x1b0
 8003920:	e9d7 0178 	ldrd	r0, r1, [r7, #480]	@ 0x1e0
 8003924:	f7fd f900 	bl	8000b28 <__aeabi_dcmpgt>
 8003928:	4603      	mov	r3, r0
 800392a:	2b00      	cmp	r3, #0
 800392c:	d064      	beq.n	80039f8 <regelschritt+0xe88>
		e0 = 0.5 * sqrt(1 + tr);
 800392e:	f04f 0200 	mov.w	r2, #0
 8003932:	4b2e      	ldr	r3, [pc, #184]	@ (80039ec <regelschritt+0xe7c>)
 8003934:	e9d7 0178 	ldrd	r0, r1, [r7, #480]	@ 0x1e0
 8003938:	f7fc fcb0 	bl	800029c <__adddf3>
 800393c:	4602      	mov	r2, r0
 800393e:	460b      	mov	r3, r1
 8003940:	ec43 2b17 	vmov	d7, r2, r3
 8003944:	eeb0 0a47 	vmov.f32	s0, s14
 8003948:	eef0 0a67 	vmov.f32	s1, s15
 800394c:	f01b fe78 	bl	801f640 <sqrt>
 8003950:	ec51 0b10 	vmov	r0, r1, d0
 8003954:	f04f 0200 	mov.w	r2, #0
 8003958:	4b25      	ldr	r3, [pc, #148]	@ (80039f0 <regelschritt+0xe80>)
 800395a:	f7fc fe55 	bl	8000608 <__aeabi_dmul>
 800395e:	4602      	mov	r2, r0
 8003960:	460b      	mov	r3, r1
 8003962:	e9c7 238e 	strd	r2, r3, [r7, #568]	@ 0x238
		r = 0.25 / e0;
 8003966:	e9d7 238e 	ldrd	r2, r3, [r7, #568]	@ 0x238
 800396a:	f04f 0000 	mov.w	r0, #0
 800396e:	4921      	ldr	r1, [pc, #132]	@ (80039f4 <regelschritt+0xe84>)
 8003970:	f7fc ff74 	bl	800085c <__aeabi_ddiv>
 8003974:	4602      	mov	r2, r0
 8003976:	460b      	mov	r3, r1
 8003978:	e9c7 2376 	strd	r2, r3, [r7, #472]	@ 0x1d8
		e1 = (R_sp[2][1] - R_sp[1][2]) * r;
 800397c:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
 8003980:	e9d7 2366 	ldrd	r2, r3, [r7, #408]	@ 0x198
 8003984:	f7fc fc88 	bl	8000298 <__aeabi_dsub>
 8003988:	4602      	mov	r2, r0
 800398a:	460b      	mov	r3, r1
 800398c:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003990:	f7fc fe3a 	bl	8000608 <__aeabi_dmul>
 8003994:	4602      	mov	r2, r0
 8003996:	460b      	mov	r3, r1
 8003998:	e9c7 238c 	strd	r2, r3, [r7, #560]	@ 0x230
		e2 = (R_sp[0][2] - R_sp[2][0]) * r;
 800399c:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
 80039a0:	e9d7 2368 	ldrd	r2, r3, [r7, #416]	@ 0x1a0
 80039a4:	f7fc fc78 	bl	8000298 <__aeabi_dsub>
 80039a8:	4602      	mov	r2, r0
 80039aa:	460b      	mov	r3, r1
 80039ac:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 80039b0:	f7fc fe2a 	bl	8000608 <__aeabi_dmul>
 80039b4:	4602      	mov	r2, r0
 80039b6:	460b      	mov	r3, r1
 80039b8:	e9c7 238a 	strd	r2, r3, [r7, #552]	@ 0x228
		e3 = (R_sp[1][0] - R_sp[0][1]) * r;
 80039bc:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
 80039c0:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 80039c4:	f7fc fc68 	bl	8000298 <__aeabi_dsub>
 80039c8:	4602      	mov	r2, r0
 80039ca:	460b      	mov	r3, r1
 80039cc:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 80039d0:	f7fc fe1a 	bl	8000608 <__aeabi_dmul>
 80039d4:	4602      	mov	r2, r0
 80039d6:	460b      	mov	r3, r1
 80039d8:	e9c7 2388 	strd	r2, r3, [r7, #544]	@ 0x220
 80039dc:	e165      	b.n	8003caa <regelschritt+0x113a>
 80039de:	bf00      	nop
 80039e0:	20001d60 	.word	0x20001d60
 80039e4:	20001d78 	.word	0x20001d78
 80039e8:	20001d48 	.word	0x20001d48
 80039ec:	3ff00000 	.word	0x3ff00000
 80039f0:	3fe00000 	.word	0x3fe00000
 80039f4:	3fd00000 	.word	0x3fd00000
	} else if (R_sp[0][0] > R_sp[1][1] && R_sp[0][0] > R_sp[2][2]) {
 80039f8:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
 80039fc:	e9d7 2364 	ldrd	r2, r3, [r7, #400]	@ 0x190
 8003a00:	f7fd f892 	bl	8000b28 <__aeabi_dcmpgt>
 8003a04:	4603      	mov	r3, r0
 8003a06:	2b00      	cmp	r3, #0
 8003a08:	d070      	beq.n	8003aec <regelschritt+0xf7c>
 8003a0a:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
 8003a0e:	e9d7 236c 	ldrd	r2, r3, [r7, #432]	@ 0x1b0
 8003a12:	f7fd f889 	bl	8000b28 <__aeabi_dcmpgt>
 8003a16:	4603      	mov	r3, r0
 8003a18:	2b00      	cmp	r3, #0
 8003a1a:	d067      	beq.n	8003aec <regelschritt+0xf7c>
		e1 = 0.5 * sqrt(1 - tr + 2 * R_sp[0][0]);
 8003a1c:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 8003a20:	f04f 0000 	mov.w	r0, #0
 8003a24:	496a      	ldr	r1, [pc, #424]	@ (8003bd0 <regelschritt+0x1060>)
 8003a26:	f7fc fc37 	bl	8000298 <__aeabi_dsub>
 8003a2a:	4602      	mov	r2, r0
 8003a2c:	460b      	mov	r3, r1
 8003a2e:	4614      	mov	r4, r2
 8003a30:	461d      	mov	r5, r3
 8003a32:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
 8003a36:	4602      	mov	r2, r0
 8003a38:	460b      	mov	r3, r1
 8003a3a:	f7fc fc2f 	bl	800029c <__adddf3>
 8003a3e:	4602      	mov	r2, r0
 8003a40:	460b      	mov	r3, r1
 8003a42:	4620      	mov	r0, r4
 8003a44:	4629      	mov	r1, r5
 8003a46:	f7fc fc29 	bl	800029c <__adddf3>
 8003a4a:	4602      	mov	r2, r0
 8003a4c:	460b      	mov	r3, r1
 8003a4e:	ec43 2b17 	vmov	d7, r2, r3
 8003a52:	eeb0 0a47 	vmov.f32	s0, s14
 8003a56:	eef0 0a67 	vmov.f32	s1, s15
 8003a5a:	f01b fdf1 	bl	801f640 <sqrt>
 8003a5e:	ec51 0b10 	vmov	r0, r1, d0
 8003a62:	f04f 0200 	mov.w	r2, #0
 8003a66:	4b5b      	ldr	r3, [pc, #364]	@ (8003bd4 <regelschritt+0x1064>)
 8003a68:	f7fc fdce 	bl	8000608 <__aeabi_dmul>
 8003a6c:	4602      	mov	r2, r0
 8003a6e:	460b      	mov	r3, r1
 8003a70:	e9c7 238c 	strd	r2, r3, [r7, #560]	@ 0x230
		r = 0.25 / e1;
 8003a74:	e9d7 238c 	ldrd	r2, r3, [r7, #560]	@ 0x230
 8003a78:	f04f 0000 	mov.w	r0, #0
 8003a7c:	4956      	ldr	r1, [pc, #344]	@ (8003bd8 <regelschritt+0x1068>)
 8003a7e:	f7fc feed 	bl	800085c <__aeabi_ddiv>
 8003a82:	4602      	mov	r2, r0
 8003a84:	460b      	mov	r3, r1
 8003a86:	e9c7 2376 	strd	r2, r3, [r7, #472]	@ 0x1d8
		e0 = (R_sp[2][1] - R_sp[1][2]) * r;
 8003a8a:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
 8003a8e:	e9d7 2366 	ldrd	r2, r3, [r7, #408]	@ 0x198
 8003a92:	f7fc fc01 	bl	8000298 <__aeabi_dsub>
 8003a96:	4602      	mov	r2, r0
 8003a98:	460b      	mov	r3, r1
 8003a9a:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003a9e:	f7fc fdb3 	bl	8000608 <__aeabi_dmul>
 8003aa2:	4602      	mov	r2, r0
 8003aa4:	460b      	mov	r3, r1
 8003aa6:	e9c7 238e 	strd	r2, r3, [r7, #568]	@ 0x238
		e2 = (R_sp[0][1] + R_sp[1][0]) * r;
 8003aaa:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
 8003aae:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	@ 0x188
 8003ab2:	f7fc fbf3 	bl	800029c <__adddf3>
 8003ab6:	4602      	mov	r2, r0
 8003ab8:	460b      	mov	r3, r1
 8003aba:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003abe:	f7fc fda3 	bl	8000608 <__aeabi_dmul>
 8003ac2:	4602      	mov	r2, r0
 8003ac4:	460b      	mov	r3, r1
 8003ac6:	e9c7 238a 	strd	r2, r3, [r7, #552]	@ 0x228
		e3 = (R_sp[0][2] + R_sp[2][0]) * r;
 8003aca:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
 8003ace:	e9d7 2368 	ldrd	r2, r3, [r7, #416]	@ 0x1a0
 8003ad2:	f7fc fbe3 	bl	800029c <__adddf3>
 8003ad6:	4602      	mov	r2, r0
 8003ad8:	460b      	mov	r3, r1
 8003ada:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003ade:	f7fc fd93 	bl	8000608 <__aeabi_dmul>
 8003ae2:	4602      	mov	r2, r0
 8003ae4:	460b      	mov	r3, r1
 8003ae6:	e9c7 2388 	strd	r2, r3, [r7, #544]	@ 0x220
 8003aea:	e0de      	b.n	8003caa <regelschritt+0x113a>
	} else if (R_sp[1][1] > R_sp[2][2]) {
 8003aec:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
 8003af0:	e9d7 236c 	ldrd	r2, r3, [r7, #432]	@ 0x1b0
 8003af4:	f7fd f818 	bl	8000b28 <__aeabi_dcmpgt>
 8003af8:	4603      	mov	r3, r0
 8003afa:	2b00      	cmp	r3, #0
 8003afc:	d06e      	beq.n	8003bdc <regelschritt+0x106c>
		e2 = 0.5 * sqrt(1 - tr + 2 * R_sp[1][1]);
 8003afe:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 8003b02:	f04f 0000 	mov.w	r0, #0
 8003b06:	4932      	ldr	r1, [pc, #200]	@ (8003bd0 <regelschritt+0x1060>)
 8003b08:	f7fc fbc6 	bl	8000298 <__aeabi_dsub>
 8003b0c:	4602      	mov	r2, r0
 8003b0e:	460b      	mov	r3, r1
 8003b10:	4614      	mov	r4, r2
 8003b12:	461d      	mov	r5, r3
 8003b14:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
 8003b18:	4602      	mov	r2, r0
 8003b1a:	460b      	mov	r3, r1
 8003b1c:	f7fc fbbe 	bl	800029c <__adddf3>
 8003b20:	4602      	mov	r2, r0
 8003b22:	460b      	mov	r3, r1
 8003b24:	4620      	mov	r0, r4
 8003b26:	4629      	mov	r1, r5
 8003b28:	f7fc fbb8 	bl	800029c <__adddf3>
 8003b2c:	4602      	mov	r2, r0
 8003b2e:	460b      	mov	r3, r1
 8003b30:	ec43 2b17 	vmov	d7, r2, r3
 8003b34:	eeb0 0a47 	vmov.f32	s0, s14
 8003b38:	eef0 0a67 	vmov.f32	s1, s15
 8003b3c:	f01b fd80 	bl	801f640 <sqrt>
 8003b40:	ec51 0b10 	vmov	r0, r1, d0
 8003b44:	f04f 0200 	mov.w	r2, #0
 8003b48:	4b22      	ldr	r3, [pc, #136]	@ (8003bd4 <regelschritt+0x1064>)
 8003b4a:	f7fc fd5d 	bl	8000608 <__aeabi_dmul>
 8003b4e:	4602      	mov	r2, r0
 8003b50:	460b      	mov	r3, r1
 8003b52:	e9c7 238a 	strd	r2, r3, [r7, #552]	@ 0x228
		r = 0.25 / e2;
 8003b56:	e9d7 238a 	ldrd	r2, r3, [r7, #552]	@ 0x228
 8003b5a:	f04f 0000 	mov.w	r0, #0
 8003b5e:	491e      	ldr	r1, [pc, #120]	@ (8003bd8 <regelschritt+0x1068>)
 8003b60:	f7fc fe7c 	bl	800085c <__aeabi_ddiv>
 8003b64:	4602      	mov	r2, r0
 8003b66:	460b      	mov	r3, r1
 8003b68:	e9c7 2376 	strd	r2, r3, [r7, #472]	@ 0x1d8
		e0 = (R_sp[0][2] - R_sp[2][0]) * r;
 8003b6c:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
 8003b70:	e9d7 2368 	ldrd	r2, r3, [r7, #416]	@ 0x1a0
 8003b74:	f7fc fb90 	bl	8000298 <__aeabi_dsub>
 8003b78:	4602      	mov	r2, r0
 8003b7a:	460b      	mov	r3, r1
 8003b7c:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003b80:	f7fc fd42 	bl	8000608 <__aeabi_dmul>
 8003b84:	4602      	mov	r2, r0
 8003b86:	460b      	mov	r3, r1
 8003b88:	e9c7 238e 	strd	r2, r3, [r7, #568]	@ 0x238
		e1 = (R_sp[0][1] + R_sp[1][0]) * r;
 8003b8c:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
 8003b90:	e9d7 2362 	ldrd	r2, r3, [r7, #392]	@ 0x188
 8003b94:	f7fc fb82 	bl	800029c <__adddf3>
 8003b98:	4602      	mov	r2, r0
 8003b9a:	460b      	mov	r3, r1
 8003b9c:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003ba0:	f7fc fd32 	bl	8000608 <__aeabi_dmul>
 8003ba4:	4602      	mov	r2, r0
 8003ba6:	460b      	mov	r3, r1
 8003ba8:	e9c7 238c 	strd	r2, r3, [r7, #560]	@ 0x230
		e3 = (R_sp[1][2] + R_sp[2][1]) * r;
 8003bac:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
 8003bb0:	e9d7 236a 	ldrd	r2, r3, [r7, #424]	@ 0x1a8
 8003bb4:	f7fc fb72 	bl	800029c <__adddf3>
 8003bb8:	4602      	mov	r2, r0
 8003bba:	460b      	mov	r3, r1
 8003bbc:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003bc0:	f7fc fd22 	bl	8000608 <__aeabi_dmul>
 8003bc4:	4602      	mov	r2, r0
 8003bc6:	460b      	mov	r3, r1
 8003bc8:	e9c7 2388 	strd	r2, r3, [r7, #544]	@ 0x220
 8003bcc:	e06d      	b.n	8003caa <regelschritt+0x113a>
 8003bce:	bf00      	nop
 8003bd0:	3ff00000 	.word	0x3ff00000
 8003bd4:	3fe00000 	.word	0x3fe00000
 8003bd8:	3fd00000 	.word	0x3fd00000
	} else {
		e3 = 0.5 * sqrt(1 - tr + 2 * R_sp[2][2]);
 8003bdc:	e9d7 2378 	ldrd	r2, r3, [r7, #480]	@ 0x1e0
 8003be0:	f04f 0000 	mov.w	r0, #0
 8003be4:	49bb      	ldr	r1, [pc, #748]	@ (8003ed4 <regelschritt+0x1364>)
 8003be6:	f7fc fb57 	bl	8000298 <__aeabi_dsub>
 8003bea:	4602      	mov	r2, r0
 8003bec:	460b      	mov	r3, r1
 8003bee:	4614      	mov	r4, r2
 8003bf0:	461d      	mov	r5, r3
 8003bf2:	e9d7 016c 	ldrd	r0, r1, [r7, #432]	@ 0x1b0
 8003bf6:	4602      	mov	r2, r0
 8003bf8:	460b      	mov	r3, r1
 8003bfa:	f7fc fb4f 	bl	800029c <__adddf3>
 8003bfe:	4602      	mov	r2, r0
 8003c00:	460b      	mov	r3, r1
 8003c02:	4620      	mov	r0, r4
 8003c04:	4629      	mov	r1, r5
 8003c06:	f7fc fb49 	bl	800029c <__adddf3>
 8003c0a:	4602      	mov	r2, r0
 8003c0c:	460b      	mov	r3, r1
 8003c0e:	ec43 2b17 	vmov	d7, r2, r3
 8003c12:	eeb0 0a47 	vmov.f32	s0, s14
 8003c16:	eef0 0a67 	vmov.f32	s1, s15
 8003c1a:	f01b fd11 	bl	801f640 <sqrt>
 8003c1e:	ec51 0b10 	vmov	r0, r1, d0
 8003c22:	f04f 0200 	mov.w	r2, #0
 8003c26:	4bac      	ldr	r3, [pc, #688]	@ (8003ed8 <regelschritt+0x1368>)
 8003c28:	f7fc fcee 	bl	8000608 <__aeabi_dmul>
 8003c2c:	4602      	mov	r2, r0
 8003c2e:	460b      	mov	r3, r1
 8003c30:	e9c7 2388 	strd	r2, r3, [r7, #544]	@ 0x220
		r = 0.25 / e3;
 8003c34:	e9d7 2388 	ldrd	r2, r3, [r7, #544]	@ 0x220
 8003c38:	f04f 0000 	mov.w	r0, #0
 8003c3c:	49a7      	ldr	r1, [pc, #668]	@ (8003edc <regelschritt+0x136c>)
 8003c3e:	f7fc fe0d 	bl	800085c <__aeabi_ddiv>
 8003c42:	4602      	mov	r2, r0
 8003c44:	460b      	mov	r3, r1
 8003c46:	e9c7 2376 	strd	r2, r3, [r7, #472]	@ 0x1d8
		e0 = (R_sp[1][0] - R_sp[0][1]) * r;
 8003c4a:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
 8003c4e:	e9d7 235e 	ldrd	r2, r3, [r7, #376]	@ 0x178
 8003c52:	f7fc fb21 	bl	8000298 <__aeabi_dsub>
 8003c56:	4602      	mov	r2, r0
 8003c58:	460b      	mov	r3, r1
 8003c5a:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003c5e:	f7fc fcd3 	bl	8000608 <__aeabi_dmul>
 8003c62:	4602      	mov	r2, r0
 8003c64:	460b      	mov	r3, r1
 8003c66:	e9c7 238e 	strd	r2, r3, [r7, #568]	@ 0x238
		e1 = (R_sp[0][2] + R_sp[2][0]) * r;
 8003c6a:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
 8003c6e:	e9d7 2368 	ldrd	r2, r3, [r7, #416]	@ 0x1a0
 8003c72:	f7fc fb13 	bl	800029c <__adddf3>
 8003c76:	4602      	mov	r2, r0
 8003c78:	460b      	mov	r3, r1
 8003c7a:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003c7e:	f7fc fcc3 	bl	8000608 <__aeabi_dmul>
 8003c82:	4602      	mov	r2, r0
 8003c84:	460b      	mov	r3, r1
 8003c86:	e9c7 238c 	strd	r2, r3, [r7, #560]	@ 0x230
		e2 = (R_sp[1][2] + R_sp[2][1]) * r;
 8003c8a:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
 8003c8e:	e9d7 236a 	ldrd	r2, r3, [r7, #424]	@ 0x1a8
 8003c92:	f7fc fb03 	bl	800029c <__adddf3>
 8003c96:	4602      	mov	r2, r0
 8003c98:	460b      	mov	r3, r1
 8003c9a:	e9d7 0176 	ldrd	r0, r1, [r7, #472]	@ 0x1d8
 8003c9e:	f7fc fcb3 	bl	8000608 <__aeabi_dmul>
 8003ca2:	4602      	mov	r2, r0
 8003ca4:	460b      	mov	r3, r1
 8003ca6:	e9c7 238a 	strd	r2, r3, [r7, #552]	@ 0x228
	}

	quaternion_ganz.w = e0;
 8003caa:	e9d7 238e 	ldrd	r2, r3, [r7, #568]	@ 0x238
 8003cae:	e9c7 2354 	strd	r2, r3, [r7, #336]	@ 0x150
	quaternion_ganz.x = e1;
 8003cb2:	e9d7 238c 	ldrd	r2, r3, [r7, #560]	@ 0x230
 8003cb6:	e9c7 2356 	strd	r2, r3, [r7, #344]	@ 0x158
	quaternion_ganz.y = e2;
 8003cba:	e9d7 238a 	ldrd	r2, r3, [r7, #552]	@ 0x228
 8003cbe:	e9c7 2358 	strd	r2, r3, [r7, #352]	@ 0x160
	quaternion_ganz.z = e3;
 8003cc2:	e9d7 2388 	ldrd	r2, r3, [r7, #544]	@ 0x220
 8003cc6:	e9c7 235a 	strd	r2, r3, [r7, #360]	@ 0x168

	if (e0 < 0) {
 8003cca:	f04f 0200 	mov.w	r2, #0
 8003cce:	f04f 0300 	mov.w	r3, #0
 8003cd2:	e9d7 018e 	ldrd	r0, r1, [r7, #568]	@ 0x238
 8003cd6:	f7fc ff09 	bl	8000aec <__aeabi_dcmplt>
 8003cda:	4603      	mov	r3, r0
 8003cdc:	2b00      	cmp	r3, #0
 8003cde:	d027      	beq.n	8003d30 <regelschritt+0x11c0>
		quaternion_ganz.w = -quaternion_ganz.w;
 8003ce0:	e9d7 2354 	ldrd	r2, r3, [r7, #336]	@ 0x150
 8003ce4:	67ba      	str	r2, [r7, #120]	@ 0x78
 8003ce6:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8003cea:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8003cec:	ed97 7b1e 	vldr	d7, [r7, #120]	@ 0x78
 8003cf0:	ed87 7b54 	vstr	d7, [r7, #336]	@ 0x150
		quaternion_ganz.x = -quaternion_ganz.x;
 8003cf4:	e9d7 2356 	ldrd	r2, r3, [r7, #344]	@ 0x158
 8003cf8:	673a      	str	r2, [r7, #112]	@ 0x70
 8003cfa:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8003cfe:	677b      	str	r3, [r7, #116]	@ 0x74
 8003d00:	ed97 7b1c 	vldr	d7, [r7, #112]	@ 0x70
 8003d04:	ed87 7b56 	vstr	d7, [r7, #344]	@ 0x158
		quaternion_ganz.y = -quaternion_ganz.y;
 8003d08:	e9d7 2358 	ldrd	r2, r3, [r7, #352]	@ 0x160
 8003d0c:	66ba      	str	r2, [r7, #104]	@ 0x68
 8003d0e:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8003d12:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8003d14:	ed97 7b1a 	vldr	d7, [r7, #104]	@ 0x68
 8003d18:	ed87 7b58 	vstr	d7, [r7, #352]	@ 0x160
		quaternion_ganz.z = -quaternion_ganz.z;
 8003d1c:	e9d7 235a 	ldrd	r2, r3, [r7, #360]	@ 0x168
 8003d20:	663a      	str	r2, [r7, #96]	@ 0x60
 8003d22:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8003d26:	667b      	str	r3, [r7, #100]	@ 0x64
 8003d28:	ed97 7b18 	vldr	d7, [r7, #96]	@ 0x60
 8003d2c:	ed87 7b5a 	vstr	d7, [r7, #360]	@ 0x168
	}

	double norm = normQuaternion(quaternion_ganz);
 8003d30:	ed97 4b54 	vldr	d4, [r7, #336]	@ 0x150
 8003d34:	ed97 5b56 	vldr	d5, [r7, #344]	@ 0x158
 8003d38:	ed97 6b58 	vldr	d6, [r7, #352]	@ 0x160
 8003d3c:	ed97 7b5a 	vldr	d7, [r7, #360]	@ 0x168
 8003d40:	eeb0 0a44 	vmov.f32	s0, s8
 8003d44:	eef0 0a64 	vmov.f32	s1, s9
 8003d48:	eeb0 1a45 	vmov.f32	s2, s10
 8003d4c:	eef0 1a65 	vmov.f32	s3, s11
 8003d50:	eeb0 2a46 	vmov.f32	s4, s12
 8003d54:	eef0 2a66 	vmov.f32	s5, s13
 8003d58:	eeb0 3a47 	vmov.f32	s6, s14
 8003d5c:	eef0 3a67 	vmov.f32	s7, s15
 8003d60:	f7fe f828 	bl	8001db4 <normQuaternion>
 8003d64:	ed87 0b74 	vstr	d0, [r7, #464]	@ 0x1d0

	quaternion_ganz = scaleQuaternion(quaternion_ganz, 1 / norm);
 8003d68:	e9d7 2374 	ldrd	r2, r3, [r7, #464]	@ 0x1d0
 8003d6c:	f04f 0000 	mov.w	r0, #0
 8003d70:	4958      	ldr	r1, [pc, #352]	@ (8003ed4 <regelschritt+0x1364>)
 8003d72:	f7fc fd73 	bl	800085c <__aeabi_ddiv>
 8003d76:	4602      	mov	r2, r0
 8003d78:	460b      	mov	r3, r1
 8003d7a:	ec43 2b14 	vmov	d4, r2, r3
 8003d7e:	ed97 3b54 	vldr	d3, [r7, #336]	@ 0x150
 8003d82:	ed97 5b56 	vldr	d5, [r7, #344]	@ 0x158
 8003d86:	ed97 6b58 	vldr	d6, [r7, #352]	@ 0x160
 8003d8a:	ed97 7b5a 	vldr	d7, [r7, #360]	@ 0x168
 8003d8e:	eeb0 0a43 	vmov.f32	s0, s6
 8003d92:	eef0 0a63 	vmov.f32	s1, s7
 8003d96:	eeb0 1a45 	vmov.f32	s2, s10
 8003d9a:	eef0 1a65 	vmov.f32	s3, s11
 8003d9e:	eeb0 2a46 	vmov.f32	s4, s12
 8003da2:	eef0 2a66 	vmov.f32	s5, s13
 8003da6:	eeb0 3a47 	vmov.f32	s6, s14
 8003daa:	eef0 3a67 	vmov.f32	s7, s15
 8003dae:	f7fe f904 	bl	8001fba <scaleQuaternion>
 8003db2:	eeb0 4a40 	vmov.f32	s8, s0
 8003db6:	eef0 4a60 	vmov.f32	s9, s1
 8003dba:	eeb0 5a41 	vmov.f32	s10, s2
 8003dbe:	eef0 5a61 	vmov.f32	s11, s3
 8003dc2:	eeb0 6a42 	vmov.f32	s12, s4
 8003dc6:	eef0 6a62 	vmov.f32	s13, s5
 8003dca:	eeb0 7a43 	vmov.f32	s14, s6
 8003dce:	eef0 7a63 	vmov.f32	s15, s7
 8003dd2:	ed87 4b54 	vstr	d4, [r7, #336]	@ 0x150
 8003dd6:	ed87 5b56 	vstr	d5, [r7, #344]	@ 0x158
 8003dda:	ed87 6b58 	vstr	d6, [r7, #352]	@ 0x160
 8003dde:	ed87 7b5a 	vstr	d7, [r7, #360]	@ 0x168
	// quaternion_ganz[2] = q_target[2];
	// quaternion_ganz[3] = q_target[3];

	// Current thrust orientation e_z and desired thrust orientation e_z_d

	quad_dcm[0][0] = 1.0;
 8003de2:	493f      	ldr	r1, [pc, #252]	@ (8003ee0 <regelschritt+0x1370>)
 8003de4:	f04f 0200 	mov.w	r2, #0
 8003de8:	4b3a      	ldr	r3, [pc, #232]	@ (8003ed4 <regelschritt+0x1364>)
 8003dea:	e9c1 2300 	strd	r2, r3, [r1]
	quad_dcm[1][1] = 1.0;
 8003dee:	493c      	ldr	r1, [pc, #240]	@ (8003ee0 <regelschritt+0x1370>)
 8003df0:	f04f 0200 	mov.w	r2, #0
 8003df4:	4b37      	ldr	r3, [pc, #220]	@ (8003ed4 <regelschritt+0x1364>)
 8003df6:	e9c1 2308 	strd	r2, r3, [r1, #32]
	quad_dcm[2][2] = 1.0;
 8003dfa:	4939      	ldr	r1, [pc, #228]	@ (8003ee0 <regelschritt+0x1370>)
 8003dfc:	f04f 0200 	mov.w	r2, #0
 8003e00:	4b34      	ldr	r3, [pc, #208]	@ (8003ed4 <regelschritt+0x1364>)
 8003e02:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40

	e_z[0] = 0.0;
 8003e06:	4937      	ldr	r1, [pc, #220]	@ (8003ee4 <regelschritt+0x1374>)
 8003e08:	f04f 0200 	mov.w	r2, #0
 8003e0c:	f04f 0300 	mov.w	r3, #0
 8003e10:	e9c1 2300 	strd	r2, r3, [r1]
	e_z[1] = 0.0;
 8003e14:	4933      	ldr	r1, [pc, #204]	@ (8003ee4 <regelschritt+0x1374>)
 8003e16:	f04f 0200 	mov.w	r2, #0
 8003e1a:	f04f 0300 	mov.w	r3, #0
 8003e1e:	e9c1 2302 	strd	r2, r3, [r1, #8]
	e_z[2] = 1.0;
 8003e22:	4930      	ldr	r1, [pc, #192]	@ (8003ee4 <regelschritt+0x1374>)
 8003e24:	f04f 0200 	mov.w	r2, #0
 8003e28:	4b2a      	ldr	r3, [pc, #168]	@ (8003ed4 <regelschritt+0x1364>)
 8003e2a:	e9c1 2304 	strd	r2, r3, [r1, #16]

	double normSollschub = sqrt(
		sollschub[0] * sollschub[0] +
 8003e2e:	4b2e      	ldr	r3, [pc, #184]	@ (8003ee8 <regelschritt+0x1378>)
 8003e30:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003e34:	4b2c      	ldr	r3, [pc, #176]	@ (8003ee8 <regelschritt+0x1378>)
 8003e36:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003e3a:	f7fc fbe5 	bl	8000608 <__aeabi_dmul>
 8003e3e:	4602      	mov	r2, r0
 8003e40:	460b      	mov	r3, r1
 8003e42:	4614      	mov	r4, r2
 8003e44:	461d      	mov	r5, r3
		sollschub[1] * sollschub[1] +
 8003e46:	4b28      	ldr	r3, [pc, #160]	@ (8003ee8 <regelschritt+0x1378>)
 8003e48:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8003e4c:	4b26      	ldr	r3, [pc, #152]	@ (8003ee8 <regelschritt+0x1378>)
 8003e4e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003e52:	f7fc fbd9 	bl	8000608 <__aeabi_dmul>
 8003e56:	4602      	mov	r2, r0
 8003e58:	460b      	mov	r3, r1
		sollschub[0] * sollschub[0] +
 8003e5a:	4620      	mov	r0, r4
 8003e5c:	4629      	mov	r1, r5
 8003e5e:	f7fc fa1d 	bl	800029c <__adddf3>
 8003e62:	4602      	mov	r2, r0
 8003e64:	460b      	mov	r3, r1
 8003e66:	4614      	mov	r4, r2
 8003e68:	461d      	mov	r5, r3
		sollschub[2] * sollschub[2]
 8003e6a:	4b1f      	ldr	r3, [pc, #124]	@ (8003ee8 <regelschritt+0x1378>)
 8003e6c:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8003e70:	4b1d      	ldr	r3, [pc, #116]	@ (8003ee8 <regelschritt+0x1378>)
 8003e72:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003e76:	f7fc fbc7 	bl	8000608 <__aeabi_dmul>
 8003e7a:	4602      	mov	r2, r0
 8003e7c:	460b      	mov	r3, r1
	double normSollschub = sqrt(
 8003e7e:	4620      	mov	r0, r4
 8003e80:	4629      	mov	r1, r5
 8003e82:	f7fc fa0b 	bl	800029c <__adddf3>
 8003e86:	4602      	mov	r2, r0
 8003e88:	460b      	mov	r3, r1
 8003e8a:	ec43 2b17 	vmov	d7, r2, r3
 8003e8e:	eeb0 0a47 	vmov.f32	s0, s14
 8003e92:	eef0 0a67 	vmov.f32	s1, s15
 8003e96:	f01b fbd3 	bl	801f640 <sqrt>
 8003e9a:	ed87 0b72 	vstr	d0, [r7, #456]	@ 0x1c8
	);

	e_z_d[0] = -sollschub[0] / normSollschub;
 8003e9e:	4b12      	ldr	r3, [pc, #72]	@ (8003ee8 <regelschritt+0x1378>)
 8003ea0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003ea4:	65ba      	str	r2, [r7, #88]	@ 0x58
 8003ea6:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8003eaa:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8003eac:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	@ 0x1c8
 8003eb0:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
 8003eb4:	f7fc fcd2 	bl	800085c <__aeabi_ddiv>
 8003eb8:	4602      	mov	r2, r0
 8003eba:	460b      	mov	r3, r1
 8003ebc:	4610      	mov	r0, r2
 8003ebe:	4619      	mov	r1, r3
 8003ec0:	4b0a      	ldr	r3, [pc, #40]	@ (8003eec <regelschritt+0x137c>)
 8003ec2:	e9c3 0100 	strd	r0, r1, [r3]
	e_z_d[1] = -sollschub[1] / normSollschub;
 8003ec6:	4b08      	ldr	r3, [pc, #32]	@ (8003ee8 <regelschritt+0x1378>)
 8003ec8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003ecc:	653a      	str	r2, [r7, #80]	@ 0x50
 8003ece:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8003ed2:	e00d      	b.n	8003ef0 <regelschritt+0x1380>
 8003ed4:	3ff00000 	.word	0x3ff00000
 8003ed8:	3fe00000 	.word	0x3fe00000
 8003edc:	3fd00000 	.word	0x3fd00000
 8003ee0:	20001da8 	.word	0x20001da8
 8003ee4:	20001f08 	.word	0x20001f08
 8003ee8:	20001e48 	.word	0x20001e48
 8003eec:	20001f20 	.word	0x20001f20
 8003ef0:	657b      	str	r3, [r7, #84]	@ 0x54
 8003ef2:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	@ 0x1c8
 8003ef6:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
 8003efa:	f7fc fcaf 	bl	800085c <__aeabi_ddiv>
 8003efe:	4602      	mov	r2, r0
 8003f00:	460b      	mov	r3, r1
 8003f02:	4610      	mov	r0, r2
 8003f04:	4619      	mov	r1, r3
 8003f06:	4bab      	ldr	r3, [pc, #684]	@ (80041b4 <regelschritt+0x1644>)
 8003f08:	e9c3 0102 	strd	r0, r1, [r3, #8]
	e_z_d[2] = -sollschub[2] / normSollschub;
 8003f0c:	4baa      	ldr	r3, [pc, #680]	@ (80041b8 <regelschritt+0x1648>)
 8003f0e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003f12:	64ba      	str	r2, [r7, #72]	@ 0x48
 8003f14:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8003f18:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8003f1a:	e9d7 2372 	ldrd	r2, r3, [r7, #456]	@ 0x1c8
 8003f1e:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
 8003f22:	f7fc fc9b 	bl	800085c <__aeabi_ddiv>
 8003f26:	4602      	mov	r2, r0
 8003f28:	460b      	mov	r3, r1
 8003f2a:	4610      	mov	r0, r2
 8003f2c:	4619      	mov	r1, r3
 8003f2e:	4ba1      	ldr	r3, [pc, #644]	@ (80041b4 <regelschritt+0x1644>)
 8003f30:	e9c3 0104 	strd	r0, r1, [r3, #16]

	double quaternionfehler_reduziert_dot_part = (
		e_z[0] * e_z_d[0] +
 8003f34:	4ba1      	ldr	r3, [pc, #644]	@ (80041bc <regelschritt+0x164c>)
 8003f36:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003f3a:	4b9e      	ldr	r3, [pc, #632]	@ (80041b4 <regelschritt+0x1644>)
 8003f3c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003f40:	f7fc fb62 	bl	8000608 <__aeabi_dmul>
 8003f44:	4602      	mov	r2, r0
 8003f46:	460b      	mov	r3, r1
 8003f48:	4614      	mov	r4, r2
 8003f4a:	461d      	mov	r5, r3
		e_z[1] * e_z_d[1] +
 8003f4c:	4b9b      	ldr	r3, [pc, #620]	@ (80041bc <regelschritt+0x164c>)
 8003f4e:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8003f52:	4b98      	ldr	r3, [pc, #608]	@ (80041b4 <regelschritt+0x1644>)
 8003f54:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003f58:	f7fc fb56 	bl	8000608 <__aeabi_dmul>
 8003f5c:	4602      	mov	r2, r0
 8003f5e:	460b      	mov	r3, r1
		e_z[0] * e_z_d[0] +
 8003f60:	4620      	mov	r0, r4
 8003f62:	4629      	mov	r1, r5
 8003f64:	f7fc f99a 	bl	800029c <__adddf3>
 8003f68:	4602      	mov	r2, r0
 8003f6a:	460b      	mov	r3, r1
 8003f6c:	4614      	mov	r4, r2
 8003f6e:	461d      	mov	r5, r3
		e_z[2] * e_z_d[2]
 8003f70:	4b92      	ldr	r3, [pc, #584]	@ (80041bc <regelschritt+0x164c>)
 8003f72:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8003f76:	4b8f      	ldr	r3, [pc, #572]	@ (80041b4 <regelschritt+0x1644>)
 8003f78:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003f7c:	f7fc fb44 	bl	8000608 <__aeabi_dmul>
 8003f80:	4602      	mov	r2, r0
 8003f82:	460b      	mov	r3, r1
	double quaternionfehler_reduziert_dot_part = (
 8003f84:	4620      	mov	r0, r4
 8003f86:	4629      	mov	r1, r5
 8003f88:	f7fc f988 	bl	800029c <__adddf3>
 8003f8c:	4602      	mov	r2, r0
 8003f8e:	460b      	mov	r3, r1
 8003f90:	e9c7 2370 	strd	r2, r3, [r7, #448]	@ 0x1c0
	);

	e_z_norm = sqrt(
		e_z[0] * e_z[0] +
 8003f94:	4b89      	ldr	r3, [pc, #548]	@ (80041bc <regelschritt+0x164c>)
 8003f96:	e9d3 0100 	ldrd	r0, r1, [r3]
 8003f9a:	4b88      	ldr	r3, [pc, #544]	@ (80041bc <regelschritt+0x164c>)
 8003f9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8003fa0:	f7fc fb32 	bl	8000608 <__aeabi_dmul>
 8003fa4:	4602      	mov	r2, r0
 8003fa6:	460b      	mov	r3, r1
 8003fa8:	4614      	mov	r4, r2
 8003faa:	461d      	mov	r5, r3
		e_z[1] * e_z[1] +
 8003fac:	4b83      	ldr	r3, [pc, #524]	@ (80041bc <regelschritt+0x164c>)
 8003fae:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8003fb2:	4b82      	ldr	r3, [pc, #520]	@ (80041bc <regelschritt+0x164c>)
 8003fb4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8003fb8:	f7fc fb26 	bl	8000608 <__aeabi_dmul>
 8003fbc:	4602      	mov	r2, r0
 8003fbe:	460b      	mov	r3, r1
		e_z[0] * e_z[0] +
 8003fc0:	4620      	mov	r0, r4
 8003fc2:	4629      	mov	r1, r5
 8003fc4:	f7fc f96a 	bl	800029c <__adddf3>
 8003fc8:	4602      	mov	r2, r0
 8003fca:	460b      	mov	r3, r1
 8003fcc:	4614      	mov	r4, r2
 8003fce:	461d      	mov	r5, r3
		e_z[2] * e_z[2]
 8003fd0:	4b7a      	ldr	r3, [pc, #488]	@ (80041bc <regelschritt+0x164c>)
 8003fd2:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8003fd6:	4b79      	ldr	r3, [pc, #484]	@ (80041bc <regelschritt+0x164c>)
 8003fd8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003fdc:	f7fc fb14 	bl	8000608 <__aeabi_dmul>
 8003fe0:	4602      	mov	r2, r0
 8003fe2:	460b      	mov	r3, r1
	e_z_norm = sqrt(
 8003fe4:	4620      	mov	r0, r4
 8003fe6:	4629      	mov	r1, r5
 8003fe8:	f7fc f958 	bl	800029c <__adddf3>
 8003fec:	4602      	mov	r2, r0
 8003fee:	460b      	mov	r3, r1
 8003ff0:	ec43 2b17 	vmov	d7, r2, r3
 8003ff4:	eeb0 0a47 	vmov.f32	s0, s14
 8003ff8:	eef0 0a67 	vmov.f32	s1, s15
 8003ffc:	f01b fb20 	bl	801f640 <sqrt>
 8004000:	eeb0 7a40 	vmov.f32	s14, s0
 8004004:	eef0 7a60 	vmov.f32	s15, s1
 8004008:	4b6d      	ldr	r3, [pc, #436]	@ (80041c0 <regelschritt+0x1650>)
 800400a:	ed83 7b00 	vstr	d7, [r3]
	);

	e_z[0] = -e_z[0] / e_z_norm;
 800400e:	4b6b      	ldr	r3, [pc, #428]	@ (80041bc <regelschritt+0x164c>)
 8004010:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004014:	643a      	str	r2, [r7, #64]	@ 0x40
 8004016:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 800401a:	647b      	str	r3, [r7, #68]	@ 0x44
 800401c:	4b68      	ldr	r3, [pc, #416]	@ (80041c0 <regelschritt+0x1650>)
 800401e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004022:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
 8004026:	f7fc fc19 	bl	800085c <__aeabi_ddiv>
 800402a:	4602      	mov	r2, r0
 800402c:	460b      	mov	r3, r1
 800402e:	4610      	mov	r0, r2
 8004030:	4619      	mov	r1, r3
 8004032:	4b62      	ldr	r3, [pc, #392]	@ (80041bc <regelschritt+0x164c>)
 8004034:	e9c3 0100 	strd	r0, r1, [r3]
	e_z[1] = -e_z[1] / e_z_norm;
 8004038:	4b60      	ldr	r3, [pc, #384]	@ (80041bc <regelschritt+0x164c>)
 800403a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800403e:	63ba      	str	r2, [r7, #56]	@ 0x38
 8004040:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8004044:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8004046:	4b5e      	ldr	r3, [pc, #376]	@ (80041c0 <regelschritt+0x1650>)
 8004048:	e9d3 2300 	ldrd	r2, r3, [r3]
 800404c:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
 8004050:	f7fc fc04 	bl	800085c <__aeabi_ddiv>
 8004054:	4602      	mov	r2, r0
 8004056:	460b      	mov	r3, r1
 8004058:	4610      	mov	r0, r2
 800405a:	4619      	mov	r1, r3
 800405c:	4b57      	ldr	r3, [pc, #348]	@ (80041bc <regelschritt+0x164c>)
 800405e:	e9c3 0102 	strd	r0, r1, [r3, #8]
	e_z[2] = -e_z[2] / e_z_norm;
 8004062:	4b56      	ldr	r3, [pc, #344]	@ (80041bc <regelschritt+0x164c>)
 8004064:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004068:	633a      	str	r2, [r7, #48]	@ 0x30
 800406a:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 800406e:	637b      	str	r3, [r7, #52]	@ 0x34
 8004070:	4b53      	ldr	r3, [pc, #332]	@ (80041c0 <regelschritt+0x1650>)
 8004072:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004076:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
 800407a:	f7fc fbef 	bl	800085c <__aeabi_ddiv>
 800407e:	4602      	mov	r2, r0
 8004080:	460b      	mov	r3, r1
 8004082:	4610      	mov	r0, r2
 8004084:	4619      	mov	r1, r3
 8004086:	4b4d      	ldr	r3, [pc, #308]	@ (80041bc <regelschritt+0x164c>)
 8004088:	e9c3 0104 	strd	r0, r1, [r3, #16]

	double e_z_d_norm = sqrt(
		e_z_d[0] * e_z_d[0] +
 800408c:	4b49      	ldr	r3, [pc, #292]	@ (80041b4 <regelschritt+0x1644>)
 800408e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004092:	4b48      	ldr	r3, [pc, #288]	@ (80041b4 <regelschritt+0x1644>)
 8004094:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004098:	f7fc fab6 	bl	8000608 <__aeabi_dmul>
 800409c:	4602      	mov	r2, r0
 800409e:	460b      	mov	r3, r1
 80040a0:	4614      	mov	r4, r2
 80040a2:	461d      	mov	r5, r3
		e_z_d[1] * e_z_d[1] +
 80040a4:	4b43      	ldr	r3, [pc, #268]	@ (80041b4 <regelschritt+0x1644>)
 80040a6:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80040aa:	4b42      	ldr	r3, [pc, #264]	@ (80041b4 <regelschritt+0x1644>)
 80040ac:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80040b0:	f7fc faaa 	bl	8000608 <__aeabi_dmul>
 80040b4:	4602      	mov	r2, r0
 80040b6:	460b      	mov	r3, r1
		e_z_d[0] * e_z_d[0] +
 80040b8:	4620      	mov	r0, r4
 80040ba:	4629      	mov	r1, r5
 80040bc:	f7fc f8ee 	bl	800029c <__adddf3>
 80040c0:	4602      	mov	r2, r0
 80040c2:	460b      	mov	r3, r1
 80040c4:	4614      	mov	r4, r2
 80040c6:	461d      	mov	r5, r3
		e_z_d[2] * e_z_d[2]
 80040c8:	4b3a      	ldr	r3, [pc, #232]	@ (80041b4 <regelschritt+0x1644>)
 80040ca:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80040ce:	4b39      	ldr	r3, [pc, #228]	@ (80041b4 <regelschritt+0x1644>)
 80040d0:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80040d4:	f7fc fa98 	bl	8000608 <__aeabi_dmul>
 80040d8:	4602      	mov	r2, r0
 80040da:	460b      	mov	r3, r1
	double e_z_d_norm = sqrt(
 80040dc:	4620      	mov	r0, r4
 80040de:	4629      	mov	r1, r5
 80040e0:	f7fc f8dc 	bl	800029c <__adddf3>
 80040e4:	4602      	mov	r2, r0
 80040e6:	460b      	mov	r3, r1
 80040e8:	ec43 2b17 	vmov	d7, r2, r3
 80040ec:	eeb0 0a47 	vmov.f32	s0, s14
 80040f0:	eef0 0a67 	vmov.f32	s1, s15
 80040f4:	f01b faa4 	bl	801f640 <sqrt>
 80040f8:	ed87 0b6e 	vstr	d0, [r7, #440]	@ 0x1b8
	);

	e_z_d[0] = -e_z_d[0] / e_z_d_norm;
 80040fc:	4b2d      	ldr	r3, [pc, #180]	@ (80041b4 <regelschritt+0x1644>)
 80040fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004102:	62ba      	str	r2, [r7, #40]	@ 0x28
 8004104:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8004108:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800410a:	e9d7 236e 	ldrd	r2, r3, [r7, #440]	@ 0x1b8
 800410e:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 8004112:	f7fc fba3 	bl	800085c <__aeabi_ddiv>
 8004116:	4602      	mov	r2, r0
 8004118:	460b      	mov	r3, r1
 800411a:	4926      	ldr	r1, [pc, #152]	@ (80041b4 <regelschritt+0x1644>)
 800411c:	e9c1 2300 	strd	r2, r3, [r1]
	e_z_d[1] = -e_z_d[1] / e_z_d_norm;
 8004120:	4b24      	ldr	r3, [pc, #144]	@ (80041b4 <regelschritt+0x1644>)
 8004122:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004126:	623a      	str	r2, [r7, #32]
 8004128:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 800412c:	627b      	str	r3, [r7, #36]	@ 0x24
 800412e:	e9d7 236e 	ldrd	r2, r3, [r7, #440]	@ 0x1b8
 8004132:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8004136:	f7fc fb91 	bl	800085c <__aeabi_ddiv>
 800413a:	4602      	mov	r2, r0
 800413c:	460b      	mov	r3, r1
 800413e:	491d      	ldr	r1, [pc, #116]	@ (80041b4 <regelschritt+0x1644>)
 8004140:	e9c1 2302 	strd	r2, r3, [r1, #8]
	e_z_d[2] = -e_z_d[2] / e_z_d_norm;
 8004144:	4b1b      	ldr	r3, [pc, #108]	@ (80041b4 <regelschritt+0x1644>)
 8004146:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800414a:	61ba      	str	r2, [r7, #24]
 800414c:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8004150:	61fb      	str	r3, [r7, #28]
 8004152:	e9d7 236e 	ldrd	r2, r3, [r7, #440]	@ 0x1b8
 8004156:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
 800415a:	f7fc fb7f 	bl	800085c <__aeabi_ddiv>
 800415e:	4602      	mov	r2, r0
 8004160:	460b      	mov	r3, r1
 8004162:	4914      	ldr	r1, [pc, #80]	@ (80041b4 <regelschritt+0x1644>)
 8004164:	e9c1 2304 	strd	r2, r3, [r1, #16]

	quaternionfehler_reduziert.w = quaternionfehler_reduziert_dot_part + sqrt(
		e_z[0] * e_z[0] +
 8004168:	4b14      	ldr	r3, [pc, #80]	@ (80041bc <regelschritt+0x164c>)
 800416a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800416e:	4b13      	ldr	r3, [pc, #76]	@ (80041bc <regelschritt+0x164c>)
 8004170:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004174:	f7fc fa48 	bl	8000608 <__aeabi_dmul>
 8004178:	4602      	mov	r2, r0
 800417a:	460b      	mov	r3, r1
 800417c:	4614      	mov	r4, r2
 800417e:	461d      	mov	r5, r3
		e_z[1] * e_z[1] +
 8004180:	4b0e      	ldr	r3, [pc, #56]	@ (80041bc <regelschritt+0x164c>)
 8004182:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004186:	4b0d      	ldr	r3, [pc, #52]	@ (80041bc <regelschritt+0x164c>)
 8004188:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800418c:	f7fc fa3c 	bl	8000608 <__aeabi_dmul>
 8004190:	4602      	mov	r2, r0
 8004192:	460b      	mov	r3, r1
		e_z[0] * e_z[0] +
 8004194:	4620      	mov	r0, r4
 8004196:	4629      	mov	r1, r5
 8004198:	f7fc f880 	bl	800029c <__adddf3>
 800419c:	4602      	mov	r2, r0
 800419e:	460b      	mov	r3, r1
 80041a0:	4614      	mov	r4, r2
 80041a2:	461d      	mov	r5, r3
		e_z[2] * e_z[2] +
 80041a4:	4b05      	ldr	r3, [pc, #20]	@ (80041bc <regelschritt+0x164c>)
 80041a6:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80041aa:	4b04      	ldr	r3, [pc, #16]	@ (80041bc <regelschritt+0x164c>)
 80041ac:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80041b0:	e008      	b.n	80041c4 <regelschritt+0x1654>
 80041b2:	bf00      	nop
 80041b4:	20001f20 	.word	0x20001f20
 80041b8:	20001e48 	.word	0x20001e48
 80041bc:	20001f08 	.word	0x20001f08
 80041c0:	20002008 	.word	0x20002008
 80041c4:	f7fc fa20 	bl	8000608 <__aeabi_dmul>
 80041c8:	4602      	mov	r2, r0
 80041ca:	460b      	mov	r3, r1
		e_z[1] * e_z[1] +
 80041cc:	4620      	mov	r0, r4
 80041ce:	4629      	mov	r1, r5
 80041d0:	f7fc f864 	bl	800029c <__adddf3>
 80041d4:	4602      	mov	r2, r0
 80041d6:	460b      	mov	r3, r1
 80041d8:	4614      	mov	r4, r2
 80041da:	461d      	mov	r5, r3
		e_z_d[0] * e_z_d[0] +
 80041dc:	4bb2      	ldr	r3, [pc, #712]	@ (80044a8 <regelschritt+0x1938>)
 80041de:	e9d3 0100 	ldrd	r0, r1, [r3]
 80041e2:	4bb1      	ldr	r3, [pc, #708]	@ (80044a8 <regelschritt+0x1938>)
 80041e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80041e8:	f7fc fa0e 	bl	8000608 <__aeabi_dmul>
 80041ec:	4602      	mov	r2, r0
 80041ee:	460b      	mov	r3, r1
		e_z[2] * e_z[2] +
 80041f0:	4620      	mov	r0, r4
 80041f2:	4629      	mov	r1, r5
 80041f4:	f7fc f852 	bl	800029c <__adddf3>
 80041f8:	4602      	mov	r2, r0
 80041fa:	460b      	mov	r3, r1
 80041fc:	4614      	mov	r4, r2
 80041fe:	461d      	mov	r5, r3
		e_z_d[1] * e_z_d[1] +
 8004200:	4ba9      	ldr	r3, [pc, #676]	@ (80044a8 <regelschritt+0x1938>)
 8004202:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004206:	4ba8      	ldr	r3, [pc, #672]	@ (80044a8 <regelschritt+0x1938>)
 8004208:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800420c:	f7fc f9fc 	bl	8000608 <__aeabi_dmul>
 8004210:	4602      	mov	r2, r0
 8004212:	460b      	mov	r3, r1
		e_z_d[0] * e_z_d[0] +
 8004214:	4620      	mov	r0, r4
 8004216:	4629      	mov	r1, r5
 8004218:	f7fc f840 	bl	800029c <__adddf3>
 800421c:	4602      	mov	r2, r0
 800421e:	460b      	mov	r3, r1
 8004220:	4614      	mov	r4, r2
 8004222:	461d      	mov	r5, r3
		e_z_d[2] * e_z_d[2]
 8004224:	4ba0      	ldr	r3, [pc, #640]	@ (80044a8 <regelschritt+0x1938>)
 8004226:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800422a:	4b9f      	ldr	r3, [pc, #636]	@ (80044a8 <regelschritt+0x1938>)
 800422c:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004230:	f7fc f9ea 	bl	8000608 <__aeabi_dmul>
 8004234:	4602      	mov	r2, r0
 8004236:	460b      	mov	r3, r1
	quaternionfehler_reduziert.w = quaternionfehler_reduziert_dot_part + sqrt(
 8004238:	4620      	mov	r0, r4
 800423a:	4629      	mov	r1, r5
 800423c:	f7fc f82e 	bl	800029c <__adddf3>
 8004240:	4602      	mov	r2, r0
 8004242:	460b      	mov	r3, r1
 8004244:	ec43 2b17 	vmov	d7, r2, r3
 8004248:	eeb0 0a47 	vmov.f32	s0, s14
 800424c:	eef0 0a67 	vmov.f32	s1, s15
 8004250:	f01b f9f6 	bl	801f640 <sqrt>
 8004254:	ec51 0b10 	vmov	r0, r1, d0
 8004258:	e9d7 2370 	ldrd	r2, r3, [r7, #448]	@ 0x1c0
 800425c:	f7fc f81e 	bl	800029c <__adddf3>
 8004260:	4602      	mov	r2, r0
 8004262:	460b      	mov	r3, r1
 8004264:	4991      	ldr	r1, [pc, #580]	@ (80044ac <regelschritt+0x193c>)
 8004266:	e9c1 2300 	strd	r2, r3, [r1]
	);

	quaternionfehler_reduziert.x = (
		e_z[1] * e_z_d[2] -
 800426a:	4b91      	ldr	r3, [pc, #580]	@ (80044b0 <regelschritt+0x1940>)
 800426c:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004270:	4b8d      	ldr	r3, [pc, #564]	@ (80044a8 <regelschritt+0x1938>)
 8004272:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004276:	f7fc f9c7 	bl	8000608 <__aeabi_dmul>
 800427a:	4602      	mov	r2, r0
 800427c:	460b      	mov	r3, r1
 800427e:	4614      	mov	r4, r2
 8004280:	461d      	mov	r5, r3
		e_z[2] * e_z_d[1]
 8004282:	4b8b      	ldr	r3, [pc, #556]	@ (80044b0 <regelschritt+0x1940>)
 8004284:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004288:	4b87      	ldr	r3, [pc, #540]	@ (80044a8 <regelschritt+0x1938>)
 800428a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800428e:	f7fc f9bb 	bl	8000608 <__aeabi_dmul>
 8004292:	4602      	mov	r2, r0
 8004294:	460b      	mov	r3, r1
		e_z[1] * e_z_d[2] -
 8004296:	4620      	mov	r0, r4
 8004298:	4629      	mov	r1, r5
 800429a:	f7fb fffd 	bl	8000298 <__aeabi_dsub>
 800429e:	4602      	mov	r2, r0
 80042a0:	460b      	mov	r3, r1
	quaternionfehler_reduziert.x = (
 80042a2:	4982      	ldr	r1, [pc, #520]	@ (80044ac <regelschritt+0x193c>)
 80042a4:	e9c1 2302 	strd	r2, r3, [r1, #8]
	);
	quaternionfehler_reduziert.y = (
		e_z[2] * e_z_d[0] -
 80042a8:	4b81      	ldr	r3, [pc, #516]	@ (80044b0 <regelschritt+0x1940>)
 80042aa:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80042ae:	4b7e      	ldr	r3, [pc, #504]	@ (80044a8 <regelschritt+0x1938>)
 80042b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80042b4:	f7fc f9a8 	bl	8000608 <__aeabi_dmul>
 80042b8:	4602      	mov	r2, r0
 80042ba:	460b      	mov	r3, r1
 80042bc:	4614      	mov	r4, r2
 80042be:	461d      	mov	r5, r3
		e_z[0] * e_z_d[2]
 80042c0:	4b7b      	ldr	r3, [pc, #492]	@ (80044b0 <regelschritt+0x1940>)
 80042c2:	e9d3 0100 	ldrd	r0, r1, [r3]
 80042c6:	4b78      	ldr	r3, [pc, #480]	@ (80044a8 <regelschritt+0x1938>)
 80042c8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80042cc:	f7fc f99c 	bl	8000608 <__aeabi_dmul>
 80042d0:	4602      	mov	r2, r0
 80042d2:	460b      	mov	r3, r1
		e_z[2] * e_z_d[0] -
 80042d4:	4620      	mov	r0, r4
 80042d6:	4629      	mov	r1, r5
 80042d8:	f7fb ffde 	bl	8000298 <__aeabi_dsub>
 80042dc:	4602      	mov	r2, r0
 80042de:	460b      	mov	r3, r1
	quaternionfehler_reduziert.y = (
 80042e0:	4972      	ldr	r1, [pc, #456]	@ (80044ac <regelschritt+0x193c>)
 80042e2:	e9c1 2304 	strd	r2, r3, [r1, #16]
	);
	quaternionfehler_reduziert.z = (
		e_z[0] * e_z_d[1] -
 80042e6:	4b72      	ldr	r3, [pc, #456]	@ (80044b0 <regelschritt+0x1940>)
 80042e8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80042ec:	4b6e      	ldr	r3, [pc, #440]	@ (80044a8 <regelschritt+0x1938>)
 80042ee:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80042f2:	f7fc f989 	bl	8000608 <__aeabi_dmul>
 80042f6:	4602      	mov	r2, r0
 80042f8:	460b      	mov	r3, r1
 80042fa:	4614      	mov	r4, r2
 80042fc:	461d      	mov	r5, r3
		e_z[1] * e_z_d[0]
 80042fe:	4b6c      	ldr	r3, [pc, #432]	@ (80044b0 <regelschritt+0x1940>)
 8004300:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004304:	4b68      	ldr	r3, [pc, #416]	@ (80044a8 <regelschritt+0x1938>)
 8004306:	e9d3 2300 	ldrd	r2, r3, [r3]
 800430a:	f7fc f97d 	bl	8000608 <__aeabi_dmul>
 800430e:	4602      	mov	r2, r0
 8004310:	460b      	mov	r3, r1
		e_z[0] * e_z_d[1] -
 8004312:	4620      	mov	r0, r4
 8004314:	4629      	mov	r1, r5
 8004316:	f7fb ffbf 	bl	8000298 <__aeabi_dsub>
 800431a:	4602      	mov	r2, r0
 800431c:	460b      	mov	r3, r1
	quaternionfehler_reduziert.z = (
 800431e:	4963      	ldr	r1, [pc, #396]	@ (80044ac <regelschritt+0x193c>)
 8004320:	e9c1 2306 	strd	r2, r3, [r1, #24]
	);

	qe_norm = normQuaternion(quaternionfehler_reduziert);
 8004324:	4b61      	ldr	r3, [pc, #388]	@ (80044ac <regelschritt+0x193c>)
 8004326:	ed93 4b00 	vldr	d4, [r3]
 800432a:	ed93 5b02 	vldr	d5, [r3, #8]
 800432e:	ed93 6b04 	vldr	d6, [r3, #16]
 8004332:	ed93 7b06 	vldr	d7, [r3, #24]
 8004336:	eeb0 0a44 	vmov.f32	s0, s8
 800433a:	eef0 0a64 	vmov.f32	s1, s9
 800433e:	eeb0 1a45 	vmov.f32	s2, s10
 8004342:	eef0 1a65 	vmov.f32	s3, s11
 8004346:	eeb0 2a46 	vmov.f32	s4, s12
 800434a:	eef0 2a66 	vmov.f32	s5, s13
 800434e:	eeb0 3a47 	vmov.f32	s6, s14
 8004352:	eef0 3a67 	vmov.f32	s7, s15
 8004356:	f7fd fd2d 	bl	8001db4 <normQuaternion>
 800435a:	eeb0 7a40 	vmov.f32	s14, s0
 800435e:	eef0 7a60 	vmov.f32	s15, s1
 8004362:	4b54      	ldr	r3, [pc, #336]	@ (80044b4 <regelschritt+0x1944>)
 8004364:	ed83 7b00 	vstr	d7, [r3]

	quaternionfehler_reduziert.w /= qe_norm;
 8004368:	4b50      	ldr	r3, [pc, #320]	@ (80044ac <regelschritt+0x193c>)
 800436a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800436e:	4b51      	ldr	r3, [pc, #324]	@ (80044b4 <regelschritt+0x1944>)
 8004370:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004374:	f7fc fa72 	bl	800085c <__aeabi_ddiv>
 8004378:	4602      	mov	r2, r0
 800437a:	460b      	mov	r3, r1
 800437c:	494b      	ldr	r1, [pc, #300]	@ (80044ac <regelschritt+0x193c>)
 800437e:	e9c1 2300 	strd	r2, r3, [r1]
	quaternionfehler_reduziert.x /= qe_norm;
 8004382:	4b4a      	ldr	r3, [pc, #296]	@ (80044ac <regelschritt+0x193c>)
 8004384:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004388:	4b4a      	ldr	r3, [pc, #296]	@ (80044b4 <regelschritt+0x1944>)
 800438a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800438e:	f7fc fa65 	bl	800085c <__aeabi_ddiv>
 8004392:	4602      	mov	r2, r0
 8004394:	460b      	mov	r3, r1
 8004396:	4945      	ldr	r1, [pc, #276]	@ (80044ac <regelschritt+0x193c>)
 8004398:	e9c1 2302 	strd	r2, r3, [r1, #8]
	quaternionfehler_reduziert.y /= qe_norm;
 800439c:	4b43      	ldr	r3, [pc, #268]	@ (80044ac <regelschritt+0x193c>)
 800439e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80043a2:	4b44      	ldr	r3, [pc, #272]	@ (80044b4 <regelschritt+0x1944>)
 80043a4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80043a8:	f7fc fa58 	bl	800085c <__aeabi_ddiv>
 80043ac:	4602      	mov	r2, r0
 80043ae:	460b      	mov	r3, r1
 80043b0:	493e      	ldr	r1, [pc, #248]	@ (80044ac <regelschritt+0x193c>)
 80043b2:	e9c1 2304 	strd	r2, r3, [r1, #16]
	quaternionfehler_reduziert.z /= qe_norm;
 80043b6:	4b3d      	ldr	r3, [pc, #244]	@ (80044ac <regelschritt+0x193c>)
 80043b8:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 80043bc:	4b3d      	ldr	r3, [pc, #244]	@ (80044b4 <regelschritt+0x1944>)
 80043be:	e9d3 2300 	ldrd	r2, r3, [r3]
 80043c2:	f7fc fa4b 	bl	800085c <__aeabi_ddiv>
 80043c6:	4602      	mov	r2, r0
 80043c8:	460b      	mov	r3, r1
 80043ca:	4938      	ldr	r1, [pc, #224]	@ (80044ac <regelschritt+0x193c>)
 80043cc:	e9c1 2306 	strd	r2, r3, [r1, #24]
	// Reduced desired quaternion (reduced because it doesn't consider the desired Yaw angle)
	// Mixed desired quaternion (between reduced and full) and resulting desired quaternion qd

	Quaternion qd_reduziert;
	qd_reduziert.w = (
		quaternionfehler_reduziert.w * drehlage.w -
 80043d0:	4b36      	ldr	r3, [pc, #216]	@ (80044ac <regelschritt+0x193c>)
 80043d2:	e9d3 0100 	ldrd	r0, r1, [r3]
 80043d6:	4b38      	ldr	r3, [pc, #224]	@ (80044b8 <regelschritt+0x1948>)
 80043d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80043dc:	f7fc f914 	bl	8000608 <__aeabi_dmul>
 80043e0:	4602      	mov	r2, r0
 80043e2:	460b      	mov	r3, r1
 80043e4:	4614      	mov	r4, r2
 80043e6:	461d      	mov	r5, r3
		quaternionfehler_reduziert.x * drehlage.x -
 80043e8:	4b30      	ldr	r3, [pc, #192]	@ (80044ac <regelschritt+0x193c>)
 80043ea:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80043ee:	4b32      	ldr	r3, [pc, #200]	@ (80044b8 <regelschritt+0x1948>)
 80043f0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80043f4:	f7fc f908 	bl	8000608 <__aeabi_dmul>
 80043f8:	4602      	mov	r2, r0
 80043fa:	460b      	mov	r3, r1
		quaternionfehler_reduziert.w * drehlage.w -
 80043fc:	4620      	mov	r0, r4
 80043fe:	4629      	mov	r1, r5
 8004400:	f7fb ff4a 	bl	8000298 <__aeabi_dsub>
 8004404:	4602      	mov	r2, r0
 8004406:	460b      	mov	r3, r1
 8004408:	4614      	mov	r4, r2
 800440a:	461d      	mov	r5, r3
		quaternionfehler_reduziert.y * drehlage.y -
 800440c:	4b27      	ldr	r3, [pc, #156]	@ (80044ac <regelschritt+0x193c>)
 800440e:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004412:	4b29      	ldr	r3, [pc, #164]	@ (80044b8 <regelschritt+0x1948>)
 8004414:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004418:	f7fc f8f6 	bl	8000608 <__aeabi_dmul>
 800441c:	4602      	mov	r2, r0
 800441e:	460b      	mov	r3, r1
		quaternionfehler_reduziert.x * drehlage.x -
 8004420:	4620      	mov	r0, r4
 8004422:	4629      	mov	r1, r5
 8004424:	f7fb ff38 	bl	8000298 <__aeabi_dsub>
 8004428:	4602      	mov	r2, r0
 800442a:	460b      	mov	r3, r1
 800442c:	4614      	mov	r4, r2
 800442e:	461d      	mov	r5, r3
		quaternionfehler_reduziert.z * drehlage.z
 8004430:	4b1e      	ldr	r3, [pc, #120]	@ (80044ac <regelschritt+0x193c>)
 8004432:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8004436:	4b20      	ldr	r3, [pc, #128]	@ (80044b8 <regelschritt+0x1948>)
 8004438:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800443c:	f7fc f8e4 	bl	8000608 <__aeabi_dmul>
 8004440:	4602      	mov	r2, r0
 8004442:	460b      	mov	r3, r1
		quaternionfehler_reduziert.y * drehlage.y -
 8004444:	4620      	mov	r0, r4
 8004446:	4629      	mov	r1, r5
 8004448:	f7fb ff26 	bl	8000298 <__aeabi_dsub>
 800444c:	4602      	mov	r2, r0
 800444e:	460b      	mov	r3, r1
	qd_reduziert.w = (
 8004450:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 8004454:	f5a1 718c 	sub.w	r1, r1, #280	@ 0x118
 8004458:	e9c1 2300 	strd	r2, r3, [r1]
	);
	qd_reduziert.x = (
		quaternionfehler_reduziert.x * drehlage.w +
 800445c:	4b13      	ldr	r3, [pc, #76]	@ (80044ac <regelschritt+0x193c>)
 800445e:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004462:	4b15      	ldr	r3, [pc, #84]	@ (80044b8 <regelschritt+0x1948>)
 8004464:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004468:	f7fc f8ce 	bl	8000608 <__aeabi_dmul>
 800446c:	4602      	mov	r2, r0
 800446e:	460b      	mov	r3, r1
 8004470:	4614      	mov	r4, r2
 8004472:	461d      	mov	r5, r3
		quaternionfehler_reduziert.w * drehlage.x -
 8004474:	4b0d      	ldr	r3, [pc, #52]	@ (80044ac <regelschritt+0x193c>)
 8004476:	e9d3 0100 	ldrd	r0, r1, [r3]
 800447a:	4b0f      	ldr	r3, [pc, #60]	@ (80044b8 <regelschritt+0x1948>)
 800447c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004480:	f7fc f8c2 	bl	8000608 <__aeabi_dmul>
 8004484:	4602      	mov	r2, r0
 8004486:	460b      	mov	r3, r1
		quaternionfehler_reduziert.x * drehlage.w +
 8004488:	4620      	mov	r0, r4
 800448a:	4629      	mov	r1, r5
 800448c:	f7fb ff06 	bl	800029c <__adddf3>
 8004490:	4602      	mov	r2, r0
 8004492:	460b      	mov	r3, r1
 8004494:	4614      	mov	r4, r2
 8004496:	461d      	mov	r5, r3
		quaternionfehler_reduziert.z * drehlage.y +
 8004498:	4b04      	ldr	r3, [pc, #16]	@ (80044ac <regelschritt+0x193c>)
 800449a:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800449e:	4b06      	ldr	r3, [pc, #24]	@ (80044b8 <regelschritt+0x1948>)
 80044a0:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80044a4:	e00a      	b.n	80044bc <regelschritt+0x194c>
 80044a6:	bf00      	nop
 80044a8:	20001f20 	.word	0x20001f20
 80044ac:	20001f38 	.word	0x20001f38
 80044b0:	20001f08 	.word	0x20001f08
 80044b4:	20002010 	.word	0x20002010
 80044b8:	20001d28 	.word	0x20001d28
 80044bc:	f7fc f8a4 	bl	8000608 <__aeabi_dmul>
 80044c0:	4602      	mov	r2, r0
 80044c2:	460b      	mov	r3, r1
		quaternionfehler_reduziert.w * drehlage.x -
 80044c4:	4620      	mov	r0, r4
 80044c6:	4629      	mov	r1, r5
 80044c8:	f7fb fee6 	bl	8000298 <__aeabi_dsub>
 80044cc:	4602      	mov	r2, r0
 80044ce:	460b      	mov	r3, r1
 80044d0:	4614      	mov	r4, r2
 80044d2:	461d      	mov	r5, r3
		quaternionfehler_reduziert.y * drehlage.z
 80044d4:	4bcc      	ldr	r3, [pc, #816]	@ (8004808 <regelschritt+0x1c98>)
 80044d6:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80044da:	4bcc      	ldr	r3, [pc, #816]	@ (800480c <regelschritt+0x1c9c>)
 80044dc:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80044e0:	f7fc f892 	bl	8000608 <__aeabi_dmul>
 80044e4:	4602      	mov	r2, r0
 80044e6:	460b      	mov	r3, r1
		quaternionfehler_reduziert.z * drehlage.y +
 80044e8:	4620      	mov	r0, r4
 80044ea:	4629      	mov	r1, r5
 80044ec:	f7fb fed6 	bl	800029c <__adddf3>
 80044f0:	4602      	mov	r2, r0
 80044f2:	460b      	mov	r3, r1
	qd_reduziert.x = (
 80044f4:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 80044f8:	f5a1 718c 	sub.w	r1, r1, #280	@ 0x118
 80044fc:	e9c1 2302 	strd	r2, r3, [r1, #8]
	);
	qd_reduziert.y = (
		quaternionfehler_reduziert.y * drehlage.w +
 8004500:	4bc1      	ldr	r3, [pc, #772]	@ (8004808 <regelschritt+0x1c98>)
 8004502:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004506:	4bc1      	ldr	r3, [pc, #772]	@ (800480c <regelschritt+0x1c9c>)
 8004508:	e9d3 2300 	ldrd	r2, r3, [r3]
 800450c:	f7fc f87c 	bl	8000608 <__aeabi_dmul>
 8004510:	4602      	mov	r2, r0
 8004512:	460b      	mov	r3, r1
 8004514:	4614      	mov	r4, r2
 8004516:	461d      	mov	r5, r3
		quaternionfehler_reduziert.z * drehlage.x +
 8004518:	4bbb      	ldr	r3, [pc, #748]	@ (8004808 <regelschritt+0x1c98>)
 800451a:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 800451e:	4bbb      	ldr	r3, [pc, #748]	@ (800480c <regelschritt+0x1c9c>)
 8004520:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004524:	f7fc f870 	bl	8000608 <__aeabi_dmul>
 8004528:	4602      	mov	r2, r0
 800452a:	460b      	mov	r3, r1
		quaternionfehler_reduziert.y * drehlage.w +
 800452c:	4620      	mov	r0, r4
 800452e:	4629      	mov	r1, r5
 8004530:	f7fb feb4 	bl	800029c <__adddf3>
 8004534:	4602      	mov	r2, r0
 8004536:	460b      	mov	r3, r1
 8004538:	4614      	mov	r4, r2
 800453a:	461d      	mov	r5, r3
		quaternionfehler_reduziert.w * drehlage.y -
 800453c:	4bb2      	ldr	r3, [pc, #712]	@ (8004808 <regelschritt+0x1c98>)
 800453e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004542:	4bb2      	ldr	r3, [pc, #712]	@ (800480c <regelschritt+0x1c9c>)
 8004544:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004548:	f7fc f85e 	bl	8000608 <__aeabi_dmul>
 800454c:	4602      	mov	r2, r0
 800454e:	460b      	mov	r3, r1
		quaternionfehler_reduziert.z * drehlage.x +
 8004550:	4620      	mov	r0, r4
 8004552:	4629      	mov	r1, r5
 8004554:	f7fb fea2 	bl	800029c <__adddf3>
 8004558:	4602      	mov	r2, r0
 800455a:	460b      	mov	r3, r1
 800455c:	4614      	mov	r4, r2
 800455e:	461d      	mov	r5, r3
		quaternionfehler_reduziert.x * drehlage.z
 8004560:	4ba9      	ldr	r3, [pc, #676]	@ (8004808 <regelschritt+0x1c98>)
 8004562:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004566:	4ba9      	ldr	r3, [pc, #676]	@ (800480c <regelschritt+0x1c9c>)
 8004568:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 800456c:	f7fc f84c 	bl	8000608 <__aeabi_dmul>
 8004570:	4602      	mov	r2, r0
 8004572:	460b      	mov	r3, r1
		quaternionfehler_reduziert.w * drehlage.y -
 8004574:	4620      	mov	r0, r4
 8004576:	4629      	mov	r1, r5
 8004578:	f7fb fe8e 	bl	8000298 <__aeabi_dsub>
 800457c:	4602      	mov	r2, r0
 800457e:	460b      	mov	r3, r1
	qd_reduziert.y = (
 8004580:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 8004584:	f5a1 718c 	sub.w	r1, r1, #280	@ 0x118
 8004588:	e9c1 2304 	strd	r2, r3, [r1, #16]
	);
	qd_reduziert.z = (
		quaternionfehler_reduziert.z * drehlage.w -
 800458c:	4b9e      	ldr	r3, [pc, #632]	@ (8004808 <regelschritt+0x1c98>)
 800458e:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8004592:	4b9e      	ldr	r3, [pc, #632]	@ (800480c <regelschritt+0x1c9c>)
 8004594:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004598:	f7fc f836 	bl	8000608 <__aeabi_dmul>
 800459c:	4602      	mov	r2, r0
 800459e:	460b      	mov	r3, r1
 80045a0:	4614      	mov	r4, r2
 80045a2:	461d      	mov	r5, r3
		quaternionfehler_reduziert.y * drehlage.x +
 80045a4:	4b98      	ldr	r3, [pc, #608]	@ (8004808 <regelschritt+0x1c98>)
 80045a6:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80045aa:	4b98      	ldr	r3, [pc, #608]	@ (800480c <regelschritt+0x1c9c>)
 80045ac:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80045b0:	f7fc f82a 	bl	8000608 <__aeabi_dmul>
 80045b4:	4602      	mov	r2, r0
 80045b6:	460b      	mov	r3, r1
		quaternionfehler_reduziert.z * drehlage.w -
 80045b8:	4620      	mov	r0, r4
 80045ba:	4629      	mov	r1, r5
 80045bc:	f7fb fe6c 	bl	8000298 <__aeabi_dsub>
 80045c0:	4602      	mov	r2, r0
 80045c2:	460b      	mov	r3, r1
 80045c4:	4614      	mov	r4, r2
 80045c6:	461d      	mov	r5, r3
		quaternionfehler_reduziert.x * drehlage.y +
 80045c8:	4b8f      	ldr	r3, [pc, #572]	@ (8004808 <regelschritt+0x1c98>)
 80045ca:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 80045ce:	4b8f      	ldr	r3, [pc, #572]	@ (800480c <regelschritt+0x1c9c>)
 80045d0:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80045d4:	f7fc f818 	bl	8000608 <__aeabi_dmul>
 80045d8:	4602      	mov	r2, r0
 80045da:	460b      	mov	r3, r1
		quaternionfehler_reduziert.y * drehlage.x +
 80045dc:	4620      	mov	r0, r4
 80045de:	4629      	mov	r1, r5
 80045e0:	f7fb fe5c 	bl	800029c <__adddf3>
 80045e4:	4602      	mov	r2, r0
 80045e6:	460b      	mov	r3, r1
 80045e8:	4614      	mov	r4, r2
 80045ea:	461d      	mov	r5, r3
		quaternionfehler_reduziert.w * drehlage.z
 80045ec:	4b86      	ldr	r3, [pc, #536]	@ (8004808 <regelschritt+0x1c98>)
 80045ee:	e9d3 0100 	ldrd	r0, r1, [r3]
 80045f2:	4b86      	ldr	r3, [pc, #536]	@ (800480c <regelschritt+0x1c9c>)
 80045f4:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 80045f8:	f7fc f806 	bl	8000608 <__aeabi_dmul>
 80045fc:	4602      	mov	r2, r0
 80045fe:	460b      	mov	r3, r1
		quaternionfehler_reduziert.x * drehlage.y +
 8004600:	4620      	mov	r0, r4
 8004602:	4629      	mov	r1, r5
 8004604:	f7fb fe4a 	bl	800029c <__adddf3>
 8004608:	4602      	mov	r2, r0
 800460a:	460b      	mov	r3, r1
	qd_reduziert.z = (
 800460c:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 8004610:	f5a1 718c 	sub.w	r1, r1, #280	@ 0x118
 8004614:	e9c1 2306 	strd	r2, r3, [r1, #24]
	);

	Quaternion qd_reduziert_inverse = inverseQuaternion(qd_reduziert);
 8004618:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 800461c:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 8004620:	ed93 4b00 	vldr	d4, [r3]
 8004624:	ed93 5b02 	vldr	d5, [r3, #8]
 8004628:	ed93 6b04 	vldr	d6, [r3, #16]
 800462c:	ed93 7b06 	vldr	d7, [r3, #24]
 8004630:	eeb0 0a44 	vmov.f32	s0, s8
 8004634:	eef0 0a64 	vmov.f32	s1, s9
 8004638:	eeb0 1a45 	vmov.f32	s2, s10
 800463c:	eef0 1a65 	vmov.f32	s3, s11
 8004640:	eeb0 2a46 	vmov.f32	s4, s12
 8004644:	eef0 2a66 	vmov.f32	s5, s13
 8004648:	eeb0 3a47 	vmov.f32	s6, s14
 800464c:	eef0 3a67 	vmov.f32	s7, s15
 8004650:	f7fd fc16 	bl	8001e80 <inverseQuaternion>
 8004654:	eeb0 4a40 	vmov.f32	s8, s0
 8004658:	eef0 4a60 	vmov.f32	s9, s1
 800465c:	eeb0 5a41 	vmov.f32	s10, s2
 8004660:	eef0 5a61 	vmov.f32	s11, s3
 8004664:	eeb0 6a42 	vmov.f32	s12, s4
 8004668:	eef0 6a62 	vmov.f32	s13, s5
 800466c:	eeb0 7a43 	vmov.f32	s14, s6
 8004670:	eef0 7a63 	vmov.f32	s15, s7
 8004674:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004678:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
 800467c:	ed83 4b00 	vstr	d4, [r3]
 8004680:	ed83 5b02 	vstr	d5, [r3, #8]
 8004684:	ed83 6b04 	vstr	d6, [r3, #16]
 8004688:	ed83 7b06 	vstr	d7, [r3, #24]

	Quaternion q_mix = kreuzproduktQuaternion(qd_reduziert_inverse, quaternion_ganz);
 800468c:	ed97 4b54 	vldr	d4, [r7, #336]	@ 0x150
 8004690:	ed97 5b56 	vldr	d5, [r7, #344]	@ 0x158
 8004694:	ed97 6b58 	vldr	d6, [r7, #352]	@ 0x160
 8004698:	ed97 7b5a 	vldr	d7, [r7, #360]	@ 0x168
 800469c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80046a0:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
 80046a4:	ed93 0b00 	vldr	d0, [r3]
 80046a8:	ed93 1b02 	vldr	d1, [r3, #8]
 80046ac:	ed93 2b04 	vldr	d2, [r3, #16]
 80046b0:	ed93 3b06 	vldr	d3, [r3, #24]
 80046b4:	f7fd fcf1 	bl	800209a <kreuzproduktQuaternion>
 80046b8:	eeb0 4a40 	vmov.f32	s8, s0
 80046bc:	eef0 4a60 	vmov.f32	s9, s1
 80046c0:	eeb0 5a41 	vmov.f32	s10, s2
 80046c4:	eef0 5a61 	vmov.f32	s11, s3
 80046c8:	eeb0 6a42 	vmov.f32	s12, s4
 80046cc:	eef0 6a62 	vmov.f32	s13, s5
 80046d0:	eeb0 7a43 	vmov.f32	s14, s6
 80046d4:	eef0 7a63 	vmov.f32	s15, s7
 80046d8:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80046dc:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 80046e0:	ed83 4b00 	vstr	d4, [r3]
 80046e4:	ed83 5b02 	vstr	d5, [r3, #8]
 80046e8:	ed83 6b04 	vstr	d6, [r3, #16]
 80046ec:	ed83 7b06 	vstr	d7, [r3, #24]


	if (q_mix.w < -1.0) {
 80046f0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80046f4:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 80046f8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80046fc:	f04f 0200 	mov.w	r2, #0
 8004700:	4b43      	ldr	r3, [pc, #268]	@ (8004810 <regelschritt+0x1ca0>)
 8004702:	f7fc f9f3 	bl	8000aec <__aeabi_dcmplt>
 8004706:	4603      	mov	r3, r0
 8004708:	2b00      	cmp	r3, #0
 800470a:	d008      	beq.n	800471e <regelschritt+0x1bae>
		q_mix.w = -1.0;
 800470c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004710:	f5a3 71ac 	sub.w	r1, r3, #344	@ 0x158
 8004714:	f04f 0200 	mov.w	r2, #0
 8004718:	4b3d      	ldr	r3, [pc, #244]	@ (8004810 <regelschritt+0x1ca0>)
 800471a:	e9c1 2300 	strd	r2, r3, [r1]
	}
	if (q_mix.w > 1.0) {
 800471e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004722:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 8004726:	e9d3 0100 	ldrd	r0, r1, [r3]
 800472a:	f04f 0200 	mov.w	r2, #0
 800472e:	4b39      	ldr	r3, [pc, #228]	@ (8004814 <regelschritt+0x1ca4>)
 8004730:	f7fc f9fa 	bl	8000b28 <__aeabi_dcmpgt>
 8004734:	4603      	mov	r3, r0
 8004736:	2b00      	cmp	r3, #0
 8004738:	d008      	beq.n	800474c <regelschritt+0x1bdc>
		q_mix.w = 1.0;
 800473a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 800473e:	f5a3 71ac 	sub.w	r1, r3, #344	@ 0x158
 8004742:	f04f 0200 	mov.w	r2, #0
 8004746:	4b33      	ldr	r3, [pc, #204]	@ (8004814 <regelschritt+0x1ca4>)
 8004748:	e9c1 2300 	strd	r2, r3, [r1]
	}
	if (q_mix.z < -1.0) {
 800474c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004750:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 8004754:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8004758:	f04f 0200 	mov.w	r2, #0
 800475c:	4b2c      	ldr	r3, [pc, #176]	@ (8004810 <regelschritt+0x1ca0>)
 800475e:	f7fc f9c5 	bl	8000aec <__aeabi_dcmplt>
 8004762:	4603      	mov	r3, r0
 8004764:	2b00      	cmp	r3, #0
 8004766:	d008      	beq.n	800477a <regelschritt+0x1c0a>
		q_mix.z = -1.0;
 8004768:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 800476c:	f5a3 71ac 	sub.w	r1, r3, #344	@ 0x158
 8004770:	f04f 0200 	mov.w	r2, #0
 8004774:	4b26      	ldr	r3, [pc, #152]	@ (8004810 <regelschritt+0x1ca0>)
 8004776:	e9c1 2306 	strd	r2, r3, [r1, #24]
	}
	if (q_mix.z > 1.0) {
 800477a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 800477e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 8004782:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8004786:	f04f 0200 	mov.w	r2, #0
 800478a:	4b22      	ldr	r3, [pc, #136]	@ (8004814 <regelschritt+0x1ca4>)
 800478c:	f7fc f9cc 	bl	8000b28 <__aeabi_dcmpgt>
 8004790:	4603      	mov	r3, r0
 8004792:	2b00      	cmp	r3, #0
 8004794:	d008      	beq.n	80047a8 <regelschritt+0x1c38>
		q_mix.z = 1.0;
 8004796:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 800479a:	f5a3 71ac 	sub.w	r1, r3, #344	@ 0x158
 800479e:	f04f 0200 	mov.w	r2, #0
 80047a2:	4b1c      	ldr	r3, [pc, #112]	@ (8004814 <regelschritt+0x1ca4>)
 80047a4:	e9c1 2306 	strd	r2, r3, [r1, #24]
	}

	Quaternion qd;
	qd.w = (
		qd_reduziert.w * cos(yaw_w * acos(q_mix.w)) -
 80047a8:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80047ac:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 80047b0:	e9d3 4500 	ldrd	r4, r5, [r3]
 80047b4:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80047b8:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 80047bc:	ed93 7b00 	vldr	d7, [r3]
 80047c0:	eeb0 0a47 	vmov.f32	s0, s14
 80047c4:	eef0 0a67 	vmov.f32	s1, s15
 80047c8:	f01a fe60 	bl	801f48c <acos>
 80047cc:	ec51 0b10 	vmov	r0, r1, d0
 80047d0:	4b11      	ldr	r3, [pc, #68]	@ (8004818 <regelschritt+0x1ca8>)
 80047d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80047d6:	f7fb ff17 	bl	8000608 <__aeabi_dmul>
 80047da:	4602      	mov	r2, r0
 80047dc:	460b      	mov	r3, r1
 80047de:	ec43 2b17 	vmov	d7, r2, r3
 80047e2:	eeb0 0a47 	vmov.f32	s0, s14
 80047e6:	eef0 0a67 	vmov.f32	s1, s15
 80047ea:	f01a ff55 	bl	801f698 <cos>
 80047ee:	ec53 2b10 	vmov	r2, r3, d0
 80047f2:	4620      	mov	r0, r4
 80047f4:	4629      	mov	r1, r5
 80047f6:	f7fb ff07 	bl	8000608 <__aeabi_dmul>
 80047fa:	4602      	mov	r2, r0
 80047fc:	460b      	mov	r3, r1
 80047fe:	4690      	mov	r8, r2
 8004800:	4699      	mov	r9, r3
		qd_reduziert.z * sin(yaw_w * asin(q_mix.z))
 8004802:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004806:	e009      	b.n	800481c <regelschritt+0x1cac>
 8004808:	20001f38 	.word	0x20001f38
 800480c:	20001d28 	.word	0x20001d28
 8004810:	bff00000 	.word	0xbff00000
 8004814:	3ff00000 	.word	0x3ff00000
 8004818:	20001fd0 	.word	0x20001fd0
 800481c:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 8004820:	e9d3 4506 	ldrd	r4, r5, [r3, #24]
 8004824:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004828:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 800482c:	ed93 7b06 	vldr	d7, [r3, #24]
 8004830:	eeb0 0a47 	vmov.f32	s0, s14
 8004834:	eef0 0a67 	vmov.f32	s1, s15
 8004838:	f01a fe5c 	bl	801f4f4 <asin>
 800483c:	ec51 0b10 	vmov	r0, r1, d0
 8004840:	4be5      	ldr	r3, [pc, #916]	@ (8004bd8 <regelschritt+0x2068>)
 8004842:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004846:	f7fb fedf 	bl	8000608 <__aeabi_dmul>
 800484a:	4602      	mov	r2, r0
 800484c:	460b      	mov	r3, r1
 800484e:	ec43 2b17 	vmov	d7, r2, r3
 8004852:	eeb0 0a47 	vmov.f32	s0, s14
 8004856:	eef0 0a67 	vmov.f32	s1, s15
 800485a:	f01a ff79 	bl	801f750 <sin>
 800485e:	ec53 2b10 	vmov	r2, r3, d0
 8004862:	4620      	mov	r0, r4
 8004864:	4629      	mov	r1, r5
 8004866:	f7fb fecf 	bl	8000608 <__aeabi_dmul>
 800486a:	4602      	mov	r2, r0
 800486c:	460b      	mov	r3, r1
		qd_reduziert.w * cos(yaw_w * acos(q_mix.w)) -
 800486e:	4640      	mov	r0, r8
 8004870:	4649      	mov	r1, r9
 8004872:	f7fb fd11 	bl	8000298 <__aeabi_dsub>
 8004876:	4602      	mov	r2, r0
 8004878:	460b      	mov	r3, r1
	qd.w = (
 800487a:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 800487e:	f5a1 71bc 	sub.w	r1, r1, #376	@ 0x178
 8004882:	e9c1 2300 	strd	r2, r3, [r1]
	);
	qd.x = (
		qd_reduziert.x * cos(yaw_w * acos(q_mix.w)) +
 8004886:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 800488a:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 800488e:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 8004892:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004896:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 800489a:	ed93 7b00 	vldr	d7, [r3]
 800489e:	eeb0 0a47 	vmov.f32	s0, s14
 80048a2:	eef0 0a67 	vmov.f32	s1, s15
 80048a6:	f01a fdf1 	bl	801f48c <acos>
 80048aa:	ec51 0b10 	vmov	r0, r1, d0
 80048ae:	4bca      	ldr	r3, [pc, #808]	@ (8004bd8 <regelschritt+0x2068>)
 80048b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80048b4:	f7fb fea8 	bl	8000608 <__aeabi_dmul>
 80048b8:	4602      	mov	r2, r0
 80048ba:	460b      	mov	r3, r1
 80048bc:	ec43 2b17 	vmov	d7, r2, r3
 80048c0:	eeb0 0a47 	vmov.f32	s0, s14
 80048c4:	eef0 0a67 	vmov.f32	s1, s15
 80048c8:	f01a fee6 	bl	801f698 <cos>
 80048cc:	ec53 2b10 	vmov	r2, r3, d0
 80048d0:	4620      	mov	r0, r4
 80048d2:	4629      	mov	r1, r5
 80048d4:	f7fb fe98 	bl	8000608 <__aeabi_dmul>
 80048d8:	4602      	mov	r2, r0
 80048da:	460b      	mov	r3, r1
 80048dc:	4690      	mov	r8, r2
 80048de:	4699      	mov	r9, r3
		qd_reduziert.y * sin(yaw_w * asin(q_mix.z))
 80048e0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80048e4:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 80048e8:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
 80048ec:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80048f0:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 80048f4:	ed93 7b06 	vldr	d7, [r3, #24]
 80048f8:	eeb0 0a47 	vmov.f32	s0, s14
 80048fc:	eef0 0a67 	vmov.f32	s1, s15
 8004900:	f01a fdf8 	bl	801f4f4 <asin>
 8004904:	ec51 0b10 	vmov	r0, r1, d0
 8004908:	4bb3      	ldr	r3, [pc, #716]	@ (8004bd8 <regelschritt+0x2068>)
 800490a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800490e:	f7fb fe7b 	bl	8000608 <__aeabi_dmul>
 8004912:	4602      	mov	r2, r0
 8004914:	460b      	mov	r3, r1
 8004916:	ec43 2b17 	vmov	d7, r2, r3
 800491a:	eeb0 0a47 	vmov.f32	s0, s14
 800491e:	eef0 0a67 	vmov.f32	s1, s15
 8004922:	f01a ff15 	bl	801f750 <sin>
 8004926:	ec53 2b10 	vmov	r2, r3, d0
 800492a:	4620      	mov	r0, r4
 800492c:	4629      	mov	r1, r5
 800492e:	f7fb fe6b 	bl	8000608 <__aeabi_dmul>
 8004932:	4602      	mov	r2, r0
 8004934:	460b      	mov	r3, r1
		qd_reduziert.x * cos(yaw_w * acos(q_mix.w)) +
 8004936:	4640      	mov	r0, r8
 8004938:	4649      	mov	r1, r9
 800493a:	f7fb fcaf 	bl	800029c <__adddf3>
 800493e:	4602      	mov	r2, r0
 8004940:	460b      	mov	r3, r1
	qd.x = (
 8004942:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 8004946:	f5a1 71bc 	sub.w	r1, r1, #376	@ 0x178
 800494a:	e9c1 2302 	strd	r2, r3, [r1, #8]
	);
	qd.y = (
		qd_reduziert.y * cos(yaw_w * acos(q_mix.w)) -
 800494e:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004952:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 8004956:	e9d3 4504 	ldrd	r4, r5, [r3, #16]
 800495a:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 800495e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 8004962:	ed93 7b00 	vldr	d7, [r3]
 8004966:	eeb0 0a47 	vmov.f32	s0, s14
 800496a:	eef0 0a67 	vmov.f32	s1, s15
 800496e:	f01a fd8d 	bl	801f48c <acos>
 8004972:	ec51 0b10 	vmov	r0, r1, d0
 8004976:	4b98      	ldr	r3, [pc, #608]	@ (8004bd8 <regelschritt+0x2068>)
 8004978:	e9d3 2300 	ldrd	r2, r3, [r3]
 800497c:	f7fb fe44 	bl	8000608 <__aeabi_dmul>
 8004980:	4602      	mov	r2, r0
 8004982:	460b      	mov	r3, r1
 8004984:	ec43 2b17 	vmov	d7, r2, r3
 8004988:	eeb0 0a47 	vmov.f32	s0, s14
 800498c:	eef0 0a67 	vmov.f32	s1, s15
 8004990:	f01a fe82 	bl	801f698 <cos>
 8004994:	ec53 2b10 	vmov	r2, r3, d0
 8004998:	4620      	mov	r0, r4
 800499a:	4629      	mov	r1, r5
 800499c:	f7fb fe34 	bl	8000608 <__aeabi_dmul>
 80049a0:	4602      	mov	r2, r0
 80049a2:	460b      	mov	r3, r1
 80049a4:	4690      	mov	r8, r2
 80049a6:	4699      	mov	r9, r3
		qd_reduziert.x * sin(yaw_w * asin(q_mix.z))
 80049a8:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80049ac:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 80049b0:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 80049b4:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 80049b8:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 80049bc:	ed93 7b06 	vldr	d7, [r3, #24]
 80049c0:	eeb0 0a47 	vmov.f32	s0, s14
 80049c4:	eef0 0a67 	vmov.f32	s1, s15
 80049c8:	f01a fd94 	bl	801f4f4 <asin>
 80049cc:	ec51 0b10 	vmov	r0, r1, d0
 80049d0:	4b81      	ldr	r3, [pc, #516]	@ (8004bd8 <regelschritt+0x2068>)
 80049d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80049d6:	f7fb fe17 	bl	8000608 <__aeabi_dmul>
 80049da:	4602      	mov	r2, r0
 80049dc:	460b      	mov	r3, r1
 80049de:	ec43 2b17 	vmov	d7, r2, r3
 80049e2:	eeb0 0a47 	vmov.f32	s0, s14
 80049e6:	eef0 0a67 	vmov.f32	s1, s15
 80049ea:	f01a feb1 	bl	801f750 <sin>
 80049ee:	ec53 2b10 	vmov	r2, r3, d0
 80049f2:	4620      	mov	r0, r4
 80049f4:	4629      	mov	r1, r5
 80049f6:	f7fb fe07 	bl	8000608 <__aeabi_dmul>
 80049fa:	4602      	mov	r2, r0
 80049fc:	460b      	mov	r3, r1
		qd_reduziert.y * cos(yaw_w * acos(q_mix.w)) -
 80049fe:	4640      	mov	r0, r8
 8004a00:	4649      	mov	r1, r9
 8004a02:	f7fb fc49 	bl	8000298 <__aeabi_dsub>
 8004a06:	4602      	mov	r2, r0
 8004a08:	460b      	mov	r3, r1
	qd.y = (
 8004a0a:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 8004a0e:	f5a1 71bc 	sub.w	r1, r1, #376	@ 0x178
 8004a12:	e9c1 2304 	strd	r2, r3, [r1, #16]
	);
	qd.z = (
		qd_reduziert.z * cos(yaw_w * acos(q_mix.w)) +
 8004a16:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004a1a:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 8004a1e:	e9d3 4506 	ldrd	r4, r5, [r3, #24]
 8004a22:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004a26:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 8004a2a:	ed93 7b00 	vldr	d7, [r3]
 8004a2e:	eeb0 0a47 	vmov.f32	s0, s14
 8004a32:	eef0 0a67 	vmov.f32	s1, s15
 8004a36:	f01a fd29 	bl	801f48c <acos>
 8004a3a:	ec51 0b10 	vmov	r0, r1, d0
 8004a3e:	4b66      	ldr	r3, [pc, #408]	@ (8004bd8 <regelschritt+0x2068>)
 8004a40:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004a44:	f7fb fde0 	bl	8000608 <__aeabi_dmul>
 8004a48:	4602      	mov	r2, r0
 8004a4a:	460b      	mov	r3, r1
 8004a4c:	ec43 2b17 	vmov	d7, r2, r3
 8004a50:	eeb0 0a47 	vmov.f32	s0, s14
 8004a54:	eef0 0a67 	vmov.f32	s1, s15
 8004a58:	f01a fe1e 	bl	801f698 <cos>
 8004a5c:	ec53 2b10 	vmov	r2, r3, d0
 8004a60:	4620      	mov	r0, r4
 8004a62:	4629      	mov	r1, r5
 8004a64:	f7fb fdd0 	bl	8000608 <__aeabi_dmul>
 8004a68:	4602      	mov	r2, r0
 8004a6a:	460b      	mov	r3, r1
 8004a6c:	4690      	mov	r8, r2
 8004a6e:	4699      	mov	r9, r3
		qd_reduziert.w * sin(yaw_w * asin(q_mix.z))
 8004a70:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004a74:	f5a3 738c 	sub.w	r3, r3, #280	@ 0x118
 8004a78:	e9d3 4500 	ldrd	r4, r5, [r3]
 8004a7c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004a80:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 8004a84:	ed93 7b06 	vldr	d7, [r3, #24]
 8004a88:	eeb0 0a47 	vmov.f32	s0, s14
 8004a8c:	eef0 0a67 	vmov.f32	s1, s15
 8004a90:	f01a fd30 	bl	801f4f4 <asin>
 8004a94:	ec51 0b10 	vmov	r0, r1, d0
 8004a98:	4b4f      	ldr	r3, [pc, #316]	@ (8004bd8 <regelschritt+0x2068>)
 8004a9a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004a9e:	f7fb fdb3 	bl	8000608 <__aeabi_dmul>
 8004aa2:	4602      	mov	r2, r0
 8004aa4:	460b      	mov	r3, r1
 8004aa6:	ec43 2b17 	vmov	d7, r2, r3
 8004aaa:	eeb0 0a47 	vmov.f32	s0, s14
 8004aae:	eef0 0a67 	vmov.f32	s1, s15
 8004ab2:	f01a fe4d 	bl	801f750 <sin>
 8004ab6:	ec53 2b10 	vmov	r2, r3, d0
 8004aba:	4620      	mov	r0, r4
 8004abc:	4629      	mov	r1, r5
 8004abe:	f7fb fda3 	bl	8000608 <__aeabi_dmul>
 8004ac2:	4602      	mov	r2, r0
 8004ac4:	460b      	mov	r3, r1
		qd_reduziert.z * cos(yaw_w * acos(q_mix.w)) +
 8004ac6:	4640      	mov	r0, r8
 8004ac8:	4649      	mov	r1, r9
 8004aca:	f7fb fbe7 	bl	800029c <__adddf3>
 8004ace:	4602      	mov	r2, r0
 8004ad0:	460b      	mov	r3, r1
	qd.z = (
 8004ad2:	f507 7112 	add.w	r1, r7, #584	@ 0x248
 8004ad6:	f5a1 71bc 	sub.w	r1, r1, #376	@ 0x178
 8004ada:	e9c1 2306 	strd	r2, r3, [r1, #24]
	);

	Quaternion drehlage_inverse = inverseQuaternion(drehlage);
 8004ade:	4b3f      	ldr	r3, [pc, #252]	@ (8004bdc <regelschritt+0x206c>)
 8004ae0:	ed93 4b00 	vldr	d4, [r3]
 8004ae4:	ed93 5b02 	vldr	d5, [r3, #8]
 8004ae8:	ed93 6b04 	vldr	d6, [r3, #16]
 8004aec:	ed93 7b06 	vldr	d7, [r3, #24]
 8004af0:	eeb0 0a44 	vmov.f32	s0, s8
 8004af4:	eef0 0a64 	vmov.f32	s1, s9
 8004af8:	eeb0 1a45 	vmov.f32	s2, s10
 8004afc:	eef0 1a65 	vmov.f32	s3, s11
 8004b00:	eeb0 2a46 	vmov.f32	s4, s12
 8004b04:	eef0 2a66 	vmov.f32	s5, s13
 8004b08:	eeb0 3a47 	vmov.f32	s6, s14
 8004b0c:	eef0 3a67 	vmov.f32	s7, s15
 8004b10:	f7fd f9b6 	bl	8001e80 <inverseQuaternion>
 8004b14:	eeb0 4a40 	vmov.f32	s8, s0
 8004b18:	eef0 4a60 	vmov.f32	s9, s1
 8004b1c:	eeb0 5a41 	vmov.f32	s10, s2
 8004b20:	eef0 5a61 	vmov.f32	s11, s3
 8004b24:	eeb0 6a42 	vmov.f32	s12, s4
 8004b28:	eef0 6a62 	vmov.f32	s13, s5
 8004b2c:	eeb0 7a43 	vmov.f32	s14, s6
 8004b30:	eef0 7a63 	vmov.f32	s15, s7
 8004b34:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004b38:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
 8004b3c:	ed83 4b00 	vstr	d4, [r3]
 8004b40:	ed83 5b02 	vstr	d5, [r3, #8]
 8004b44:	ed83 6b04 	vstr	d6, [r3, #16]
 8004b48:	ed83 7b06 	vstr	d7, [r3, #24]

	Quaternion drehlagefehler;
	drehlagefehler = kreuzproduktQuaternion(drehlage_inverse, qd);
 8004b4c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004b50:	f5a3 73bc 	sub.w	r3, r3, #376	@ 0x178
 8004b54:	ed93 4b00 	vldr	d4, [r3]
 8004b58:	ed93 5b02 	vldr	d5, [r3, #8]
 8004b5c:	ed93 6b04 	vldr	d6, [r3, #16]
 8004b60:	ed93 7b06 	vldr	d7, [r3, #24]
 8004b64:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004b68:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
 8004b6c:	ed93 0b00 	vldr	d0, [r3]
 8004b70:	ed93 1b02 	vldr	d1, [r3, #8]
 8004b74:	ed93 2b04 	vldr	d2, [r3, #16]
 8004b78:	ed93 3b06 	vldr	d3, [r3, #24]
 8004b7c:	f7fd fa8d 	bl	800209a <kreuzproduktQuaternion>
 8004b80:	eeb0 4a40 	vmov.f32	s8, s0
 8004b84:	eef0 4a60 	vmov.f32	s9, s1
 8004b88:	eeb0 5a41 	vmov.f32	s10, s2
 8004b8c:	eef0 5a61 	vmov.f32	s11, s3
 8004b90:	eeb0 6a42 	vmov.f32	s12, s4
 8004b94:	eef0 6a62 	vmov.f32	s13, s5
 8004b98:	eeb0 7a43 	vmov.f32	s14, s6
 8004b9c:	eef0 7a63 	vmov.f32	s15, s7
 8004ba0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004ba4:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004ba8:	ed83 4b00 	vstr	d4, [r3]
 8004bac:	ed83 5b02 	vstr	d5, [r3, #8]
 8004bb0:	ed83 6b04 	vstr	d6, [r3, #16]
 8004bb4:	ed83 7b06 	vstr	d7, [r3, #24]

	if (drehlagefehler.w > 0) {
 8004bb8:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004bbc:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004bc0:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004bc4:	f04f 0200 	mov.w	r2, #0
 8004bc8:	f04f 0300 	mov.w	r3, #0
 8004bcc:	f7fb ffac 	bl	8000b28 <__aeabi_dcmpgt>
 8004bd0:	4603      	mov	r3, r0
 8004bd2:	2b00      	cmp	r3, #0
 8004bd4:	d052      	beq.n	8004c7c <regelschritt+0x210c>
 8004bd6:	e003      	b.n	8004be0 <regelschritt+0x2070>
 8004bd8:	20001fd0 	.word	0x20001fd0
 8004bdc:	20001d28 	.word	0x20001d28
		drehratensollwert.rollen = (2.0 * drehlagefehler.x * attitute_p_gain[0]);
 8004be0:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004be4:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004be8:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004bec:	4602      	mov	r2, r0
 8004bee:	460b      	mov	r3, r1
 8004bf0:	f7fb fb54 	bl	800029c <__adddf3>
 8004bf4:	4602      	mov	r2, r0
 8004bf6:	460b      	mov	r3, r1
 8004bf8:	4610      	mov	r0, r2
 8004bfa:	4619      	mov	r1, r3
 8004bfc:	4b1d      	ldr	r3, [pc, #116]	@ (8004c74 <regelschritt+0x2104>)
 8004bfe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004c02:	f7fb fd01 	bl	8000608 <__aeabi_dmul>
 8004c06:	4602      	mov	r2, r0
 8004c08:	460b      	mov	r3, r1
 8004c0a:	491b      	ldr	r1, [pc, #108]	@ (8004c78 <regelschritt+0x2108>)
 8004c0c:	e9c1 2300 	strd	r2, r3, [r1]
		drehratensollwert.nicken = (2.0 * drehlagefehler.y * attitute_p_gain[1]);
 8004c10:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004c14:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004c18:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004c1c:	4602      	mov	r2, r0
 8004c1e:	460b      	mov	r3, r1
 8004c20:	f7fb fb3c 	bl	800029c <__adddf3>
 8004c24:	4602      	mov	r2, r0
 8004c26:	460b      	mov	r3, r1
 8004c28:	4610      	mov	r0, r2
 8004c2a:	4619      	mov	r1, r3
 8004c2c:	4b11      	ldr	r3, [pc, #68]	@ (8004c74 <regelschritt+0x2104>)
 8004c2e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004c32:	f7fb fce9 	bl	8000608 <__aeabi_dmul>
 8004c36:	4602      	mov	r2, r0
 8004c38:	460b      	mov	r3, r1
 8004c3a:	490f      	ldr	r1, [pc, #60]	@ (8004c78 <regelschritt+0x2108>)
 8004c3c:	e9c1 2302 	strd	r2, r3, [r1, #8]
		drehratensollwert.gieren = (2.0 * drehlagefehler.z * attitute_p_gain[2]);
 8004c40:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004c44:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004c48:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8004c4c:	4602      	mov	r2, r0
 8004c4e:	460b      	mov	r3, r1
 8004c50:	f7fb fb24 	bl	800029c <__adddf3>
 8004c54:	4602      	mov	r2, r0
 8004c56:	460b      	mov	r3, r1
 8004c58:	4610      	mov	r0, r2
 8004c5a:	4619      	mov	r1, r3
 8004c5c:	4b05      	ldr	r3, [pc, #20]	@ (8004c74 <regelschritt+0x2104>)
 8004c5e:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004c62:	f7fb fcd1 	bl	8000608 <__aeabi_dmul>
 8004c66:	4602      	mov	r2, r0
 8004c68:	460b      	mov	r3, r1
 8004c6a:	4903      	ldr	r1, [pc, #12]	@ (8004c78 <regelschritt+0x2108>)
 8004c6c:	e9c1 2304 	strd	r2, r3, [r1, #16]
 8004c70:	e05e      	b.n	8004d30 <regelschritt+0x21c0>
 8004c72:	bf00      	nop
 8004c74:	20000110 	.word	0x20000110
 8004c78:	20001e60 	.word	0x20001e60
	} else {
		drehratensollwert.rollen = -(2.0 * drehlagefehler.x * attitute_p_gain[0]);
 8004c7c:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004c80:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004c84:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004c88:	4602      	mov	r2, r0
 8004c8a:	460b      	mov	r3, r1
 8004c8c:	f7fb fb06 	bl	800029c <__adddf3>
 8004c90:	4602      	mov	r2, r0
 8004c92:	460b      	mov	r3, r1
 8004c94:	4610      	mov	r0, r2
 8004c96:	4619      	mov	r1, r3
 8004c98:	4bb9      	ldr	r3, [pc, #740]	@ (8004f80 <regelschritt+0x2410>)
 8004c9a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004c9e:	f7fb fcb3 	bl	8000608 <__aeabi_dmul>
 8004ca2:	4602      	mov	r2, r0
 8004ca4:	460b      	mov	r3, r1
 8004ca6:	613a      	str	r2, [r7, #16]
 8004ca8:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8004cac:	617b      	str	r3, [r7, #20]
 8004cae:	4bb5      	ldr	r3, [pc, #724]	@ (8004f84 <regelschritt+0x2414>)
 8004cb0:	ed97 7b04 	vldr	d7, [r7, #16]
 8004cb4:	ed83 7b00 	vstr	d7, [r3]
		drehratensollwert.nicken = -(2.0 * drehlagefehler.y * attitute_p_gain[1]);
 8004cb8:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004cbc:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004cc0:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004cc4:	4602      	mov	r2, r0
 8004cc6:	460b      	mov	r3, r1
 8004cc8:	f7fb fae8 	bl	800029c <__adddf3>
 8004ccc:	4602      	mov	r2, r0
 8004cce:	460b      	mov	r3, r1
 8004cd0:	4610      	mov	r0, r2
 8004cd2:	4619      	mov	r1, r3
 8004cd4:	4baa      	ldr	r3, [pc, #680]	@ (8004f80 <regelschritt+0x2410>)
 8004cd6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004cda:	f7fb fc95 	bl	8000608 <__aeabi_dmul>
 8004cde:	4602      	mov	r2, r0
 8004ce0:	460b      	mov	r3, r1
 8004ce2:	60ba      	str	r2, [r7, #8]
 8004ce4:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8004ce8:	60fb      	str	r3, [r7, #12]
 8004cea:	4ba6      	ldr	r3, [pc, #664]	@ (8004f84 <regelschritt+0x2414>)
 8004cec:	ed97 7b02 	vldr	d7, [r7, #8]
 8004cf0:	ed83 7b02 	vstr	d7, [r3, #8]
		drehratensollwert.gieren = -(2.0 * drehlagefehler.z * attitute_p_gain[2]);
 8004cf4:	f507 7312 	add.w	r3, r7, #584	@ 0x248
 8004cf8:	f5a3 73dc 	sub.w	r3, r3, #440	@ 0x1b8
 8004cfc:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8004d00:	4602      	mov	r2, r0
 8004d02:	460b      	mov	r3, r1
 8004d04:	f7fb faca 	bl	800029c <__adddf3>
 8004d08:	4602      	mov	r2, r0
 8004d0a:	460b      	mov	r3, r1
 8004d0c:	4610      	mov	r0, r2
 8004d0e:	4619      	mov	r1, r3
 8004d10:	4b9b      	ldr	r3, [pc, #620]	@ (8004f80 <regelschritt+0x2410>)
 8004d12:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004d16:	f7fb fc77 	bl	8000608 <__aeabi_dmul>
 8004d1a:	4602      	mov	r2, r0
 8004d1c:	460b      	mov	r3, r1
 8004d1e:	603a      	str	r2, [r7, #0]
 8004d20:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000
 8004d24:	607b      	str	r3, [r7, #4]
 8004d26:	4b97      	ldr	r3, [pc, #604]	@ (8004f84 <regelschritt+0x2414>)
 8004d28:	ed97 7b00 	vldr	d7, [r7]
 8004d2c:	ed83 7b04 	vstr	d7, [r3, #16]
	}

	// Rate Control
	drehratenfehler.rollen = drehratensollwert.rollen - drehrate.rollen;
 8004d30:	4b94      	ldr	r3, [pc, #592]	@ (8004f84 <regelschritt+0x2414>)
 8004d32:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004d36:	4b94      	ldr	r3, [pc, #592]	@ (8004f88 <regelschritt+0x2418>)
 8004d38:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004d3c:	f7fb faac 	bl	8000298 <__aeabi_dsub>
 8004d40:	4602      	mov	r2, r0
 8004d42:	460b      	mov	r3, r1
 8004d44:	4991      	ldr	r1, [pc, #580]	@ (8004f8c <regelschritt+0x241c>)
 8004d46:	e9c1 2300 	strd	r2, r3, [r1]
	drehratenstellwert.rollen = (
		rate_p_gain[0] * drehratenfehler.rollen -
 8004d4a:	4b91      	ldr	r3, [pc, #580]	@ (8004f90 <regelschritt+0x2420>)
 8004d4c:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004d50:	4b8e      	ldr	r3, [pc, #568]	@ (8004f8c <regelschritt+0x241c>)
 8004d52:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004d56:	f7fb fc57 	bl	8000608 <__aeabi_dmul>
 8004d5a:	4602      	mov	r2, r0
 8004d5c:	460b      	mov	r3, r1
 8004d5e:	4614      	mov	r4, r2
 8004d60:	461d      	mov	r5, r3
		rate_d_gain[0] * omega_dot.rollen
 8004d62:	4b8c      	ldr	r3, [pc, #560]	@ (8004f94 <regelschritt+0x2424>)
 8004d64:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004d68:	4b8b      	ldr	r3, [pc, #556]	@ (8004f98 <regelschritt+0x2428>)
 8004d6a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004d6e:	f7fb fc4b 	bl	8000608 <__aeabi_dmul>
 8004d72:	4602      	mov	r2, r0
 8004d74:	460b      	mov	r3, r1
		rate_p_gain[0] * drehratenfehler.rollen -
 8004d76:	4620      	mov	r0, r4
 8004d78:	4629      	mov	r1, r5
 8004d7a:	f7fb fa8d 	bl	8000298 <__aeabi_dsub>
 8004d7e:	4602      	mov	r2, r0
 8004d80:	460b      	mov	r3, r1
	drehratenstellwert.rollen = (
 8004d82:	4986      	ldr	r1, [pc, #536]	@ (8004f9c <regelschritt+0x242c>)
 8004d84:	e9c1 2300 	strd	r2, r3, [r1]
	);
	drehratenfehler.nicken = drehratensollwert.nicken - drehrate.nicken;
 8004d88:	4b7e      	ldr	r3, [pc, #504]	@ (8004f84 <regelschritt+0x2414>)
 8004d8a:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004d8e:	4b7e      	ldr	r3, [pc, #504]	@ (8004f88 <regelschritt+0x2418>)
 8004d90:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004d94:	f7fb fa80 	bl	8000298 <__aeabi_dsub>
 8004d98:	4602      	mov	r2, r0
 8004d9a:	460b      	mov	r3, r1
 8004d9c:	497b      	ldr	r1, [pc, #492]	@ (8004f8c <regelschritt+0x241c>)
 8004d9e:	e9c1 2302 	strd	r2, r3, [r1, #8]
	drehratenstellwert.nicken = (
		rate_p_gain[1] * drehratenfehler.nicken -
 8004da2:	4b7b      	ldr	r3, [pc, #492]	@ (8004f90 <regelschritt+0x2420>)
 8004da4:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004da8:	4b78      	ldr	r3, [pc, #480]	@ (8004f8c <regelschritt+0x241c>)
 8004daa:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004dae:	f7fb fc2b 	bl	8000608 <__aeabi_dmul>
 8004db2:	4602      	mov	r2, r0
 8004db4:	460b      	mov	r3, r1
 8004db6:	4614      	mov	r4, r2
 8004db8:	461d      	mov	r5, r3
		rate_d_gain[1] * omega_dot.nicken
 8004dba:	4b76      	ldr	r3, [pc, #472]	@ (8004f94 <regelschritt+0x2424>)
 8004dbc:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004dc0:	4b75      	ldr	r3, [pc, #468]	@ (8004f98 <regelschritt+0x2428>)
 8004dc2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004dc6:	f7fb fc1f 	bl	8000608 <__aeabi_dmul>
 8004dca:	4602      	mov	r2, r0
 8004dcc:	460b      	mov	r3, r1
		rate_p_gain[1] * drehratenfehler.nicken -
 8004dce:	4620      	mov	r0, r4
 8004dd0:	4629      	mov	r1, r5
 8004dd2:	f7fb fa61 	bl	8000298 <__aeabi_dsub>
 8004dd6:	4602      	mov	r2, r0
 8004dd8:	460b      	mov	r3, r1
	drehratenstellwert.nicken = (
 8004dda:	4970      	ldr	r1, [pc, #448]	@ (8004f9c <regelschritt+0x242c>)
 8004ddc:	e9c1 2302 	strd	r2, r3, [r1, #8]
	);
	drehratenfehler.gieren = drehratensollwert.gieren - drehrate.gieren;
 8004de0:	4b68      	ldr	r3, [pc, #416]	@ (8004f84 <regelschritt+0x2414>)
 8004de2:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004de6:	4b68      	ldr	r3, [pc, #416]	@ (8004f88 <regelschritt+0x2418>)
 8004de8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004dec:	f7fb fa54 	bl	8000298 <__aeabi_dsub>
 8004df0:	4602      	mov	r2, r0
 8004df2:	460b      	mov	r3, r1
 8004df4:	4965      	ldr	r1, [pc, #404]	@ (8004f8c <regelschritt+0x241c>)
 8004df6:	e9c1 2304 	strd	r2, r3, [r1, #16]
	drehratenstellwert.gieren = (
		rate_p_gain[2] * drehratenfehler.gieren -
 8004dfa:	4b65      	ldr	r3, [pc, #404]	@ (8004f90 <regelschritt+0x2420>)
 8004dfc:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004e00:	4b62      	ldr	r3, [pc, #392]	@ (8004f8c <regelschritt+0x241c>)
 8004e02:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004e06:	f7fb fbff 	bl	8000608 <__aeabi_dmul>
 8004e0a:	4602      	mov	r2, r0
 8004e0c:	460b      	mov	r3, r1
 8004e0e:	4614      	mov	r4, r2
 8004e10:	461d      	mov	r5, r3
		rate_d_gain[2] * omega_dot.gieren
 8004e12:	4b60      	ldr	r3, [pc, #384]	@ (8004f94 <regelschritt+0x2424>)
 8004e14:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004e18:	4b5f      	ldr	r3, [pc, #380]	@ (8004f98 <regelschritt+0x2428>)
 8004e1a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004e1e:	f7fb fbf3 	bl	8000608 <__aeabi_dmul>
 8004e22:	4602      	mov	r2, r0
 8004e24:	460b      	mov	r3, r1
		rate_p_gain[2] * drehratenfehler.gieren -
 8004e26:	4620      	mov	r0, r4
 8004e28:	4629      	mov	r1, r5
 8004e2a:	f7fb fa35 	bl	8000298 <__aeabi_dsub>
 8004e2e:	4602      	mov	r2, r0
 8004e30:	460b      	mov	r3, r1
	drehratenstellwert.gieren = (
 8004e32:	495a      	ldr	r1, [pc, #360]	@ (8004f9c <regelschritt+0x242c>)
 8004e34:	e9c1 2304 	strd	r2, r3, [r1, #16]
	);

	sollschub_norm = sqrt(
		pow(sollschub[0], 2) +
 8004e38:	4b59      	ldr	r3, [pc, #356]	@ (8004fa0 <regelschritt+0x2430>)
 8004e3a:	ed93 7b00 	vldr	d7, [r3]
 8004e3e:	ed9f 1b4e 	vldr	d1, [pc, #312]	@ 8004f78 <regelschritt+0x2408>
 8004e42:	eeb0 0a47 	vmov.f32	s0, s14
 8004e46:	eef0 0a67 	vmov.f32	s1, s15
 8004e4a:	f01a fb89 	bl	801f560 <pow>
 8004e4e:	ec55 4b10 	vmov	r4, r5, d0
		pow(sollschub[1], 2) +
 8004e52:	4b53      	ldr	r3, [pc, #332]	@ (8004fa0 <regelschritt+0x2430>)
 8004e54:	ed93 7b02 	vldr	d7, [r3, #8]
 8004e58:	ed9f 1b47 	vldr	d1, [pc, #284]	@ 8004f78 <regelschritt+0x2408>
 8004e5c:	eeb0 0a47 	vmov.f32	s0, s14
 8004e60:	eef0 0a67 	vmov.f32	s1, s15
 8004e64:	f01a fb7c 	bl	801f560 <pow>
 8004e68:	ec53 2b10 	vmov	r2, r3, d0
		pow(sollschub[0], 2) +
 8004e6c:	4620      	mov	r0, r4
 8004e6e:	4629      	mov	r1, r5
 8004e70:	f7fb fa14 	bl	800029c <__adddf3>
 8004e74:	4602      	mov	r2, r0
 8004e76:	460b      	mov	r3, r1
 8004e78:	4614      	mov	r4, r2
 8004e7a:	461d      	mov	r5, r3
		pow(sollschub[2], 2)
 8004e7c:	4b48      	ldr	r3, [pc, #288]	@ (8004fa0 <regelschritt+0x2430>)
 8004e7e:	ed93 7b04 	vldr	d7, [r3, #16]
 8004e82:	ed9f 1b3d 	vldr	d1, [pc, #244]	@ 8004f78 <regelschritt+0x2408>
 8004e86:	eeb0 0a47 	vmov.f32	s0, s14
 8004e8a:	eef0 0a67 	vmov.f32	s1, s15
 8004e8e:	f01a fb67 	bl	801f560 <pow>
 8004e92:	ec53 2b10 	vmov	r2, r3, d0
	sollschub_norm = sqrt(
 8004e96:	4620      	mov	r0, r4
 8004e98:	4629      	mov	r1, r5
 8004e9a:	f7fb f9ff 	bl	800029c <__adddf3>
 8004e9e:	4602      	mov	r2, r0
 8004ea0:	460b      	mov	r3, r1
 8004ea2:	ec43 2b17 	vmov	d7, r2, r3
 8004ea6:	eeb0 0a47 	vmov.f32	s0, s14
 8004eaa:	eef0 0a67 	vmov.f32	s1, s15
 8004eae:	f01a fbc7 	bl	801f640 <sqrt>
 8004eb2:	eeb0 7a40 	vmov.f32	s14, s0
 8004eb6:	eef0 7a60 	vmov.f32	s15, s1
 8004eba:	4b3a      	ldr	r3, [pc, #232]	@ (8004fa4 <regelschritt+0x2434>)
 8004ebc:	ed83 7b00 	vstr	d7, [r3]
	);

	w_cmd[M1] = (
		mixerFM[0][0] * sollschub_norm +
 8004ec0:	4b39      	ldr	r3, [pc, #228]	@ (8004fa8 <regelschritt+0x2438>)
 8004ec2:	e9d3 0100 	ldrd	r0, r1, [r3]
 8004ec6:	4b37      	ldr	r3, [pc, #220]	@ (8004fa4 <regelschritt+0x2434>)
 8004ec8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004ecc:	f7fb fb9c 	bl	8000608 <__aeabi_dmul>
 8004ed0:	4602      	mov	r2, r0
 8004ed2:	460b      	mov	r3, r1
 8004ed4:	4614      	mov	r4, r2
 8004ed6:	461d      	mov	r5, r3
		mixerFM[0][1] * drehratenstellwert.rollen +
 8004ed8:	4b33      	ldr	r3, [pc, #204]	@ (8004fa8 <regelschritt+0x2438>)
 8004eda:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 8004ede:	4b2f      	ldr	r3, [pc, #188]	@ (8004f9c <regelschritt+0x242c>)
 8004ee0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004ee4:	f7fb fb90 	bl	8000608 <__aeabi_dmul>
 8004ee8:	4602      	mov	r2, r0
 8004eea:	460b      	mov	r3, r1
		mixerFM[0][0] * sollschub_norm +
 8004eec:	4620      	mov	r0, r4
 8004eee:	4629      	mov	r1, r5
 8004ef0:	f7fb f9d4 	bl	800029c <__adddf3>
 8004ef4:	4602      	mov	r2, r0
 8004ef6:	460b      	mov	r3, r1
 8004ef8:	4614      	mov	r4, r2
 8004efa:	461d      	mov	r5, r3
		mixerFM[0][2] * drehratenstellwert.nicken +
 8004efc:	4b2a      	ldr	r3, [pc, #168]	@ (8004fa8 <regelschritt+0x2438>)
 8004efe:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8004f02:	4b26      	ldr	r3, [pc, #152]	@ (8004f9c <regelschritt+0x242c>)
 8004f04:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004f08:	f7fb fb7e 	bl	8000608 <__aeabi_dmul>
 8004f0c:	4602      	mov	r2, r0
 8004f0e:	460b      	mov	r3, r1
		mixerFM[0][1] * drehratenstellwert.rollen +
 8004f10:	4620      	mov	r0, r4
 8004f12:	4629      	mov	r1, r5
 8004f14:	f7fb f9c2 	bl	800029c <__adddf3>
 8004f18:	4602      	mov	r2, r0
 8004f1a:	460b      	mov	r3, r1
 8004f1c:	4614      	mov	r4, r2
 8004f1e:	461d      	mov	r5, r3
		mixerFM[0][3] * drehratenstellwert.gieren
 8004f20:	4b21      	ldr	r3, [pc, #132]	@ (8004fa8 <regelschritt+0x2438>)
 8004f22:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 8004f26:	4b1d      	ldr	r3, [pc, #116]	@ (8004f9c <regelschritt+0x242c>)
 8004f28:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004f2c:	f7fb fb6c 	bl	8000608 <__aeabi_dmul>
 8004f30:	4602      	mov	r2, r0
 8004f32:	460b      	mov	r3, r1
		mixerFM[0][2] * drehratenstellwert.nicken +
 8004f34:	4620      	mov	r0, r4
 8004f36:	4629      	mov	r1, r5
 8004f38:	f7fb f9b0 	bl	800029c <__adddf3>
 8004f3c:	4602      	mov	r2, r0
 8004f3e:	460b      	mov	r3, r1
	w_cmd[M1] = (
 8004f40:	491a      	ldr	r1, [pc, #104]	@ (8004fac <regelschritt+0x243c>)
 8004f42:	e9c1 2300 	strd	r2, r3, [r1]
	);
	w_cmd[M2] = (
		mixerFM[1][0] * sollschub_norm +
 8004f46:	4b18      	ldr	r3, [pc, #96]	@ (8004fa8 <regelschritt+0x2438>)
 8004f48:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 8004f4c:	4b15      	ldr	r3, [pc, #84]	@ (8004fa4 <regelschritt+0x2434>)
 8004f4e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004f52:	f7fb fb59 	bl	8000608 <__aeabi_dmul>
 8004f56:	4602      	mov	r2, r0
 8004f58:	460b      	mov	r3, r1
 8004f5a:	4614      	mov	r4, r2
 8004f5c:	461d      	mov	r5, r3
		mixerFM[1][1] * drehratenstellwert.rollen +
 8004f5e:	4b12      	ldr	r3, [pc, #72]	@ (8004fa8 <regelschritt+0x2438>)
 8004f60:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
 8004f64:	4b0d      	ldr	r3, [pc, #52]	@ (8004f9c <regelschritt+0x242c>)
 8004f66:	e9d3 2300 	ldrd	r2, r3, [r3]
 8004f6a:	f7fb fb4d 	bl	8000608 <__aeabi_dmul>
 8004f6e:	4602      	mov	r2, r0
 8004f70:	460b      	mov	r3, r1
 8004f72:	e01d      	b.n	8004fb0 <regelschritt+0x2440>
 8004f74:	f3af 8000 	nop.w
 8004f78:	00000000 	.word	0x00000000
 8004f7c:	40000000 	.word	0x40000000
 8004f80:	20000110 	.word	0x20000110
 8004f84:	20001e60 	.word	0x20001e60
 8004f88:	20001eb8 	.word	0x20001eb8
 8004f8c:	20001fd8 	.word	0x20001fd8
 8004f90:	200000e0 	.word	0x200000e0
 8004f94:	200000f8 	.word	0x200000f8
 8004f98:	20001ee8 	.word	0x20001ee8
 8004f9c:	20001ff0 	.word	0x20001ff0
 8004fa0:	20001e48 	.word	0x20001e48
 8004fa4:	20002018 	.word	0x20002018
 8004fa8:	20000030 	.word	0x20000030
 8004fac:	20001f58 	.word	0x20001f58
		mixerFM[1][0] * sollschub_norm +
 8004fb0:	4620      	mov	r0, r4
 8004fb2:	4629      	mov	r1, r5
 8004fb4:	f7fb f972 	bl	800029c <__adddf3>
 8004fb8:	4602      	mov	r2, r0
 8004fba:	460b      	mov	r3, r1
 8004fbc:	4614      	mov	r4, r2
 8004fbe:	461d      	mov	r5, r3
		mixerFM[1][2] * drehratenstellwert.nicken +
 8004fc0:	4b57      	ldr	r3, [pc, #348]	@ (8005120 <regelschritt+0x25b0>)
 8004fc2:	e9d3 010c 	ldrd	r0, r1, [r3, #48]	@ 0x30
 8004fc6:	4b57      	ldr	r3, [pc, #348]	@ (8005124 <regelschritt+0x25b4>)
 8004fc8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8004fcc:	f7fb fb1c 	bl	8000608 <__aeabi_dmul>
 8004fd0:	4602      	mov	r2, r0
 8004fd2:	460b      	mov	r3, r1
		mixerFM[1][1] * drehratenstellwert.rollen +
 8004fd4:	4620      	mov	r0, r4
 8004fd6:	4629      	mov	r1, r5
 8004fd8:	f7fb f960 	bl	800029c <__adddf3>
 8004fdc:	4602      	mov	r2, r0
 8004fde:	460b      	mov	r3, r1
 8004fe0:	4614      	mov	r4, r2
 8004fe2:	461d      	mov	r5, r3
		mixerFM[1][3] * drehratenstellwert.gieren
 8004fe4:	4b4e      	ldr	r3, [pc, #312]	@ (8005120 <regelschritt+0x25b0>)
 8004fe6:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	@ 0x38
 8004fea:	4b4e      	ldr	r3, [pc, #312]	@ (8005124 <regelschritt+0x25b4>)
 8004fec:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8004ff0:	f7fb fb0a 	bl	8000608 <__aeabi_dmul>
 8004ff4:	4602      	mov	r2, r0
 8004ff6:	460b      	mov	r3, r1
		mixerFM[1][2] * drehratenstellwert.nicken +
 8004ff8:	4620      	mov	r0, r4
 8004ffa:	4629      	mov	r1, r5
 8004ffc:	f7fb f94e 	bl	800029c <__adddf3>
 8005000:	4602      	mov	r2, r0
 8005002:	460b      	mov	r3, r1
	w_cmd[M2] = (
 8005004:	4948      	ldr	r1, [pc, #288]	@ (8005128 <regelschritt+0x25b8>)
 8005006:	e9c1 2302 	strd	r2, r3, [r1, #8]
	);
	w_cmd[M3] = (
		mixerFM[2][0] * sollschub_norm +
 800500a:	4b45      	ldr	r3, [pc, #276]	@ (8005120 <regelschritt+0x25b0>)
 800500c:	e9d3 0110 	ldrd	r0, r1, [r3, #64]	@ 0x40
 8005010:	4b46      	ldr	r3, [pc, #280]	@ (800512c <regelschritt+0x25bc>)
 8005012:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005016:	f7fb faf7 	bl	8000608 <__aeabi_dmul>
 800501a:	4602      	mov	r2, r0
 800501c:	460b      	mov	r3, r1
 800501e:	4614      	mov	r4, r2
 8005020:	461d      	mov	r5, r3
		mixerFM[2][1] * drehratenstellwert.rollen +
 8005022:	4b3f      	ldr	r3, [pc, #252]	@ (8005120 <regelschritt+0x25b0>)
 8005024:	e9d3 0112 	ldrd	r0, r1, [r3, #72]	@ 0x48
 8005028:	4b3e      	ldr	r3, [pc, #248]	@ (8005124 <regelschritt+0x25b4>)
 800502a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800502e:	f7fb faeb 	bl	8000608 <__aeabi_dmul>
 8005032:	4602      	mov	r2, r0
 8005034:	460b      	mov	r3, r1
		mixerFM[2][0] * sollschub_norm +
 8005036:	4620      	mov	r0, r4
 8005038:	4629      	mov	r1, r5
 800503a:	f7fb f92f 	bl	800029c <__adddf3>
 800503e:	4602      	mov	r2, r0
 8005040:	460b      	mov	r3, r1
 8005042:	4614      	mov	r4, r2
 8005044:	461d      	mov	r5, r3
		mixerFM[2][2] * drehratenstellwert.nicken +
 8005046:	4b36      	ldr	r3, [pc, #216]	@ (8005120 <regelschritt+0x25b0>)
 8005048:	e9d3 0114 	ldrd	r0, r1, [r3, #80]	@ 0x50
 800504c:	4b35      	ldr	r3, [pc, #212]	@ (8005124 <regelschritt+0x25b4>)
 800504e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8005052:	f7fb fad9 	bl	8000608 <__aeabi_dmul>
 8005056:	4602      	mov	r2, r0
 8005058:	460b      	mov	r3, r1
		mixerFM[2][1] * drehratenstellwert.rollen +
 800505a:	4620      	mov	r0, r4
 800505c:	4629      	mov	r1, r5
 800505e:	f7fb f91d 	bl	800029c <__adddf3>
 8005062:	4602      	mov	r2, r0
 8005064:	460b      	mov	r3, r1
 8005066:	4614      	mov	r4, r2
 8005068:	461d      	mov	r5, r3
		mixerFM[2][3] * drehratenstellwert.gieren
 800506a:	4b2d      	ldr	r3, [pc, #180]	@ (8005120 <regelschritt+0x25b0>)
 800506c:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	@ 0x58
 8005070:	4b2c      	ldr	r3, [pc, #176]	@ (8005124 <regelschritt+0x25b4>)
 8005072:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8005076:	f7fb fac7 	bl	8000608 <__aeabi_dmul>
 800507a:	4602      	mov	r2, r0
 800507c:	460b      	mov	r3, r1
		mixerFM[2][2] * drehratenstellwert.nicken +
 800507e:	4620      	mov	r0, r4
 8005080:	4629      	mov	r1, r5
 8005082:	f7fb f90b 	bl	800029c <__adddf3>
 8005086:	4602      	mov	r2, r0
 8005088:	460b      	mov	r3, r1
	w_cmd[M3] = (
 800508a:	4927      	ldr	r1, [pc, #156]	@ (8005128 <regelschritt+0x25b8>)
 800508c:	e9c1 2304 	strd	r2, r3, [r1, #16]
	);
	w_cmd[M4] = (
		mixerFM[3][0] * sollschub_norm +
 8005090:	4b23      	ldr	r3, [pc, #140]	@ (8005120 <regelschritt+0x25b0>)
 8005092:	e9d3 0118 	ldrd	r0, r1, [r3, #96]	@ 0x60
 8005096:	4b25      	ldr	r3, [pc, #148]	@ (800512c <regelschritt+0x25bc>)
 8005098:	e9d3 2300 	ldrd	r2, r3, [r3]
 800509c:	f7fb fab4 	bl	8000608 <__aeabi_dmul>
 80050a0:	4602      	mov	r2, r0
 80050a2:	460b      	mov	r3, r1
 80050a4:	4614      	mov	r4, r2
 80050a6:	461d      	mov	r5, r3
		mixerFM[3][1] * drehratenstellwert.rollen +
 80050a8:	4b1d      	ldr	r3, [pc, #116]	@ (8005120 <regelschritt+0x25b0>)
 80050aa:	e9d3 011a 	ldrd	r0, r1, [r3, #104]	@ 0x68
 80050ae:	4b1d      	ldr	r3, [pc, #116]	@ (8005124 <regelschritt+0x25b4>)
 80050b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80050b4:	f7fb faa8 	bl	8000608 <__aeabi_dmul>
 80050b8:	4602      	mov	r2, r0
 80050ba:	460b      	mov	r3, r1
		mixerFM[3][0] * sollschub_norm +
 80050bc:	4620      	mov	r0, r4
 80050be:	4629      	mov	r1, r5
 80050c0:	f7fb f8ec 	bl	800029c <__adddf3>
 80050c4:	4602      	mov	r2, r0
 80050c6:	460b      	mov	r3, r1
 80050c8:	4614      	mov	r4, r2
 80050ca:	461d      	mov	r5, r3
		mixerFM[3][2] * drehratenstellwert.nicken +
 80050cc:	4b14      	ldr	r3, [pc, #80]	@ (8005120 <regelschritt+0x25b0>)
 80050ce:	e9d3 011c 	ldrd	r0, r1, [r3, #112]	@ 0x70
 80050d2:	4b14      	ldr	r3, [pc, #80]	@ (8005124 <regelschritt+0x25b4>)
 80050d4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80050d8:	f7fb fa96 	bl	8000608 <__aeabi_dmul>
 80050dc:	4602      	mov	r2, r0
 80050de:	460b      	mov	r3, r1
		mixerFM[3][1] * drehratenstellwert.rollen +
 80050e0:	4620      	mov	r0, r4
 80050e2:	4629      	mov	r1, r5
 80050e4:	f7fb f8da 	bl	800029c <__adddf3>
 80050e8:	4602      	mov	r2, r0
 80050ea:	460b      	mov	r3, r1
 80050ec:	4614      	mov	r4, r2
 80050ee:	461d      	mov	r5, r3
		mixerFM[3][3] * drehratenstellwert.gieren
 80050f0:	4b0b      	ldr	r3, [pc, #44]	@ (8005120 <regelschritt+0x25b0>)
 80050f2:	e9d3 011e 	ldrd	r0, r1, [r3, #120]	@ 0x78
 80050f6:	4b0b      	ldr	r3, [pc, #44]	@ (8005124 <regelschritt+0x25b4>)
 80050f8:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 80050fc:	f7fb fa84 	bl	8000608 <__aeabi_dmul>
 8005100:	4602      	mov	r2, r0
 8005102:	460b      	mov	r3, r1
		mixerFM[3][2] * drehratenstellwert.nicken +
 8005104:	4620      	mov	r0, r4
 8005106:	4629      	mov	r1, r5
 8005108:	f7fb f8c8 	bl	800029c <__adddf3>
 800510c:	4602      	mov	r2, r0
 800510e:	460b      	mov	r3, r1
	w_cmd[M4] = (
 8005110:	4905      	ldr	r1, [pc, #20]	@ (8005128 <regelschritt+0x25b8>)
 8005112:	e9c1 2306 	strd	r2, r3, [r1, #24]
	);

	for (int i = 0; i < 4; i++) {
 8005116:	2300      	movs	r3, #0
 8005118:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
 800511c:	e087      	b.n	800522e <regelschritt+0x26be>
 800511e:	bf00      	nop
 8005120:	20000030 	.word	0x20000030
 8005124:	20001ff0 	.word	0x20001ff0
 8005128:	20001f58 	.word	0x20001f58
 800512c:	20002018 	.word	0x20002018
		if (w_cmd[i] < pow(minWMotor, 2)) {
 8005130:	4ad3      	ldr	r2, [pc, #844]	@ (8005480 <regelschritt+0x2910>)
 8005132:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 8005136:	00db      	lsls	r3, r3, #3
 8005138:	4413      	add	r3, r2
 800513a:	e9d3 4500 	ldrd	r4, r5, [r3]
 800513e:	4bd1      	ldr	r3, [pc, #836]	@ (8005484 <regelschritt+0x2914>)
 8005140:	ed93 7b00 	vldr	d7, [r3]
 8005144:	ed9f 1bca 	vldr	d1, [pc, #808]	@ 8005470 <regelschritt+0x2900>
 8005148:	eeb0 0a47 	vmov.f32	s0, s14
 800514c:	eef0 0a67 	vmov.f32	s1, s15
 8005150:	f01a fa06 	bl	801f560 <pow>
 8005154:	ec53 2b10 	vmov	r2, r3, d0
 8005158:	4620      	mov	r0, r4
 800515a:	4629      	mov	r1, r5
 800515c:	f7fb fcc6 	bl	8000aec <__aeabi_dcmplt>
 8005160:	4603      	mov	r3, r0
 8005162:	2b00      	cmp	r3, #0
 8005164:	d015      	beq.n	8005192 <regelschritt+0x2622>
			w_cmd[i] = pow(minWMotor, 2);
 8005166:	4bc7      	ldr	r3, [pc, #796]	@ (8005484 <regelschritt+0x2914>)
 8005168:	ed93 7b00 	vldr	d7, [r3]
 800516c:	ed9f 1bc0 	vldr	d1, [pc, #768]	@ 8005470 <regelschritt+0x2900>
 8005170:	eeb0 0a47 	vmov.f32	s0, s14
 8005174:	eef0 0a67 	vmov.f32	s1, s15
 8005178:	f01a f9f2 	bl	801f560 <pow>
 800517c:	eeb0 7a40 	vmov.f32	s14, s0
 8005180:	eef0 7a60 	vmov.f32	s15, s1
 8005184:	4abe      	ldr	r2, [pc, #760]	@ (8005480 <regelschritt+0x2910>)
 8005186:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 800518a:	00db      	lsls	r3, r3, #3
 800518c:	4413      	add	r3, r2
 800518e:	ed83 7b00 	vstr	d7, [r3]
		};
		if (w_cmd[i] > pow(maxWMotor, 2)) {
 8005192:	4abb      	ldr	r2, [pc, #748]	@ (8005480 <regelschritt+0x2910>)
 8005194:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 8005198:	00db      	lsls	r3, r3, #3
 800519a:	4413      	add	r3, r2
 800519c:	e9d3 4500 	ldrd	r4, r5, [r3]
 80051a0:	4bb9      	ldr	r3, [pc, #740]	@ (8005488 <regelschritt+0x2918>)
 80051a2:	ed93 7b00 	vldr	d7, [r3]
 80051a6:	ed9f 1bb2 	vldr	d1, [pc, #712]	@ 8005470 <regelschritt+0x2900>
 80051aa:	eeb0 0a47 	vmov.f32	s0, s14
 80051ae:	eef0 0a67 	vmov.f32	s1, s15
 80051b2:	f01a f9d5 	bl	801f560 <pow>
 80051b6:	ec53 2b10 	vmov	r2, r3, d0
 80051ba:	4620      	mov	r0, r4
 80051bc:	4629      	mov	r1, r5
 80051be:	f7fb fcb3 	bl	8000b28 <__aeabi_dcmpgt>
 80051c2:	4603      	mov	r3, r0
 80051c4:	2b00      	cmp	r3, #0
 80051c6:	d015      	beq.n	80051f4 <regelschritt+0x2684>
			w_cmd[i] = pow(maxWMotor, 2);
 80051c8:	4baf      	ldr	r3, [pc, #700]	@ (8005488 <regelschritt+0x2918>)
 80051ca:	ed93 7b00 	vldr	d7, [r3]
 80051ce:	ed9f 1ba8 	vldr	d1, [pc, #672]	@ 8005470 <regelschritt+0x2900>
 80051d2:	eeb0 0a47 	vmov.f32	s0, s14
 80051d6:	eef0 0a67 	vmov.f32	s1, s15
 80051da:	f01a f9c1 	bl	801f560 <pow>
 80051de:	eeb0 7a40 	vmov.f32	s14, s0
 80051e2:	eef0 7a60 	vmov.f32	s15, s1
 80051e6:	4aa6      	ldr	r2, [pc, #664]	@ (8005480 <regelschritt+0x2910>)
 80051e8:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 80051ec:	00db      	lsls	r3, r3, #3
 80051ee:	4413      	add	r3, r2
 80051f0:	ed83 7b00 	vstr	d7, [r3]
		};

		w_cmd[i] = sqrt(w_cmd[i]);
 80051f4:	4aa2      	ldr	r2, [pc, #648]	@ (8005480 <regelschritt+0x2910>)
 80051f6:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 80051fa:	00db      	lsls	r3, r3, #3
 80051fc:	4413      	add	r3, r2
 80051fe:	ed93 7b00 	vldr	d7, [r3]
 8005202:	eeb0 0a47 	vmov.f32	s0, s14
 8005206:	eef0 0a67 	vmov.f32	s1, s15
 800520a:	f01a fa19 	bl	801f640 <sqrt>
 800520e:	eeb0 7a40 	vmov.f32	s14, s0
 8005212:	eef0 7a60 	vmov.f32	s15, s1
 8005216:	4a9a      	ldr	r2, [pc, #616]	@ (8005480 <regelschritt+0x2910>)
 8005218:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 800521c:	00db      	lsls	r3, r3, #3
 800521e:	4413      	add	r3, r2
 8005220:	ed83 7b00 	vstr	d7, [r3]
	for (int i = 0; i < 4; i++) {
 8005224:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 8005228:	3301      	adds	r3, #1
 800522a:	f8c7 321c 	str.w	r3, [r7, #540]	@ 0x21c
 800522e:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 8005232:	2b03      	cmp	r3, #3
 8005234:	f77f af7c 	ble.w	8005130 <regelschritt+0x25c0>
	};

	// PWM
	schub = joystick_schub / 100.0f;
 8005238:	4b94      	ldr	r3, [pc, #592]	@ (800548c <regelschritt+0x291c>)
 800523a:	781b      	ldrb	r3, [r3, #0]
 800523c:	ee07 3a90 	vmov	s15, r3
 8005240:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8005244:	eddf 6a92 	vldr	s13, [pc, #584]	@ 8005490 <regelschritt+0x2920>
 8005248:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800524c:	4b91      	ldr	r3, [pc, #580]	@ (8005494 <regelschritt+0x2924>)
 800524e:	edc3 7a00 	vstr	s15, [r3]
	if (regleran) {
 8005252:	4b91      	ldr	r3, [pc, #580]	@ (8005498 <regelschritt+0x2928>)
 8005254:	781b      	ldrb	r3, [r3, #0]
 8005256:	2b00      	cmp	r3, #0
 8005258:	f000 8199 	beq.w	800558e <regelschritt+0x2a1e>
		skalar = (pwmoberegrenze - pwmunteregrenze) / 1000.0f;
 800525c:	4b8f      	ldr	r3, [pc, #572]	@ (800549c <regelschritt+0x292c>)
 800525e:	ed93 7a00 	vldr	s14, [r3]
 8005262:	4b8f      	ldr	r3, [pc, #572]	@ (80054a0 <regelschritt+0x2930>)
 8005264:	edd3 7a00 	vldr	s15, [r3]
 8005268:	ee37 7a67 	vsub.f32	s14, s14, s15
 800526c:	eddf 6a8d 	vldr	s13, [pc, #564]	@ 80054a4 <regelschritt+0x2934>
 8005270:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8005274:	4b8c      	ldr	r3, [pc, #560]	@ (80054a8 <regelschritt+0x2938>)
 8005276:	edc3 7a00 	vstr	s15, [r3]
		// Pin PA8
		TIM1->CCR1 = ((skalar * schub * ((w_cmd[M1] + w_cmd_tminus1[M1] + w_cmd_tminus2[M1]) / 3) + pwmunteregrenze) / 1000.0f) * 30259;
 800527a:	4b8b      	ldr	r3, [pc, #556]	@ (80054a8 <regelschritt+0x2938>)
 800527c:	ed93 7a00 	vldr	s14, [r3]
 8005280:	4b84      	ldr	r3, [pc, #528]	@ (8005494 <regelschritt+0x2924>)
 8005282:	edd3 7a00 	vldr	s15, [r3]
 8005286:	ee67 7a27 	vmul.f32	s15, s14, s15
 800528a:	ee17 0a90 	vmov	r0, s15
 800528e:	f7fb f963 	bl	8000558 <__aeabi_f2d>
 8005292:	4604      	mov	r4, r0
 8005294:	460d      	mov	r5, r1
 8005296:	4b7a      	ldr	r3, [pc, #488]	@ (8005480 <regelschritt+0x2910>)
 8005298:	e9d3 0100 	ldrd	r0, r1, [r3]
 800529c:	4b83      	ldr	r3, [pc, #524]	@ (80054ac <regelschritt+0x293c>)
 800529e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80052a2:	f7fa fffb 	bl	800029c <__adddf3>
 80052a6:	4602      	mov	r2, r0
 80052a8:	460b      	mov	r3, r1
 80052aa:	4610      	mov	r0, r2
 80052ac:	4619      	mov	r1, r3
 80052ae:	4b80      	ldr	r3, [pc, #512]	@ (80054b0 <regelschritt+0x2940>)
 80052b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80052b4:	f7fa fff2 	bl	800029c <__adddf3>
 80052b8:	4602      	mov	r2, r0
 80052ba:	460b      	mov	r3, r1
 80052bc:	4610      	mov	r0, r2
 80052be:	4619      	mov	r1, r3
 80052c0:	f04f 0200 	mov.w	r2, #0
 80052c4:	4b7b      	ldr	r3, [pc, #492]	@ (80054b4 <regelschritt+0x2944>)
 80052c6:	f7fb fac9 	bl	800085c <__aeabi_ddiv>
 80052ca:	4602      	mov	r2, r0
 80052cc:	460b      	mov	r3, r1
 80052ce:	4620      	mov	r0, r4
 80052d0:	4629      	mov	r1, r5
 80052d2:	f7fb f999 	bl	8000608 <__aeabi_dmul>
 80052d6:	4602      	mov	r2, r0
 80052d8:	460b      	mov	r3, r1
 80052da:	4614      	mov	r4, r2
 80052dc:	461d      	mov	r5, r3
 80052de:	4b70      	ldr	r3, [pc, #448]	@ (80054a0 <regelschritt+0x2930>)
 80052e0:	681b      	ldr	r3, [r3, #0]
 80052e2:	4618      	mov	r0, r3
 80052e4:	f7fb f938 	bl	8000558 <__aeabi_f2d>
 80052e8:	4602      	mov	r2, r0
 80052ea:	460b      	mov	r3, r1
 80052ec:	4620      	mov	r0, r4
 80052ee:	4629      	mov	r1, r5
 80052f0:	f7fa ffd4 	bl	800029c <__adddf3>
 80052f4:	4602      	mov	r2, r0
 80052f6:	460b      	mov	r3, r1
 80052f8:	4610      	mov	r0, r2
 80052fa:	4619      	mov	r1, r3
 80052fc:	f04f 0200 	mov.w	r2, #0
 8005300:	4b6d      	ldr	r3, [pc, #436]	@ (80054b8 <regelschritt+0x2948>)
 8005302:	f7fb faab 	bl	800085c <__aeabi_ddiv>
 8005306:	4602      	mov	r2, r0
 8005308:	460b      	mov	r3, r1
 800530a:	4610      	mov	r0, r2
 800530c:	4619      	mov	r1, r3
 800530e:	a35a      	add	r3, pc, #360	@ (adr r3, 8005478 <regelschritt+0x2908>)
 8005310:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005314:	f7fb f978 	bl	8000608 <__aeabi_dmul>
 8005318:	4602      	mov	r2, r0
 800531a:	460b      	mov	r3, r1
 800531c:	4c67      	ldr	r4, [pc, #412]	@ (80054bc <regelschritt+0x294c>)
 800531e:	4610      	mov	r0, r2
 8005320:	4619      	mov	r1, r3
 8005322:	f7fb fc49 	bl	8000bb8 <__aeabi_d2uiz>
 8005326:	4603      	mov	r3, r0
 8005328:	6363      	str	r3, [r4, #52]	@ 0x34
		// Pin PA9
		TIM1->CCR2 = ((skalar * schub * ((w_cmd[M2] + w_cmd_tminus1[M2] + w_cmd_tminus2[M2]) / 3) + pwmunteregrenze) / 1000.0f) * 30259;
 800532a:	4b5f      	ldr	r3, [pc, #380]	@ (80054a8 <regelschritt+0x2938>)
 800532c:	ed93 7a00 	vldr	s14, [r3]
 8005330:	4b58      	ldr	r3, [pc, #352]	@ (8005494 <regelschritt+0x2924>)
 8005332:	edd3 7a00 	vldr	s15, [r3]
 8005336:	ee67 7a27 	vmul.f32	s15, s14, s15
 800533a:	ee17 0a90 	vmov	r0, s15
 800533e:	f7fb f90b 	bl	8000558 <__aeabi_f2d>
 8005342:	4604      	mov	r4, r0
 8005344:	460d      	mov	r5, r1
 8005346:	4b4e      	ldr	r3, [pc, #312]	@ (8005480 <regelschritt+0x2910>)
 8005348:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
 800534c:	4b57      	ldr	r3, [pc, #348]	@ (80054ac <regelschritt+0x293c>)
 800534e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8005352:	f7fa ffa3 	bl	800029c <__adddf3>
 8005356:	4602      	mov	r2, r0
 8005358:	460b      	mov	r3, r1
 800535a:	4610      	mov	r0, r2
 800535c:	4619      	mov	r1, r3
 800535e:	4b54      	ldr	r3, [pc, #336]	@ (80054b0 <regelschritt+0x2940>)
 8005360:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8005364:	f7fa ff9a 	bl	800029c <__adddf3>
 8005368:	4602      	mov	r2, r0
 800536a:	460b      	mov	r3, r1
 800536c:	4610      	mov	r0, r2
 800536e:	4619      	mov	r1, r3
 8005370:	f04f 0200 	mov.w	r2, #0
 8005374:	4b4f      	ldr	r3, [pc, #316]	@ (80054b4 <regelschritt+0x2944>)
 8005376:	f7fb fa71 	bl	800085c <__aeabi_ddiv>
 800537a:	4602      	mov	r2, r0
 800537c:	460b      	mov	r3, r1
 800537e:	4620      	mov	r0, r4
 8005380:	4629      	mov	r1, r5
 8005382:	f7fb f941 	bl	8000608 <__aeabi_dmul>
 8005386:	4602      	mov	r2, r0
 8005388:	460b      	mov	r3, r1
 800538a:	4614      	mov	r4, r2
 800538c:	461d      	mov	r5, r3
 800538e:	4b44      	ldr	r3, [pc, #272]	@ (80054a0 <regelschritt+0x2930>)
 8005390:	681b      	ldr	r3, [r3, #0]
 8005392:	4618      	mov	r0, r3
 8005394:	f7fb f8e0 	bl	8000558 <__aeabi_f2d>
 8005398:	4602      	mov	r2, r0
 800539a:	460b      	mov	r3, r1
 800539c:	4620      	mov	r0, r4
 800539e:	4629      	mov	r1, r5
 80053a0:	f7fa ff7c 	bl	800029c <__adddf3>
 80053a4:	4602      	mov	r2, r0
 80053a6:	460b      	mov	r3, r1
 80053a8:	4610      	mov	r0, r2
 80053aa:	4619      	mov	r1, r3
 80053ac:	f04f 0200 	mov.w	r2, #0
 80053b0:	4b41      	ldr	r3, [pc, #260]	@ (80054b8 <regelschritt+0x2948>)
 80053b2:	f7fb fa53 	bl	800085c <__aeabi_ddiv>
 80053b6:	4602      	mov	r2, r0
 80053b8:	460b      	mov	r3, r1
 80053ba:	4610      	mov	r0, r2
 80053bc:	4619      	mov	r1, r3
 80053be:	a32e      	add	r3, pc, #184	@ (adr r3, 8005478 <regelschritt+0x2908>)
 80053c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80053c4:	f7fb f920 	bl	8000608 <__aeabi_dmul>
 80053c8:	4602      	mov	r2, r0
 80053ca:	460b      	mov	r3, r1
 80053cc:	4c3b      	ldr	r4, [pc, #236]	@ (80054bc <regelschritt+0x294c>)
 80053ce:	4610      	mov	r0, r2
 80053d0:	4619      	mov	r1, r3
 80053d2:	f7fb fbf1 	bl	8000bb8 <__aeabi_d2uiz>
 80053d6:	4603      	mov	r3, r0
 80053d8:	63a3      	str	r3, [r4, #56]	@ 0x38
		// Pin PA10
		TIM1->CCR3 = ((skalar * schub * ((w_cmd[M3] + w_cmd_tminus1[M3] + w_cmd_tminus2[M3]) / 3) + pwmunteregrenze) / 1000.0f) * 30259;
 80053da:	4b33      	ldr	r3, [pc, #204]	@ (80054a8 <regelschritt+0x2938>)
 80053dc:	ed93 7a00 	vldr	s14, [r3]
 80053e0:	4b2c      	ldr	r3, [pc, #176]	@ (8005494 <regelschritt+0x2924>)
 80053e2:	edd3 7a00 	vldr	s15, [r3]
 80053e6:	ee67 7a27 	vmul.f32	s15, s14, s15
 80053ea:	ee17 0a90 	vmov	r0, s15
 80053ee:	f7fb f8b3 	bl	8000558 <__aeabi_f2d>
 80053f2:	4604      	mov	r4, r0
 80053f4:	460d      	mov	r5, r1
 80053f6:	4b22      	ldr	r3, [pc, #136]	@ (8005480 <regelschritt+0x2910>)
 80053f8:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 80053fc:	4b2b      	ldr	r3, [pc, #172]	@ (80054ac <regelschritt+0x293c>)
 80053fe:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8005402:	f7fa ff4b 	bl	800029c <__adddf3>
 8005406:	4602      	mov	r2, r0
 8005408:	460b      	mov	r3, r1
 800540a:	4610      	mov	r0, r2
 800540c:	4619      	mov	r1, r3
 800540e:	4b28      	ldr	r3, [pc, #160]	@ (80054b0 <regelschritt+0x2940>)
 8005410:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8005414:	f7fa ff42 	bl	800029c <__adddf3>
 8005418:	4602      	mov	r2, r0
 800541a:	460b      	mov	r3, r1
 800541c:	4610      	mov	r0, r2
 800541e:	4619      	mov	r1, r3
 8005420:	f04f 0200 	mov.w	r2, #0
 8005424:	4b23      	ldr	r3, [pc, #140]	@ (80054b4 <regelschritt+0x2944>)
 8005426:	f7fb fa19 	bl	800085c <__aeabi_ddiv>
 800542a:	4602      	mov	r2, r0
 800542c:	460b      	mov	r3, r1
 800542e:	4620      	mov	r0, r4
 8005430:	4629      	mov	r1, r5
 8005432:	f7fb f8e9 	bl	8000608 <__aeabi_dmul>
 8005436:	4602      	mov	r2, r0
 8005438:	460b      	mov	r3, r1
 800543a:	4614      	mov	r4, r2
 800543c:	461d      	mov	r5, r3
 800543e:	4b18      	ldr	r3, [pc, #96]	@ (80054a0 <regelschritt+0x2930>)
 8005440:	681b      	ldr	r3, [r3, #0]
 8005442:	4618      	mov	r0, r3
 8005444:	f7fb f888 	bl	8000558 <__aeabi_f2d>
 8005448:	4602      	mov	r2, r0
 800544a:	460b      	mov	r3, r1
 800544c:	4620      	mov	r0, r4
 800544e:	4629      	mov	r1, r5
 8005450:	f7fa ff24 	bl	800029c <__adddf3>
 8005454:	4602      	mov	r2, r0
 8005456:	460b      	mov	r3, r1
 8005458:	4610      	mov	r0, r2
 800545a:	4619      	mov	r1, r3
 800545c:	f04f 0200 	mov.w	r2, #0
 8005460:	4b15      	ldr	r3, [pc, #84]	@ (80054b8 <regelschritt+0x2948>)
 8005462:	f7fb f9fb 	bl	800085c <__aeabi_ddiv>
 8005466:	4602      	mov	r2, r0
 8005468:	460b      	mov	r3, r1
 800546a:	4610      	mov	r0, r2
 800546c:	4619      	mov	r1, r3
 800546e:	e027      	b.n	80054c0 <regelschritt+0x2950>
 8005470:	00000000 	.word	0x00000000
 8005474:	40000000 	.word	0x40000000
 8005478:	00000000 	.word	0x00000000
 800547c:	40dd8cc0 	.word	0x40dd8cc0
 8005480:	20001f58 	.word	0x20001f58
 8005484:	20001e08 	.word	0x20001e08
 8005488:	20000128 	.word	0x20000128
 800548c:	20001c64 	.word	0x20001c64
 8005490:	42c80000 	.word	0x42c80000
 8005494:	20001e40 	.word	0x20001e40
 8005498:	20001c91 	.word	0x20001c91
 800549c:	2000000c 	.word	0x2000000c
 80054a0:	20000008 	.word	0x20000008
 80054a4:	447a0000 	.word	0x447a0000
 80054a8:	20001f00 	.word	0x20001f00
 80054ac:	20001f78 	.word	0x20001f78
 80054b0:	20001f98 	.word	0x20001f98
 80054b4:	40080000 	.word	0x40080000
 80054b8:	408f4000 	.word	0x408f4000
 80054bc:	40010000 	.word	0x40010000
 80054c0:	a371      	add	r3, pc, #452	@ (adr r3, 8005688 <regelschritt+0x2b18>)
 80054c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80054c6:	f7fb f89f 	bl	8000608 <__aeabi_dmul>
 80054ca:	4602      	mov	r2, r0
 80054cc:	460b      	mov	r3, r1
 80054ce:	4c70      	ldr	r4, [pc, #448]	@ (8005690 <regelschritt+0x2b20>)
 80054d0:	4610      	mov	r0, r2
 80054d2:	4619      	mov	r1, r3
 80054d4:	f7fb fb70 	bl	8000bb8 <__aeabi_d2uiz>
 80054d8:	4603      	mov	r3, r0
 80054da:	63e3      	str	r3, [r4, #60]	@ 0x3c
		// Pin PA11
		TIM1->CCR4 = ((skalar * schub * ((w_cmd[M4] + w_cmd_tminus1[M4] + w_cmd_tminus2[M4]) / 3) + pwmunteregrenze) / 1000.0f) * 30259;
 80054dc:	4b6d      	ldr	r3, [pc, #436]	@ (8005694 <regelschritt+0x2b24>)
 80054de:	ed93 7a00 	vldr	s14, [r3]
 80054e2:	4b6d      	ldr	r3, [pc, #436]	@ (8005698 <regelschritt+0x2b28>)
 80054e4:	edd3 7a00 	vldr	s15, [r3]
 80054e8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80054ec:	ee17 0a90 	vmov	r0, s15
 80054f0:	f7fb f832 	bl	8000558 <__aeabi_f2d>
 80054f4:	4604      	mov	r4, r0
 80054f6:	460d      	mov	r5, r1
 80054f8:	4b68      	ldr	r3, [pc, #416]	@ (800569c <regelschritt+0x2b2c>)
 80054fa:	e9d3 0106 	ldrd	r0, r1, [r3, #24]
 80054fe:	4b68      	ldr	r3, [pc, #416]	@ (80056a0 <regelschritt+0x2b30>)
 8005500:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8005504:	f7fa feca 	bl	800029c <__adddf3>
 8005508:	4602      	mov	r2, r0
 800550a:	460b      	mov	r3, r1
 800550c:	4610      	mov	r0, r2
 800550e:	4619      	mov	r1, r3
 8005510:	4b64      	ldr	r3, [pc, #400]	@ (80056a4 <regelschritt+0x2b34>)
 8005512:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8005516:	f7fa fec1 	bl	800029c <__adddf3>
 800551a:	4602      	mov	r2, r0
 800551c:	460b      	mov	r3, r1
 800551e:	4610      	mov	r0, r2
 8005520:	4619      	mov	r1, r3
 8005522:	f04f 0200 	mov.w	r2, #0
 8005526:	4b60      	ldr	r3, [pc, #384]	@ (80056a8 <regelschritt+0x2b38>)
 8005528:	f7fb f998 	bl	800085c <__aeabi_ddiv>
 800552c:	4602      	mov	r2, r0
 800552e:	460b      	mov	r3, r1
 8005530:	4620      	mov	r0, r4
 8005532:	4629      	mov	r1, r5
 8005534:	f7fb f868 	bl	8000608 <__aeabi_dmul>
 8005538:	4602      	mov	r2, r0
 800553a:	460b      	mov	r3, r1
 800553c:	4614      	mov	r4, r2
 800553e:	461d      	mov	r5, r3
 8005540:	4b5a      	ldr	r3, [pc, #360]	@ (80056ac <regelschritt+0x2b3c>)
 8005542:	681b      	ldr	r3, [r3, #0]
 8005544:	4618      	mov	r0, r3
 8005546:	f7fb f807 	bl	8000558 <__aeabi_f2d>
 800554a:	4602      	mov	r2, r0
 800554c:	460b      	mov	r3, r1
 800554e:	4620      	mov	r0, r4
 8005550:	4629      	mov	r1, r5
 8005552:	f7fa fea3 	bl	800029c <__adddf3>
 8005556:	4602      	mov	r2, r0
 8005558:	460b      	mov	r3, r1
 800555a:	4610      	mov	r0, r2
 800555c:	4619      	mov	r1, r3
 800555e:	f04f 0200 	mov.w	r2, #0
 8005562:	4b53      	ldr	r3, [pc, #332]	@ (80056b0 <regelschritt+0x2b40>)
 8005564:	f7fb f97a 	bl	800085c <__aeabi_ddiv>
 8005568:	4602      	mov	r2, r0
 800556a:	460b      	mov	r3, r1
 800556c:	4610      	mov	r0, r2
 800556e:	4619      	mov	r1, r3
 8005570:	a345      	add	r3, pc, #276	@ (adr r3, 8005688 <regelschritt+0x2b18>)
 8005572:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005576:	f7fb f847 	bl	8000608 <__aeabi_dmul>
 800557a:	4602      	mov	r2, r0
 800557c:	460b      	mov	r3, r1
 800557e:	4c44      	ldr	r4, [pc, #272]	@ (8005690 <regelschritt+0x2b20>)
 8005580:	4610      	mov	r0, r2
 8005582:	4619      	mov	r1, r3
 8005584:	f7fb fb18 	bl	8000bb8 <__aeabi_d2uiz>
 8005588:	4603      	mov	r3, r0
 800558a:	6423      	str	r3, [r4, #64]	@ 0x40
 800558c:	e044      	b.n	8005618 <regelschritt+0x2aa8>
	} else if (schubnur) {
 800558e:	4b49      	ldr	r3, [pc, #292]	@ (80056b4 <regelschritt+0x2b44>)
 8005590:	681b      	ldr	r3, [r3, #0]
 8005592:	2b00      	cmp	r3, #0
 8005594:	d034      	beq.n	8005600 <regelschritt+0x2a90>
		TIM1->CCR1 = schub * 30259;
 8005596:	4b40      	ldr	r3, [pc, #256]	@ (8005698 <regelschritt+0x2b28>)
 8005598:	edd3 7a00 	vldr	s15, [r3]
 800559c:	ed9f 7a46 	vldr	s14, [pc, #280]	@ 80056b8 <regelschritt+0x2b48>
 80055a0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80055a4:	4b3a      	ldr	r3, [pc, #232]	@ (8005690 <regelschritt+0x2b20>)
 80055a6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80055aa:	ee17 2a90 	vmov	r2, s15
 80055ae:	635a      	str	r2, [r3, #52]	@ 0x34
		TIM1->CCR2 = schub * 30259;
 80055b0:	4b39      	ldr	r3, [pc, #228]	@ (8005698 <regelschritt+0x2b28>)
 80055b2:	edd3 7a00 	vldr	s15, [r3]
 80055b6:	ed9f 7a40 	vldr	s14, [pc, #256]	@ 80056b8 <regelschritt+0x2b48>
 80055ba:	ee67 7a87 	vmul.f32	s15, s15, s14
 80055be:	4b34      	ldr	r3, [pc, #208]	@ (8005690 <regelschritt+0x2b20>)
 80055c0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80055c4:	ee17 2a90 	vmov	r2, s15
 80055c8:	639a      	str	r2, [r3, #56]	@ 0x38
		TIM1->CCR3 = schub * 30259;
 80055ca:	4b33      	ldr	r3, [pc, #204]	@ (8005698 <regelschritt+0x2b28>)
 80055cc:	edd3 7a00 	vldr	s15, [r3]
 80055d0:	ed9f 7a39 	vldr	s14, [pc, #228]	@ 80056b8 <regelschritt+0x2b48>
 80055d4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80055d8:	4b2d      	ldr	r3, [pc, #180]	@ (8005690 <regelschritt+0x2b20>)
 80055da:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80055de:	ee17 2a90 	vmov	r2, s15
 80055e2:	63da      	str	r2, [r3, #60]	@ 0x3c
		TIM1->CCR4 = schub * 30259;
 80055e4:	4b2c      	ldr	r3, [pc, #176]	@ (8005698 <regelschritt+0x2b28>)
 80055e6:	edd3 7a00 	vldr	s15, [r3]
 80055ea:	ed9f 7a33 	vldr	s14, [pc, #204]	@ 80056b8 <regelschritt+0x2b48>
 80055ee:	ee67 7a87 	vmul.f32	s15, s15, s14
 80055f2:	4b27      	ldr	r3, [pc, #156]	@ (8005690 <regelschritt+0x2b20>)
 80055f4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80055f8:	ee17 2a90 	vmov	r2, s15
 80055fc:	641a      	str	r2, [r3, #64]	@ 0x40
 80055fe:	e00b      	b.n	8005618 <regelschritt+0x2aa8>
	} else {
		TIM1->CCR1 = 0;
 8005600:	4b23      	ldr	r3, [pc, #140]	@ (8005690 <regelschritt+0x2b20>)
 8005602:	2200      	movs	r2, #0
 8005604:	635a      	str	r2, [r3, #52]	@ 0x34
		TIM1->CCR2 = 0;
 8005606:	4b22      	ldr	r3, [pc, #136]	@ (8005690 <regelschritt+0x2b20>)
 8005608:	2200      	movs	r2, #0
 800560a:	639a      	str	r2, [r3, #56]	@ 0x38
		TIM1->CCR3 = 0;
 800560c:	4b20      	ldr	r3, [pc, #128]	@ (8005690 <regelschritt+0x2b20>)
 800560e:	2200      	movs	r2, #0
 8005610:	63da      	str	r2, [r3, #60]	@ 0x3c
		TIM1->CCR4 = 0;
 8005612:	4b1f      	ldr	r3, [pc, #124]	@ (8005690 <regelschritt+0x2b20>)
 8005614:	2200      	movs	r2, #0
 8005616:	641a      	str	r2, [r3, #64]	@ 0x40
	}

	w_cmd_tminus1[0] = w_cmd[0];
 8005618:	4b20      	ldr	r3, [pc, #128]	@ (800569c <regelschritt+0x2b2c>)
 800561a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800561e:	4920      	ldr	r1, [pc, #128]	@ (80056a0 <regelschritt+0x2b30>)
 8005620:	e9c1 2300 	strd	r2, r3, [r1]
	w_cmd_tminus1[1] = w_cmd[1];
 8005624:	4b1d      	ldr	r3, [pc, #116]	@ (800569c <regelschritt+0x2b2c>)
 8005626:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800562a:	491d      	ldr	r1, [pc, #116]	@ (80056a0 <regelschritt+0x2b30>)
 800562c:	e9c1 2302 	strd	r2, r3, [r1, #8]
	w_cmd_tminus1[2] = w_cmd[2];
 8005630:	4b1a      	ldr	r3, [pc, #104]	@ (800569c <regelschritt+0x2b2c>)
 8005632:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8005636:	491a      	ldr	r1, [pc, #104]	@ (80056a0 <regelschritt+0x2b30>)
 8005638:	e9c1 2304 	strd	r2, r3, [r1, #16]
	w_cmd_tminus1[3] = w_cmd[3];
 800563c:	4b17      	ldr	r3, [pc, #92]	@ (800569c <regelschritt+0x2b2c>)
 800563e:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8005642:	4917      	ldr	r1, [pc, #92]	@ (80056a0 <regelschritt+0x2b30>)
 8005644:	e9c1 2306 	strd	r2, r3, [r1, #24]

	w_cmd_tminus2[0] = w_cmd_tminus1[0];
 8005648:	4b15      	ldr	r3, [pc, #84]	@ (80056a0 <regelschritt+0x2b30>)
 800564a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800564e:	4915      	ldr	r1, [pc, #84]	@ (80056a4 <regelschritt+0x2b34>)
 8005650:	e9c1 2300 	strd	r2, r3, [r1]
	w_cmd_tminus2[1] = w_cmd_tminus1[1];
 8005654:	4b12      	ldr	r3, [pc, #72]	@ (80056a0 <regelschritt+0x2b30>)
 8005656:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800565a:	4912      	ldr	r1, [pc, #72]	@ (80056a4 <regelschritt+0x2b34>)
 800565c:	e9c1 2302 	strd	r2, r3, [r1, #8]
	w_cmd_tminus2[2] = w_cmd_tminus1[2];
 8005660:	4b0f      	ldr	r3, [pc, #60]	@ (80056a0 <regelschritt+0x2b30>)
 8005662:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8005666:	490f      	ldr	r1, [pc, #60]	@ (80056a4 <regelschritt+0x2b34>)
 8005668:	e9c1 2304 	strd	r2, r3, [r1, #16]
	w_cmd_tminus2[3] = w_cmd_tminus1[3];
 800566c:	4b0c      	ldr	r3, [pc, #48]	@ (80056a0 <regelschritt+0x2b30>)
 800566e:	e9d3 2306 	ldrd	r2, r3, [r3, #24]
 8005672:	490c      	ldr	r1, [pc, #48]	@ (80056a4 <regelschritt+0x2b34>)
 8005674:	e9c1 2306 	strd	r2, r3, [r1, #24]
}
 8005678:	bf00      	nop
 800567a:	f507 7712 	add.w	r7, r7, #584	@ 0x248
 800567e:	46bd      	mov	sp, r7
 8005680:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8005684:	f3af 8000 	nop.w
 8005688:	00000000 	.word	0x00000000
 800568c:	40dd8cc0 	.word	0x40dd8cc0
 8005690:	40010000 	.word	0x40010000
 8005694:	20001f00 	.word	0x20001f00
 8005698:	20001e40 	.word	0x20001e40
 800569c:	20001f58 	.word	0x20001f58
 80056a0:	20001f78 	.word	0x20001f78
 80056a4:	20001f98 	.word	0x20001f98
 80056a8:	40080000 	.word	0x40080000
 80056ac:	20000008 	.word	0x20000008
 80056b0:	408f4000 	.word	0x408f4000
 80056b4:	20000140 	.word	0x20000140
 80056b8:	46ec6600 	.word	0x46ec6600

080056bc <READ_ACCELEROMETER>:

static void READ_ACCELEROMETER(void)
{
 80056bc:	b580      	push	{r7, lr}
 80056be:	af00      	add	r7, sp, #0
    if (UseOfflineData == 1)
 80056c0:	4b15      	ldr	r3, [pc, #84]	@ (8005718 <READ_ACCELEROMETER+0x5c>)
 80056c2:	781b      	ldrb	r3, [r3, #0]
 80056c4:	2b01      	cmp	r3, #1
 80056c6:	d121      	bne.n	800570c <READ_ACCELEROMETER+0x50>
    {
		AccValue.x = OfflineData[OfflineDataReadIndex].acceleration_x_mg;
 80056c8:	4b14      	ldr	r3, [pc, #80]	@ (800571c <READ_ACCELEROMETER+0x60>)
 80056ca:	681b      	ldr	r3, [r3, #0]
 80056cc:	4a14      	ldr	r2, [pc, #80]	@ (8005720 <READ_ACCELEROMETER+0x64>)
 80056ce:	2134      	movs	r1, #52	@ 0x34
 80056d0:	fb01 f303 	mul.w	r3, r1, r3
 80056d4:	4413      	add	r3, r2
 80056d6:	3310      	adds	r3, #16
 80056d8:	681b      	ldr	r3, [r3, #0]
 80056da:	4a12      	ldr	r2, [pc, #72]	@ (8005724 <READ_ACCELEROMETER+0x68>)
 80056dc:	6013      	str	r3, [r2, #0]
		AccValue.y = OfflineData[OfflineDataReadIndex].acceleration_y_mg;
 80056de:	4b0f      	ldr	r3, [pc, #60]	@ (800571c <READ_ACCELEROMETER+0x60>)
 80056e0:	681b      	ldr	r3, [r3, #0]
 80056e2:	4a0f      	ldr	r2, [pc, #60]	@ (8005720 <READ_ACCELEROMETER+0x64>)
 80056e4:	2134      	movs	r1, #52	@ 0x34
 80056e6:	fb01 f303 	mul.w	r3, r1, r3
 80056ea:	4413      	add	r3, r2
 80056ec:	3314      	adds	r3, #20
 80056ee:	681b      	ldr	r3, [r3, #0]
 80056f0:	4a0c      	ldr	r2, [pc, #48]	@ (8005724 <READ_ACCELEROMETER+0x68>)
 80056f2:	6053      	str	r3, [r2, #4]
		AccValue.z = OfflineData[OfflineDataReadIndex].acceleration_z_mg;
 80056f4:	4b09      	ldr	r3, [pc, #36]	@ (800571c <READ_ACCELEROMETER+0x60>)
 80056f6:	681b      	ldr	r3, [r3, #0]
 80056f8:	4a09      	ldr	r2, [pc, #36]	@ (8005720 <READ_ACCELEROMETER+0x64>)
 80056fa:	2134      	movs	r1, #52	@ 0x34
 80056fc:	fb01 f303 	mul.w	r3, r1, r3
 8005700:	4413      	add	r3, r2
 8005702:	3318      	adds	r3, #24
 8005704:	681b      	ldr	r3, [r3, #0]
 8005706:	4a07      	ldr	r2, [pc, #28]	@ (8005724 <READ_ACCELEROMETER+0x68>)
 8005708:	6093      	str	r3, [r2, #8]
    }
    else
    {
		BSP_SENSOR_ACC_GetAxes(&AccValue);
    }
}
 800570a:	e002      	b.n	8005712 <READ_ACCELEROMETER+0x56>
		BSP_SENSOR_ACC_GetAxes(&AccValue);
 800570c:	4805      	ldr	r0, [pc, #20]	@ (8005724 <READ_ACCELEROMETER+0x68>)
 800570e:	f7fb fd99 	bl	8001244 <BSP_SENSOR_ACC_GetAxes>
}
 8005712:	bf00      	nop
 8005714:	bd80      	pop	{r7, pc}
 8005716:	bf00      	nop
 8005718:	20000dd1 	.word	0x20000dd1
 800571c:	20000f74 	.word	0x20000f74
 8005720:	20000dd4 	.word	0x20000dd4
 8005724:	20001c40 	.word	0x20001c40

08005728 <READ_GYRO>:

static void READ_GYRO(void)
{
 8005728:	b580      	push	{r7, lr}
 800572a:	af00      	add	r7, sp, #0
    if (UseOfflineData == 1)
 800572c:	4b15      	ldr	r3, [pc, #84]	@ (8005784 <READ_GYRO+0x5c>)
 800572e:	781b      	ldrb	r3, [r3, #0]
 8005730:	2b01      	cmp	r3, #1
 8005732:	d121      	bne.n	8005778 <READ_GYRO+0x50>
    {
		GyrValue.x = OfflineData[OfflineDataReadIndex].angular_rate_x_mdps;
 8005734:	4b14      	ldr	r3, [pc, #80]	@ (8005788 <READ_GYRO+0x60>)
 8005736:	681b      	ldr	r3, [r3, #0]
 8005738:	4a14      	ldr	r2, [pc, #80]	@ (800578c <READ_GYRO+0x64>)
 800573a:	2134      	movs	r1, #52	@ 0x34
 800573c:	fb01 f303 	mul.w	r3, r1, r3
 8005740:	4413      	add	r3, r2
 8005742:	331c      	adds	r3, #28
 8005744:	681b      	ldr	r3, [r3, #0]
 8005746:	4a12      	ldr	r2, [pc, #72]	@ (8005790 <READ_GYRO+0x68>)
 8005748:	6013      	str	r3, [r2, #0]
		GyrValue.y = OfflineData[OfflineDataReadIndex].angular_rate_y_mdps;
 800574a:	4b0f      	ldr	r3, [pc, #60]	@ (8005788 <READ_GYRO+0x60>)
 800574c:	681b      	ldr	r3, [r3, #0]
 800574e:	4a0f      	ldr	r2, [pc, #60]	@ (800578c <READ_GYRO+0x64>)
 8005750:	2134      	movs	r1, #52	@ 0x34
 8005752:	fb01 f303 	mul.w	r3, r1, r3
 8005756:	4413      	add	r3, r2
 8005758:	3320      	adds	r3, #32
 800575a:	681b      	ldr	r3, [r3, #0]
 800575c:	4a0c      	ldr	r2, [pc, #48]	@ (8005790 <READ_GYRO+0x68>)
 800575e:	6053      	str	r3, [r2, #4]
		GyrValue.z = OfflineData[OfflineDataReadIndex].angular_rate_z_mdps;
 8005760:	4b09      	ldr	r3, [pc, #36]	@ (8005788 <READ_GYRO+0x60>)
 8005762:	681b      	ldr	r3, [r3, #0]
 8005764:	4a09      	ldr	r2, [pc, #36]	@ (800578c <READ_GYRO+0x64>)
 8005766:	2134      	movs	r1, #52	@ 0x34
 8005768:	fb01 f303 	mul.w	r3, r1, r3
 800576c:	4413      	add	r3, r2
 800576e:	3324      	adds	r3, #36	@ 0x24
 8005770:	681b      	ldr	r3, [r3, #0]
 8005772:	4a07      	ldr	r2, [pc, #28]	@ (8005790 <READ_GYRO+0x68>)
 8005774:	6093      	str	r3, [r2, #8]
    }
    else
    {
    	BSP_SENSOR_GYR_GetAxes(&GyrValue);
    }
}
 8005776:	e002      	b.n	800577e <READ_GYRO+0x56>
    	BSP_SENSOR_GYR_GetAxes(&GyrValue);
 8005778:	4805      	ldr	r0, [pc, #20]	@ (8005790 <READ_GYRO+0x68>)
 800577a:	f7fb fd70 	bl	800125e <BSP_SENSOR_GYR_GetAxes>
}
 800577e:	bf00      	nop
 8005780:	bd80      	pop	{r7, pc}
 8005782:	bf00      	nop
 8005784:	20000dd1 	.word	0x20000dd1
 8005788:	20000f74 	.word	0x20000f74
 800578c:	20000dd4 	.word	0x20000dd4
 8005790:	20001c4c 	.word	0x20001c4c

08005794 <READ_MAG>:

static void READ_MAG(void)
{
 8005794:	b580      	push	{r7, lr}
 8005796:	af00      	add	r7, sp, #0

    if (UseOfflineData == 1)
 8005798:	4b15      	ldr	r3, [pc, #84]	@ (80057f0 <READ_MAG+0x5c>)
 800579a:	781b      	ldrb	r3, [r3, #0]
 800579c:	2b01      	cmp	r3, #1
 800579e:	d121      	bne.n	80057e4 <READ_MAG+0x50>
    {
     MagValue.x = OfflineData[OfflineDataReadIndex].magnetic_field_x_mgauss;
 80057a0:	4b14      	ldr	r3, [pc, #80]	@ (80057f4 <READ_MAG+0x60>)
 80057a2:	681b      	ldr	r3, [r3, #0]
 80057a4:	4a14      	ldr	r2, [pc, #80]	@ (80057f8 <READ_MAG+0x64>)
 80057a6:	2134      	movs	r1, #52	@ 0x34
 80057a8:	fb01 f303 	mul.w	r3, r1, r3
 80057ac:	4413      	add	r3, r2
 80057ae:	3328      	adds	r3, #40	@ 0x28
 80057b0:	681b      	ldr	r3, [r3, #0]
 80057b2:	4a12      	ldr	r2, [pc, #72]	@ (80057fc <READ_MAG+0x68>)
 80057b4:	6013      	str	r3, [r2, #0]
     MagValue.y = OfflineData[OfflineDataReadIndex].magnetic_field_y_mgauss;
 80057b6:	4b0f      	ldr	r3, [pc, #60]	@ (80057f4 <READ_MAG+0x60>)
 80057b8:	681b      	ldr	r3, [r3, #0]
 80057ba:	4a0f      	ldr	r2, [pc, #60]	@ (80057f8 <READ_MAG+0x64>)
 80057bc:	2134      	movs	r1, #52	@ 0x34
 80057be:	fb01 f303 	mul.w	r3, r1, r3
 80057c2:	4413      	add	r3, r2
 80057c4:	332c      	adds	r3, #44	@ 0x2c
 80057c6:	681b      	ldr	r3, [r3, #0]
 80057c8:	4a0c      	ldr	r2, [pc, #48]	@ (80057fc <READ_MAG+0x68>)
 80057ca:	6053      	str	r3, [r2, #4]
     MagValue.z = OfflineData[OfflineDataReadIndex].magnetic_field_z_mgauss;
 80057cc:	4b09      	ldr	r3, [pc, #36]	@ (80057f4 <READ_MAG+0x60>)
 80057ce:	681b      	ldr	r3, [r3, #0]
 80057d0:	4a09      	ldr	r2, [pc, #36]	@ (80057f8 <READ_MAG+0x64>)
 80057d2:	2134      	movs	r1, #52	@ 0x34
 80057d4:	fb01 f303 	mul.w	r3, r1, r3
 80057d8:	4413      	add	r3, r2
 80057da:	3330      	adds	r3, #48	@ 0x30
 80057dc:	681b      	ldr	r3, [r3, #0]
 80057de:	4a07      	ldr	r2, [pc, #28]	@ (80057fc <READ_MAG+0x68>)
 80057e0:	6093      	str	r3, [r2, #8]
    }
    else
    {
      BSP_SENSOR_MAG_GetAxes(&MagValue);
    }
}
 80057e2:	e002      	b.n	80057ea <READ_MAG+0x56>
      BSP_SENSOR_MAG_GetAxes(&MagValue);
 80057e4:	4805      	ldr	r0, [pc, #20]	@ (80057fc <READ_MAG+0x68>)
 80057e6:	f7fb fd47 	bl	8001278 <BSP_SENSOR_MAG_GetAxes>
}
 80057ea:	bf00      	nop
 80057ec:	bd80      	pop	{r7, pc}
 80057ee:	bf00      	nop
 80057f0:	20000dd1 	.word	0x20000dd1
 80057f4:	20000f74 	.word	0x20000f74
 80057f8:	20000dd4 	.word	0x20000dd4
 80057fc:	20001c58 	.word	0x20001c58

08005800 <LED_Off>:
{
	LL_GPIO_SetOutputPin(LED2_GPIO_PORT, LED2_PIN);
}

void LED_Off(void)
{
 8005800:	b580      	push	{r7, lr}
 8005802:	af00      	add	r7, sp, #0
	LL_GPIO_ResetOutputPin(LED2_GPIO_PORT, LED2_PIN);
 8005804:	2120      	movs	r1, #32
 8005806:	4802      	ldr	r0, [pc, #8]	@ (8005810 <LED_Off+0x10>)
 8005808:	f7fb ffc6 	bl	8001798 <LL_GPIO_ResetOutputPin>
}
 800580c:	bf00      	nop
 800580e:	bd80      	pop	{r7, pc}
 8005810:	40020000 	.word	0x40020000

08005814 <DWT_Start>:
  * @brief  Start counting clock cycles
  * @param  None
  * @retval None
  */
static void DWT_Start(void)
{
 8005814:	b480      	push	{r7}
 8005816:	af00      	add	r7, sp, #0
	DWT->CYCCNT = 0; /* Clear count of clock cycles */
 8005818:	4b06      	ldr	r3, [pc, #24]	@ (8005834 <DWT_Start+0x20>)
 800581a:	2200      	movs	r2, #0
 800581c:	605a      	str	r2, [r3, #4]
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk; /* Enable counter */
 800581e:	4b05      	ldr	r3, [pc, #20]	@ (8005834 <DWT_Start+0x20>)
 8005820:	681b      	ldr	r3, [r3, #0]
 8005822:	4a04      	ldr	r2, [pc, #16]	@ (8005834 <DWT_Start+0x20>)
 8005824:	f043 0301 	orr.w	r3, r3, #1
 8005828:	6013      	str	r3, [r2, #0]
}
 800582a:	bf00      	nop
 800582c:	46bd      	mov	sp, r7
 800582e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005832:	4770      	bx	lr
 8005834:	e0001000 	.word	0xe0001000

08005838 <DWT_Stop>:
  * @brief  Stop counting clock cycles and calculate elapsed time in [us]
  * @param  None
  * @retval Elapsed time in [us]
  */
static uint32_t DWT_Stop(void)
{
 8005838:	b480      	push	{r7}
 800583a:	b083      	sub	sp, #12
 800583c:	af00      	add	r7, sp, #0
	volatile uint32_t cycles_count = 0U;
 800583e:	2300      	movs	r3, #0
 8005840:	603b      	str	r3, [r7, #0]
	uint32_t system_core_clock_mhz = 0U;
 8005842:	2300      	movs	r3, #0
 8005844:	607b      	str	r3, [r7, #4]

	DWT->CTRL &= ~DWT_CTRL_CYCCNTENA_Msk;
 8005846:	4b0d      	ldr	r3, [pc, #52]	@ (800587c <DWT_Stop+0x44>)
 8005848:	681b      	ldr	r3, [r3, #0]
 800584a:	4a0c      	ldr	r2, [pc, #48]	@ (800587c <DWT_Stop+0x44>)
 800584c:	f023 0301 	bic.w	r3, r3, #1
 8005850:	6013      	str	r3, [r2, #0]
	cycles_count = DWT->CYCCNT;
 8005852:	4b0a      	ldr	r3, [pc, #40]	@ (800587c <DWT_Stop+0x44>)
 8005854:	685b      	ldr	r3, [r3, #4]
 8005856:	603b      	str	r3, [r7, #0]

	/* Calculate elapsed time in [us] */
	system_core_clock_mhz = SystemCoreClock / 1000000U;
 8005858:	4b09      	ldr	r3, [pc, #36]	@ (8005880 <DWT_Stop+0x48>)
 800585a:	681b      	ldr	r3, [r3, #0]
 800585c:	4a09      	ldr	r2, [pc, #36]	@ (8005884 <DWT_Stop+0x4c>)
 800585e:	fba2 2303 	umull	r2, r3, r2, r3
 8005862:	0c9b      	lsrs	r3, r3, #18
 8005864:	607b      	str	r3, [r7, #4]
	return cycles_count / system_core_clock_mhz;
 8005866:	683a      	ldr	r2, [r7, #0]
 8005868:	687b      	ldr	r3, [r7, #4]
 800586a:	fbb2 f3f3 	udiv	r3, r2, r3
}
 800586e:	4618      	mov	r0, r3
 8005870:	370c      	adds	r7, #12
 8005872:	46bd      	mov	sp, r7
 8005874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005878:	4770      	bx	lr
 800587a:	bf00      	nop
 800587c:	e0001000 	.word	0xe0001000
 8005880:	20000144 	.word	0x20000144
 8005884:	431bde83 	.word	0x431bde83

08005888 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8005888:	b480      	push	{r7}
 800588a:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800588c:	b672      	cpsid	i
}
 800588e:	bf00      	nop
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
 8005890:	bf00      	nop
 8005892:	e7fd      	b.n	8005890 <Error_Handler+0x8>

08005894 <HAL_MspInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
                    /**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8005894:	b580      	push	{r7, lr}
 8005896:	b082      	sub	sp, #8
 8005898:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800589a:	2300      	movs	r3, #0
 800589c:	607b      	str	r3, [r7, #4]
 800589e:	4b10      	ldr	r3, [pc, #64]	@ (80058e0 <HAL_MspInit+0x4c>)
 80058a0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80058a2:	4a0f      	ldr	r2, [pc, #60]	@ (80058e0 <HAL_MspInit+0x4c>)
 80058a4:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 80058a8:	6453      	str	r3, [r2, #68]	@ 0x44
 80058aa:	4b0d      	ldr	r3, [pc, #52]	@ (80058e0 <HAL_MspInit+0x4c>)
 80058ac:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80058ae:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80058b2:	607b      	str	r3, [r7, #4]
 80058b4:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 80058b6:	2300      	movs	r3, #0
 80058b8:	603b      	str	r3, [r7, #0]
 80058ba:	4b09      	ldr	r3, [pc, #36]	@ (80058e0 <HAL_MspInit+0x4c>)
 80058bc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80058be:	4a08      	ldr	r2, [pc, #32]	@ (80058e0 <HAL_MspInit+0x4c>)
 80058c0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80058c4:	6413      	str	r3, [r2, #64]	@ 0x40
 80058c6:	4b06      	ldr	r3, [pc, #24]	@ (80058e0 <HAL_MspInit+0x4c>)
 80058c8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80058ca:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80058ce:	603b      	str	r3, [r7, #0]
 80058d0:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 80058d2:	2007      	movs	r0, #7
 80058d4:	f009 fe36 	bl	800f544 <HAL_NVIC_SetPriorityGrouping>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80058d8:	bf00      	nop
 80058da:	3708      	adds	r7, #8
 80058dc:	46bd      	mov	sp, r7
 80058de:	bd80      	pop	{r7, pc}
 80058e0:	40023800 	.word	0x40023800

080058e4 <HAL_CRC_MspInit>:
* This function configures the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 80058e4:	b480      	push	{r7}
 80058e6:	b085      	sub	sp, #20
 80058e8:	af00      	add	r7, sp, #0
 80058ea:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 80058ec:	687b      	ldr	r3, [r7, #4]
 80058ee:	681b      	ldr	r3, [r3, #0]
 80058f0:	4a0b      	ldr	r2, [pc, #44]	@ (8005920 <HAL_CRC_MspInit+0x3c>)
 80058f2:	4293      	cmp	r3, r2
 80058f4:	d10d      	bne.n	8005912 <HAL_CRC_MspInit+0x2e>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 80058f6:	2300      	movs	r3, #0
 80058f8:	60fb      	str	r3, [r7, #12]
 80058fa:	4b0a      	ldr	r3, [pc, #40]	@ (8005924 <HAL_CRC_MspInit+0x40>)
 80058fc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80058fe:	4a09      	ldr	r2, [pc, #36]	@ (8005924 <HAL_CRC_MspInit+0x40>)
 8005900:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8005904:	6313      	str	r3, [r2, #48]	@ 0x30
 8005906:	4b07      	ldr	r3, [pc, #28]	@ (8005924 <HAL_CRC_MspInit+0x40>)
 8005908:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800590a:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800590e:	60fb      	str	r3, [r7, #12]
 8005910:	68fb      	ldr	r3, [r7, #12]

  /* USER CODE END CRC_MspInit 1 */

  }

}
 8005912:	bf00      	nop
 8005914:	3714      	adds	r7, #20
 8005916:	46bd      	mov	sp, r7
 8005918:	f85d 7b04 	ldr.w	r7, [sp], #4
 800591c:	4770      	bx	lr
 800591e:	bf00      	nop
 8005920:	40023000 	.word	0x40023000
 8005924:	40023800 	.word	0x40023800

08005928 <HAL_RTC_MspInit>:
* This function configures the hardware resources used in this example
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 8005928:	b580      	push	{r7, lr}
 800592a:	b088      	sub	sp, #32
 800592c:	af00      	add	r7, sp, #0
 800592e:	6078      	str	r0, [r7, #4]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8005930:	f107 0308 	add.w	r3, r7, #8
 8005934:	2200      	movs	r2, #0
 8005936:	601a      	str	r2, [r3, #0]
 8005938:	605a      	str	r2, [r3, #4]
 800593a:	609a      	str	r2, [r3, #8]
 800593c:	60da      	str	r2, [r3, #12]
 800593e:	611a      	str	r2, [r3, #16]
 8005940:	615a      	str	r2, [r3, #20]
  if(hrtc->Instance==RTC)
 8005942:	687b      	ldr	r3, [r7, #4]
 8005944:	681b      	ldr	r3, [r3, #0]
 8005946:	4a0c      	ldr	r2, [pc, #48]	@ (8005978 <HAL_RTC_MspInit+0x50>)
 8005948:	4293      	cmp	r3, r2
 800594a:	d111      	bne.n	8005970 <HAL_RTC_MspInit+0x48>

  /* USER CODE END RTC_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800594c:	2302      	movs	r3, #2
 800594e:	60bb      	str	r3, [r7, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8005950:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8005954:	61bb      	str	r3, [r7, #24]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8005956:	f107 0308 	add.w	r3, r7, #8
 800595a:	4618      	mov	r0, r3
 800595c:	f00e f882 	bl	8013a64 <HAL_RCCEx_PeriphCLKConfig>
 8005960:	4603      	mov	r3, r0
 8005962:	2b00      	cmp	r3, #0
 8005964:	d001      	beq.n	800596a <HAL_RTC_MspInit+0x42>
    {
      Error_Handler();
 8005966:	f7ff ff8f 	bl	8005888 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 800596a:	4b04      	ldr	r3, [pc, #16]	@ (800597c <HAL_RTC_MspInit+0x54>)
 800596c:	2201      	movs	r2, #1
 800596e:	601a      	str	r2, [r3, #0]

  /* USER CODE END RTC_MspInit 1 */

  }

}
 8005970:	bf00      	nop
 8005972:	3720      	adds	r7, #32
 8005974:	46bd      	mov	sp, r7
 8005976:	bd80      	pop	{r7, pc}
 8005978:	40002800 	.word	0x40002800
 800597c:	42470e3c 	.word	0x42470e3c

08005980 <HAL_TIM_PWM_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_pwm: TIM_PWM handle pointer
* @retval None
*/
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 8005980:	b480      	push	{r7}
 8005982:	b085      	sub	sp, #20
 8005984:	af00      	add	r7, sp, #0
 8005986:	6078      	str	r0, [r7, #4]
  if(htim_pwm->Instance==TIM1)
 8005988:	687b      	ldr	r3, [r7, #4]
 800598a:	681b      	ldr	r3, [r3, #0]
 800598c:	4a0b      	ldr	r2, [pc, #44]	@ (80059bc <HAL_TIM_PWM_MspInit+0x3c>)
 800598e:	4293      	cmp	r3, r2
 8005990:	d10d      	bne.n	80059ae <HAL_TIM_PWM_MspInit+0x2e>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 8005992:	2300      	movs	r3, #0
 8005994:	60fb      	str	r3, [r7, #12]
 8005996:	4b0a      	ldr	r3, [pc, #40]	@ (80059c0 <HAL_TIM_PWM_MspInit+0x40>)
 8005998:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800599a:	4a09      	ldr	r2, [pc, #36]	@ (80059c0 <HAL_TIM_PWM_MspInit+0x40>)
 800599c:	f043 0301 	orr.w	r3, r3, #1
 80059a0:	6453      	str	r3, [r2, #68]	@ 0x44
 80059a2:	4b07      	ldr	r3, [pc, #28]	@ (80059c0 <HAL_TIM_PWM_MspInit+0x40>)
 80059a4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80059a6:	f003 0301 	and.w	r3, r3, #1
 80059aa:	60fb      	str	r3, [r7, #12]
 80059ac:	68fb      	ldr	r3, [r7, #12]

  /* USER CODE END TIM1_MspInit 1 */

  }

}
 80059ae:	bf00      	nop
 80059b0:	3714      	adds	r7, #20
 80059b2:	46bd      	mov	sp, r7
 80059b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80059b8:	4770      	bx	lr
 80059ba:	bf00      	nop
 80059bc:	40010000 	.word	0x40010000
 80059c0:	40023800 	.word	0x40023800

080059c4 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 80059c4:	b580      	push	{r7, lr}
 80059c6:	b084      	sub	sp, #16
 80059c8:	af00      	add	r7, sp, #0
 80059ca:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM2)
 80059cc:	687b      	ldr	r3, [r7, #4]
 80059ce:	681b      	ldr	r3, [r3, #0]
 80059d0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80059d4:	d10e      	bne.n	80059f4 <HAL_TIM_Base_MspInit+0x30>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 80059d6:	2300      	movs	r3, #0
 80059d8:	60fb      	str	r3, [r7, #12]
 80059da:	4b16      	ldr	r3, [pc, #88]	@ (8005a34 <HAL_TIM_Base_MspInit+0x70>)
 80059dc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80059de:	4a15      	ldr	r2, [pc, #84]	@ (8005a34 <HAL_TIM_Base_MspInit+0x70>)
 80059e0:	f043 0301 	orr.w	r3, r3, #1
 80059e4:	6413      	str	r3, [r2, #64]	@ 0x40
 80059e6:	4b13      	ldr	r3, [pc, #76]	@ (8005a34 <HAL_TIM_Base_MspInit+0x70>)
 80059e8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80059ea:	f003 0301 	and.w	r3, r3, #1
 80059ee:	60fb      	str	r3, [r7, #12]
 80059f0:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }

}
 80059f2:	e01a      	b.n	8005a2a <HAL_TIM_Base_MspInit+0x66>
  else if(htim_base->Instance==TIM3)
 80059f4:	687b      	ldr	r3, [r7, #4]
 80059f6:	681b      	ldr	r3, [r3, #0]
 80059f8:	4a0f      	ldr	r2, [pc, #60]	@ (8005a38 <HAL_TIM_Base_MspInit+0x74>)
 80059fa:	4293      	cmp	r3, r2
 80059fc:	d115      	bne.n	8005a2a <HAL_TIM_Base_MspInit+0x66>
    __HAL_RCC_TIM3_CLK_ENABLE();
 80059fe:	2300      	movs	r3, #0
 8005a00:	60bb      	str	r3, [r7, #8]
 8005a02:	4b0c      	ldr	r3, [pc, #48]	@ (8005a34 <HAL_TIM_Base_MspInit+0x70>)
 8005a04:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005a06:	4a0b      	ldr	r2, [pc, #44]	@ (8005a34 <HAL_TIM_Base_MspInit+0x70>)
 8005a08:	f043 0302 	orr.w	r3, r3, #2
 8005a0c:	6413      	str	r3, [r2, #64]	@ 0x40
 8005a0e:	4b09      	ldr	r3, [pc, #36]	@ (8005a34 <HAL_TIM_Base_MspInit+0x70>)
 8005a10:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005a12:	f003 0302 	and.w	r3, r3, #2
 8005a16:	60bb      	str	r3, [r7, #8]
 8005a18:	68bb      	ldr	r3, [r7, #8]
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
 8005a1a:	2200      	movs	r2, #0
 8005a1c:	2100      	movs	r1, #0
 8005a1e:	201d      	movs	r0, #29
 8005a20:	f009 fd9b 	bl	800f55a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 8005a24:	201d      	movs	r0, #29
 8005a26:	f009 fdb4 	bl	800f592 <HAL_NVIC_EnableIRQ>
}
 8005a2a:	bf00      	nop
 8005a2c:	3710      	adds	r7, #16
 8005a2e:	46bd      	mov	sp, r7
 8005a30:	bd80      	pop	{r7, pc}
 8005a32:	bf00      	nop
 8005a34:	40023800 	.word	0x40023800
 8005a38:	40000400 	.word	0x40000400

08005a3c <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8005a3c:	b580      	push	{r7, lr}
 8005a3e:	b088      	sub	sp, #32
 8005a40:	af00      	add	r7, sp, #0
 8005a42:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005a44:	f107 030c 	add.w	r3, r7, #12
 8005a48:	2200      	movs	r2, #0
 8005a4a:	601a      	str	r2, [r3, #0]
 8005a4c:	605a      	str	r2, [r3, #4]
 8005a4e:	609a      	str	r2, [r3, #8]
 8005a50:	60da      	str	r2, [r3, #12]
 8005a52:	611a      	str	r2, [r3, #16]
  if(htim->Instance==TIM1)
 8005a54:	687b      	ldr	r3, [r7, #4]
 8005a56:	681b      	ldr	r3, [r3, #0]
 8005a58:	4a12      	ldr	r2, [pc, #72]	@ (8005aa4 <HAL_TIM_MspPostInit+0x68>)
 8005a5a:	4293      	cmp	r3, r2
 8005a5c:	d11e      	bne.n	8005a9c <HAL_TIM_MspPostInit+0x60>
  {
  /* USER CODE BEGIN TIM1_MspPostInit 0 */

  /* USER CODE END TIM1_MspPostInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8005a5e:	2300      	movs	r3, #0
 8005a60:	60bb      	str	r3, [r7, #8]
 8005a62:	4b11      	ldr	r3, [pc, #68]	@ (8005aa8 <HAL_TIM_MspPostInit+0x6c>)
 8005a64:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8005a66:	4a10      	ldr	r2, [pc, #64]	@ (8005aa8 <HAL_TIM_MspPostInit+0x6c>)
 8005a68:	f043 0301 	orr.w	r3, r3, #1
 8005a6c:	6313      	str	r3, [r2, #48]	@ 0x30
 8005a6e:	4b0e      	ldr	r3, [pc, #56]	@ (8005aa8 <HAL_TIM_MspPostInit+0x6c>)
 8005a70:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8005a72:	f003 0301 	and.w	r3, r3, #1
 8005a76:	60bb      	str	r3, [r7, #8]
 8005a78:	68bb      	ldr	r3, [r7, #8]
    PA8     ------> TIM1_CH1
    PA9     ------> TIM1_CH2
    PA10     ------> TIM1_CH3
    PA11     ------> TIM1_CH4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 8005a7a:	f44f 6370 	mov.w	r3, #3840	@ 0xf00
 8005a7e:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005a80:	2302      	movs	r3, #2
 8005a82:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005a84:	2300      	movs	r3, #0
 8005a86:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8005a88:	2300      	movs	r3, #0
 8005a8a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8005a8c:	2301      	movs	r3, #1
 8005a8e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8005a90:	f107 030c 	add.w	r3, r7, #12
 8005a94:	4619      	mov	r1, r3
 8005a96:	4805      	ldr	r0, [pc, #20]	@ (8005aac <HAL_TIM_MspPostInit+0x70>)
 8005a98:	f009 fec8 	bl	800f82c <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }

}
 8005a9c:	bf00      	nop
 8005a9e:	3720      	adds	r7, #32
 8005aa0:	46bd      	mov	sp, r7
 8005aa2:	bd80      	pop	{r7, pc}
 8005aa4:	40010000 	.word	0x40010000
 8005aa8:	40023800 	.word	0x40023800
 8005aac:	40020000 	.word	0x40020000

08005ab0 <LL_USART_IsActiveFlag_RXNE>:
{
 8005ab0:	b480      	push	{r7}
 8005ab2:	b083      	sub	sp, #12
 8005ab4:	af00      	add	r7, sp, #0
 8005ab6:	6078      	str	r0, [r7, #4]
  return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 8005ab8:	687b      	ldr	r3, [r7, #4]
 8005aba:	681b      	ldr	r3, [r3, #0]
 8005abc:	f003 0320 	and.w	r3, r3, #32
 8005ac0:	2b20      	cmp	r3, #32
 8005ac2:	bf0c      	ite	eq
 8005ac4:	2301      	moveq	r3, #1
 8005ac6:	2300      	movne	r3, #0
 8005ac8:	b2db      	uxtb	r3, r3
}
 8005aca:	4618      	mov	r0, r3
 8005acc:	370c      	adds	r7, #12
 8005ace:	46bd      	mov	sp, r7
 8005ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ad4:	4770      	bx	lr

08005ad6 <LL_USART_IsEnabledIT_RXNE>:
{
 8005ad6:	b480      	push	{r7}
 8005ad8:	b083      	sub	sp, #12
 8005ada:	af00      	add	r7, sp, #0
 8005adc:	6078      	str	r0, [r7, #4]
  return (READ_BIT(USARTx->CR1, USART_CR1_RXNEIE) == (USART_CR1_RXNEIE));
 8005ade:	687b      	ldr	r3, [r7, #4]
 8005ae0:	68db      	ldr	r3, [r3, #12]
 8005ae2:	f003 0320 	and.w	r3, r3, #32
 8005ae6:	2b20      	cmp	r3, #32
 8005ae8:	bf0c      	ite	eq
 8005aea:	2301      	moveq	r3, #1
 8005aec:	2300      	movne	r3, #0
 8005aee:	b2db      	uxtb	r3, r3
}
 8005af0:	4618      	mov	r0, r3
 8005af2:	370c      	adds	r7, #12
 8005af4:	46bd      	mov	sp, r7
 8005af6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005afa:	4770      	bx	lr

08005afc <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8005afc:	b480      	push	{r7}
 8005afe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8005b00:	bf00      	nop
 8005b02:	e7fd      	b.n	8005b00 <NMI_Handler+0x4>

08005b04 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8005b04:	b480      	push	{r7}
 8005b06:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8005b08:	bf00      	nop
 8005b0a:	e7fd      	b.n	8005b08 <HardFault_Handler+0x4>

08005b0c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8005b0c:	b480      	push	{r7}
 8005b0e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8005b10:	bf00      	nop
 8005b12:	e7fd      	b.n	8005b10 <MemManage_Handler+0x4>

08005b14 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8005b14:	b480      	push	{r7}
 8005b16:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8005b18:	bf00      	nop
 8005b1a:	e7fd      	b.n	8005b18 <BusFault_Handler+0x4>

08005b1c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8005b1c:	b480      	push	{r7}
 8005b1e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8005b20:	bf00      	nop
 8005b22:	e7fd      	b.n	8005b20 <UsageFault_Handler+0x4>

08005b24 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8005b24:	b480      	push	{r7}
 8005b26:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8005b28:	bf00      	nop
 8005b2a:	46bd      	mov	sp, r7
 8005b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b30:	4770      	bx	lr

08005b32 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8005b32:	b480      	push	{r7}
 8005b34:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8005b36:	bf00      	nop
 8005b38:	46bd      	mov	sp, r7
 8005b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b3e:	4770      	bx	lr

08005b40 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8005b40:	b480      	push	{r7}
 8005b42:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8005b44:	bf00      	nop
 8005b46:	46bd      	mov	sp, r7
 8005b48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b4c:	4770      	bx	lr

08005b4e <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8005b4e:	b580      	push	{r7, lr}
 8005b50:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8005b52:	f009 fbbf 	bl	800f2d4 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8005b56:	bf00      	nop
 8005b58:	bd80      	pop	{r7, pc}
	...

08005b5c <TIM3_IRQHandler>:

/**
  * @brief This function handles TIM3 global interrupt.
  */
void TIM3_IRQHandler(void)
{
 8005b5c:	b580      	push	{r7, lr}
 8005b5e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM3_IRQn 0 */

  /* USER CODE END TIM3_IRQn 0 */
  HAL_TIM_IRQHandler(&htim3);
 8005b60:	4802      	ldr	r0, [pc, #8]	@ (8005b6c <TIM3_IRQHandler+0x10>)
 8005b62:	f00e fc5b 	bl	801441c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM3_IRQn 1 */

  /* USER CODE END TIM3_IRQn 1 */
}
 8005b66:	bf00      	nop
 8005b68:	bd80      	pop	{r7, pc}
 8005b6a:	bf00      	nop
 8005b6c:	20001bf8 	.word	0x20001bf8

08005b70 <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
 8005b70:	b580      	push	{r7, lr}
 8005b72:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
 8005b74:	4802      	ldr	r0, [pc, #8]	@ (8005b80 <I2C1_EV_IRQHandler+0x10>)
 8005b76:	f00b f8eb 	bl	8010d50 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
 8005b7a:	bf00      	nop
 8005b7c:	bd80      	pop	{r7, pc}
 8005b7e:	bf00      	nop
 8005b80:	20002020 	.word	0x20002020

08005b84 <I2C1_ER_IRQHandler>:

/**
  * @brief This function handles I2C1 error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
 8005b84:	b580      	push	{r7, lr}
 8005b86:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
 8005b88:	4802      	ldr	r0, [pc, #8]	@ (8005b94 <I2C1_ER_IRQHandler+0x10>)
 8005b8a:	f00b fa34 	bl	8010ff6 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}
 8005b8e:	bf00      	nop
 8005b90:	bd80      	pop	{r7, pc}
 8005b92:	bf00      	nop
 8005b94:	20002020 	.word	0x20002020

08005b98 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8005b98:	b580      	push	{r7, lr}
 8005b9a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */
//
  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_EXTI_IRQHandler(&H_EXTI_13);
 8005b9c:	4802      	ldr	r0, [pc, #8]	@ (8005ba8 <EXTI15_10_IRQHandler+0x10>)
 8005b9e:	f009 fe21 	bl	800f7e4 <HAL_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */
//
  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8005ba2:	bf00      	nop
 8005ba4:	bd80      	pop	{r7, pc}
 8005ba6:	bf00      	nop
 8005ba8:	20000340 	.word	0x20000340

08005bac <USART2_IRQHandler>:
  * Brief   This function handles USARTx Instance interrupt request.
  * Param   None
  * Retval  None
  */
void USARTx_IRQHandler(void)
{
 8005bac:	b580      	push	{r7, lr}
 8005bae:	af00      	add	r7, sp, #0
  /* Check RXNE flag value in SR register */
  if(LL_USART_IsActiveFlag_RXNE(USARTx_INSTANCE) && LL_USART_IsEnabledIT_RXNE(USARTx_INSTANCE))
 8005bb0:	4807      	ldr	r0, [pc, #28]	@ (8005bd0 <USART2_IRQHandler+0x24>)
 8005bb2:	f7ff ff7d 	bl	8005ab0 <LL_USART_IsActiveFlag_RXNE>
 8005bb6:	4603      	mov	r3, r0
 8005bb8:	2b00      	cmp	r3, #0
 8005bba:	d007      	beq.n	8005bcc <USART2_IRQHandler+0x20>
 8005bbc:	4804      	ldr	r0, [pc, #16]	@ (8005bd0 <USART2_IRQHandler+0x24>)
 8005bbe:	f7ff ff8a 	bl	8005ad6 <LL_USART_IsEnabledIT_RXNE>
 8005bc2:	4603      	mov	r3, r0
 8005bc4:	2b00      	cmp	r3, #0
 8005bc6:	d001      	beq.n	8005bcc <USART2_IRQHandler+0x20>
  {
    /* RXNE flag will be cleared by reading of DR register (done in call) */
    /* Call function in charge of handling Character reception */
    USART_CharReception_Callback();
 8005bc8:	f7fc ff46 	bl	8002a58 <USART_CharReception_Callback>
  {
    /* Call Error function */
    // Error_Callback();
  }

}
 8005bcc:	bf00      	nop
 8005bce:	bd80      	pop	{r7, pc}
 8005bd0:	40004400 	.word	0x40004400

08005bd4 <BSP_I2C1_Init>:
/**
  * @brief  Initialize I2C HAL
  * @retval BSP status
  */
int32_t BSP_I2C1_Init(void)
{
 8005bd4:	b580      	push	{r7, lr}
 8005bd6:	b082      	sub	sp, #8
 8005bd8:	af00      	add	r7, sp, #0

  int32_t ret = BSP_ERROR_NONE;
 8005bda:	2300      	movs	r3, #0
 8005bdc:	607b      	str	r3, [r7, #4]

  hi2c1.Instance  = I2C1;
 8005bde:	4b13      	ldr	r3, [pc, #76]	@ (8005c2c <BSP_I2C1_Init+0x58>)
 8005be0:	4a13      	ldr	r2, [pc, #76]	@ (8005c30 <BSP_I2C1_Init+0x5c>)
 8005be2:	601a      	str	r2, [r3, #0]

  if(I2C1InitCounter++ == 0)
 8005be4:	4b13      	ldr	r3, [pc, #76]	@ (8005c34 <BSP_I2C1_Init+0x60>)
 8005be6:	681b      	ldr	r3, [r3, #0]
 8005be8:	1c5a      	adds	r2, r3, #1
 8005bea:	4912      	ldr	r1, [pc, #72]	@ (8005c34 <BSP_I2C1_Init+0x60>)
 8005bec:	600a      	str	r2, [r1, #0]
 8005bee:	2b00      	cmp	r3, #0
 8005bf0:	d117      	bne.n	8005c22 <BSP_I2C1_Init+0x4e>
  {
    if (HAL_I2C_GetState(&hi2c1) == HAL_I2C_STATE_RESET)
 8005bf2:	480e      	ldr	r0, [pc, #56]	@ (8005c2c <BSP_I2C1_Init+0x58>)
 8005bf4:	f00b fb06 	bl	8011204 <HAL_I2C_GetState>
 8005bf8:	4603      	mov	r3, r0
 8005bfa:	2b00      	cmp	r3, #0
 8005bfc:	d111      	bne.n	8005c22 <BSP_I2C1_Init+0x4e>
    {
    #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0U)
      /* Init the I2C Msp */
      I2C1_MspInit(&hi2c1);
 8005bfe:	480b      	ldr	r0, [pc, #44]	@ (8005c2c <BSP_I2C1_Init+0x58>)
 8005c00:	f000 f936 	bl	8005e70 <I2C1_MspInit>
        {
          return BSP_ERROR_MSP_FAILURE;
        }
      }
    #endif
      if(ret == BSP_ERROR_NONE)
 8005c04:	687b      	ldr	r3, [r7, #4]
 8005c06:	2b00      	cmp	r3, #0
 8005c08:	d10b      	bne.n	8005c22 <BSP_I2C1_Init+0x4e>
      {
        /* Init the I2C */
        if(MX_I2C1_Init(&hi2c1) != HAL_OK)
 8005c0a:	4808      	ldr	r0, [pc, #32]	@ (8005c2c <BSP_I2C1_Init+0x58>)
 8005c0c:	f000 f8fc 	bl	8005e08 <MX_I2C1_Init>
 8005c10:	4603      	mov	r3, r0
 8005c12:	2b00      	cmp	r3, #0
 8005c14:	d003      	beq.n	8005c1e <BSP_I2C1_Init+0x4a>
        {
          ret = BSP_ERROR_BUS_FAILURE;
 8005c16:	f06f 0307 	mvn.w	r3, #7
 8005c1a:	607b      	str	r3, [r7, #4]
 8005c1c:	e001      	b.n	8005c22 <BSP_I2C1_Init+0x4e>
        }
        else
        {
          ret = BSP_ERROR_NONE;
 8005c1e:	2300      	movs	r3, #0
 8005c20:	607b      	str	r3, [r7, #4]
        }
      }
    }
  }
  return ret;
 8005c22:	687b      	ldr	r3, [r7, #4]
}
 8005c24:	4618      	mov	r0, r3
 8005c26:	3708      	adds	r7, #8
 8005c28:	46bd      	mov	sp, r7
 8005c2a:	bd80      	pop	{r7, pc}
 8005c2c:	20002020 	.word	0x20002020
 8005c30:	40005400 	.word	0x40005400
 8005c34:	20002074 	.word	0x20002074

08005c38 <BSP_I2C1_DeInit>:
/**
  * @brief  DeInitialize I2C HAL.
  * @retval BSP status
  */
int32_t BSP_I2C1_DeInit(void)
{
 8005c38:	b580      	push	{r7, lr}
 8005c3a:	b082      	sub	sp, #8
 8005c3c:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
 8005c3e:	2300      	movs	r3, #0
 8005c40:	607b      	str	r3, [r7, #4]

  if (I2C1InitCounter > 0)
 8005c42:	4b0f      	ldr	r3, [pc, #60]	@ (8005c80 <BSP_I2C1_DeInit+0x48>)
 8005c44:	681b      	ldr	r3, [r3, #0]
 8005c46:	2b00      	cmp	r3, #0
 8005c48:	d014      	beq.n	8005c74 <BSP_I2C1_DeInit+0x3c>
  {
    if (--I2C1InitCounter == 0)
 8005c4a:	4b0d      	ldr	r3, [pc, #52]	@ (8005c80 <BSP_I2C1_DeInit+0x48>)
 8005c4c:	681b      	ldr	r3, [r3, #0]
 8005c4e:	3b01      	subs	r3, #1
 8005c50:	4a0b      	ldr	r2, [pc, #44]	@ (8005c80 <BSP_I2C1_DeInit+0x48>)
 8005c52:	6013      	str	r3, [r2, #0]
 8005c54:	4b0a      	ldr	r3, [pc, #40]	@ (8005c80 <BSP_I2C1_DeInit+0x48>)
 8005c56:	681b      	ldr	r3, [r3, #0]
 8005c58:	2b00      	cmp	r3, #0
 8005c5a:	d10b      	bne.n	8005c74 <BSP_I2C1_DeInit+0x3c>
    {
  #if (USE_HAL_I2C_REGISTER_CALLBACKS == 0U)
      /* DeInit the I2C */
      I2C1_MspDeInit(&hi2c1);
 8005c5c:	4809      	ldr	r0, [pc, #36]	@ (8005c84 <BSP_I2C1_DeInit+0x4c>)
 8005c5e:	f000 f961 	bl	8005f24 <I2C1_MspDeInit>
  #endif
      /* DeInit the I2C */
      if (HAL_I2C_DeInit(&hi2c1) != HAL_OK)
 8005c62:	4808      	ldr	r0, [pc, #32]	@ (8005c84 <BSP_I2C1_DeInit+0x4c>)
 8005c64:	f00a f9c0 	bl	800ffe8 <HAL_I2C_DeInit>
 8005c68:	4603      	mov	r3, r0
 8005c6a:	2b00      	cmp	r3, #0
 8005c6c:	d002      	beq.n	8005c74 <BSP_I2C1_DeInit+0x3c>
      {
        ret = BSP_ERROR_BUS_FAILURE;
 8005c6e:	f06f 0307 	mvn.w	r3, #7
 8005c72:	607b      	str	r3, [r7, #4]
      }
    }
  }
  return ret;
 8005c74:	687b      	ldr	r3, [r7, #4]
}
 8005c76:	4618      	mov	r0, r3
 8005c78:	3708      	adds	r7, #8
 8005c7a:	46bd      	mov	sp, r7
 8005c7c:	bd80      	pop	{r7, pc}
 8005c7e:	bf00      	nop
 8005c80:	20002074 	.word	0x20002074
 8005c84:	20002020 	.word	0x20002020

08005c88 <BSP_I2C1_WriteReg>:
  * @param  Length Data Length
  * @retval BSP status
  */

int32_t BSP_I2C1_WriteReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 8005c88:	b580      	push	{r7, lr}
 8005c8a:	b08a      	sub	sp, #40	@ 0x28
 8005c8c:	af04      	add	r7, sp, #16
 8005c8e:	60ba      	str	r2, [r7, #8]
 8005c90:	461a      	mov	r2, r3
 8005c92:	4603      	mov	r3, r0
 8005c94:	81fb      	strh	r3, [r7, #14]
 8005c96:	460b      	mov	r3, r1
 8005c98:	81bb      	strh	r3, [r7, #12]
 8005c9a:	4613      	mov	r3, r2
 8005c9c:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 8005c9e:	2300      	movs	r3, #0
 8005ca0:	617b      	str	r3, [r7, #20]

  if (HAL_I2C_Mem_Write(&hi2c1, DevAddr,Reg, I2C_MEMADD_SIZE_8BIT,pData, Length, BUS_I2C1_POLL_TIMEOUT) != HAL_OK)
 8005ca2:	89ba      	ldrh	r2, [r7, #12]
 8005ca4:	89f9      	ldrh	r1, [r7, #14]
 8005ca6:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8005caa:	9302      	str	r3, [sp, #8]
 8005cac:	88fb      	ldrh	r3, [r7, #6]
 8005cae:	9301      	str	r3, [sp, #4]
 8005cb0:	68bb      	ldr	r3, [r7, #8]
 8005cb2:	9300      	str	r3, [sp, #0]
 8005cb4:	2301      	movs	r3, #1
 8005cb6:	480c      	ldr	r0, [pc, #48]	@ (8005ce8 <BSP_I2C1_WriteReg+0x60>)
 8005cb8:	f00a fd1e 	bl	80106f8 <HAL_I2C_Mem_Write>
 8005cbc:	4603      	mov	r3, r0
 8005cbe:	2b00      	cmp	r3, #0
 8005cc0:	d00c      	beq.n	8005cdc <BSP_I2C1_WriteReg+0x54>
  {
    if (HAL_I2C_GetError(&hi2c1) == HAL_I2C_ERROR_AF)
 8005cc2:	4809      	ldr	r0, [pc, #36]	@ (8005ce8 <BSP_I2C1_WriteReg+0x60>)
 8005cc4:	f00b faac 	bl	8011220 <HAL_I2C_GetError>
 8005cc8:	4603      	mov	r3, r0
 8005cca:	2b04      	cmp	r3, #4
 8005ccc:	d103      	bne.n	8005cd6 <BSP_I2C1_WriteReg+0x4e>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 8005cce:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 8005cd2:	617b      	str	r3, [r7, #20]
 8005cd4:	e002      	b.n	8005cdc <BSP_I2C1_WriteReg+0x54>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 8005cd6:	f06f 0303 	mvn.w	r3, #3
 8005cda:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
 8005cdc:	697b      	ldr	r3, [r7, #20]
}
 8005cde:	4618      	mov	r0, r3
 8005ce0:	3718      	adds	r7, #24
 8005ce2:	46bd      	mov	sp, r7
 8005ce4:	bd80      	pop	{r7, pc}
 8005ce6:	bf00      	nop
 8005ce8:	20002020 	.word	0x20002020

08005cec <BSP_I2C1_ReadReg>:
  * @param  pData  Pointer to data buffer to read
  * @param  Length Data Length
  * @retval BSP status
  */
int32_t  BSP_I2C1_ReadReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
 8005cec:	b580      	push	{r7, lr}
 8005cee:	b08a      	sub	sp, #40	@ 0x28
 8005cf0:	af04      	add	r7, sp, #16
 8005cf2:	60ba      	str	r2, [r7, #8]
 8005cf4:	461a      	mov	r2, r3
 8005cf6:	4603      	mov	r3, r0
 8005cf8:	81fb      	strh	r3, [r7, #14]
 8005cfa:	460b      	mov	r3, r1
 8005cfc:	81bb      	strh	r3, [r7, #12]
 8005cfe:	4613      	mov	r3, r2
 8005d00:	80fb      	strh	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 8005d02:	2300      	movs	r3, #0
 8005d04:	617b      	str	r3, [r7, #20]

  if (HAL_I2C_Mem_Read(&hi2c1, DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length, BUS_I2C1_POLL_TIMEOUT) != HAL_OK)
 8005d06:	89ba      	ldrh	r2, [r7, #12]
 8005d08:	89f9      	ldrh	r1, [r7, #14]
 8005d0a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8005d0e:	9302      	str	r3, [sp, #8]
 8005d10:	88fb      	ldrh	r3, [r7, #6]
 8005d12:	9301      	str	r3, [sp, #4]
 8005d14:	68bb      	ldr	r3, [r7, #8]
 8005d16:	9300      	str	r3, [sp, #0]
 8005d18:	2301      	movs	r3, #1
 8005d1a:	480c      	ldr	r0, [pc, #48]	@ (8005d4c <BSP_I2C1_ReadReg+0x60>)
 8005d1c:	f00a fde6 	bl	80108ec <HAL_I2C_Mem_Read>
 8005d20:	4603      	mov	r3, r0
 8005d22:	2b00      	cmp	r3, #0
 8005d24:	d00c      	beq.n	8005d40 <BSP_I2C1_ReadReg+0x54>
  {
    if (HAL_I2C_GetError(&hi2c1) == HAL_I2C_ERROR_AF)
 8005d26:	4809      	ldr	r0, [pc, #36]	@ (8005d4c <BSP_I2C1_ReadReg+0x60>)
 8005d28:	f00b fa7a 	bl	8011220 <HAL_I2C_GetError>
 8005d2c:	4603      	mov	r3, r0
 8005d2e:	2b04      	cmp	r3, #4
 8005d30:	d103      	bne.n	8005d3a <BSP_I2C1_ReadReg+0x4e>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 8005d32:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 8005d36:	617b      	str	r3, [r7, #20]
 8005d38:	e002      	b.n	8005d40 <BSP_I2C1_ReadReg+0x54>
    }
    else
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 8005d3a:	f06f 0303 	mvn.w	r3, #3
 8005d3e:	617b      	str	r3, [r7, #20]
    }
  }
  return ret;
 8005d40:	697b      	ldr	r3, [r7, #20]
}
 8005d42:	4618      	mov	r0, r3
 8005d44:	3718      	adds	r7, #24
 8005d46:	46bd      	mov	sp, r7
 8005d48:	bd80      	pop	{r7, pc}
 8005d4a:	bf00      	nop
 8005d4c:	20002020 	.word	0x20002020

08005d50 <BSP_I2C1_Send>:
  * @param  DevAddr: Device address on Bus.
  * @param  pData: Data pointer
  * @param  Length: Data length
  * @retval BSP status
  */
int32_t BSP_I2C1_Send(uint16_t DevAddr, uint8_t *pData, uint16_t Length) {
 8005d50:	b580      	push	{r7, lr}
 8005d52:	b086      	sub	sp, #24
 8005d54:	af02      	add	r7, sp, #8
 8005d56:	4603      	mov	r3, r0
 8005d58:	6039      	str	r1, [r7, #0]
 8005d5a:	80fb      	strh	r3, [r7, #6]
 8005d5c:	4613      	mov	r3, r2
 8005d5e:	80bb      	strh	r3, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
 8005d60:	2300      	movs	r3, #0
 8005d62:	60fb      	str	r3, [r7, #12]

  if (HAL_I2C_Master_Transmit(&hi2c1, DevAddr, pData, Length, BUS_I2C1_POLL_TIMEOUT) != HAL_OK)
 8005d64:	88bb      	ldrh	r3, [r7, #4]
 8005d66:	88f9      	ldrh	r1, [r7, #6]
 8005d68:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8005d6c:	9200      	str	r2, [sp, #0]
 8005d6e:	683a      	ldr	r2, [r7, #0]
 8005d70:	480b      	ldr	r0, [pc, #44]	@ (8005da0 <BSP_I2C1_Send+0x50>)
 8005d72:	f00a f991 	bl	8010098 <HAL_I2C_Master_Transmit>
 8005d76:	4603      	mov	r3, r0
 8005d78:	2b00      	cmp	r3, #0
 8005d7a:	d00c      	beq.n	8005d96 <BSP_I2C1_Send+0x46>
  {
    if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
 8005d7c:	4808      	ldr	r0, [pc, #32]	@ (8005da0 <BSP_I2C1_Send+0x50>)
 8005d7e:	f00b fa4f 	bl	8011220 <HAL_I2C_GetError>
 8005d82:	4603      	mov	r3, r0
 8005d84:	2b04      	cmp	r3, #4
 8005d86:	d003      	beq.n	8005d90 <BSP_I2C1_Send+0x40>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 8005d88:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 8005d8c:	60fb      	str	r3, [r7, #12]
 8005d8e:	e002      	b.n	8005d96 <BSP_I2C1_Send+0x46>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 8005d90:	f06f 0303 	mvn.w	r3, #3
 8005d94:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 8005d96:	68fb      	ldr	r3, [r7, #12]
}
 8005d98:	4618      	mov	r0, r3
 8005d9a:	3710      	adds	r7, #16
 8005d9c:	46bd      	mov	sp, r7
 8005d9e:	bd80      	pop	{r7, pc}
 8005da0:	20002020 	.word	0x20002020

08005da4 <BSP_I2C1_Recv>:
  * @param  DevAddr: Device address on Bus.
  * @param  pData: Data pointer
  * @param  Length: Data length
  * @retval BSP status
  */
int32_t BSP_I2C1_Recv(uint16_t DevAddr, uint8_t *pData, uint16_t Length) {
 8005da4:	b580      	push	{r7, lr}
 8005da6:	b086      	sub	sp, #24
 8005da8:	af02      	add	r7, sp, #8
 8005daa:	4603      	mov	r3, r0
 8005dac:	6039      	str	r1, [r7, #0]
 8005dae:	80fb      	strh	r3, [r7, #6]
 8005db0:	4613      	mov	r3, r2
 8005db2:	80bb      	strh	r3, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
 8005db4:	2300      	movs	r3, #0
 8005db6:	60fb      	str	r3, [r7, #12]

  if (HAL_I2C_Master_Receive(&hi2c1, DevAddr, pData, Length, BUS_I2C1_POLL_TIMEOUT) != HAL_OK)
 8005db8:	88bb      	ldrh	r3, [r7, #4]
 8005dba:	88f9      	ldrh	r1, [r7, #6]
 8005dbc:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8005dc0:	9200      	str	r2, [sp, #0]
 8005dc2:	683a      	ldr	r2, [r7, #0]
 8005dc4:	480b      	ldr	r0, [pc, #44]	@ (8005df4 <BSP_I2C1_Recv+0x50>)
 8005dc6:	f00a fa65 	bl	8010294 <HAL_I2C_Master_Receive>
 8005dca:	4603      	mov	r3, r0
 8005dcc:	2b00      	cmp	r3, #0
 8005dce:	d00c      	beq.n	8005dea <BSP_I2C1_Recv+0x46>
  {
    if (HAL_I2C_GetError(&hi2c1) != HAL_I2C_ERROR_AF)
 8005dd0:	4808      	ldr	r0, [pc, #32]	@ (8005df4 <BSP_I2C1_Recv+0x50>)
 8005dd2:	f00b fa25 	bl	8011220 <HAL_I2C_GetError>
 8005dd6:	4603      	mov	r3, r0
 8005dd8:	2b04      	cmp	r3, #4
 8005dda:	d003      	beq.n	8005de4 <BSP_I2C1_Recv+0x40>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
 8005ddc:	f06f 0365 	mvn.w	r3, #101	@ 0x65
 8005de0:	60fb      	str	r3, [r7, #12]
 8005de2:	e002      	b.n	8005dea <BSP_I2C1_Recv+0x46>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 8005de4:	f06f 0303 	mvn.w	r3, #3
 8005de8:	60fb      	str	r3, [r7, #12]
    }
  }
  return ret;
 8005dea:	68fb      	ldr	r3, [r7, #12]
}
 8005dec:	4618      	mov	r0, r3
 8005dee:	3710      	adds	r7, #16
 8005df0:	46bd      	mov	sp, r7
 8005df2:	bd80      	pop	{r7, pc}
 8005df4:	20002020 	.word	0x20002020

08005df8 <BSP_GetTick>:

/**
  * @brief  Return system tick in ms
  * @retval Current HAL time base time stamp
  */
int32_t BSP_GetTick(void) {
 8005df8:	b580      	push	{r7, lr}
 8005dfa:	af00      	add	r7, sp, #0
  return HAL_GetTick();
 8005dfc:	f009 fa7e 	bl	800f2fc <HAL_GetTick>
 8005e00:	4603      	mov	r3, r0
}
 8005e02:	4618      	mov	r0, r3
 8005e04:	bd80      	pop	{r7, pc}
	...

08005e08 <MX_I2C1_Init>:

/* I2C1 init function */

__weak HAL_StatusTypeDef MX_I2C1_Init(I2C_HandleTypeDef* hi2c)
{
 8005e08:	b580      	push	{r7, lr}
 8005e0a:	b084      	sub	sp, #16
 8005e0c:	af00      	add	r7, sp, #0
 8005e0e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 8005e10:	2300      	movs	r3, #0
 8005e12:	73fb      	strb	r3, [r7, #15]

  hi2c->Instance = I2C1;
 8005e14:	687b      	ldr	r3, [r7, #4]
 8005e16:	4a14      	ldr	r2, [pc, #80]	@ (8005e68 <MX_I2C1_Init+0x60>)
 8005e18:	601a      	str	r2, [r3, #0]
  hi2c->Init.ClockSpeed = 400000;
 8005e1a:	687b      	ldr	r3, [r7, #4]
 8005e1c:	4a13      	ldr	r2, [pc, #76]	@ (8005e6c <MX_I2C1_Init+0x64>)
 8005e1e:	605a      	str	r2, [r3, #4]
  hi2c->Init.DutyCycle = I2C_DUTYCYCLE_2;
 8005e20:	687b      	ldr	r3, [r7, #4]
 8005e22:	2200      	movs	r2, #0
 8005e24:	609a      	str	r2, [r3, #8]
  hi2c->Init.OwnAddress1 = 0;
 8005e26:	687b      	ldr	r3, [r7, #4]
 8005e28:	2200      	movs	r2, #0
 8005e2a:	60da      	str	r2, [r3, #12]
  hi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005e2c:	687b      	ldr	r3, [r7, #4]
 8005e2e:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8005e32:	611a      	str	r2, [r3, #16]
  hi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8005e34:	687b      	ldr	r3, [r7, #4]
 8005e36:	2200      	movs	r2, #0
 8005e38:	615a      	str	r2, [r3, #20]
  hi2c->Init.OwnAddress2 = 0;
 8005e3a:	687b      	ldr	r3, [r7, #4]
 8005e3c:	2200      	movs	r2, #0
 8005e3e:	619a      	str	r2, [r3, #24]
  hi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005e40:	687b      	ldr	r3, [r7, #4]
 8005e42:	2200      	movs	r2, #0
 8005e44:	61da      	str	r2, [r3, #28]
  hi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005e46:	687b      	ldr	r3, [r7, #4]
 8005e48:	2200      	movs	r2, #0
 8005e4a:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(hi2c) != HAL_OK)
 8005e4c:	6878      	ldr	r0, [r7, #4]
 8005e4e:	f009 ff87 	bl	800fd60 <HAL_I2C_Init>
 8005e52:	4603      	mov	r3, r0
 8005e54:	2b00      	cmp	r3, #0
 8005e56:	d001      	beq.n	8005e5c <MX_I2C1_Init+0x54>
  {
    ret = HAL_ERROR;
 8005e58:	2301      	movs	r3, #1
 8005e5a:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 8005e5c:	7bfb      	ldrb	r3, [r7, #15]
}
 8005e5e:	4618      	mov	r0, r3
 8005e60:	3710      	adds	r7, #16
 8005e62:	46bd      	mov	sp, r7
 8005e64:	bd80      	pop	{r7, pc}
 8005e66:	bf00      	nop
 8005e68:	40005400 	.word	0x40005400
 8005e6c:	00061a80 	.word	0x00061a80

08005e70 <I2C1_MspInit>:

static void I2C1_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8005e70:	b580      	push	{r7, lr}
 8005e72:	b08a      	sub	sp, #40	@ 0x28
 8005e74:	af00      	add	r7, sp, #0
 8005e76:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005e78:	2300      	movs	r3, #0
 8005e7a:	613b      	str	r3, [r7, #16]
 8005e7c:	4b27      	ldr	r3, [pc, #156]	@ (8005f1c <I2C1_MspInit+0xac>)
 8005e7e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8005e80:	4a26      	ldr	r2, [pc, #152]	@ (8005f1c <I2C1_MspInit+0xac>)
 8005e82:	f043 0302 	orr.w	r3, r3, #2
 8005e86:	6313      	str	r3, [r2, #48]	@ 0x30
 8005e88:	4b24      	ldr	r3, [pc, #144]	@ (8005f1c <I2C1_MspInit+0xac>)
 8005e8a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8005e8c:	f003 0302 	and.w	r3, r3, #2
 8005e90:	613b      	str	r3, [r7, #16]
 8005e92:	693b      	ldr	r3, [r7, #16]
    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = BUS_I2C1_SCL_GPIO_PIN;
 8005e94:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8005e98:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005e9a:	2312      	movs	r3, #18
 8005e9c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005e9e:	2300      	movs	r3, #0
 8005ea0:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005ea2:	2303      	movs	r3, #3
 8005ea4:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = BUS_I2C1_SCL_GPIO_AF;
 8005ea6:	2304      	movs	r3, #4
 8005ea8:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUS_I2C1_SCL_GPIO_PORT, &GPIO_InitStruct);
 8005eaa:	f107 0314 	add.w	r3, r7, #20
 8005eae:	4619      	mov	r1, r3
 8005eb0:	481b      	ldr	r0, [pc, #108]	@ (8005f20 <I2C1_MspInit+0xb0>)
 8005eb2:	f009 fcbb 	bl	800f82c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_I2C1_SDA_GPIO_PIN;
 8005eb6:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8005eba:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005ebc:	2312      	movs	r3, #18
 8005ebe:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ec0:	2300      	movs	r3, #0
 8005ec2:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005ec4:	2303      	movs	r3, #3
 8005ec6:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = BUS_I2C1_SDA_GPIO_AF;
 8005ec8:	2304      	movs	r3, #4
 8005eca:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUS_I2C1_SDA_GPIO_PORT, &GPIO_InitStruct);
 8005ecc:	f107 0314 	add.w	r3, r7, #20
 8005ed0:	4619      	mov	r1, r3
 8005ed2:	4813      	ldr	r0, [pc, #76]	@ (8005f20 <I2C1_MspInit+0xb0>)
 8005ed4:	f009 fcaa 	bl	800f82c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8005ed8:	2300      	movs	r3, #0
 8005eda:	60fb      	str	r3, [r7, #12]
 8005edc:	4b0f      	ldr	r3, [pc, #60]	@ (8005f1c <I2C1_MspInit+0xac>)
 8005ede:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005ee0:	4a0e      	ldr	r2, [pc, #56]	@ (8005f1c <I2C1_MspInit+0xac>)
 8005ee2:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8005ee6:	6413      	str	r3, [r2, #64]	@ 0x40
 8005ee8:	4b0c      	ldr	r3, [pc, #48]	@ (8005f1c <I2C1_MspInit+0xac>)
 8005eea:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005eec:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8005ef0:	60fb      	str	r3, [r7, #12]
 8005ef2:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 8005ef4:	2200      	movs	r2, #0
 8005ef6:	2100      	movs	r1, #0
 8005ef8:	201f      	movs	r0, #31
 8005efa:	f009 fb2e 	bl	800f55a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 8005efe:	201f      	movs	r0, #31
 8005f00:	f009 fb47 	bl	800f592 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 0, 0);
 8005f04:	2200      	movs	r2, #0
 8005f06:	2100      	movs	r1, #0
 8005f08:	2020      	movs	r0, #32
 8005f0a:	f009 fb26 	bl	800f55a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
 8005f0e:	2020      	movs	r0, #32
 8005f10:	f009 fb3f 	bl	800f592 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
}
 8005f14:	bf00      	nop
 8005f16:	3728      	adds	r7, #40	@ 0x28
 8005f18:	46bd      	mov	sp, r7
 8005f1a:	bd80      	pop	{r7, pc}
 8005f1c:	40023800 	.word	0x40023800
 8005f20:	40020400 	.word	0x40020400

08005f24 <I2C1_MspDeInit>:

static void I2C1_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
 8005f24:	b580      	push	{r7, lr}
 8005f26:	b082      	sub	sp, #8
 8005f28:	af00      	add	r7, sp, #0
 8005f2a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN I2C1_MspDeInit 0 */

  /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();
 8005f2c:	4b0c      	ldr	r3, [pc, #48]	@ (8005f60 <I2C1_MspDeInit+0x3c>)
 8005f2e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005f30:	4a0b      	ldr	r2, [pc, #44]	@ (8005f60 <I2C1_MspDeInit+0x3c>)
 8005f32:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8005f36:	6413      	str	r3, [r2, #64]	@ 0x40

    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    HAL_GPIO_DeInit(BUS_I2C1_SCL_GPIO_PORT, BUS_I2C1_SCL_GPIO_PIN);
 8005f38:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8005f3c:	4809      	ldr	r0, [pc, #36]	@ (8005f64 <I2C1_MspDeInit+0x40>)
 8005f3e:	f009 fdf9 	bl	800fb34 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(BUS_I2C1_SDA_GPIO_PORT, BUS_I2C1_SDA_GPIO_PIN);
 8005f42:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8005f46:	4807      	ldr	r0, [pc, #28]	@ (8005f64 <I2C1_MspDeInit+0x40>)
 8005f48:	f009 fdf4 	bl	800fb34 <HAL_GPIO_DeInit>

    /* Peripheral interrupt Deinit*/
    HAL_NVIC_DisableIRQ(I2C1_EV_IRQn);
 8005f4c:	201f      	movs	r0, #31
 8005f4e:	f009 fb2e 	bl	800f5ae <HAL_NVIC_DisableIRQ>

    HAL_NVIC_DisableIRQ(I2C1_ER_IRQn);
 8005f52:	2020      	movs	r0, #32
 8005f54:	f009 fb2b 	bl	800f5ae <HAL_NVIC_DisableIRQ>

  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
}
 8005f58:	bf00      	nop
 8005f5a:	3708      	adds	r7, #8
 8005f5c:	46bd      	mov	sp, r7
 8005f5e:	bd80      	pop	{r7, pc}
 8005f60:	40023800 	.word	0x40023800
 8005f64:	40020400 	.word	0x40020400

08005f68 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 8005f68:	b480      	push	{r7}
 8005f6a:	af00      	add	r7, sp, #0
  return 1;
 8005f6c:	2301      	movs	r3, #1
}
 8005f6e:	4618      	mov	r0, r3
 8005f70:	46bd      	mov	sp, r7
 8005f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f76:	4770      	bx	lr

08005f78 <_kill>:

int _kill(int pid, int sig)
{
 8005f78:	b580      	push	{r7, lr}
 8005f7a:	b082      	sub	sp, #8
 8005f7c:	af00      	add	r7, sp, #0
 8005f7e:	6078      	str	r0, [r7, #4]
 8005f80:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 8005f82:	f017 fbb3 	bl	801d6ec <__errno>
 8005f86:	4603      	mov	r3, r0
 8005f88:	2216      	movs	r2, #22
 8005f8a:	601a      	str	r2, [r3, #0]
  return -1;
 8005f8c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
 8005f90:	4618      	mov	r0, r3
 8005f92:	3708      	adds	r7, #8
 8005f94:	46bd      	mov	sp, r7
 8005f96:	bd80      	pop	{r7, pc}

08005f98 <_exit>:

void _exit (int status)
{
 8005f98:	b580      	push	{r7, lr}
 8005f9a:	b082      	sub	sp, #8
 8005f9c:	af00      	add	r7, sp, #0
 8005f9e:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 8005fa0:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 8005fa4:	6878      	ldr	r0, [r7, #4]
 8005fa6:	f7ff ffe7 	bl	8005f78 <_kill>
  while (1) {}    /* Make sure we hang here */
 8005faa:	bf00      	nop
 8005fac:	e7fd      	b.n	8005faa <_exit+0x12>

08005fae <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8005fae:	b580      	push	{r7, lr}
 8005fb0:	b086      	sub	sp, #24
 8005fb2:	af00      	add	r7, sp, #0
 8005fb4:	60f8      	str	r0, [r7, #12]
 8005fb6:	60b9      	str	r1, [r7, #8]
 8005fb8:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8005fba:	2300      	movs	r3, #0
 8005fbc:	617b      	str	r3, [r7, #20]
 8005fbe:	e00a      	b.n	8005fd6 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 8005fc0:	f3af 8000 	nop.w
 8005fc4:	4601      	mov	r1, r0
 8005fc6:	68bb      	ldr	r3, [r7, #8]
 8005fc8:	1c5a      	adds	r2, r3, #1
 8005fca:	60ba      	str	r2, [r7, #8]
 8005fcc:	b2ca      	uxtb	r2, r1
 8005fce:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8005fd0:	697b      	ldr	r3, [r7, #20]
 8005fd2:	3301      	adds	r3, #1
 8005fd4:	617b      	str	r3, [r7, #20]
 8005fd6:	697a      	ldr	r2, [r7, #20]
 8005fd8:	687b      	ldr	r3, [r7, #4]
 8005fda:	429a      	cmp	r2, r3
 8005fdc:	dbf0      	blt.n	8005fc0 <_read+0x12>
  }

  return len;
 8005fde:	687b      	ldr	r3, [r7, #4]
}
 8005fe0:	4618      	mov	r0, r3
 8005fe2:	3718      	adds	r7, #24
 8005fe4:	46bd      	mov	sp, r7
 8005fe6:	bd80      	pop	{r7, pc}

08005fe8 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8005fe8:	b580      	push	{r7, lr}
 8005fea:	b086      	sub	sp, #24
 8005fec:	af00      	add	r7, sp, #0
 8005fee:	60f8      	str	r0, [r7, #12]
 8005ff0:	60b9      	str	r1, [r7, #8]
 8005ff2:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8005ff4:	2300      	movs	r3, #0
 8005ff6:	617b      	str	r3, [r7, #20]
 8005ff8:	e009      	b.n	800600e <_write+0x26>
  {
    __io_putchar(*ptr++);
 8005ffa:	68bb      	ldr	r3, [r7, #8]
 8005ffc:	1c5a      	adds	r2, r3, #1
 8005ffe:	60ba      	str	r2, [r7, #8]
 8006000:	781b      	ldrb	r3, [r3, #0]
 8006002:	4618      	mov	r0, r3
 8006004:	f009 f8b0 	bl	800f168 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8006008:	697b      	ldr	r3, [r7, #20]
 800600a:	3301      	adds	r3, #1
 800600c:	617b      	str	r3, [r7, #20]
 800600e:	697a      	ldr	r2, [r7, #20]
 8006010:	687b      	ldr	r3, [r7, #4]
 8006012:	429a      	cmp	r2, r3
 8006014:	dbf1      	blt.n	8005ffa <_write+0x12>
  }
  return len;
 8006016:	687b      	ldr	r3, [r7, #4]
}
 8006018:	4618      	mov	r0, r3
 800601a:	3718      	adds	r7, #24
 800601c:	46bd      	mov	sp, r7
 800601e:	bd80      	pop	{r7, pc}

08006020 <_close>:

int _close(int file)
{
 8006020:	b480      	push	{r7}
 8006022:	b083      	sub	sp, #12
 8006024:	af00      	add	r7, sp, #0
 8006026:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 8006028:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
 800602c:	4618      	mov	r0, r3
 800602e:	370c      	adds	r7, #12
 8006030:	46bd      	mov	sp, r7
 8006032:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006036:	4770      	bx	lr

08006038 <_fstat>:


int _fstat(int file, struct stat *st)
{
 8006038:	b480      	push	{r7}
 800603a:	b083      	sub	sp, #12
 800603c:	af00      	add	r7, sp, #0
 800603e:	6078      	str	r0, [r7, #4]
 8006040:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 8006042:	683b      	ldr	r3, [r7, #0]
 8006044:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8006048:	605a      	str	r2, [r3, #4]
  return 0;
 800604a:	2300      	movs	r3, #0
}
 800604c:	4618      	mov	r0, r3
 800604e:	370c      	adds	r7, #12
 8006050:	46bd      	mov	sp, r7
 8006052:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006056:	4770      	bx	lr

08006058 <_isatty>:

int _isatty(int file)
{
 8006058:	b480      	push	{r7}
 800605a:	b083      	sub	sp, #12
 800605c:	af00      	add	r7, sp, #0
 800605e:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 8006060:	2301      	movs	r3, #1
}
 8006062:	4618      	mov	r0, r3
 8006064:	370c      	adds	r7, #12
 8006066:	46bd      	mov	sp, r7
 8006068:	f85d 7b04 	ldr.w	r7, [sp], #4
 800606c:	4770      	bx	lr

0800606e <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 800606e:	b480      	push	{r7}
 8006070:	b085      	sub	sp, #20
 8006072:	af00      	add	r7, sp, #0
 8006074:	60f8      	str	r0, [r7, #12]
 8006076:	60b9      	str	r1, [r7, #8]
 8006078:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 800607a:	2300      	movs	r3, #0
}
 800607c:	4618      	mov	r0, r3
 800607e:	3714      	adds	r7, #20
 8006080:	46bd      	mov	sp, r7
 8006082:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006086:	4770      	bx	lr

08006088 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8006088:	b580      	push	{r7, lr}
 800608a:	b086      	sub	sp, #24
 800608c:	af00      	add	r7, sp, #0
 800608e:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8006090:	4a14      	ldr	r2, [pc, #80]	@ (80060e4 <_sbrk+0x5c>)
 8006092:	4b15      	ldr	r3, [pc, #84]	@ (80060e8 <_sbrk+0x60>)
 8006094:	1ad3      	subs	r3, r2, r3
 8006096:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8006098:	697b      	ldr	r3, [r7, #20]
 800609a:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 800609c:	4b13      	ldr	r3, [pc, #76]	@ (80060ec <_sbrk+0x64>)
 800609e:	681b      	ldr	r3, [r3, #0]
 80060a0:	2b00      	cmp	r3, #0
 80060a2:	d102      	bne.n	80060aa <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 80060a4:	4b11      	ldr	r3, [pc, #68]	@ (80060ec <_sbrk+0x64>)
 80060a6:	4a12      	ldr	r2, [pc, #72]	@ (80060f0 <_sbrk+0x68>)
 80060a8:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80060aa:	4b10      	ldr	r3, [pc, #64]	@ (80060ec <_sbrk+0x64>)
 80060ac:	681a      	ldr	r2, [r3, #0]
 80060ae:	687b      	ldr	r3, [r7, #4]
 80060b0:	4413      	add	r3, r2
 80060b2:	693a      	ldr	r2, [r7, #16]
 80060b4:	429a      	cmp	r2, r3
 80060b6:	d207      	bcs.n	80060c8 <_sbrk+0x40>
  {
    errno = ENOMEM;
 80060b8:	f017 fb18 	bl	801d6ec <__errno>
 80060bc:	4603      	mov	r3, r0
 80060be:	220c      	movs	r2, #12
 80060c0:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 80060c2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80060c6:	e009      	b.n	80060dc <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80060c8:	4b08      	ldr	r3, [pc, #32]	@ (80060ec <_sbrk+0x64>)
 80060ca:	681b      	ldr	r3, [r3, #0]
 80060cc:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 80060ce:	4b07      	ldr	r3, [pc, #28]	@ (80060ec <_sbrk+0x64>)
 80060d0:	681a      	ldr	r2, [r3, #0]
 80060d2:	687b      	ldr	r3, [r7, #4]
 80060d4:	4413      	add	r3, r2
 80060d6:	4a05      	ldr	r2, [pc, #20]	@ (80060ec <_sbrk+0x64>)
 80060d8:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 80060da:	68fb      	ldr	r3, [r7, #12]
}
 80060dc:	4618      	mov	r0, r3
 80060de:	3718      	adds	r7, #24
 80060e0:	46bd      	mov	sp, r7
 80060e2:	bd80      	pop	{r7, pc}
 80060e4:	20020000 	.word	0x20020000
 80060e8:	00008000 	.word	0x00008000
 80060ec:	20002078 	.word	0x20002078
 80060f0:	20002460 	.word	0x20002460

080060f4 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80060f4:	b480      	push	{r7}
 80060f6:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80060f8:	4b06      	ldr	r3, [pc, #24]	@ (8006114 <SystemInit+0x20>)
 80060fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80060fe:	4a05      	ldr	r2, [pc, #20]	@ (8006114 <SystemInit+0x20>)
 8006100:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8006104:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8006108:	bf00      	nop
 800610a:	46bd      	mov	sp, r7
 800610c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006110:	4770      	bx	lr
 8006112:	bf00      	nop
 8006114:	e000ed00 	.word	0xe000ed00

08006118 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8006118:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8006150 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800611c:	f7ff ffea 	bl	80060f4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8006120:	480c      	ldr	r0, [pc, #48]	@ (8006154 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8006122:	490d      	ldr	r1, [pc, #52]	@ (8006158 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8006124:	4a0d      	ldr	r2, [pc, #52]	@ (800615c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8006126:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8006128:	e002      	b.n	8006130 <LoopCopyDataInit>

0800612a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800612a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800612c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800612e:	3304      	adds	r3, #4

08006130 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8006130:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8006132:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8006134:	d3f9      	bcc.n	800612a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8006136:	4a0a      	ldr	r2, [pc, #40]	@ (8006160 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8006138:	4c0a      	ldr	r4, [pc, #40]	@ (8006164 <LoopFillZerobss+0x22>)
  movs r3, #0
 800613a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800613c:	e001      	b.n	8006142 <LoopFillZerobss>

0800613e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800613e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8006140:	3204      	adds	r2, #4

08006142 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8006142:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8006144:	d3fb      	bcc.n	800613e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8006146:	f017 fad7 	bl	801d6f8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800614a:	f7fc f8d1 	bl	80022f0 <main>
  bx  lr    
 800614e:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8006150:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8006154:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8006158:	20000530 	.word	0x20000530
  ldr r2, =_sidata
 800615c:	08024448 	.word	0x08024448
  ldr r2, =_sbss
 8006160:	20000530 	.word	0x20000530
  ldr r4, =_ebss
 8006164:	20002460 	.word	0x20002460

08006168 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8006168:	e7fe      	b.n	8006168 <ADC_IRQHandler>
	...

0800616c <LIS2DUXS12_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_RegisterBusIO(LIS2DUXS12_Object_t *pObj, LIS2DUXS12_IO_t *pIO)
{
 800616c:	b580      	push	{r7, lr}
 800616e:	b084      	sub	sp, #16
 8006170:	af00      	add	r7, sp, #0
 8006172:	6078      	str	r0, [r7, #4]
 8006174:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2DUXS12_OK;
 8006176:	2300      	movs	r3, #0
 8006178:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 800617a:	687b      	ldr	r3, [r7, #4]
 800617c:	2b00      	cmp	r3, #0
 800617e:	d103      	bne.n	8006188 <LIS2DUXS12_RegisterBusIO+0x1c>
  {
    ret = LIS2DUXS12_ERROR;
 8006180:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006184:	60fb      	str	r3, [r7, #12]
 8006186:	e084      	b.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 8006188:	683b      	ldr	r3, [r7, #0]
 800618a:	681a      	ldr	r2, [r3, #0]
 800618c:	687b      	ldr	r3, [r7, #4]
 800618e:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 8006190:	683b      	ldr	r3, [r7, #0]
 8006192:	685a      	ldr	r2, [r3, #4]
 8006194:	687b      	ldr	r3, [r7, #4]
 8006196:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 8006198:	683b      	ldr	r3, [r7, #0]
 800619a:	689a      	ldr	r2, [r3, #8]
 800619c:	687b      	ldr	r3, [r7, #4]
 800619e:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 80061a0:	683b      	ldr	r3, [r7, #0]
 80061a2:	7b1a      	ldrb	r2, [r3, #12]
 80061a4:	687b      	ldr	r3, [r7, #4]
 80061a6:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 80061a8:	683b      	ldr	r3, [r7, #0]
 80061aa:	691a      	ldr	r2, [r3, #16]
 80061ac:	687b      	ldr	r3, [r7, #4]
 80061ae:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 80061b0:	683b      	ldr	r3, [r7, #0]
 80061b2:	695a      	ldr	r2, [r3, #20]
 80061b4:	687b      	ldr	r3, [r7, #4]
 80061b6:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 80061b8:	683b      	ldr	r3, [r7, #0]
 80061ba:	699a      	ldr	r2, [r3, #24]
 80061bc:	687b      	ldr	r3, [r7, #4]
 80061be:	619a      	str	r2, [r3, #24]
    pObj->IO.Delay     = pIO->Delay;
 80061c0:	683b      	ldr	r3, [r7, #0]
 80061c2:	69da      	ldr	r2, [r3, #28]
 80061c4:	687b      	ldr	r3, [r7, #4]
 80061c6:	61da      	str	r2, [r3, #28]

    pObj->Ctx.read_reg  = ReadRegWrap;
 80061c8:	687b      	ldr	r3, [r7, #4]
 80061ca:	4a34      	ldr	r2, [pc, #208]	@ (800629c <LIS2DUXS12_RegisterBusIO+0x130>)
 80061cc:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 80061ce:	687b      	ldr	r3, [r7, #4]
 80061d0:	4a33      	ldr	r2, [pc, #204]	@ (80062a0 <LIS2DUXS12_RegisterBusIO+0x134>)
 80061d2:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 80061d4:	683b      	ldr	r3, [r7, #0]
 80061d6:	69da      	ldr	r2, [r3, #28]
 80061d8:	687b      	ldr	r3, [r7, #4]
 80061da:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 80061dc:	687b      	ldr	r3, [r7, #4]
 80061de:	687a      	ldr	r2, [r7, #4]
 80061e0:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 80061e2:	687b      	ldr	r3, [r7, #4]
 80061e4:	681b      	ldr	r3, [r3, #0]
 80061e6:	2b00      	cmp	r3, #0
 80061e8:	d103      	bne.n	80061f2 <LIS2DUXS12_RegisterBusIO+0x86>
    {
      ret = LIS2DUXS12_ERROR;
 80061ea:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80061ee:	60fb      	str	r3, [r7, #12]
 80061f0:	e04f      	b.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
    }
    else if (pObj->IO.Init() != LIS2DUXS12_OK)
 80061f2:	687b      	ldr	r3, [r7, #4]
 80061f4:	681b      	ldr	r3, [r3, #0]
 80061f6:	4798      	blx	r3
 80061f8:	4603      	mov	r3, r0
 80061fa:	2b00      	cmp	r3, #0
 80061fc:	d003      	beq.n	8006206 <LIS2DUXS12_RegisterBusIO+0x9a>
    {
      ret = LIS2DUXS12_ERROR;
 80061fe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006202:	60fb      	str	r3, [r7, #12]
 8006204:	e045      	b.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
    }
    else
    {
      if (pObj->IO.BusType == LIS2DUXS12_SPI_3WIRES_BUS) /* SPI 3-Wires */
 8006206:	687b      	ldr	r3, [r7, #4]
 8006208:	689b      	ldr	r3, [r3, #8]
 800620a:	2b02      	cmp	r3, #2
 800620c:	d11c      	bne.n	8006248 <LIS2DUXS12_RegisterBusIO+0xdc>
      {
        /* Enable the SPI 3-Wires support only the first time */
        if (pObj->is_initialized == 0U)
 800620e:	687b      	ldr	r3, [r7, #4]
 8006210:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8006214:	2b00      	cmp	r3, #0
 8006216:	d13c      	bne.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
        {
          /* Exit from deep power down only the first time in SPI mode */
          if (LIS2DUXS12_ExitDeepPowerDownSPI(pObj) != LIS2DUXS12_OK)
 8006218:	6878      	ldr	r0, [r7, #4]
 800621a:	f000 f8e6 	bl	80063ea <LIS2DUXS12_ExitDeepPowerDownSPI>
 800621e:	4603      	mov	r3, r0
 8006220:	2b00      	cmp	r3, #0
 8006222:	d002      	beq.n	800622a <LIS2DUXS12_RegisterBusIO+0xbe>
          {
            ret = LIS2DUXS12_ERROR;
 8006224:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006228:	60fb      	str	r3, [r7, #12]
          }
          /* Enable SPI 3-Wires on the component */
          uint8_t data = 0x50;
 800622a:	2350      	movs	r3, #80	@ 0x50
 800622c:	72fb      	strb	r3, [r7, #11]

          if (LIS2DUXS12_Write_Reg(pObj, LIS2DUXS12_CTRL1, data) != LIS2DUXS12_OK)
 800622e:	7afb      	ldrb	r3, [r7, #11]
 8006230:	461a      	mov	r2, r3
 8006232:	2110      	movs	r1, #16
 8006234:	6878      	ldr	r0, [r7, #4]
 8006236:	f000 fbe8 	bl	8006a0a <LIS2DUXS12_Write_Reg>
 800623a:	4603      	mov	r3, r0
 800623c:	2b00      	cmp	r3, #0
 800623e:	d028      	beq.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
          {
            ret = LIS2DUXS12_ERROR;
 8006240:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006244:	60fb      	str	r3, [r7, #12]
 8006246:	e024      	b.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
          }
        }
      }
      else if (pObj->IO.BusType == LIS2DUXS12_SPI_4WIRES_BUS)
 8006248:	687b      	ldr	r3, [r7, #4]
 800624a:	689b      	ldr	r3, [r3, #8]
 800624c:	2b01      	cmp	r3, #1
 800624e:	d10e      	bne.n	800626e <LIS2DUXS12_RegisterBusIO+0x102>
      {
        /* Exit from deep power down only the first time in SPI mode */
        if (pObj->is_initialized == 0U)
 8006250:	687b      	ldr	r3, [r7, #4]
 8006252:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8006256:	2b00      	cmp	r3, #0
 8006258:	d11b      	bne.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
        {
          if (LIS2DUXS12_ExitDeepPowerDownSPI(pObj) != LIS2DUXS12_OK)
 800625a:	6878      	ldr	r0, [r7, #4]
 800625c:	f000 f8c5 	bl	80063ea <LIS2DUXS12_ExitDeepPowerDownSPI>
 8006260:	4603      	mov	r3, r0
 8006262:	2b00      	cmp	r3, #0
 8006264:	d015      	beq.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
          {
            ret = LIS2DUXS12_ERROR;
 8006266:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800626a:	60fb      	str	r3, [r7, #12]
 800626c:	e011      	b.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
          }
        }
      }
      else if (pObj->IO.BusType == LIS2DUXS12_I2C_BUS)
 800626e:	687b      	ldr	r3, [r7, #4]
 8006270:	689b      	ldr	r3, [r3, #8]
 8006272:	2b00      	cmp	r3, #0
 8006274:	d10d      	bne.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
      {
        /* Exit from deep power down only the first time in I2C mode */
        if (pObj->is_initialized == 0U)
 8006276:	687b      	ldr	r3, [r7, #4]
 8006278:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800627c:	2b00      	cmp	r3, #0
 800627e:	d108      	bne.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
        {
          if (LIS2DUXS12_ExitDeepPowerDownI2C(pObj) != LIS2DUXS12_OK)
 8006280:	6878      	ldr	r0, [r7, #4]
 8006282:	f000 f89d 	bl	80063c0 <LIS2DUXS12_ExitDeepPowerDownI2C>
 8006286:	4603      	mov	r3, r0
 8006288:	2b00      	cmp	r3, #0
 800628a:	d002      	beq.n	8006292 <LIS2DUXS12_RegisterBusIO+0x126>
          {
            ret = LIS2DUXS12_ERROR;
 800628c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006290:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

  return ret;
 8006292:	68fb      	ldr	r3, [r7, #12]
}
 8006294:	4618      	mov	r0, r3
 8006296:	3710      	adds	r7, #16
 8006298:	46bd      	mov	sp, r7
 800629a:	bd80      	pop	{r7, pc}
 800629c:	08006e81 	.word	0x08006e81
 80062a0:	08006eb7 	.word	0x08006eb7

080062a4 <LIS2DUXS12_Init>:
  * @brief  Initialize the LIS2DUXS12 sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_Init(LIS2DUXS12_Object_t *pObj)
{
 80062a4:	b580      	push	{r7, lr}
 80062a6:	b086      	sub	sp, #24
 80062a8:	af00      	add	r7, sp, #0
 80062aa:	6078      	str	r0, [r7, #4]
  lis2duxs12_i3c_cfg_t val;

  if(pObj->IO.BusType != LIS2DUXS12_I3C_BUS)
 80062ac:	687b      	ldr	r3, [r7, #4]
 80062ae:	689b      	ldr	r3, [r3, #8]
 80062b0:	2b03      	cmp	r3, #3
 80062b2:	d01f      	beq.n	80062f4 <LIS2DUXS12_Init+0x50>
  {
    /* Disable I3C */
    if (lis2duxs12_i3c_configure_get(&(pObj->Ctx), &val) != LIS2DUXS12_OK)
 80062b4:	687b      	ldr	r3, [r7, #4]
 80062b6:	3320      	adds	r3, #32
 80062b8:	f107 0214 	add.w	r2, r7, #20
 80062bc:	4611      	mov	r1, r2
 80062be:	4618      	mov	r0, r3
 80062c0:	f001 fa72 	bl	80077a8 <lis2duxs12_i3c_configure_get>
 80062c4:	4603      	mov	r3, r0
 80062c6:	2b00      	cmp	r3, #0
 80062c8:	d002      	beq.n	80062d0 <LIS2DUXS12_Init+0x2c>
    {
      return LIS2DUXS12_ERROR;
 80062ca:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80062ce:	e052      	b.n	8006376 <LIS2DUXS12_Init+0xd2>
    }
    val.asf_on = PROPERTY_ENABLE;
 80062d0:	7d7b      	ldrb	r3, [r7, #21]
 80062d2:	f043 0301 	orr.w	r3, r3, #1
 80062d6:	757b      	strb	r3, [r7, #21]
    if (lis2duxs12_i3c_configure_set(&(pObj->Ctx), &val) != LIS2DUXS12_OK)
 80062d8:	687b      	ldr	r3, [r7, #4]
 80062da:	3320      	adds	r3, #32
 80062dc:	f107 0214 	add.w	r2, r7, #20
 80062e0:	4611      	mov	r1, r2
 80062e2:	4618      	mov	r0, r3
 80062e4:	f001 fa28 	bl	8007738 <lis2duxs12_i3c_configure_set>
 80062e8:	4603      	mov	r3, r0
 80062ea:	2b00      	cmp	r3, #0
 80062ec:	d002      	beq.n	80062f4 <LIS2DUXS12_Init+0x50>
    {
      return LIS2DUXS12_ERROR;
 80062ee:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80062f2:	e040      	b.n	8006376 <LIS2DUXS12_Init+0xd2>
    }
  }

  /* Enable register address automatically incremented during a multiple byte
  access with a serial interface. Enable BDU. */
  if (lis2duxs12_init_set(&(pObj->Ctx), LIS2DUXS12_SENSOR_ONLY_ON) != LIS2DUXS12_OK)
 80062f4:	687b      	ldr	r3, [r7, #4]
 80062f6:	3320      	adds	r3, #32
 80062f8:	2100      	movs	r1, #0
 80062fa:	4618      	mov	r0, r3
 80062fc:	f000 fe98 	bl	8007030 <lis2duxs12_init_set>
 8006300:	4603      	mov	r3, r0
 8006302:	2b00      	cmp	r3, #0
 8006304:	d002      	beq.n	800630c <LIS2DUXS12_Init+0x68>
  {
    return LIS2DUXS12_ERROR;
 8006306:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800630a:	e034      	b.n	8006376 <LIS2DUXS12_Init+0xd2>
  }

  /* FIFO mode selection */
  lis2duxs12_fifo_mode_t fifo_mode =
 800630c:	f107 030c 	add.w	r3, r7, #12
 8006310:	2200      	movs	r2, #0
 8006312:	601a      	str	r2, [r3, #0]
 8006314:	809a      	strh	r2, [r3, #4]
    .operation = LIS2DUXS12_BYPASS_MODE,
    .store     = LIS2DUXS12_FIFO_1X,
    .watermark = 0,
  };

  if (lis2duxs12_fifo_mode_set(&(pObj->Ctx), fifo_mode) != LIS2DUXS12_OK)
 8006316:	687b      	ldr	r3, [r7, #4]
 8006318:	f103 0020 	add.w	r0, r3, #32
 800631c:	f107 030c 	add.w	r3, r7, #12
 8006320:	e893 0006 	ldmia.w	r3, {r1, r2}
 8006324:	f001 fa7f 	bl	8007826 <lis2duxs12_fifo_mode_set>
 8006328:	4603      	mov	r3, r0
 800632a:	2b00      	cmp	r3, #0
 800632c:	d002      	beq.n	8006334 <LIS2DUXS12_Init+0x90>
  {
    return LIS2DUXS12_ERROR;
 800632e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006332:	e020      	b.n	8006376 <LIS2DUXS12_Init+0xd2>
  }

  /* Select default output data rate. */
  pObj->acc_odr = 100.0f;
 8006334:	687b      	ldr	r3, [r7, #4]
 8006336:	4a12      	ldr	r2, [pc, #72]	@ (8006380 <LIS2DUXS12_Init+0xdc>)
 8006338:	635a      	str	r2, [r3, #52]	@ 0x34
  /* Select default ultra low power (disabled). */
  pObj->power_mode = LIS2DUXS12_LOW_POWER;
 800633a:	687b      	ldr	r3, [r7, #4]
 800633c:	2201      	movs	r2, #1
 800633e:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  /* Output data rate: power down, full scale: 2g */
  lis2duxs12_md_t mode =
 8006342:	f107 0308 	add.w	r3, r7, #8
 8006346:	2100      	movs	r1, #0
 8006348:	460a      	mov	r2, r1
 800634a:	801a      	strh	r2, [r3, #0]
 800634c:	460a      	mov	r2, r1
 800634e:	709a      	strb	r2, [r3, #2]
  {
    .odr = LIS2DUXS12_OFF,
    .fs  = LIS2DUXS12_2g,
  };

  if (lis2duxs12_mode_set(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006350:	687b      	ldr	r3, [r7, #4]
 8006352:	3320      	adds	r3, #32
 8006354:	f107 0208 	add.w	r2, r7, #8
 8006358:	4611      	mov	r1, r2
 800635a:	4618      	mov	r0, r3
 800635c:	f000 ff10 	bl	8007180 <lis2duxs12_mode_set>
 8006360:	4603      	mov	r3, r0
 8006362:	2b00      	cmp	r3, #0
 8006364:	d002      	beq.n	800636c <LIS2DUXS12_Init+0xc8>
  {
    return LIS2DUXS12_ERROR;
 8006366:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800636a:	e004      	b.n	8006376 <LIS2DUXS12_Init+0xd2>
  }

  pObj->is_initialized = 1;
 800636c:	687b      	ldr	r3, [r7, #4]
 800636e:	2201      	movs	r2, #1
 8006370:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2DUXS12_OK;
 8006374:	2300      	movs	r3, #0
}
 8006376:	4618      	mov	r0, r3
 8006378:	3718      	adds	r7, #24
 800637a:	46bd      	mov	sp, r7
 800637c:	bd80      	pop	{r7, pc}
 800637e:	bf00      	nop
 8006380:	42c80000 	.word	0x42c80000

08006384 <LIS2DUXS12_DeInit>:
  * @brief  Deinitialize the LIS2DUXS12 sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_DeInit(LIS2DUXS12_Object_t *pObj)
{
 8006384:	b580      	push	{r7, lr}
 8006386:	b082      	sub	sp, #8
 8006388:	af00      	add	r7, sp, #0
 800638a:	6078      	str	r0, [r7, #4]
  /* Disable the component */
  if (LIS2DUXS12_ACC_Disable(pObj) != LIS2DUXS12_OK)
 800638c:	6878      	ldr	r0, [r7, #4]
 800638e:	f000 f8ad 	bl	80064ec <LIS2DUXS12_ACC_Disable>
 8006392:	4603      	mov	r3, r0
 8006394:	2b00      	cmp	r3, #0
 8006396:	d002      	beq.n	800639e <LIS2DUXS12_DeInit+0x1a>
  {
    return LIS2DUXS12_ERROR;
 8006398:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800639c:	e00c      	b.n	80063b8 <LIS2DUXS12_DeInit+0x34>
  }

  /* Reset output data rate. */
  pObj->acc_odr = 0.0f;
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	f04f 0200 	mov.w	r2, #0
 80063a4:	635a      	str	r2, [r3, #52]	@ 0x34
  /* Reset ultra low power to default value (disabled). */
  pObj->power_mode = LIS2DUXS12_LOW_POWER;
 80063a6:	687b      	ldr	r3, [r7, #4]
 80063a8:	2201      	movs	r2, #1
 80063aa:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  pObj->is_initialized = 0;
 80063ae:	687b      	ldr	r3, [r7, #4]
 80063b0:	2200      	movs	r2, #0
 80063b2:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2DUXS12_OK;
 80063b6:	2300      	movs	r3, #0
}
 80063b8:	4618      	mov	r0, r3
 80063ba:	3708      	adds	r7, #8
 80063bc:	46bd      	mov	sp, r7
 80063be:	bd80      	pop	{r7, pc}

080063c0 <LIS2DUXS12_ExitDeepPowerDownI2C>:
  * @brief  Exit from deep power down in I2C
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ExitDeepPowerDownI2C(LIS2DUXS12_Object_t *pObj)
{
 80063c0:	b580      	push	{r7, lr}
 80063c2:	b084      	sub	sp, #16
 80063c4:	af00      	add	r7, sp, #0
 80063c6:	6078      	str	r0, [r7, #4]
  uint8_t val;

  /* Perform dummy read in order to exit from deep power down in I2C mode*/
  (void)lis2duxs12_device_id_get(&(pObj->Ctx), &val);
 80063c8:	687b      	ldr	r3, [r7, #4]
 80063ca:	3320      	adds	r3, #32
 80063cc:	f107 020f 	add.w	r2, r7, #15
 80063d0:	4611      	mov	r1, r2
 80063d2:	4618      	mov	r0, r3
 80063d4:	f000 fe1a 	bl	800700c <lis2duxs12_device_id_get>

  /* Wait for 25 ms based on datasheet */
  pObj->Ctx.mdelay(25);
 80063d8:	687b      	ldr	r3, [r7, #4]
 80063da:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80063dc:	2019      	movs	r0, #25
 80063de:	4798      	blx	r3

  return LIS2DUXS12_OK;
 80063e0:	2300      	movs	r3, #0
}
 80063e2:	4618      	mov	r0, r3
 80063e4:	3710      	adds	r7, #16
 80063e6:	46bd      	mov	sp, r7
 80063e8:	bd80      	pop	{r7, pc}

080063ea <LIS2DUXS12_ExitDeepPowerDownSPI>:
  * @brief  Exit from deep power down in SPI
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ExitDeepPowerDownSPI(LIS2DUXS12_Object_t *pObj)
{
 80063ea:	b580      	push	{r7, lr}
 80063ec:	b082      	sub	sp, #8
 80063ee:	af00      	add	r7, sp, #0
 80063f0:	6078      	str	r0, [r7, #4]
  /* Write IF_WAKE_UP register to exit from deep power down in SPI mode*/
  (void)lis2duxs12_exit_deep_power_down(&(pObj->Ctx));
 80063f2:	687b      	ldr	r3, [r7, #4]
 80063f4:	3320      	adds	r3, #32
 80063f6:	4618      	mov	r0, r3
 80063f8:	f001 f8da 	bl	80075b0 <lis2duxs12_exit_deep_power_down>

  /* Wait for 25 ms based on datasheet */
  pObj->Ctx.mdelay(25);
 80063fc:	687b      	ldr	r3, [r7, #4]
 80063fe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006400:	2019      	movs	r0, #25
 8006402:	4798      	blx	r3

  return LIS2DUXS12_OK;
 8006404:	2300      	movs	r3, #0
}
 8006406:	4618      	mov	r0, r3
 8006408:	3708      	adds	r7, #8
 800640a:	46bd      	mov	sp, r7
 800640c:	bd80      	pop	{r7, pc}

0800640e <LIS2DUXS12_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ReadID(LIS2DUXS12_Object_t *pObj, uint8_t *Id)
{
 800640e:	b580      	push	{r7, lr}
 8006410:	b084      	sub	sp, #16
 8006412:	af00      	add	r7, sp, #0
 8006414:	6078      	str	r0, [r7, #4]
 8006416:	6039      	str	r1, [r7, #0]
  uint8_t val;

  if (lis2duxs12_device_id_get(&(pObj->Ctx), &val) != LIS2DUXS12_OK)
 8006418:	687b      	ldr	r3, [r7, #4]
 800641a:	3320      	adds	r3, #32
 800641c:	f107 020f 	add.w	r2, r7, #15
 8006420:	4611      	mov	r1, r2
 8006422:	4618      	mov	r0, r3
 8006424:	f000 fdf2 	bl	800700c <lis2duxs12_device_id_get>
 8006428:	4603      	mov	r3, r0
 800642a:	2b00      	cmp	r3, #0
 800642c:	d002      	beq.n	8006434 <LIS2DUXS12_ReadID+0x26>
  {
    return LIS2DUXS12_ERROR;
 800642e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006432:	e003      	b.n	800643c <LIS2DUXS12_ReadID+0x2e>
  }

  *Id = val;
 8006434:	7bfa      	ldrb	r2, [r7, #15]
 8006436:	683b      	ldr	r3, [r7, #0]
 8006438:	701a      	strb	r2, [r3, #0]

  return LIS2DUXS12_OK;
 800643a:	2300      	movs	r3, #0
}
 800643c:	4618      	mov	r0, r3
 800643e:	3710      	adds	r7, #16
 8006440:	46bd      	mov	sp, r7
 8006442:	bd80      	pop	{r7, pc}

08006444 <LIS2DUXS12_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LIS2DUXS12 sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_GetCapabilities(LIS2DUXS12_Object_t *pObj, LIS2DUXS12_Capabilities_t *Capabilities)
{
 8006444:	b480      	push	{r7}
 8006446:	b083      	sub	sp, #12
 8006448:	af00      	add	r7, sp, #0
 800644a:	6078      	str	r0, [r7, #4]
 800644c:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc        = 1;
 800644e:	683b      	ldr	r3, [r7, #0]
 8006450:	2201      	movs	r2, #1
 8006452:	701a      	strb	r2, [r3, #0]
  Capabilities->Gyro       = 0;
 8006454:	683b      	ldr	r3, [r7, #0]
 8006456:	2200      	movs	r2, #0
 8006458:	705a      	strb	r2, [r3, #1]
  Capabilities->Magneto    = 0;
 800645a:	683b      	ldr	r3, [r7, #0]
 800645c:	2200      	movs	r2, #0
 800645e:	709a      	strb	r2, [r3, #2]
  Capabilities->LowPower   = 1;
 8006460:	683b      	ldr	r3, [r7, #0]
 8006462:	2201      	movs	r2, #1
 8006464:	70da      	strb	r2, [r3, #3]
  Capabilities->GyroMaxFS  = 0;
 8006466:	683b      	ldr	r3, [r7, #0]
 8006468:	2200      	movs	r2, #0
 800646a:	605a      	str	r2, [r3, #4]
  Capabilities->AccMaxFS   = 16;
 800646c:	683b      	ldr	r3, [r7, #0]
 800646e:	2210      	movs	r2, #16
 8006470:	609a      	str	r2, [r3, #8]
  Capabilities->MagMaxFS   = 0;
 8006472:	683b      	ldr	r3, [r7, #0]
 8006474:	2200      	movs	r2, #0
 8006476:	60da      	str	r2, [r3, #12]
  Capabilities->GyroMaxOdr = 0.0f;
 8006478:	683b      	ldr	r3, [r7, #0]
 800647a:	f04f 0200 	mov.w	r2, #0
 800647e:	611a      	str	r2, [r3, #16]
  Capabilities->AccMaxOdr  = 800.0f;
 8006480:	683b      	ldr	r3, [r7, #0]
 8006482:	4a06      	ldr	r2, [pc, #24]	@ (800649c <LIS2DUXS12_GetCapabilities+0x58>)
 8006484:	615a      	str	r2, [r3, #20]
  Capabilities->MagMaxOdr  = 0.0f;
 8006486:	683b      	ldr	r3, [r7, #0]
 8006488:	f04f 0200 	mov.w	r2, #0
 800648c:	619a      	str	r2, [r3, #24]
  return LIS2DUXS12_OK;
 800648e:	2300      	movs	r3, #0
}
 8006490:	4618      	mov	r0, r3
 8006492:	370c      	adds	r7, #12
 8006494:	46bd      	mov	sp, r7
 8006496:	f85d 7b04 	ldr.w	r7, [sp], #4
 800649a:	4770      	bx	lr
 800649c:	44480000 	.word	0x44480000

080064a0 <LIS2DUXS12_ACC_Enable>:
  * @brief  Enable the LIS2DUXS12 accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_Enable(LIS2DUXS12_Object_t *pObj)
{
 80064a0:	b580      	push	{r7, lr}
 80064a2:	b082      	sub	sp, #8
 80064a4:	af00      	add	r7, sp, #0
 80064a6:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->acc_is_enabled == 1U)
 80064a8:	687b      	ldr	r3, [r7, #4]
 80064aa:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 80064ae:	2b01      	cmp	r3, #1
 80064b0:	d101      	bne.n	80064b6 <LIS2DUXS12_ACC_Enable+0x16>
  {
    return LIS2DUXS12_OK;
 80064b2:	2300      	movs	r3, #0
 80064b4:	e016      	b.n	80064e4 <LIS2DUXS12_ACC_Enable+0x44>
  }

  /* Output data rate selection. */
  if (LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled(pObj, pObj->acc_odr, pObj->power_mode) != LIS2DUXS12_OK)
 80064b6:	687b      	ldr	r3, [r7, #4]
 80064b8:	edd3 7a0d 	vldr	s15, [r3, #52]	@ 0x34
 80064bc:	687b      	ldr	r3, [r7, #4]
 80064be:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 80064c2:	4619      	mov	r1, r3
 80064c4:	eeb0 0a67 	vmov.f32	s0, s15
 80064c8:	6878      	ldr	r0, [r7, #4]
 80064ca:	f000 fab9 	bl	8006a40 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled>
 80064ce:	4603      	mov	r3, r0
 80064d0:	2b00      	cmp	r3, #0
 80064d2:	d002      	beq.n	80064da <LIS2DUXS12_ACC_Enable+0x3a>
  {
    return LIS2DUXS12_ERROR;
 80064d4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80064d8:	e004      	b.n	80064e4 <LIS2DUXS12_ACC_Enable+0x44>
  }

  pObj->acc_is_enabled = 1;
 80064da:	687b      	ldr	r3, [r7, #4]
 80064dc:	2201      	movs	r2, #1
 80064de:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2DUXS12_OK;
 80064e2:	2300      	movs	r3, #0
}
 80064e4:	4618      	mov	r0, r3
 80064e6:	3708      	adds	r7, #8
 80064e8:	46bd      	mov	sp, r7
 80064ea:	bd80      	pop	{r7, pc}

080064ec <LIS2DUXS12_ACC_Disable>:
  * @brief  Disable the LIS2DUXS12 accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_Disable(LIS2DUXS12_Object_t *pObj)
{
 80064ec:	b580      	push	{r7, lr}
 80064ee:	b084      	sub	sp, #16
 80064f0:	af00      	add	r7, sp, #0
 80064f2:	6078      	str	r0, [r7, #4]
  float_t Odr;
  /* Check if the component is already disabled */
  if (pObj->acc_is_enabled == 0U)
 80064f4:	687b      	ldr	r3, [r7, #4]
 80064f6:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 80064fa:	2b00      	cmp	r3, #0
 80064fc:	d101      	bne.n	8006502 <LIS2DUXS12_ACC_Disable+0x16>
  {
    return LIS2DUXS12_OK;
 80064fe:	2300      	movs	r3, #0
 8006500:	e046      	b.n	8006590 <LIS2DUXS12_ACC_Disable+0xa4>
  }

  if (LIS2DUXS12_ACC_GetOutputDataRate(pObj, &Odr) != LIS2DUXS12_OK)
 8006502:	f107 030c 	add.w	r3, r7, #12
 8006506:	4619      	mov	r1, r3
 8006508:	6878      	ldr	r0, [r7, #4]
 800650a:	f000 f893 	bl	8006634 <LIS2DUXS12_ACC_GetOutputDataRate>
 800650e:	4603      	mov	r3, r0
 8006510:	2b00      	cmp	r3, #0
 8006512:	d002      	beq.n	800651a <LIS2DUXS12_ACC_Disable+0x2e>
  {
    return LIS2DUXS12_ERROR;
 8006514:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006518:	e03a      	b.n	8006590 <LIS2DUXS12_ACC_Disable+0xa4>
  }

  if (Odr == 800.0f)
 800651a:	edd7 7a03 	vldr	s15, [r7, #12]
 800651e:	ed9f 7a1e 	vldr	s14, [pc, #120]	@ 8006598 <LIS2DUXS12_ACC_Disable+0xac>
 8006522:	eef4 7a47 	vcmp.f32	s15, s14
 8006526:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800652a:	d10e      	bne.n	800654a <LIS2DUXS12_ACC_Disable+0x5e>
  {
    if (LIS2DUXS12_ACC_SetOutputDataRate(pObj, 400.0f) != LIS2DUXS12_OK)
 800652c:	ed9f 0a1b 	vldr	s0, [pc, #108]	@ 800659c <LIS2DUXS12_ACC_Disable+0xb0>
 8006530:	6878      	ldr	r0, [r7, #4]
 8006532:	f000 f94b 	bl	80067cc <LIS2DUXS12_ACC_SetOutputDataRate>
 8006536:	4603      	mov	r3, r0
 8006538:	2b00      	cmp	r3, #0
 800653a:	d002      	beq.n	8006542 <LIS2DUXS12_ACC_Disable+0x56>
    {
      return LIS2DUXS12_ERROR;
 800653c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006540:	e026      	b.n	8006590 <LIS2DUXS12_ACC_Disable+0xa4>
    }

    /* Wait for 3 ms based on datasheet */
    pObj->Ctx.mdelay(3);
 8006542:	687b      	ldr	r3, [r7, #4]
 8006544:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006546:	2003      	movs	r0, #3
 8006548:	4798      	blx	r3
  }

  /* Output data rate selection - power down. */
  lis2duxs12_md_t mode;

  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 800654a:	687b      	ldr	r3, [r7, #4]
 800654c:	3320      	adds	r3, #32
 800654e:	f107 0208 	add.w	r2, r7, #8
 8006552:	4611      	mov	r1, r2
 8006554:	4618      	mov	r0, r3
 8006556:	f000 ff33 	bl	80073c0 <lis2duxs12_mode_get>
 800655a:	4603      	mov	r3, r0
 800655c:	2b00      	cmp	r3, #0
 800655e:	d002      	beq.n	8006566 <LIS2DUXS12_ACC_Disable+0x7a>
  {
    return LIS2DUXS12_ERROR;
 8006560:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006564:	e014      	b.n	8006590 <LIS2DUXS12_ACC_Disable+0xa4>
  }

  mode.odr = LIS2DUXS12_OFF;
 8006566:	2300      	movs	r3, #0
 8006568:	723b      	strb	r3, [r7, #8]

  if (lis2duxs12_mode_set(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 800656a:	687b      	ldr	r3, [r7, #4]
 800656c:	3320      	adds	r3, #32
 800656e:	f107 0208 	add.w	r2, r7, #8
 8006572:	4611      	mov	r1, r2
 8006574:	4618      	mov	r0, r3
 8006576:	f000 fe03 	bl	8007180 <lis2duxs12_mode_set>
 800657a:	4603      	mov	r3, r0
 800657c:	2b00      	cmp	r3, #0
 800657e:	d002      	beq.n	8006586 <LIS2DUXS12_ACC_Disable+0x9a>
  {
    return LIS2DUXS12_ERROR;
 8006580:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006584:	e004      	b.n	8006590 <LIS2DUXS12_ACC_Disable+0xa4>
  }

  pObj->acc_is_enabled = 0;
 8006586:	687b      	ldr	r3, [r7, #4]
 8006588:	2200      	movs	r2, #0
 800658a:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2DUXS12_OK;
 800658e:	2300      	movs	r3, #0
}
 8006590:	4618      	mov	r0, r3
 8006592:	3710      	adds	r7, #16
 8006594:	46bd      	mov	sp, r7
 8006596:	bd80      	pop	{r7, pc}
 8006598:	44480000 	.word	0x44480000
 800659c:	43c80000 	.word	0x43c80000

080065a0 <LIS2DUXS12_ACC_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_GetSensitivity(LIS2DUXS12_Object_t *pObj, float_t *Sensitivity)
{
 80065a0:	b580      	push	{r7, lr}
 80065a2:	b084      	sub	sp, #16
 80065a4:	af00      	add	r7, sp, #0
 80065a6:	6078      	str	r0, [r7, #4]
 80065a8:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2DUXS12_OK;
 80065aa:	2300      	movs	r3, #0
 80065ac:	60fb      	str	r3, [r7, #12]
  lis2duxs12_md_t mode;

  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 80065ae:	687b      	ldr	r3, [r7, #4]
 80065b0:	3320      	adds	r3, #32
 80065b2:	f107 0208 	add.w	r2, r7, #8
 80065b6:	4611      	mov	r1, r2
 80065b8:	4618      	mov	r0, r3
 80065ba:	f000 ff01 	bl	80073c0 <lis2duxs12_mode_get>
 80065be:	4603      	mov	r3, r0
 80065c0:	2b00      	cmp	r3, #0
 80065c2:	d002      	beq.n	80065ca <LIS2DUXS12_ACC_GetSensitivity+0x2a>
  {
    return LIS2DUXS12_ERROR;
 80065c4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80065c8:	e026      	b.n	8006618 <LIS2DUXS12_ACC_GetSensitivity+0x78>
  }

  switch (mode.fs)
 80065ca:	7a7b      	ldrb	r3, [r7, #9]
 80065cc:	2b03      	cmp	r3, #3
 80065ce:	d81b      	bhi.n	8006608 <LIS2DUXS12_ACC_GetSensitivity+0x68>
 80065d0:	a201      	add	r2, pc, #4	@ (adr r2, 80065d8 <LIS2DUXS12_ACC_GetSensitivity+0x38>)
 80065d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80065d6:	bf00      	nop
 80065d8:	080065e9 	.word	0x080065e9
 80065dc:	080065f1 	.word	0x080065f1
 80065e0:	080065f9 	.word	0x080065f9
 80065e4:	08006601 	.word	0x08006601
  {
    case LIS2DUXS12_2g:
      *Sensitivity = LIS2DUXS12_ACC_SENSITIVITY_FOR_FS_2G;
 80065e8:	683b      	ldr	r3, [r7, #0]
 80065ea:	4a0d      	ldr	r2, [pc, #52]	@ (8006620 <LIS2DUXS12_ACC_GetSensitivity+0x80>)
 80065ec:	601a      	str	r2, [r3, #0]
      break;
 80065ee:	e012      	b.n	8006616 <LIS2DUXS12_ACC_GetSensitivity+0x76>

    case LIS2DUXS12_4g:
      *Sensitivity = LIS2DUXS12_ACC_SENSITIVITY_FOR_FS_4G;
 80065f0:	683b      	ldr	r3, [r7, #0]
 80065f2:	4a0c      	ldr	r2, [pc, #48]	@ (8006624 <LIS2DUXS12_ACC_GetSensitivity+0x84>)
 80065f4:	601a      	str	r2, [r3, #0]
      break;
 80065f6:	e00e      	b.n	8006616 <LIS2DUXS12_ACC_GetSensitivity+0x76>

    case LIS2DUXS12_8g:
      *Sensitivity = LIS2DUXS12_ACC_SENSITIVITY_FOR_FS_8G;
 80065f8:	683b      	ldr	r3, [r7, #0]
 80065fa:	4a0b      	ldr	r2, [pc, #44]	@ (8006628 <LIS2DUXS12_ACC_GetSensitivity+0x88>)
 80065fc:	601a      	str	r2, [r3, #0]
      break;
 80065fe:	e00a      	b.n	8006616 <LIS2DUXS12_ACC_GetSensitivity+0x76>

    case LIS2DUXS12_16g:
      *Sensitivity = LIS2DUXS12_ACC_SENSITIVITY_FOR_FS_16G;
 8006600:	683b      	ldr	r3, [r7, #0]
 8006602:	4a0a      	ldr	r2, [pc, #40]	@ (800662c <LIS2DUXS12_ACC_GetSensitivity+0x8c>)
 8006604:	601a      	str	r2, [r3, #0]
      break;
 8006606:	e006      	b.n	8006616 <LIS2DUXS12_ACC_GetSensitivity+0x76>

    default:
      *Sensitivity = -1.0f;
 8006608:	683b      	ldr	r3, [r7, #0]
 800660a:	4a09      	ldr	r2, [pc, #36]	@ (8006630 <LIS2DUXS12_ACC_GetSensitivity+0x90>)
 800660c:	601a      	str	r2, [r3, #0]
      ret = LIS2DUXS12_ERROR;
 800660e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006612:	60fb      	str	r3, [r7, #12]
      break;
 8006614:	bf00      	nop
  }

  return ret;
 8006616:	68fb      	ldr	r3, [r7, #12]
}
 8006618:	4618      	mov	r0, r3
 800661a:	3710      	adds	r7, #16
 800661c:	46bd      	mov	sp, r7
 800661e:	bd80      	pop	{r7, pc}
 8006620:	3d79db23 	.word	0x3d79db23
 8006624:	3df9db23 	.word	0x3df9db23
 8006628:	3e79db23 	.word	0x3e79db23
 800662c:	3ef9db23 	.word	0x3ef9db23
 8006630:	bf800000 	.word	0xbf800000

08006634 <LIS2DUXS12_ACC_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_GetOutputDataRate(LIS2DUXS12_Object_t *pObj, float_t *Odr)
{
 8006634:	b580      	push	{r7, lr}
 8006636:	b084      	sub	sp, #16
 8006638:	af00      	add	r7, sp, #0
 800663a:	6078      	str	r0, [r7, #4]
 800663c:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2DUXS12_OK;
 800663e:	2300      	movs	r3, #0
 8006640:	60fb      	str	r3, [r7, #12]
  lis2duxs12_md_t mode;

  /* Read actual output data rate from sensor. */
  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006642:	687b      	ldr	r3, [r7, #4]
 8006644:	3320      	adds	r3, #32
 8006646:	f107 0208 	add.w	r2, r7, #8
 800664a:	4611      	mov	r1, r2
 800664c:	4618      	mov	r0, r3
 800664e:	f000 feb7 	bl	80073c0 <lis2duxs12_mode_get>
 8006652:	4603      	mov	r3, r0
 8006654:	2b00      	cmp	r3, #0
 8006656:	d002      	beq.n	800665e <LIS2DUXS12_ACC_GetOutputDataRate+0x2a>
  {
    return LIS2DUXS12_ERROR;
 8006658:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800665c:	e09b      	b.n	8006796 <LIS2DUXS12_ACC_GetOutputDataRate+0x162>
  }

  switch (mode.odr)
 800665e:	7a3b      	ldrb	r3, [r7, #8]
 8006660:	2b2f      	cmp	r3, #47	@ 0x2f
 8006662:	f200 8090 	bhi.w	8006786 <LIS2DUXS12_ACC_GetOutputDataRate+0x152>
 8006666:	a201      	add	r2, pc, #4	@ (adr r2, 800666c <LIS2DUXS12_ACC_GetOutputDataRate+0x38>)
 8006668:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800666c:	0800672d 	.word	0x0800672d
 8006670:	08006737 	.word	0x08006737
 8006674:	0800673f 	.word	0x0800673f
 8006678:	08006757 	.word	0x08006757
 800667c:	08006747 	.word	0x08006747
 8006680:	0800674f 	.word	0x0800674f
 8006684:	08006757 	.word	0x08006757
 8006688:	0800675f 	.word	0x0800675f
 800668c:	08006767 	.word	0x08006767
 8006690:	0800676f 	.word	0x0800676f
 8006694:	08006777 	.word	0x08006777
 8006698:	0800677f 	.word	0x0800677f
 800669c:	08006787 	.word	0x08006787
 80066a0:	08006787 	.word	0x08006787
 80066a4:	08006787 	.word	0x08006787
 80066a8:	08006787 	.word	0x08006787
 80066ac:	08006787 	.word	0x08006787
 80066b0:	08006787 	.word	0x08006787
 80066b4:	08006787 	.word	0x08006787
 80066b8:	08006787 	.word	0x08006787
 80066bc:	08006747 	.word	0x08006747
 80066c0:	0800674f 	.word	0x0800674f
 80066c4:	08006757 	.word	0x08006757
 80066c8:	0800675f 	.word	0x0800675f
 80066cc:	08006767 	.word	0x08006767
 80066d0:	0800676f 	.word	0x0800676f
 80066d4:	08006777 	.word	0x08006777
 80066d8:	0800677f 	.word	0x0800677f
 80066dc:	08006787 	.word	0x08006787
 80066e0:	08006787 	.word	0x08006787
 80066e4:	08006787 	.word	0x08006787
 80066e8:	08006787 	.word	0x08006787
 80066ec:	08006787 	.word	0x08006787
 80066f0:	08006787 	.word	0x08006787
 80066f4:	08006787 	.word	0x08006787
 80066f8:	08006787 	.word	0x08006787
 80066fc:	08006787 	.word	0x08006787
 8006700:	08006787 	.word	0x08006787
 8006704:	08006787 	.word	0x08006787
 8006708:	08006787 	.word	0x08006787
 800670c:	08006787 	.word	0x08006787
 8006710:	08006787 	.word	0x08006787
 8006714:	08006787 	.word	0x08006787
 8006718:	08006787 	.word	0x08006787
 800671c:	08006787 	.word	0x08006787
 8006720:	08006787 	.word	0x08006787
 8006724:	0800672d 	.word	0x0800672d
 8006728:	0800672d 	.word	0x0800672d
  {
    case LIS2DUXS12_OFF:
    case LIS2DUXS12_TRIG_PIN:
    case LIS2DUXS12_TRIG_SW:
      *Odr = 0.0f;
 800672c:	683b      	ldr	r3, [r7, #0]
 800672e:	f04f 0200 	mov.w	r2, #0
 8006732:	601a      	str	r2, [r3, #0]
      break;
 8006734:	e02e      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_1Hz6_ULP:
      *Odr = 1.6f;
 8006736:	683b      	ldr	r3, [r7, #0]
 8006738:	4a19      	ldr	r2, [pc, #100]	@ (80067a0 <LIS2DUXS12_ACC_GetOutputDataRate+0x16c>)
 800673a:	601a      	str	r2, [r3, #0]
      break;
 800673c:	e02a      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_3Hz_ULP:
      *Odr = 3.0f;
 800673e:	683b      	ldr	r3, [r7, #0]
 8006740:	4a18      	ldr	r2, [pc, #96]	@ (80067a4 <LIS2DUXS12_ACC_GetOutputDataRate+0x170>)
 8006742:	601a      	str	r2, [r3, #0]
      break;
 8006744:	e026      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_6Hz_LP:
    case LIS2DUXS12_6Hz_HP:
      *Odr = 6.0f;
 8006746:	683b      	ldr	r3, [r7, #0]
 8006748:	4a17      	ldr	r2, [pc, #92]	@ (80067a8 <LIS2DUXS12_ACC_GetOutputDataRate+0x174>)
 800674a:	601a      	str	r2, [r3, #0]
      break;
 800674c:	e022      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_12Hz5_LP:
    case LIS2DUXS12_12Hz5_HP:
      *Odr = 12.5f;
 800674e:	683b      	ldr	r3, [r7, #0]
 8006750:	4a16      	ldr	r2, [pc, #88]	@ (80067ac <LIS2DUXS12_ACC_GetOutputDataRate+0x178>)
 8006752:	601a      	str	r2, [r3, #0]
      break;
 8006754:	e01e      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_25Hz_ULP:
    case LIS2DUXS12_25Hz_LP:
    case LIS2DUXS12_25Hz_HP:
      *Odr = 25.0f;
 8006756:	683b      	ldr	r3, [r7, #0]
 8006758:	4a15      	ldr	r2, [pc, #84]	@ (80067b0 <LIS2DUXS12_ACC_GetOutputDataRate+0x17c>)
 800675a:	601a      	str	r2, [r3, #0]
      break;
 800675c:	e01a      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_50Hz_LP:
    case LIS2DUXS12_50Hz_HP:
      *Odr = 50.0f;
 800675e:	683b      	ldr	r3, [r7, #0]
 8006760:	4a14      	ldr	r2, [pc, #80]	@ (80067b4 <LIS2DUXS12_ACC_GetOutputDataRate+0x180>)
 8006762:	601a      	str	r2, [r3, #0]
      break;
 8006764:	e016      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_100Hz_LP:
    case LIS2DUXS12_100Hz_HP:
      *Odr = 100.0f;
 8006766:	683b      	ldr	r3, [r7, #0]
 8006768:	4a13      	ldr	r2, [pc, #76]	@ (80067b8 <LIS2DUXS12_ACC_GetOutputDataRate+0x184>)
 800676a:	601a      	str	r2, [r3, #0]
      break;
 800676c:	e012      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_200Hz_LP:
    case LIS2DUXS12_200Hz_HP:
      *Odr = 200.0f;
 800676e:	683b      	ldr	r3, [r7, #0]
 8006770:	4a12      	ldr	r2, [pc, #72]	@ (80067bc <LIS2DUXS12_ACC_GetOutputDataRate+0x188>)
 8006772:	601a      	str	r2, [r3, #0]
      break;
 8006774:	e00e      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_400Hz_LP:
    case LIS2DUXS12_400Hz_HP:
      *Odr = 400.0f;
 8006776:	683b      	ldr	r3, [r7, #0]
 8006778:	4a11      	ldr	r2, [pc, #68]	@ (80067c0 <LIS2DUXS12_ACC_GetOutputDataRate+0x18c>)
 800677a:	601a      	str	r2, [r3, #0]
      break;
 800677c:	e00a      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    case LIS2DUXS12_800Hz_LP:
    case LIS2DUXS12_800Hz_HP:
      *Odr = 800.0f;
 800677e:	683b      	ldr	r3, [r7, #0]
 8006780:	4a10      	ldr	r2, [pc, #64]	@ (80067c4 <LIS2DUXS12_ACC_GetOutputDataRate+0x190>)
 8006782:	601a      	str	r2, [r3, #0]
      break;
 8006784:	e006      	b.n	8006794 <LIS2DUXS12_ACC_GetOutputDataRate+0x160>

    default:
      *Odr = -1.0f;
 8006786:	683b      	ldr	r3, [r7, #0]
 8006788:	4a0f      	ldr	r2, [pc, #60]	@ (80067c8 <LIS2DUXS12_ACC_GetOutputDataRate+0x194>)
 800678a:	601a      	str	r2, [r3, #0]
      ret = LIS2DUXS12_ERROR;
 800678c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006790:	60fb      	str	r3, [r7, #12]
      break;
 8006792:	bf00      	nop
  }

  return ret;
 8006794:	68fb      	ldr	r3, [r7, #12]
}
 8006796:	4618      	mov	r0, r3
 8006798:	3710      	adds	r7, #16
 800679a:	46bd      	mov	sp, r7
 800679c:	bd80      	pop	{r7, pc}
 800679e:	bf00      	nop
 80067a0:	3fcccccd 	.word	0x3fcccccd
 80067a4:	40400000 	.word	0x40400000
 80067a8:	40c00000 	.word	0x40c00000
 80067ac:	41480000 	.word	0x41480000
 80067b0:	41c80000 	.word	0x41c80000
 80067b4:	42480000 	.word	0x42480000
 80067b8:	42c80000 	.word	0x42c80000
 80067bc:	43480000 	.word	0x43480000
 80067c0:	43c80000 	.word	0x43c80000
 80067c4:	44480000 	.word	0x44480000
 80067c8:	bf800000 	.word	0xbf800000

080067cc <LIS2DUXS12_ACC_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_SetOutputDataRate(LIS2DUXS12_Object_t *pObj, float_t Odr)
{
 80067cc:	b580      	push	{r7, lr}
 80067ce:	b082      	sub	sp, #8
 80067d0:	af00      	add	r7, sp, #0
 80067d2:	6078      	str	r0, [r7, #4]
 80067d4:	ed87 0a00 	vstr	s0, [r7]
  /* By default we use Ultra Low Power disabled */
  return LIS2DUXS12_ACC_SetOutputDataRate_With_Mode(pObj, Odr, LIS2DUXS12_LOW_POWER);
 80067d8:	2101      	movs	r1, #1
 80067da:	ed97 0a00 	vldr	s0, [r7]
 80067de:	6878      	ldr	r0, [r7, #4]
 80067e0:	f000 f805 	bl	80067ee <LIS2DUXS12_ACC_SetOutputDataRate_With_Mode>
 80067e4:	4603      	mov	r3, r0
}
 80067e6:	4618      	mov	r0, r3
 80067e8:	3708      	adds	r7, #8
 80067ea:	46bd      	mov	sp, r7
 80067ec:	bd80      	pop	{r7, pc}

080067ee <LIS2DUXS12_ACC_SetOutputDataRate_With_Mode>:
  * @param  Odr the output data rate value to be set
  * @param  Power the ultra low power option
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_SetOutputDataRate_With_Mode(LIS2DUXS12_Object_t *pObj, float_t Odr, LIS2DUXS12_Power_Mode_t Power)
{
 80067ee:	b580      	push	{r7, lr}
 80067f0:	b084      	sub	sp, #16
 80067f2:	af00      	add	r7, sp, #0
 80067f4:	60f8      	str	r0, [r7, #12]
 80067f6:	ed87 0a02 	vstr	s0, [r7, #8]
 80067fa:	460b      	mov	r3, r1
 80067fc:	71fb      	strb	r3, [r7, #7]
  /* Check if the component is enabled */
  if (pObj->acc_is_enabled == 1U)
 80067fe:	68fb      	ldr	r3, [r7, #12]
 8006800:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8006804:	2b01      	cmp	r3, #1
 8006806:	d108      	bne.n	800681a <LIS2DUXS12_ACC_SetOutputDataRate_With_Mode+0x2c>
  {
    return LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled(pObj, Odr, Power);
 8006808:	79fb      	ldrb	r3, [r7, #7]
 800680a:	4619      	mov	r1, r3
 800680c:	ed97 0a02 	vldr	s0, [r7, #8]
 8006810:	68f8      	ldr	r0, [r7, #12]
 8006812:	f000 f915 	bl	8006a40 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled>
 8006816:	4603      	mov	r3, r0
 8006818:	e007      	b.n	800682a <LIS2DUXS12_ACC_SetOutputDataRate_With_Mode+0x3c>
  }
  else
  {
    return LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled(pObj, Odr, Power);
 800681a:	79fb      	ldrb	r3, [r7, #7]
 800681c:	4619      	mov	r1, r3
 800681e:	ed97 0a02 	vldr	s0, [r7, #8]
 8006822:	68f8      	ldr	r0, [r7, #12]
 8006824:	f000 fa8a 	bl	8006d3c <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled>
 8006828:	4603      	mov	r3, r0
  }
}
 800682a:	4618      	mov	r0, r3
 800682c:	3710      	adds	r7, #16
 800682e:	46bd      	mov	sp, r7
 8006830:	bd80      	pop	{r7, pc}
	...

08006834 <LIS2DUXS12_ACC_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_GetFullScale(LIS2DUXS12_Object_t *pObj, int32_t *FullScale)
{
 8006834:	b580      	push	{r7, lr}
 8006836:	b084      	sub	sp, #16
 8006838:	af00      	add	r7, sp, #0
 800683a:	6078      	str	r0, [r7, #4]
 800683c:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2DUXS12_OK;
 800683e:	2300      	movs	r3, #0
 8006840:	60fb      	str	r3, [r7, #12]
  lis2duxs12_md_t mode;

  /* Read actual full scale selection from sensor. */
  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006842:	687b      	ldr	r3, [r7, #4]
 8006844:	3320      	adds	r3, #32
 8006846:	f107 0208 	add.w	r2, r7, #8
 800684a:	4611      	mov	r1, r2
 800684c:	4618      	mov	r0, r3
 800684e:	f000 fdb7 	bl	80073c0 <lis2duxs12_mode_get>
 8006852:	4603      	mov	r3, r0
 8006854:	2b00      	cmp	r3, #0
 8006856:	d002      	beq.n	800685e <LIS2DUXS12_ACC_GetFullScale+0x2a>
  {
    return LIS2DUXS12_ERROR;
 8006858:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800685c:	e027      	b.n	80068ae <LIS2DUXS12_ACC_GetFullScale+0x7a>
  }

  switch (mode.fs)
 800685e:	7a7b      	ldrb	r3, [r7, #9]
 8006860:	2b03      	cmp	r3, #3
 8006862:	d81b      	bhi.n	800689c <LIS2DUXS12_ACC_GetFullScale+0x68>
 8006864:	a201      	add	r2, pc, #4	@ (adr r2, 800686c <LIS2DUXS12_ACC_GetFullScale+0x38>)
 8006866:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800686a:	bf00      	nop
 800686c:	0800687d 	.word	0x0800687d
 8006870:	08006885 	.word	0x08006885
 8006874:	0800688d 	.word	0x0800688d
 8006878:	08006895 	.word	0x08006895
  {
    case LIS2DUXS12_2g:
      *FullScale =  2;
 800687c:	683b      	ldr	r3, [r7, #0]
 800687e:	2202      	movs	r2, #2
 8006880:	601a      	str	r2, [r3, #0]
      break;
 8006882:	e013      	b.n	80068ac <LIS2DUXS12_ACC_GetFullScale+0x78>

    case LIS2DUXS12_4g:
      *FullScale =  4;
 8006884:	683b      	ldr	r3, [r7, #0]
 8006886:	2204      	movs	r2, #4
 8006888:	601a      	str	r2, [r3, #0]
      break;
 800688a:	e00f      	b.n	80068ac <LIS2DUXS12_ACC_GetFullScale+0x78>

    case LIS2DUXS12_8g:
      *FullScale =  8;
 800688c:	683b      	ldr	r3, [r7, #0]
 800688e:	2208      	movs	r2, #8
 8006890:	601a      	str	r2, [r3, #0]
      break;
 8006892:	e00b      	b.n	80068ac <LIS2DUXS12_ACC_GetFullScale+0x78>

    case LIS2DUXS12_16g:
      *FullScale = 16;
 8006894:	683b      	ldr	r3, [r7, #0]
 8006896:	2210      	movs	r2, #16
 8006898:	601a      	str	r2, [r3, #0]
      break;
 800689a:	e007      	b.n	80068ac <LIS2DUXS12_ACC_GetFullScale+0x78>

    default:
      *FullScale = -1;
 800689c:	683b      	ldr	r3, [r7, #0]
 800689e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80068a2:	601a      	str	r2, [r3, #0]
      ret = LIS2DUXS12_ERROR;
 80068a4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80068a8:	60fb      	str	r3, [r7, #12]
      break;
 80068aa:	bf00      	nop
  }

  return ret;
 80068ac:	68fb      	ldr	r3, [r7, #12]
}
 80068ae:	4618      	mov	r0, r3
 80068b0:	3710      	adds	r7, #16
 80068b2:	46bd      	mov	sp, r7
 80068b4:	bd80      	pop	{r7, pc}
 80068b6:	bf00      	nop

080068b8 <LIS2DUXS12_ACC_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_SetFullScale(LIS2DUXS12_Object_t *pObj, int32_t FullScale)
{
 80068b8:	b580      	push	{r7, lr}
 80068ba:	b084      	sub	sp, #16
 80068bc:	af00      	add	r7, sp, #0
 80068be:	6078      	str	r0, [r7, #4]
 80068c0:	6039      	str	r1, [r7, #0]
  lis2duxs12_md_t mode;

  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 80068c2:	687b      	ldr	r3, [r7, #4]
 80068c4:	3320      	adds	r3, #32
 80068c6:	f107 020c 	add.w	r2, r7, #12
 80068ca:	4611      	mov	r1, r2
 80068cc:	4618      	mov	r0, r3
 80068ce:	f000 fd77 	bl	80073c0 <lis2duxs12_mode_get>
 80068d2:	4603      	mov	r3, r0
 80068d4:	2b00      	cmp	r3, #0
 80068d6:	d002      	beq.n	80068de <LIS2DUXS12_ACC_SetFullScale+0x26>
  {
    return LIS2DUXS12_ERROR;
 80068d8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80068dc:	e01f      	b.n	800691e <LIS2DUXS12_ACC_SetFullScale+0x66>
  }

  /* Seems like MISRA C-2012 rule 14.3a violation but only from single file statical analysis point of view because
     the parameter passed to the function is not known at the moment of analysis */
  mode.fs = (FullScale <= 2) ? LIS2DUXS12_2g
            : (FullScale <= 4) ? LIS2DUXS12_4g
 80068de:	683b      	ldr	r3, [r7, #0]
 80068e0:	2b02      	cmp	r3, #2
 80068e2:	dd0b      	ble.n	80068fc <LIS2DUXS12_ACC_SetFullScale+0x44>
 80068e4:	683b      	ldr	r3, [r7, #0]
 80068e6:	2b04      	cmp	r3, #4
 80068e8:	dd06      	ble.n	80068f8 <LIS2DUXS12_ACC_SetFullScale+0x40>
 80068ea:	683b      	ldr	r3, [r7, #0]
 80068ec:	2b08      	cmp	r3, #8
 80068ee:	dc01      	bgt.n	80068f4 <LIS2DUXS12_ACC_SetFullScale+0x3c>
 80068f0:	2302      	movs	r3, #2
 80068f2:	e004      	b.n	80068fe <LIS2DUXS12_ACC_SetFullScale+0x46>
 80068f4:	2303      	movs	r3, #3
 80068f6:	e002      	b.n	80068fe <LIS2DUXS12_ACC_SetFullScale+0x46>
 80068f8:	2301      	movs	r3, #1
 80068fa:	e000      	b.n	80068fe <LIS2DUXS12_ACC_SetFullScale+0x46>
 80068fc:	2300      	movs	r3, #0
  mode.fs = (FullScale <= 2) ? LIS2DUXS12_2g
 80068fe:	737b      	strb	r3, [r7, #13]
            : (FullScale <= 8) ? LIS2DUXS12_8g
            :                    LIS2DUXS12_16g;

  if (lis2duxs12_mode_set(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006900:	687b      	ldr	r3, [r7, #4]
 8006902:	3320      	adds	r3, #32
 8006904:	f107 020c 	add.w	r2, r7, #12
 8006908:	4611      	mov	r1, r2
 800690a:	4618      	mov	r0, r3
 800690c:	f000 fc38 	bl	8007180 <lis2duxs12_mode_set>
 8006910:	4603      	mov	r3, r0
 8006912:	2b00      	cmp	r3, #0
 8006914:	d002      	beq.n	800691c <LIS2DUXS12_ACC_SetFullScale+0x64>
  {
    return LIS2DUXS12_ERROR;
 8006916:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800691a:	e000      	b.n	800691e <LIS2DUXS12_ACC_SetFullScale+0x66>
  }

  return LIS2DUXS12_OK;
 800691c:	2300      	movs	r3, #0
}
 800691e:	4618      	mov	r0, r3
 8006920:	3710      	adds	r7, #16
 8006922:	46bd      	mov	sp, r7
 8006924:	bd80      	pop	{r7, pc}

08006926 <LIS2DUXS12_ACC_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_GetAxesRaw(LIS2DUXS12_Object_t *pObj, LIS2DUXS12_AxesRaw_t *Value)
{
 8006926:	b580      	push	{r7, lr}
 8006928:	b088      	sub	sp, #32
 800692a:	af00      	add	r7, sp, #0
 800692c:	6078      	str	r0, [r7, #4]
 800692e:	6039      	str	r1, [r7, #0]
  lis2duxs12_md_t mode;
  lis2duxs12_xl_data_t data;

  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006930:	687b      	ldr	r3, [r7, #4]
 8006932:	3320      	adds	r3, #32
 8006934:	f107 021c 	add.w	r2, r7, #28
 8006938:	4611      	mov	r1, r2
 800693a:	4618      	mov	r0, r3
 800693c:	f000 fd40 	bl	80073c0 <lis2duxs12_mode_get>
 8006940:	4603      	mov	r3, r0
 8006942:	2b00      	cmp	r3, #0
 8006944:	d002      	beq.n	800694c <LIS2DUXS12_ACC_GetAxesRaw+0x26>
  {
    return LIS2DUXS12_ERROR;
 8006946:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800694a:	e01b      	b.n	8006984 <LIS2DUXS12_ACC_GetAxesRaw+0x5e>
  }

  if (lis2duxs12_xl_data_get(&(pObj->Ctx), &mode, &data) != LIS2DUXS12_OK)
 800694c:	687b      	ldr	r3, [r7, #4]
 800694e:	3320      	adds	r3, #32
 8006950:	f107 0208 	add.w	r2, r7, #8
 8006954:	f107 011c 	add.w	r1, r7, #28
 8006958:	4618      	mov	r0, r3
 800695a:	f000 fe41 	bl	80075e0 <lis2duxs12_xl_data_get>
 800695e:	4603      	mov	r3, r0
 8006960:	2b00      	cmp	r3, #0
 8006962:	d002      	beq.n	800696a <LIS2DUXS12_ACC_GetAxesRaw+0x44>
  {
    return LIS2DUXS12_ERROR;
 8006964:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006968:	e00c      	b.n	8006984 <LIS2DUXS12_ACC_GetAxesRaw+0x5e>
  }

  Value->x = data.raw[0];
 800696a:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 800696e:	683b      	ldr	r3, [r7, #0]
 8006970:	801a      	strh	r2, [r3, #0]
  Value->y = data.raw[1];
 8006972:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8006976:	683b      	ldr	r3, [r7, #0]
 8006978:	805a      	strh	r2, [r3, #2]
  Value->z = data.raw[2];
 800697a:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 800697e:	683b      	ldr	r3, [r7, #0]
 8006980:	809a      	strh	r2, [r3, #4]

  return LIS2DUXS12_OK;
 8006982:	2300      	movs	r3, #0
}
 8006984:	4618      	mov	r0, r3
 8006986:	3720      	adds	r7, #32
 8006988:	46bd      	mov	sp, r7
 800698a:	bd80      	pop	{r7, pc}

0800698c <LIS2DUXS12_ACC_GetAxes>:
  * @param  pObj the device pObj
  * @param  Acceleration pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_ACC_GetAxes(LIS2DUXS12_Object_t *pObj, LIS2DUXS12_Axes_t *Acceleration)
{
 800698c:	b580      	push	{r7, lr}
 800698e:	b088      	sub	sp, #32
 8006990:	af00      	add	r7, sp, #0
 8006992:	6078      	str	r0, [r7, #4]
 8006994:	6039      	str	r1, [r7, #0]
  lis2duxs12_md_t mode;
  lis2duxs12_xl_data_t data;

  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006996:	687b      	ldr	r3, [r7, #4]
 8006998:	3320      	adds	r3, #32
 800699a:	f107 021c 	add.w	r2, r7, #28
 800699e:	4611      	mov	r1, r2
 80069a0:	4618      	mov	r0, r3
 80069a2:	f000 fd0d 	bl	80073c0 <lis2duxs12_mode_get>
 80069a6:	4603      	mov	r3, r0
 80069a8:	2b00      	cmp	r3, #0
 80069aa:	d002      	beq.n	80069b2 <LIS2DUXS12_ACC_GetAxes+0x26>
  {
    return LIS2DUXS12_ERROR;
 80069ac:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80069b0:	e027      	b.n	8006a02 <LIS2DUXS12_ACC_GetAxes+0x76>
  }

  if (lis2duxs12_xl_data_get(&(pObj->Ctx), &mode, &data) != LIS2DUXS12_OK)
 80069b2:	687b      	ldr	r3, [r7, #4]
 80069b4:	3320      	adds	r3, #32
 80069b6:	f107 0208 	add.w	r2, r7, #8
 80069ba:	f107 011c 	add.w	r1, r7, #28
 80069be:	4618      	mov	r0, r3
 80069c0:	f000 fe0e 	bl	80075e0 <lis2duxs12_xl_data_get>
 80069c4:	4603      	mov	r3, r0
 80069c6:	2b00      	cmp	r3, #0
 80069c8:	d002      	beq.n	80069d0 <LIS2DUXS12_ACC_GetAxes+0x44>
  {
    return LIS2DUXS12_ERROR;
 80069ca:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80069ce:	e018      	b.n	8006a02 <LIS2DUXS12_ACC_GetAxes+0x76>
  }

  Acceleration->x = (int32_t)data.mg[0];
 80069d0:	edd7 7a02 	vldr	s15, [r7, #8]
 80069d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80069d8:	ee17 2a90 	vmov	r2, s15
 80069dc:	683b      	ldr	r3, [r7, #0]
 80069de:	601a      	str	r2, [r3, #0]
  Acceleration->y = (int32_t)data.mg[1];
 80069e0:	edd7 7a03 	vldr	s15, [r7, #12]
 80069e4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80069e8:	ee17 2a90 	vmov	r2, s15
 80069ec:	683b      	ldr	r3, [r7, #0]
 80069ee:	605a      	str	r2, [r3, #4]
  Acceleration->z = (int32_t)data.mg[2];
 80069f0:	edd7 7a04 	vldr	s15, [r7, #16]
 80069f4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80069f8:	ee17 2a90 	vmov	r2, s15
 80069fc:	683b      	ldr	r3, [r7, #0]
 80069fe:	609a      	str	r2, [r3, #8]

  return LIS2DUXS12_OK;
 8006a00:	2300      	movs	r3, #0
}
 8006a02:	4618      	mov	r0, r3
 8006a04:	3720      	adds	r7, #32
 8006a06:	46bd      	mov	sp, r7
 8006a08:	bd80      	pop	{r7, pc}

08006a0a <LIS2DUXS12_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2DUXS12_Write_Reg(LIS2DUXS12_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 8006a0a:	b580      	push	{r7, lr}
 8006a0c:	b082      	sub	sp, #8
 8006a0e:	af00      	add	r7, sp, #0
 8006a10:	6078      	str	r0, [r7, #4]
 8006a12:	460b      	mov	r3, r1
 8006a14:	70fb      	strb	r3, [r7, #3]
 8006a16:	4613      	mov	r3, r2
 8006a18:	70bb      	strb	r3, [r7, #2]
  if (lis2duxs12_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LIS2DUXS12_OK)
 8006a1a:	687b      	ldr	r3, [r7, #4]
 8006a1c:	f103 0020 	add.w	r0, r3, #32
 8006a20:	1cba      	adds	r2, r7, #2
 8006a22:	78f9      	ldrb	r1, [r7, #3]
 8006a24:	2301      	movs	r3, #1
 8006a26:	f000 fa79 	bl	8006f1c <lis2duxs12_write_reg>
 8006a2a:	4603      	mov	r3, r0
 8006a2c:	2b00      	cmp	r3, #0
 8006a2e:	d002      	beq.n	8006a36 <LIS2DUXS12_Write_Reg+0x2c>
  {
    return LIS2DUXS12_ERROR;
 8006a30:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006a34:	e000      	b.n	8006a38 <LIS2DUXS12_Write_Reg+0x2e>
  }

  return LIS2DUXS12_OK;
 8006a36:	2300      	movs	r3, #0
}
 8006a38:	4618      	mov	r0, r3
 8006a3a:	3708      	adds	r7, #8
 8006a3c:	46bd      	mov	sp, r7
 8006a3e:	bd80      	pop	{r7, pc}

08006a40 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled>:
  * @param  Power the ultra low power option
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled(LIS2DUXS12_Object_t *pObj, float_t Odr,
    LIS2DUXS12_Power_Mode_t Power)
{
 8006a40:	b580      	push	{r7, lr}
 8006a42:	b086      	sub	sp, #24
 8006a44:	af00      	add	r7, sp, #0
 8006a46:	60f8      	str	r0, [r7, #12]
 8006a48:	ed87 0a02 	vstr	s0, [r7, #8]
 8006a4c:	460b      	mov	r3, r1
 8006a4e:	71fb      	strb	r3, [r7, #7]
  lis2duxs12_md_t mode;

  if (lis2duxs12_mode_get(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006a50:	68fb      	ldr	r3, [r7, #12]
 8006a52:	3320      	adds	r3, #32
 8006a54:	f107 0214 	add.w	r2, r7, #20
 8006a58:	4611      	mov	r1, r2
 8006a5a:	4618      	mov	r0, r3
 8006a5c:	f000 fcb0 	bl	80073c0 <lis2duxs12_mode_get>
 8006a60:	4603      	mov	r3, r0
 8006a62:	2b00      	cmp	r3, #0
 8006a64:	d002      	beq.n	8006a6c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2c>
  {
    return LIS2DUXS12_ERROR;
 8006a66:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006a6a:	e142      	b.n	8006cf2 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2b2>
  }

  if (Power == LIS2DUXS12_ULTRA_LOW_POWER)
 8006a6c:	79fb      	ldrb	r3, [r7, #7]
 8006a6e:	2b00      	cmp	r3, #0
 8006a70:	d118      	bne.n	8006aa4 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x64>
  {
    mode.odr = (Odr <= 1.6f) ? LIS2DUXS12_1Hz6_ULP
               : (Odr <= 3.0f) ? LIS2DUXS12_3Hz_ULP
 8006a72:	edd7 7a02 	vldr	s15, [r7, #8]
 8006a76:	ed9f 7aa1 	vldr	s14, [pc, #644]	@ 8006cfc <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2bc>
 8006a7a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006a7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006a82:	d801      	bhi.n	8006a88 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x48>
 8006a84:	2301      	movs	r3, #1
 8006a86:	e00b      	b.n	8006aa0 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x60>
 8006a88:	edd7 7a02 	vldr	s15, [r7, #8]
 8006a8c:	eeb0 7a08 	vmov.f32	s14, #8	@ 0x40400000  3.0
 8006a90:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006a94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006a98:	d801      	bhi.n	8006a9e <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x5e>
 8006a9a:	2302      	movs	r3, #2
 8006a9c:	e000      	b.n	8006aa0 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x60>
 8006a9e:	2303      	movs	r3, #3
    mode.odr = (Odr <= 1.6f) ? LIS2DUXS12_1Hz6_ULP
 8006aa0:	753b      	strb	r3, [r7, #20]
 8006aa2:	e0a4      	b.n	8006bee <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ae>
               :                 LIS2DUXS12_25Hz_ULP;
  }
  else if (Power == LIS2DUXS12_LOW_POWER)
 8006aa4:	79fb      	ldrb	r3, [r7, #7]
 8006aa6:	2b01      	cmp	r3, #1
 8006aa8:	d14f      	bne.n	8006b4a <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x10a>
  {
    mode.odr = (Odr <=   6.0f) ? LIS2DUXS12_6Hz_LP
               : (Odr <=  12.5f) ? LIS2DUXS12_12Hz5_LP
 8006aaa:	edd7 7a02 	vldr	s15, [r7, #8]
 8006aae:	eeb1 7a08 	vmov.f32	s14, #24	@ 0x40c00000  6.0
 8006ab2:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006ab6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006aba:	d801      	bhi.n	8006ac0 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x80>
 8006abc:	2304      	movs	r3, #4
 8006abe:	e042      	b.n	8006b46 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x106>
 8006ac0:	edd7 7a02 	vldr	s15, [r7, #8]
 8006ac4:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 8006ac8:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006acc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006ad0:	d801      	bhi.n	8006ad6 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x96>
 8006ad2:	2305      	movs	r3, #5
 8006ad4:	e037      	b.n	8006b46 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x106>
 8006ad6:	edd7 7a02 	vldr	s15, [r7, #8]
 8006ada:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8006ade:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006ae2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006ae6:	d801      	bhi.n	8006aec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0xac>
 8006ae8:	2306      	movs	r3, #6
 8006aea:	e02c      	b.n	8006b46 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x106>
 8006aec:	edd7 7a02 	vldr	s15, [r7, #8]
 8006af0:	ed9f 7a83 	vldr	s14, [pc, #524]	@ 8006d00 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2c0>
 8006af4:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006af8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006afc:	d801      	bhi.n	8006b02 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0xc2>
 8006afe:	2307      	movs	r3, #7
 8006b00:	e021      	b.n	8006b46 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x106>
 8006b02:	edd7 7a02 	vldr	s15, [r7, #8]
 8006b06:	ed9f 7a7f 	vldr	s14, [pc, #508]	@ 8006d04 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2c4>
 8006b0a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006b0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006b12:	d801      	bhi.n	8006b18 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0xd8>
 8006b14:	2308      	movs	r3, #8
 8006b16:	e016      	b.n	8006b46 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x106>
 8006b18:	edd7 7a02 	vldr	s15, [r7, #8]
 8006b1c:	ed9f 7a7a 	vldr	s14, [pc, #488]	@ 8006d08 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2c8>
 8006b20:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006b24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006b28:	d801      	bhi.n	8006b2e <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0xee>
 8006b2a:	2309      	movs	r3, #9
 8006b2c:	e00b      	b.n	8006b46 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x106>
 8006b2e:	edd7 7a02 	vldr	s15, [r7, #8]
 8006b32:	ed9f 7a76 	vldr	s14, [pc, #472]	@ 8006d0c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2cc>
 8006b36:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006b3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006b3e:	d801      	bhi.n	8006b44 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x104>
 8006b40:	230a      	movs	r3, #10
 8006b42:	e000      	b.n	8006b46 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x106>
 8006b44:	230b      	movs	r3, #11
    mode.odr = (Odr <=   6.0f) ? LIS2DUXS12_6Hz_LP
 8006b46:	753b      	strb	r3, [r7, #20]
 8006b48:	e051      	b.n	8006bee <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ae>
               : (Odr <= 100.0f) ? LIS2DUXS12_100Hz_LP
               : (Odr <= 200.0f) ? LIS2DUXS12_200Hz_LP
               : (Odr <= 400.0f) ? LIS2DUXS12_400Hz_LP
               :                   LIS2DUXS12_800Hz_LP;
  }
  else if (Power == LIS2DUXS12_HIGH_PERFORMANCE)
 8006b4a:	79fb      	ldrb	r3, [r7, #7]
 8006b4c:	2b02      	cmp	r3, #2
 8006b4e:	d14e      	bne.n	8006bee <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ae>
  {
    mode.odr = (Odr <=   6.0f) ? LIS2DUXS12_6Hz_HP
               : (Odr <=  12.5f) ? LIS2DUXS12_12Hz5_HP
 8006b50:	edd7 7a02 	vldr	s15, [r7, #8]
 8006b54:	eeb1 7a08 	vmov.f32	s14, #24	@ 0x40c00000  6.0
 8006b58:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006b5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006b60:	d801      	bhi.n	8006b66 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x126>
 8006b62:	2314      	movs	r3, #20
 8006b64:	e042      	b.n	8006bec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
 8006b66:	edd7 7a02 	vldr	s15, [r7, #8]
 8006b6a:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 8006b6e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006b72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006b76:	d801      	bhi.n	8006b7c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x13c>
 8006b78:	2315      	movs	r3, #21
 8006b7a:	e037      	b.n	8006bec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
 8006b7c:	edd7 7a02 	vldr	s15, [r7, #8]
 8006b80:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8006b84:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006b88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006b8c:	d801      	bhi.n	8006b92 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x152>
 8006b8e:	2316      	movs	r3, #22
 8006b90:	e02c      	b.n	8006bec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
 8006b92:	edd7 7a02 	vldr	s15, [r7, #8]
 8006b96:	ed9f 7a5a 	vldr	s14, [pc, #360]	@ 8006d00 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2c0>
 8006b9a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006b9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006ba2:	d801      	bhi.n	8006ba8 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x168>
 8006ba4:	2317      	movs	r3, #23
 8006ba6:	e021      	b.n	8006bec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
 8006ba8:	edd7 7a02 	vldr	s15, [r7, #8]
 8006bac:	ed9f 7a55 	vldr	s14, [pc, #340]	@ 8006d04 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2c4>
 8006bb0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006bb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006bb8:	d801      	bhi.n	8006bbe <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x17e>
 8006bba:	2318      	movs	r3, #24
 8006bbc:	e016      	b.n	8006bec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
 8006bbe:	edd7 7a02 	vldr	s15, [r7, #8]
 8006bc2:	ed9f 7a51 	vldr	s14, [pc, #324]	@ 8006d08 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2c8>
 8006bc6:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006bca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006bce:	d801      	bhi.n	8006bd4 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x194>
 8006bd0:	2319      	movs	r3, #25
 8006bd2:	e00b      	b.n	8006bec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
 8006bd4:	edd7 7a02 	vldr	s15, [r7, #8]
 8006bd8:	ed9f 7a4c 	vldr	s14, [pc, #304]	@ 8006d0c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2cc>
 8006bdc:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006be0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006be4:	d801      	bhi.n	8006bea <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1aa>
 8006be6:	231a      	movs	r3, #26
 8006be8:	e000      	b.n	8006bec <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ac>
 8006bea:	231b      	movs	r3, #27
    mode.odr = (Odr <=   6.0f) ? LIS2DUXS12_6Hz_HP
 8006bec:	753b      	strb	r3, [r7, #20]
  else
  {
    /* Do nothing */
  }

  if (lis2duxs12_mode_set(&(pObj->Ctx), &mode) != LIS2DUXS12_OK)
 8006bee:	68fb      	ldr	r3, [r7, #12]
 8006bf0:	3320      	adds	r3, #32
 8006bf2:	f107 0214 	add.w	r2, r7, #20
 8006bf6:	4611      	mov	r1, r2
 8006bf8:	4618      	mov	r0, r3
 8006bfa:	f000 fac1 	bl	8007180 <lis2duxs12_mode_set>
 8006bfe:	4603      	mov	r3, r0
 8006c00:	2b00      	cmp	r3, #0
 8006c02:	d002      	beq.n	8006c0a <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x1ca>
  {
    return LIS2DUXS12_ERROR;
 8006c04:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006c08:	e073      	b.n	8006cf2 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2b2>
  }

  /* Store the current Odr value */
  pObj->acc_odr = (mode.odr == LIS2DUXS12_1Hz6_ULP) ?   1.6f
 8006c0a:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_3Hz_ULP)  ?   3.0f
 8006c0c:	2b01      	cmp	r3, #1
 8006c0e:	d05b      	beq.n	8006cc8 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x288>
 8006c10:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_6Hz_LP)   ?   6.0f
 8006c12:	2b02      	cmp	r3, #2
 8006c14:	d056      	beq.n	8006cc4 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x284>
 8006c16:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_6Hz_HP)   ?   6.0f
 8006c18:	2b04      	cmp	r3, #4
 8006c1a:	d051      	beq.n	8006cc0 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x280>
 8006c1c:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_12Hz5_LP) ?  12.5f
 8006c1e:	2b14      	cmp	r3, #20
 8006c20:	d04c      	beq.n	8006cbc <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x27c>
 8006c22:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_12Hz5_HP) ?  12.5f
 8006c24:	2b05      	cmp	r3, #5
 8006c26:	d047      	beq.n	8006cb8 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x278>
 8006c28:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_25Hz_ULP) ?  25.0f
 8006c2a:	2b15      	cmp	r3, #21
 8006c2c:	d042      	beq.n	8006cb4 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x274>
 8006c2e:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_25Hz_LP)  ?  25.0f
 8006c30:	2b03      	cmp	r3, #3
 8006c32:	d03d      	beq.n	8006cb0 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x270>
 8006c34:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_25Hz_HP)  ?  25.0f
 8006c36:	2b06      	cmp	r3, #6
 8006c38:	d038      	beq.n	8006cac <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x26c>
 8006c3a:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_50Hz_LP)  ?  50.0f
 8006c3c:	2b16      	cmp	r3, #22
 8006c3e:	d033      	beq.n	8006ca8 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x268>
 8006c40:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_50Hz_HP)  ?  50.0f
 8006c42:	2b07      	cmp	r3, #7
 8006c44:	d02e      	beq.n	8006ca4 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x264>
 8006c46:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_100Hz_LP) ? 100.0f
 8006c48:	2b17      	cmp	r3, #23
 8006c4a:	d029      	beq.n	8006ca0 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x260>
 8006c4c:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_100Hz_HP) ? 100.0f
 8006c4e:	2b08      	cmp	r3, #8
 8006c50:	d024      	beq.n	8006c9c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x25c>
 8006c52:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_200Hz_LP) ? 200.0f
 8006c54:	2b18      	cmp	r3, #24
 8006c56:	d01f      	beq.n	8006c98 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x258>
 8006c58:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_200Hz_HP) ? 200.0f
 8006c5a:	2b09      	cmp	r3, #9
 8006c5c:	d01a      	beq.n	8006c94 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x254>
 8006c5e:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_400Hz_LP) ? 400.0f
 8006c60:	2b19      	cmp	r3, #25
 8006c62:	d015      	beq.n	8006c90 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x250>
 8006c64:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_400Hz_HP) ? 400.0f
 8006c66:	2b0a      	cmp	r3, #10
 8006c68:	d010      	beq.n	8006c8c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x24c>
 8006c6a:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_800Hz_LP) ? 800.0f
 8006c6c:	2b1a      	cmp	r3, #26
 8006c6e:	d00b      	beq.n	8006c88 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x248>
 8006c70:	7d3b      	ldrb	r3, [r7, #20]
                  : (mode.odr == LIS2DUXS12_800Hz_HP) ? 800.0f
 8006c72:	2b0b      	cmp	r3, #11
 8006c74:	d006      	beq.n	8006c84 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x244>
 8006c76:	7d3b      	ldrb	r3, [r7, #20]
                  :                                     -1.0f;
 8006c78:	2b1b      	cmp	r3, #27
 8006c7a:	d101      	bne.n	8006c80 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x240>
 8006c7c:	4b24      	ldr	r3, [pc, #144]	@ (8006d10 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2d0>)
 8006c7e:	e024      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
 8006c80:	4b24      	ldr	r3, [pc, #144]	@ (8006d14 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2d4>)
 8006c82:	e022      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_800Hz_HP) ? 800.0f
 8006c84:	4b22      	ldr	r3, [pc, #136]	@ (8006d10 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2d0>)
 8006c86:	e020      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_800Hz_LP) ? 800.0f
 8006c88:	4b23      	ldr	r3, [pc, #140]	@ (8006d18 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2d8>)
 8006c8a:	e01e      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_400Hz_HP) ? 400.0f
 8006c8c:	4b22      	ldr	r3, [pc, #136]	@ (8006d18 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2d8>)
 8006c8e:	e01c      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_400Hz_LP) ? 400.0f
 8006c90:	4b22      	ldr	r3, [pc, #136]	@ (8006d1c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2dc>)
 8006c92:	e01a      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_200Hz_HP) ? 200.0f
 8006c94:	4b21      	ldr	r3, [pc, #132]	@ (8006d1c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2dc>)
 8006c96:	e018      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_200Hz_LP) ? 200.0f
 8006c98:	4b21      	ldr	r3, [pc, #132]	@ (8006d20 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2e0>)
 8006c9a:	e016      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_100Hz_HP) ? 100.0f
 8006c9c:	4b20      	ldr	r3, [pc, #128]	@ (8006d20 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2e0>)
 8006c9e:	e014      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_100Hz_LP) ? 100.0f
 8006ca0:	4b20      	ldr	r3, [pc, #128]	@ (8006d24 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2e4>)
 8006ca2:	e012      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_50Hz_HP)  ?  50.0f
 8006ca4:	4b1f      	ldr	r3, [pc, #124]	@ (8006d24 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2e4>)
 8006ca6:	e010      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_50Hz_LP)  ?  50.0f
 8006ca8:	4b1f      	ldr	r3, [pc, #124]	@ (8006d28 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2e8>)
 8006caa:	e00e      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_25Hz_HP)  ?  25.0f
 8006cac:	4b1e      	ldr	r3, [pc, #120]	@ (8006d28 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2e8>)
 8006cae:	e00c      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_25Hz_LP)  ?  25.0f
 8006cb0:	4b1d      	ldr	r3, [pc, #116]	@ (8006d28 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2e8>)
 8006cb2:	e00a      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_25Hz_ULP) ?  25.0f
 8006cb4:	4b1d      	ldr	r3, [pc, #116]	@ (8006d2c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2ec>)
 8006cb6:	e008      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_12Hz5_HP) ?  12.5f
 8006cb8:	4b1c      	ldr	r3, [pc, #112]	@ (8006d2c <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2ec>)
 8006cba:	e006      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_12Hz5_LP) ?  12.5f
 8006cbc:	4b1c      	ldr	r3, [pc, #112]	@ (8006d30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2f0>)
 8006cbe:	e004      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_6Hz_HP)   ?   6.0f
 8006cc0:	4b1b      	ldr	r3, [pc, #108]	@ (8006d30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2f0>)
 8006cc2:	e002      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_6Hz_LP)   ?   6.0f
 8006cc4:	4b1b      	ldr	r3, [pc, #108]	@ (8006d34 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2f4>)
 8006cc6:	e000      	b.n	8006cca <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x28a>
                  : (mode.odr == LIS2DUXS12_3Hz_ULP)  ?   3.0f
 8006cc8:	4b1b      	ldr	r3, [pc, #108]	@ (8006d38 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2f8>)
  pObj->acc_odr = (mode.odr == LIS2DUXS12_1Hz6_ULP) ?   1.6f
 8006cca:	68fa      	ldr	r2, [r7, #12]
 8006ccc:	6353      	str	r3, [r2, #52]	@ 0x34

  if (pObj->acc_odr == -1.0f)
 8006cce:	68fb      	ldr	r3, [r7, #12]
 8006cd0:	edd3 7a0d 	vldr	s15, [r3, #52]	@ 0x34
 8006cd4:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8006cd8:	eef4 7a47 	vcmp.f32	s15, s14
 8006cdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006ce0:	d102      	bne.n	8006ce8 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2a8>
  {
    return LIS2DUXS12_ERROR;
 8006ce2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8006ce6:	e004      	b.n	8006cf2 <LIS2DUXS12_ACC_SetOutputDataRate_When_Enabled+0x2b2>
  }

  /* Store the current Power value */
  pObj->power_mode = Power;
 8006ce8:	68fb      	ldr	r3, [r7, #12]
 8006cea:	79fa      	ldrb	r2, [r7, #7]
 8006cec:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  return LIS2DUXS12_OK;
 8006cf0:	2300      	movs	r3, #0
}
 8006cf2:	4618      	mov	r0, r3
 8006cf4:	3718      	adds	r7, #24
 8006cf6:	46bd      	mov	sp, r7
 8006cf8:	bd80      	pop	{r7, pc}
 8006cfa:	bf00      	nop
 8006cfc:	3fcccccd 	.word	0x3fcccccd
 8006d00:	42480000 	.word	0x42480000
 8006d04:	42c80000 	.word	0x42c80000
 8006d08:	43480000 	.word	0x43480000
 8006d0c:	43c80000 	.word	0x43c80000
 8006d10:	44480000 	.word	0x44480000
 8006d14:	bf800000 	.word	0xbf800000
 8006d18:	43c80000 	.word	0x43c80000
 8006d1c:	43480000 	.word	0x43480000
 8006d20:	42c80000 	.word	0x42c80000
 8006d24:	42480000 	.word	0x42480000
 8006d28:	41c80000 	.word	0x41c80000
 8006d2c:	41480000 	.word	0x41480000
 8006d30:	40c00000 	.word	0x40c00000
 8006d34:	40400000 	.word	0x40400000
 8006d38:	3fcccccd 	.word	0x3fcccccd

08006d3c <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled>:
  * @param  Power the ultra low power option
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled(LIS2DUXS12_Object_t *pObj, float_t Odr,
    LIS2DUXS12_Power_Mode_t Power)
{
 8006d3c:	b480      	push	{r7}
 8006d3e:	b085      	sub	sp, #20
 8006d40:	af00      	add	r7, sp, #0
 8006d42:	60f8      	str	r0, [r7, #12]
 8006d44:	ed87 0a02 	vstr	s0, [r7, #8]
 8006d48:	460b      	mov	r3, r1
 8006d4a:	71fb      	strb	r3, [r7, #7]
  /* Store the new Odr value */
  if (Power == LIS2DUXS12_ULTRA_LOW_POWER)
 8006d4c:	79fb      	ldrb	r3, [r7, #7]
 8006d4e:	2b00      	cmp	r3, #0
 8006d50:	d11a      	bne.n	8006d88 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x4c>
  {
    pObj->acc_odr = (Odr <= 1.5f) ? 1.5f
                    : (Odr <= 3.0f) ? 3.0f
 8006d52:	edd7 7a02 	vldr	s15, [r7, #8]
 8006d56:	eeb7 7a08 	vmov.f32	s14, #120	@ 0x3fc00000  1.5
 8006d5a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006d5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006d62:	d802      	bhi.n	8006d6a <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x2e>
 8006d64:	f04f 537f 	mov.w	r3, #1069547520	@ 0x3fc00000
 8006d68:	e00b      	b.n	8006d82 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x46>
                    :                25.0f;
 8006d6a:	edd7 7a02 	vldr	s15, [r7, #8]
 8006d6e:	eeb0 7a08 	vmov.f32	s14, #8	@ 0x40400000  3.0
 8006d72:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006d76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006d7a:	d801      	bhi.n	8006d80 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x44>
 8006d7c:	4b33      	ldr	r3, [pc, #204]	@ (8006e4c <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x110>)
 8006d7e:	e000      	b.n	8006d82 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x46>
 8006d80:	4b33      	ldr	r3, [pc, #204]	@ (8006e50 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x114>)
    pObj->acc_odr = (Odr <= 1.5f) ? 1.5f
 8006d82:	68fa      	ldr	r2, [r7, #12]
 8006d84:	6353      	str	r3, [r2, #52]	@ 0x34
 8006d86:	e055      	b.n	8006e34 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf8>
  }
  else if ((Power == LIS2DUXS12_LOW_POWER) || (Power == LIS2DUXS12_HIGH_PERFORMANCE))
 8006d88:	79fb      	ldrb	r3, [r7, #7]
 8006d8a:	2b01      	cmp	r3, #1
 8006d8c:	d002      	beq.n	8006d94 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x58>
 8006d8e:	79fb      	ldrb	r3, [r7, #7]
 8006d90:	2b02      	cmp	r3, #2
 8006d92:	d14f      	bne.n	8006e34 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf8>
  {
    pObj->acc_odr = (Odr <=   6.0f) ?   6.0f
                    : (Odr <=  12.5f) ?  12.5f
 8006d94:	edd7 7a02 	vldr	s15, [r7, #8]
 8006d98:	eeb1 7a08 	vmov.f32	s14, #24	@ 0x40c00000  6.0
 8006d9c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006da0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006da4:	d801      	bhi.n	8006daa <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x6e>
 8006da6:	4b2b      	ldr	r3, [pc, #172]	@ (8006e54 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x118>)
 8006da8:	e042      	b.n	8006e30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf4>
                    : (Odr <=  25.0f) ?  25.0f
 8006daa:	edd7 7a02 	vldr	s15, [r7, #8]
 8006dae:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 8006db2:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006db6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006dba:	d801      	bhi.n	8006dc0 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x84>
 8006dbc:	4b26      	ldr	r3, [pc, #152]	@ (8006e58 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x11c>)
 8006dbe:	e037      	b.n	8006e30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf4>
                    : (Odr <=  50.0f) ?  50.0f
 8006dc0:	edd7 7a02 	vldr	s15, [r7, #8]
 8006dc4:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8006dc8:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006dcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006dd0:	d801      	bhi.n	8006dd6 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x9a>
 8006dd2:	4b1f      	ldr	r3, [pc, #124]	@ (8006e50 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x114>)
 8006dd4:	e02c      	b.n	8006e30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf4>
                    : (Odr <= 100.0f) ? 100.0f
 8006dd6:	edd7 7a02 	vldr	s15, [r7, #8]
 8006dda:	ed9f 7a20 	vldr	s14, [pc, #128]	@ 8006e5c <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x120>
 8006dde:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006de2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006de6:	d801      	bhi.n	8006dec <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xb0>
 8006de8:	4b1d      	ldr	r3, [pc, #116]	@ (8006e60 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x124>)
 8006dea:	e021      	b.n	8006e30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf4>
                    : (Odr <= 200.0f) ? 200.0f
 8006dec:	edd7 7a02 	vldr	s15, [r7, #8]
 8006df0:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 8006e64 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x128>
 8006df4:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006df8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006dfc:	d801      	bhi.n	8006e02 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xc6>
 8006dfe:	4b1a      	ldr	r3, [pc, #104]	@ (8006e68 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x12c>)
 8006e00:	e016      	b.n	8006e30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf4>
                    : (Odr <= 400.0f) ? 400.0f
 8006e02:	edd7 7a02 	vldr	s15, [r7, #8]
 8006e06:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 8006e6c <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x130>
 8006e0a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006e0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e12:	d801      	bhi.n	8006e18 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xdc>
 8006e14:	4b16      	ldr	r3, [pc, #88]	@ (8006e70 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x134>)
 8006e16:	e00b      	b.n	8006e30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf4>
                    :                   800.0f;
 8006e18:	edd7 7a02 	vldr	s15, [r7, #8]
 8006e1c:	ed9f 7a15 	vldr	s14, [pc, #84]	@ 8006e74 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x138>
 8006e20:	eef4 7ac7 	vcmpe.f32	s15, s14
 8006e24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006e28:	d801      	bhi.n	8006e2e <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf2>
 8006e2a:	4b13      	ldr	r3, [pc, #76]	@ (8006e78 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x13c>)
 8006e2c:	e000      	b.n	8006e30 <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0xf4>
 8006e2e:	4b13      	ldr	r3, [pc, #76]	@ (8006e7c <LIS2DUXS12_ACC_SetOutputDataRate_When_Disabled+0x140>)
    pObj->acc_odr = (Odr <=   6.0f) ?   6.0f
 8006e30:	68fa      	ldr	r2, [r7, #12]
 8006e32:	6353      	str	r3, [r2, #52]	@ 0x34
  {
    /* Do nothing */
  }

  /* Store the new Power value */
  pObj->power_mode = Power;
 8006e34:	68fb      	ldr	r3, [r7, #12]
 8006e36:	79fa      	ldrb	r2, [r7, #7]
 8006e38:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38

  return LIS2DUXS12_OK;
 8006e3c:	2300      	movs	r3, #0
}
 8006e3e:	4618      	mov	r0, r3
 8006e40:	3714      	adds	r7, #20
 8006e42:	46bd      	mov	sp, r7
 8006e44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e48:	4770      	bx	lr
 8006e4a:	bf00      	nop
 8006e4c:	40400000 	.word	0x40400000
 8006e50:	41c80000 	.word	0x41c80000
 8006e54:	40c00000 	.word	0x40c00000
 8006e58:	41480000 	.word	0x41480000
 8006e5c:	42480000 	.word	0x42480000
 8006e60:	42480000 	.word	0x42480000
 8006e64:	42c80000 	.word	0x42c80000
 8006e68:	42c80000 	.word	0x42c80000
 8006e6c:	43480000 	.word	0x43480000
 8006e70:	43480000 	.word	0x43480000
 8006e74:	43c80000 	.word	0x43c80000
 8006e78:	43c80000 	.word	0x43c80000
 8006e7c:	44480000 	.word	0x44480000

08006e80 <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8006e80:	b590      	push	{r4, r7, lr}
 8006e82:	b087      	sub	sp, #28
 8006e84:	af00      	add	r7, sp, #0
 8006e86:	60f8      	str	r0, [r7, #12]
 8006e88:	607a      	str	r2, [r7, #4]
 8006e8a:	461a      	mov	r2, r3
 8006e8c:	460b      	mov	r3, r1
 8006e8e:	72fb      	strb	r3, [r7, #11]
 8006e90:	4613      	mov	r3, r2
 8006e92:	813b      	strh	r3, [r7, #8]
  LIS2DUXS12_Object_t *pObj = (LIS2DUXS12_Object_t *)Handle;
 8006e94:	68fb      	ldr	r3, [r7, #12]
 8006e96:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 8006e98:	697b      	ldr	r3, [r7, #20]
 8006e9a:	695c      	ldr	r4, [r3, #20]
 8006e9c:	697b      	ldr	r3, [r7, #20]
 8006e9e:	7b1b      	ldrb	r3, [r3, #12]
 8006ea0:	4618      	mov	r0, r3
 8006ea2:	7afb      	ldrb	r3, [r7, #11]
 8006ea4:	b299      	uxth	r1, r3
 8006ea6:	893b      	ldrh	r3, [r7, #8]
 8006ea8:	687a      	ldr	r2, [r7, #4]
 8006eaa:	47a0      	blx	r4
 8006eac:	4603      	mov	r3, r0
}
 8006eae:	4618      	mov	r0, r3
 8006eb0:	371c      	adds	r7, #28
 8006eb2:	46bd      	mov	sp, r7
 8006eb4:	bd90      	pop	{r4, r7, pc}

08006eb6 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8006eb6:	b590      	push	{r4, r7, lr}
 8006eb8:	b087      	sub	sp, #28
 8006eba:	af00      	add	r7, sp, #0
 8006ebc:	60f8      	str	r0, [r7, #12]
 8006ebe:	607a      	str	r2, [r7, #4]
 8006ec0:	461a      	mov	r2, r3
 8006ec2:	460b      	mov	r3, r1
 8006ec4:	72fb      	strb	r3, [r7, #11]
 8006ec6:	4613      	mov	r3, r2
 8006ec8:	813b      	strh	r3, [r7, #8]
  LIS2DUXS12_Object_t *pObj = (LIS2DUXS12_Object_t *)Handle;
 8006eca:	68fb      	ldr	r3, [r7, #12]
 8006ecc:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 8006ece:	697b      	ldr	r3, [r7, #20]
 8006ed0:	691c      	ldr	r4, [r3, #16]
 8006ed2:	697b      	ldr	r3, [r7, #20]
 8006ed4:	7b1b      	ldrb	r3, [r3, #12]
 8006ed6:	4618      	mov	r0, r3
 8006ed8:	7afb      	ldrb	r3, [r7, #11]
 8006eda:	b299      	uxth	r1, r3
 8006edc:	893b      	ldrh	r3, [r7, #8]
 8006ede:	687a      	ldr	r2, [r7, #4]
 8006ee0:	47a0      	blx	r4
 8006ee2:	4603      	mov	r3, r0
}
 8006ee4:	4618      	mov	r0, r3
 8006ee6:	371c      	adds	r7, #28
 8006ee8:	46bd      	mov	sp, r7
 8006eea:	bd90      	pop	{r4, r7, pc}

08006eec <lis2duxs12_read_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t __weak lis2duxs12_read_reg(stmdev_ctx_t* ctx, uint8_t reg, uint8_t* data,
                                   uint16_t len)
{
 8006eec:	b590      	push	{r4, r7, lr}
 8006eee:	b087      	sub	sp, #28
 8006ef0:	af00      	add	r7, sp, #0
 8006ef2:	60f8      	str	r0, [r7, #12]
 8006ef4:	607a      	str	r2, [r7, #4]
 8006ef6:	461a      	mov	r2, r3
 8006ef8:	460b      	mov	r3, r1
 8006efa:	72fb      	strb	r3, [r7, #11]
 8006efc:	4613      	mov	r3, r2
 8006efe:	813b      	strh	r3, [r7, #8]
  int32_t ret;
  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8006f00:	68fb      	ldr	r3, [r7, #12]
 8006f02:	685c      	ldr	r4, [r3, #4]
 8006f04:	68fb      	ldr	r3, [r7, #12]
 8006f06:	68d8      	ldr	r0, [r3, #12]
 8006f08:	893b      	ldrh	r3, [r7, #8]
 8006f0a:	7af9      	ldrb	r1, [r7, #11]
 8006f0c:	687a      	ldr	r2, [r7, #4]
 8006f0e:	47a0      	blx	r4
 8006f10:	6178      	str	r0, [r7, #20]
  return ret;
 8006f12:	697b      	ldr	r3, [r7, #20]
}
 8006f14:	4618      	mov	r0, r3
 8006f16:	371c      	adds	r7, #28
 8006f18:	46bd      	mov	sp, r7
 8006f1a:	bd90      	pop	{r4, r7, pc}

08006f1c <lis2duxs12_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t __weak lis2duxs12_write_reg(stmdev_ctx_t* ctx, uint8_t reg, uint8_t* data,
                                    uint16_t len)
{
 8006f1c:	b590      	push	{r4, r7, lr}
 8006f1e:	b087      	sub	sp, #28
 8006f20:	af00      	add	r7, sp, #0
 8006f22:	60f8      	str	r0, [r7, #12]
 8006f24:	607a      	str	r2, [r7, #4]
 8006f26:	461a      	mov	r2, r3
 8006f28:	460b      	mov	r3, r1
 8006f2a:	72fb      	strb	r3, [r7, #11]
 8006f2c:	4613      	mov	r3, r2
 8006f2e:	813b      	strh	r3, [r7, #8]
  int32_t ret;
  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8006f30:	68fb      	ldr	r3, [r7, #12]
 8006f32:	681c      	ldr	r4, [r3, #0]
 8006f34:	68fb      	ldr	r3, [r7, #12]
 8006f36:	68d8      	ldr	r0, [r3, #12]
 8006f38:	893b      	ldrh	r3, [r7, #8]
 8006f3a:	7af9      	ldrb	r1, [r7, #11]
 8006f3c:	687a      	ldr	r2, [r7, #4]
 8006f3e:	47a0      	blx	r4
 8006f40:	6178      	str	r0, [r7, #20]
  return ret;
 8006f42:	697b      	ldr	r3, [r7, #20]
}
 8006f44:	4618      	mov	r0, r3
 8006f46:	371c      	adds	r7, #28
 8006f48:	46bd      	mov	sp, r7
 8006f4a:	bd90      	pop	{r4, r7, pc}

08006f4c <lis2duxs12_from_fs2g_to_mg>:
  * @{
  *
  */

float_t lis2duxs12_from_fs2g_to_mg(int16_t lsb)
{
 8006f4c:	b480      	push	{r7}
 8006f4e:	b083      	sub	sp, #12
 8006f50:	af00      	add	r7, sp, #0
 8006f52:	4603      	mov	r3, r0
 8006f54:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.061f;
 8006f56:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8006f5a:	ee07 3a90 	vmov	s15, r3
 8006f5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006f62:	ed9f 7a05 	vldr	s14, [pc, #20]	@ 8006f78 <lis2duxs12_from_fs2g_to_mg+0x2c>
 8006f66:	ee67 7a87 	vmul.f32	s15, s15, s14
}
 8006f6a:	eeb0 0a67 	vmov.f32	s0, s15
 8006f6e:	370c      	adds	r7, #12
 8006f70:	46bd      	mov	sp, r7
 8006f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f76:	4770      	bx	lr
 8006f78:	3d79db23 	.word	0x3d79db23

08006f7c <lis2duxs12_from_fs4g_to_mg>:

float_t lis2duxs12_from_fs4g_to_mg(int16_t lsb)
{
 8006f7c:	b480      	push	{r7}
 8006f7e:	b083      	sub	sp, #12
 8006f80:	af00      	add	r7, sp, #0
 8006f82:	4603      	mov	r3, r0
 8006f84:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.122f;
 8006f86:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8006f8a:	ee07 3a90 	vmov	s15, r3
 8006f8e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006f92:	ed9f 7a05 	vldr	s14, [pc, #20]	@ 8006fa8 <lis2duxs12_from_fs4g_to_mg+0x2c>
 8006f96:	ee67 7a87 	vmul.f32	s15, s15, s14
}
 8006f9a:	eeb0 0a67 	vmov.f32	s0, s15
 8006f9e:	370c      	adds	r7, #12
 8006fa0:	46bd      	mov	sp, r7
 8006fa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006fa6:	4770      	bx	lr
 8006fa8:	3df9db23 	.word	0x3df9db23

08006fac <lis2duxs12_from_fs8g_to_mg>:

float_t lis2duxs12_from_fs8g_to_mg(int16_t lsb)
{
 8006fac:	b480      	push	{r7}
 8006fae:	b083      	sub	sp, #12
 8006fb0:	af00      	add	r7, sp, #0
 8006fb2:	4603      	mov	r3, r0
 8006fb4:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.244f;
 8006fb6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8006fba:	ee07 3a90 	vmov	s15, r3
 8006fbe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006fc2:	ed9f 7a05 	vldr	s14, [pc, #20]	@ 8006fd8 <lis2duxs12_from_fs8g_to_mg+0x2c>
 8006fc6:	ee67 7a87 	vmul.f32	s15, s15, s14
}
 8006fca:	eeb0 0a67 	vmov.f32	s0, s15
 8006fce:	370c      	adds	r7, #12
 8006fd0:	46bd      	mov	sp, r7
 8006fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006fd6:	4770      	bx	lr
 8006fd8:	3e79db23 	.word	0x3e79db23

08006fdc <lis2duxs12_from_fs16g_to_mg>:

float_t lis2duxs12_from_fs16g_to_mg(int16_t lsb)
{
 8006fdc:	b480      	push	{r7}
 8006fde:	b083      	sub	sp, #12
 8006fe0:	af00      	add	r7, sp, #0
 8006fe2:	4603      	mov	r3, r0
 8006fe4:	80fb      	strh	r3, [r7, #6]
  return (float_t)lsb * 0.488f;
 8006fe6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8006fea:	ee07 3a90 	vmov	s15, r3
 8006fee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006ff2:	ed9f 7a05 	vldr	s14, [pc, #20]	@ 8007008 <lis2duxs12_from_fs16g_to_mg+0x2c>
 8006ff6:	ee67 7a87 	vmul.f32	s15, s15, s14
}
 8006ffa:	eeb0 0a67 	vmov.f32	s0, s15
 8006ffe:	370c      	adds	r7, #12
 8007000:	46bd      	mov	sp, r7
 8007002:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007006:	4770      	bx	lr
 8007008:	3ef9db23 	.word	0x3ef9db23

0800700c <lis2duxs12_device_id_get>:
  * @param  val      Device ID.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_device_id_get(stmdev_ctx_t *ctx, uint8_t *val)
{
 800700c:	b580      	push	{r7, lr}
 800700e:	b084      	sub	sp, #16
 8007010:	af00      	add	r7, sp, #0
 8007012:	6078      	str	r0, [r7, #4]
 8007014:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = lis2duxs12_read_reg(ctx, LIS2DUXS12_WHO_AM_I, val, 1);
 8007016:	2301      	movs	r3, #1
 8007018:	683a      	ldr	r2, [r7, #0]
 800701a:	210f      	movs	r1, #15
 800701c:	6878      	ldr	r0, [r7, #4]
 800701e:	f7ff ff65 	bl	8006eec <lis2duxs12_read_reg>
 8007022:	60f8      	str	r0, [r7, #12]

  return ret;
 8007024:	68fb      	ldr	r3, [r7, #12]
}
 8007026:	4618      	mov	r0, r3
 8007028:	3710      	adds	r7, #16
 800702a:	46bd      	mov	sp, r7
 800702c:	bd80      	pop	{r7, pc}
	...

08007030 <lis2duxs12_init_set>:
  * @param  val   configures the bus operating mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_init_set(stmdev_ctx_t *ctx, lis2duxs12_init_t val)
{
 8007030:	b580      	push	{r7, lr}
 8007032:	b086      	sub	sp, #24
 8007034:	af00      	add	r7, sp, #0
 8007036:	6078      	str	r0, [r7, #4]
 8007038:	460b      	mov	r3, r1
 800703a:	70fb      	strb	r3, [r7, #3]
  lis2duxs12_ctrl1_t ctrl1;
  lis2duxs12_ctrl4_t ctrl4;
  int32_t ret = 0;
 800703c:	2300      	movs	r3, #0
 800703e:	617b      	str	r3, [r7, #20]

  ret += lis2duxs12_read_reg(ctx, LIS2DUXS12_CTRL1, (uint8_t*)&ctrl1, 1);
 8007040:	f107 0210 	add.w	r2, r7, #16
 8007044:	2301      	movs	r3, #1
 8007046:	2110      	movs	r1, #16
 8007048:	6878      	ldr	r0, [r7, #4]
 800704a:	f7ff ff4f 	bl	8006eec <lis2duxs12_read_reg>
 800704e:	4602      	mov	r2, r0
 8007050:	697b      	ldr	r3, [r7, #20]
 8007052:	4413      	add	r3, r2
 8007054:	617b      	str	r3, [r7, #20]
  ret += lis2duxs12_read_reg(ctx, LIS2DUXS12_CTRL4, (uint8_t*)&ctrl4, 1);
 8007056:	f107 020c 	add.w	r2, r7, #12
 800705a:	2301      	movs	r3, #1
 800705c:	2113      	movs	r1, #19
 800705e:	6878      	ldr	r0, [r7, #4]
 8007060:	f7ff ff44 	bl	8006eec <lis2duxs12_read_reg>
 8007064:	4602      	mov	r2, r0
 8007066:	697b      	ldr	r3, [r7, #20]
 8007068:	4413      	add	r3, r2
 800706a:	617b      	str	r3, [r7, #20]
  switch (val) {
 800706c:	78fb      	ldrb	r3, [r7, #3]
 800706e:	2b03      	cmp	r3, #3
 8007070:	d870      	bhi.n	8007154 <lis2duxs12_init_set+0x124>
 8007072:	a201      	add	r2, pc, #4	@ (adr r2, 8007078 <lis2duxs12_init_set+0x48>)
 8007074:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007078:	080070c9 	.word	0x080070c9
 800707c:	08007089 	.word	0x08007089
 8007080:	080070a9 	.word	0x080070a9
 8007084:	0800710f 	.word	0x0800710f
    case LIS2DUXS12_BOOT:
      ctrl4.boot = PROPERTY_ENABLE;
 8007088:	7b3b      	ldrb	r3, [r7, #12]
 800708a:	f043 0301 	orr.w	r3, r3, #1
 800708e:	733b      	strb	r3, [r7, #12]
      ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL4, (uint8_t*)&ctrl4, 1);
 8007090:	f107 020c 	add.w	r2, r7, #12
 8007094:	2301      	movs	r3, #1
 8007096:	2113      	movs	r1, #19
 8007098:	6878      	ldr	r0, [r7, #4]
 800709a:	f7ff ff3f 	bl	8006f1c <lis2duxs12_write_reg>
 800709e:	4602      	mov	r2, r0
 80070a0:	697b      	ldr	r3, [r7, #20]
 80070a2:	4413      	add	r3, r2
 80070a4:	617b      	str	r3, [r7, #20]
      break;
 80070a6:	e065      	b.n	8007174 <lis2duxs12_init_set+0x144>
    case LIS2DUXS12_RESET:

      ctrl1.sw_reset = PROPERTY_ENABLE;
 80070a8:	7c3b      	ldrb	r3, [r7, #16]
 80070aa:	f043 0320 	orr.w	r3, r3, #32
 80070ae:	743b      	strb	r3, [r7, #16]
      ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL1, (uint8_t*)&ctrl1, 1);
 80070b0:	f107 0210 	add.w	r2, r7, #16
 80070b4:	2301      	movs	r3, #1
 80070b6:	2110      	movs	r1, #16
 80070b8:	6878      	ldr	r0, [r7, #4]
 80070ba:	f7ff ff2f 	bl	8006f1c <lis2duxs12_write_reg>
 80070be:	4602      	mov	r2, r0
 80070c0:	697b      	ldr	r3, [r7, #20]
 80070c2:	4413      	add	r3, r2
 80070c4:	617b      	str	r3, [r7, #20]
      break;
 80070c6:	e055      	b.n	8007174 <lis2duxs12_init_set+0x144>
    case LIS2DUXS12_SENSOR_ONLY_ON:
      /* no embedded funcs are used */
      ctrl4.emb_func_en = PROPERTY_DISABLE;
 80070c8:	7b3b      	ldrb	r3, [r7, #12]
 80070ca:	f36f 1304 	bfc	r3, #4, #1
 80070ce:	733b      	strb	r3, [r7, #12]
      ctrl4.bdu = PROPERTY_ENABLE;
 80070d0:	7b3b      	ldrb	r3, [r7, #12]
 80070d2:	f043 0320 	orr.w	r3, r3, #32
 80070d6:	733b      	strb	r3, [r7, #12]
      ctrl1.if_add_inc = PROPERTY_ENABLE;
 80070d8:	7c3b      	ldrb	r3, [r7, #16]
 80070da:	f043 0310 	orr.w	r3, r3, #16
 80070de:	743b      	strb	r3, [r7, #16]
      ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL4, (uint8_t*)&ctrl4, 1);
 80070e0:	f107 020c 	add.w	r2, r7, #12
 80070e4:	2301      	movs	r3, #1
 80070e6:	2113      	movs	r1, #19
 80070e8:	6878      	ldr	r0, [r7, #4]
 80070ea:	f7ff ff17 	bl	8006f1c <lis2duxs12_write_reg>
 80070ee:	4602      	mov	r2, r0
 80070f0:	697b      	ldr	r3, [r7, #20]
 80070f2:	4413      	add	r3, r2
 80070f4:	617b      	str	r3, [r7, #20]
      ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL1, (uint8_t*)&ctrl1, 1);
 80070f6:	f107 0210 	add.w	r2, r7, #16
 80070fa:	2301      	movs	r3, #1
 80070fc:	2110      	movs	r1, #16
 80070fe:	6878      	ldr	r0, [r7, #4]
 8007100:	f7ff ff0c 	bl	8006f1c <lis2duxs12_write_reg>
 8007104:	4602      	mov	r2, r0
 8007106:	697b      	ldr	r3, [r7, #20]
 8007108:	4413      	add	r3, r2
 800710a:	617b      	str	r3, [r7, #20]
      break;
 800710c:	e032      	b.n	8007174 <lis2duxs12_init_set+0x144>
    case LIS2DUXS12_SENSOR_EMB_FUNC_ON:
      /* complete configuration is used */
      ctrl4.emb_func_en = PROPERTY_ENABLE;
 800710e:	7b3b      	ldrb	r3, [r7, #12]
 8007110:	f043 0310 	orr.w	r3, r3, #16
 8007114:	733b      	strb	r3, [r7, #12]
      ctrl4.bdu = PROPERTY_ENABLE;
 8007116:	7b3b      	ldrb	r3, [r7, #12]
 8007118:	f043 0320 	orr.w	r3, r3, #32
 800711c:	733b      	strb	r3, [r7, #12]
      ctrl1.if_add_inc = PROPERTY_ENABLE;
 800711e:	7c3b      	ldrb	r3, [r7, #16]
 8007120:	f043 0310 	orr.w	r3, r3, #16
 8007124:	743b      	strb	r3, [r7, #16]
      ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL4, (uint8_t*)&ctrl4, 1);
 8007126:	f107 020c 	add.w	r2, r7, #12
 800712a:	2301      	movs	r3, #1
 800712c:	2113      	movs	r1, #19
 800712e:	6878      	ldr	r0, [r7, #4]
 8007130:	f7ff fef4 	bl	8006f1c <lis2duxs12_write_reg>
 8007134:	4602      	mov	r2, r0
 8007136:	697b      	ldr	r3, [r7, #20]
 8007138:	4413      	add	r3, r2
 800713a:	617b      	str	r3, [r7, #20]
      ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL1, (uint8_t*)&ctrl1, 1);
 800713c:	f107 0210 	add.w	r2, r7, #16
 8007140:	2301      	movs	r3, #1
 8007142:	2110      	movs	r1, #16
 8007144:	6878      	ldr	r0, [r7, #4]
 8007146:	f7ff fee9 	bl	8006f1c <lis2duxs12_write_reg>
 800714a:	4602      	mov	r2, r0
 800714c:	697b      	ldr	r3, [r7, #20]
 800714e:	4413      	add	r3, r2
 8007150:	617b      	str	r3, [r7, #20]
      break;
 8007152:	e00f      	b.n	8007174 <lis2duxs12_init_set+0x144>
    default:
      ctrl1.sw_reset = PROPERTY_ENABLE;
 8007154:	7c3b      	ldrb	r3, [r7, #16]
 8007156:	f043 0320 	orr.w	r3, r3, #32
 800715a:	743b      	strb	r3, [r7, #16]
      ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL1, (uint8_t*)&ctrl1, 1);
 800715c:	f107 0210 	add.w	r2, r7, #16
 8007160:	2301      	movs	r3, #1
 8007162:	2110      	movs	r1, #16
 8007164:	6878      	ldr	r0, [r7, #4]
 8007166:	f7ff fed9 	bl	8006f1c <lis2duxs12_write_reg>
 800716a:	4602      	mov	r2, r0
 800716c:	697b      	ldr	r3, [r7, #20]
 800716e:	4413      	add	r3, r2
 8007170:	617b      	str	r3, [r7, #20]
      break;
 8007172:	bf00      	nop
  }
  return ret;
 8007174:	697b      	ldr	r3, [r7, #20]
}
 8007176:	4618      	mov	r0, r3
 8007178:	3718      	adds	r7, #24
 800717a:	46bd      	mov	sp, r7
 800717c:	bd80      	pop	{r7, pc}
 800717e:	bf00      	nop

08007180 <lis2duxs12_mode_set>:
  * @param  val   set the sensor FS and ODR.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_mode_set(stmdev_ctx_t *ctx, lis2duxs12_md_t *val)
{
 8007180:	b580      	push	{r7, lr}
 8007182:	b086      	sub	sp, #24
 8007184:	af00      	add	r7, sp, #0
 8007186:	6078      	str	r0, [r7, #4]
 8007188:	6039      	str	r1, [r7, #0]
  lis2duxs12_ctrl3_t ctrl3;
  lis2duxs12_ctrl5_t ctrl5;
  int32_t ret;

  ret = lis2duxs12_read_reg(ctx, LIS2DUXS12_CTRL5, (uint8_t*)&ctrl5, 1);
 800718a:	f107 020c 	add.w	r2, r7, #12
 800718e:	2301      	movs	r3, #1
 8007190:	2114      	movs	r1, #20
 8007192:	6878      	ldr	r0, [r7, #4]
 8007194:	f7ff feaa 	bl	8006eec <lis2duxs12_read_reg>
 8007198:	6178      	str	r0, [r7, #20]

  ctrl5.odr = (uint8_t)val->odr & 0xFU;
 800719a:	683b      	ldr	r3, [r7, #0]
 800719c:	781b      	ldrb	r3, [r3, #0]
 800719e:	f003 030f 	and.w	r3, r3, #15
 80071a2:	b2da      	uxtb	r2, r3
 80071a4:	7b3b      	ldrb	r3, [r7, #12]
 80071a6:	f362 1307 	bfi	r3, r2, #4, #4
 80071aa:	733b      	strb	r3, [r7, #12]
  ctrl5.fs = (uint8_t)val->fs;
 80071ac:	683b      	ldr	r3, [r7, #0]
 80071ae:	785b      	ldrb	r3, [r3, #1]
 80071b0:	f003 0303 	and.w	r3, r3, #3
 80071b4:	b2da      	uxtb	r2, r3
 80071b6:	7b3b      	ldrb	r3, [r7, #12]
 80071b8:	f362 0301 	bfi	r3, r2, #0, #2
 80071bc:	733b      	strb	r3, [r7, #12]

  /* set the bandwidth */
  switch (val->odr) {
 80071be:	683b      	ldr	r3, [r7, #0]
 80071c0:	781b      	ldrb	r3, [r3, #0]
 80071c2:	2b2f      	cmp	r3, #47	@ 0x2f
 80071c4:	f200 80c8 	bhi.w	8007358 <lis2duxs12_mode_set+0x1d8>
 80071c8:	a201      	add	r2, pc, #4	@ (adr r2, 80071d0 <lis2duxs12_mode_set+0x50>)
 80071ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80071ce:	bf00      	nop
 80071d0:	08007291 	.word	0x08007291
 80071d4:	08007291 	.word	0x08007291
 80071d8:	08007291 	.word	0x08007291
 80071dc:	08007291 	.word	0x08007291
 80071e0:	0800729b 	.word	0x0800729b
 80071e4:	080072bf 	.word	0x080072bf
 80071e8:	080072f3 	.word	0x080072f3
 80071ec:	0800733b 	.word	0x0800733b
 80071f0:	0800733b 	.word	0x0800733b
 80071f4:	0800733b 	.word	0x0800733b
 80071f8:	0800733b 	.word	0x0800733b
 80071fc:	0800733b 	.word	0x0800733b
 8007200:	08007359 	.word	0x08007359
 8007204:	08007359 	.word	0x08007359
 8007208:	08007359 	.word	0x08007359
 800720c:	08007359 	.word	0x08007359
 8007210:	08007359 	.word	0x08007359
 8007214:	08007359 	.word	0x08007359
 8007218:	08007359 	.word	0x08007359
 800721c:	08007359 	.word	0x08007359
 8007220:	0800733b 	.word	0x0800733b
 8007224:	0800733b 	.word	0x0800733b
 8007228:	0800733b 	.word	0x0800733b
 800722c:	0800733b 	.word	0x0800733b
 8007230:	0800733b 	.word	0x0800733b
 8007234:	0800733b 	.word	0x0800733b
 8007238:	0800733b 	.word	0x0800733b
 800723c:	0800733b 	.word	0x0800733b
 8007240:	08007359 	.word	0x08007359
 8007244:	08007359 	.word	0x08007359
 8007248:	08007359 	.word	0x08007359
 800724c:	08007359 	.word	0x08007359
 8007250:	08007359 	.word	0x08007359
 8007254:	08007359 	.word	0x08007359
 8007258:	08007359 	.word	0x08007359
 800725c:	08007359 	.word	0x08007359
 8007260:	08007359 	.word	0x08007359
 8007264:	08007359 	.word	0x08007359
 8007268:	08007359 	.word	0x08007359
 800726c:	08007359 	.word	0x08007359
 8007270:	08007359 	.word	0x08007359
 8007274:	08007359 	.word	0x08007359
 8007278:	08007359 	.word	0x08007359
 800727c:	08007359 	.word	0x08007359
 8007280:	08007359 	.word	0x08007359
 8007284:	08007359 	.word	0x08007359
 8007288:	0800733b 	.word	0x0800733b
 800728c:	0800733b 	.word	0x0800733b
    /* no anti-aliasing filter present */
    case LIS2DUXS12_OFF:
    case LIS2DUXS12_1Hz6_ULP:
    case LIS2DUXS12_3Hz_ULP:
    case LIS2DUXS12_25Hz_ULP:
      ctrl5.bw = 0x0;
 8007290:	7b3b      	ldrb	r3, [r7, #12]
 8007292:	f36f 0383 	bfc	r3, #2, #2
 8007296:	733b      	strb	r3, [r7, #12]
      break;
 8007298:	e05e      	b.n	8007358 <lis2duxs12_mode_set+0x1d8>

    /* low-power mode with ODR < 50 Hz */
    case LIS2DUXS12_6Hz_LP:
      switch(val->bw) {
 800729a:	683b      	ldr	r3, [r7, #0]
 800729c:	789b      	ldrb	r3, [r3, #2]
 800729e:	2b00      	cmp	r3, #0
 80072a0:	d007      	beq.n	80072b2 <lis2duxs12_mode_set+0x132>
 80072a2:	2b00      	cmp	r3, #0
 80072a4:	db53      	blt.n	800734e <lis2duxs12_mode_set+0x1ce>
 80072a6:	3b01      	subs	r3, #1
 80072a8:	2b02      	cmp	r3, #2
 80072aa:	d850      	bhi.n	800734e <lis2duxs12_mode_set+0x1ce>
        case LIS2DUXS12_ODR_div_4:
        case LIS2DUXS12_ODR_div_8:
        case LIS2DUXS12_ODR_div_16:
          return -1;
 80072ac:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80072b0:	e081      	b.n	80073b6 <lis2duxs12_mode_set+0x236>
        case LIS2DUXS12_ODR_div_2:
          ctrl5.bw = 0x3;
 80072b2:	7b3b      	ldrb	r3, [r7, #12]
 80072b4:	f043 030c 	orr.w	r3, r3, #12
 80072b8:	733b      	strb	r3, [r7, #12]
          break;
 80072ba:	bf00      	nop
      }
      break;
 80072bc:	e047      	b.n	800734e <lis2duxs12_mode_set+0x1ce>
    case LIS2DUXS12_12Hz5_LP:
      switch(val->bw) {
 80072be:	683b      	ldr	r3, [r7, #0]
 80072c0:	789b      	ldrb	r3, [r3, #2]
 80072c2:	2b03      	cmp	r3, #3
 80072c4:	dc45      	bgt.n	8007352 <lis2duxs12_mode_set+0x1d2>
 80072c6:	2b02      	cmp	r3, #2
 80072c8:	da04      	bge.n	80072d4 <lis2duxs12_mode_set+0x154>
 80072ca:	2b00      	cmp	r3, #0
 80072cc:	d005      	beq.n	80072da <lis2duxs12_mode_set+0x15a>
 80072ce:	2b01      	cmp	r3, #1
 80072d0:	d009      	beq.n	80072e6 <lis2duxs12_mode_set+0x166>
          break;
        case LIS2DUXS12_ODR_div_4:
          ctrl5.bw = 0x3;
          break;
      }
      break;
 80072d2:	e03e      	b.n	8007352 <lis2duxs12_mode_set+0x1d2>
          return -1;
 80072d4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80072d8:	e06d      	b.n	80073b6 <lis2duxs12_mode_set+0x236>
          ctrl5.bw = 0x2;
 80072da:	7b3b      	ldrb	r3, [r7, #12]
 80072dc:	2202      	movs	r2, #2
 80072de:	f362 0383 	bfi	r3, r2, #2, #2
 80072e2:	733b      	strb	r3, [r7, #12]
          break;
 80072e4:	e004      	b.n	80072f0 <lis2duxs12_mode_set+0x170>
          ctrl5.bw = 0x3;
 80072e6:	7b3b      	ldrb	r3, [r7, #12]
 80072e8:	f043 030c 	orr.w	r3, r3, #12
 80072ec:	733b      	strb	r3, [r7, #12]
          break;
 80072ee:	bf00      	nop
      break;
 80072f0:	e02f      	b.n	8007352 <lis2duxs12_mode_set+0x1d2>
    case LIS2DUXS12_25Hz_LP:
      switch(val->bw) {
 80072f2:	683b      	ldr	r3, [r7, #0]
 80072f4:	789b      	ldrb	r3, [r3, #2]
 80072f6:	2b03      	cmp	r3, #3
 80072f8:	d82d      	bhi.n	8007356 <lis2duxs12_mode_set+0x1d6>
 80072fa:	a201      	add	r2, pc, #4	@ (adr r2, 8007300 <lis2duxs12_mode_set+0x180>)
 80072fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007300:	08007317 	.word	0x08007317
 8007304:	08007323 	.word	0x08007323
 8007308:	0800732f 	.word	0x0800732f
 800730c:	08007311 	.word	0x08007311
        case LIS2DUXS12_ODR_div_16:
          return -1;
 8007310:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007314:	e04f      	b.n	80073b6 <lis2duxs12_mode_set+0x236>
        case LIS2DUXS12_ODR_div_2:
          ctrl5.bw = 0x1;
 8007316:	7b3b      	ldrb	r3, [r7, #12]
 8007318:	2201      	movs	r2, #1
 800731a:	f362 0383 	bfi	r3, r2, #2, #2
 800731e:	733b      	strb	r3, [r7, #12]
          break;
 8007320:	e00a      	b.n	8007338 <lis2duxs12_mode_set+0x1b8>
        case LIS2DUXS12_ODR_div_4:
          ctrl5.bw = 0x2;
 8007322:	7b3b      	ldrb	r3, [r7, #12]
 8007324:	2202      	movs	r2, #2
 8007326:	f362 0383 	bfi	r3, r2, #2, #2
 800732a:	733b      	strb	r3, [r7, #12]
          break;
 800732c:	e004      	b.n	8007338 <lis2duxs12_mode_set+0x1b8>
        case LIS2DUXS12_ODR_div_8:
          ctrl5.bw = 0x3;
 800732e:	7b3b      	ldrb	r3, [r7, #12]
 8007330:	f043 030c 	orr.w	r3, r3, #12
 8007334:	733b      	strb	r3, [r7, #12]
          break;
 8007336:	bf00      	nop
      }
      break;
 8007338:	e00d      	b.n	8007356 <lis2duxs12_mode_set+0x1d6>
    case LIS2DUXS12_50Hz_HP:
    case LIS2DUXS12_100Hz_HP:
    case LIS2DUXS12_200Hz_HP:
    case LIS2DUXS12_400Hz_HP:
    case LIS2DUXS12_800Hz_HP:
      ctrl5.bw = (uint8_t)val->bw;
 800733a:	683b      	ldr	r3, [r7, #0]
 800733c:	789b      	ldrb	r3, [r3, #2]
 800733e:	f003 0303 	and.w	r3, r3, #3
 8007342:	b2da      	uxtb	r2, r3
 8007344:	7b3b      	ldrb	r3, [r7, #12]
 8007346:	f362 0383 	bfi	r3, r2, #2, #2
 800734a:	733b      	strb	r3, [r7, #12]
      break;
 800734c:	e004      	b.n	8007358 <lis2duxs12_mode_set+0x1d8>
      break;
 800734e:	bf00      	nop
 8007350:	e002      	b.n	8007358 <lis2duxs12_mode_set+0x1d8>
      break;
 8007352:	bf00      	nop
 8007354:	e000      	b.n	8007358 <lis2duxs12_mode_set+0x1d8>
      break;
 8007356:	bf00      	nop
  }

  ret += lis2duxs12_read_reg(ctx, LIS2DUXS12_CTRL3, (uint8_t*)&ctrl3, 1);
 8007358:	f107 0210 	add.w	r2, r7, #16
 800735c:	2301      	movs	r3, #1
 800735e:	2112      	movs	r1, #18
 8007360:	6878      	ldr	r0, [r7, #4]
 8007362:	f7ff fdc3 	bl	8006eec <lis2duxs12_read_reg>
 8007366:	4602      	mov	r2, r0
 8007368:	697b      	ldr	r3, [r7, #20]
 800736a:	4413      	add	r3, r2
 800736c:	617b      	str	r3, [r7, #20]

  ctrl3.hp_en = (((uint8_t)val->odr & 0x30U) == 0x10U) ? 1U : 0U;
 800736e:	683b      	ldr	r3, [r7, #0]
 8007370:	781b      	ldrb	r3, [r3, #0]
 8007372:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 8007376:	2b10      	cmp	r3, #16
 8007378:	d101      	bne.n	800737e <lis2duxs12_mode_set+0x1fe>
 800737a:	2201      	movs	r2, #1
 800737c:	e000      	b.n	8007380 <lis2duxs12_mode_set+0x200>
 800737e:	2200      	movs	r2, #0
 8007380:	7c3b      	ldrb	r3, [r7, #16]
 8007382:	f362 0382 	bfi	r3, r2, #2, #1
 8007386:	743b      	strb	r3, [r7, #16]

  if (ret == 0) {
 8007388:	697b      	ldr	r3, [r7, #20]
 800738a:	2b00      	cmp	r3, #0
 800738c:	d112      	bne.n	80073b4 <lis2duxs12_mode_set+0x234>
    ret = lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL5, (uint8_t*)&ctrl5, 1);
 800738e:	f107 020c 	add.w	r2, r7, #12
 8007392:	2301      	movs	r3, #1
 8007394:	2114      	movs	r1, #20
 8007396:	6878      	ldr	r0, [r7, #4]
 8007398:	f7ff fdc0 	bl	8006f1c <lis2duxs12_write_reg>
 800739c:	6178      	str	r0, [r7, #20]
    ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL3, (uint8_t*)&ctrl3, 1);
 800739e:	f107 0210 	add.w	r2, r7, #16
 80073a2:	2301      	movs	r3, #1
 80073a4:	2112      	movs	r1, #18
 80073a6:	6878      	ldr	r0, [r7, #4]
 80073a8:	f7ff fdb8 	bl	8006f1c <lis2duxs12_write_reg>
 80073ac:	4602      	mov	r2, r0
 80073ae:	697b      	ldr	r3, [r7, #20]
 80073b0:	4413      	add	r3, r2
 80073b2:	617b      	str	r3, [r7, #20]
  }

  return ret;
 80073b4:	697b      	ldr	r3, [r7, #20]
}
 80073b6:	4618      	mov	r0, r3
 80073b8:	3718      	adds	r7, #24
 80073ba:	46bd      	mov	sp, r7
 80073bc:	bd80      	pop	{r7, pc}
 80073be:	bf00      	nop

080073c0 <lis2duxs12_mode_get>:
  * @param  val   get the sensor FS and ODR.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_mode_get(stmdev_ctx_t *ctx, lis2duxs12_md_t *val)
{
 80073c0:	b580      	push	{r7, lr}
 80073c2:	b086      	sub	sp, #24
 80073c4:	af00      	add	r7, sp, #0
 80073c6:	6078      	str	r0, [r7, #4]
 80073c8:	6039      	str	r1, [r7, #0]
  lis2duxs12_ctrl3_t ctrl3;
  lis2duxs12_ctrl5_t ctrl5;
  int32_t ret;

  ret = lis2duxs12_read_reg(ctx, LIS2DUXS12_CTRL5, (uint8_t*)&ctrl5, 1);
 80073ca:	f107 020c 	add.w	r2, r7, #12
 80073ce:	2301      	movs	r3, #1
 80073d0:	2114      	movs	r1, #20
 80073d2:	6878      	ldr	r0, [r7, #4]
 80073d4:	f7ff fd8a 	bl	8006eec <lis2duxs12_read_reg>
 80073d8:	6178      	str	r0, [r7, #20]
  ret += lis2duxs12_read_reg(ctx, LIS2DUXS12_CTRL3, (uint8_t*)&ctrl3, 1);
 80073da:	f107 0210 	add.w	r2, r7, #16
 80073de:	2301      	movs	r3, #1
 80073e0:	2112      	movs	r1, #18
 80073e2:	6878      	ldr	r0, [r7, #4]
 80073e4:	f7ff fd82 	bl	8006eec <lis2duxs12_read_reg>
 80073e8:	4602      	mov	r2, r0
 80073ea:	697b      	ldr	r3, [r7, #20]
 80073ec:	4413      	add	r3, r2
 80073ee:	617b      	str	r3, [r7, #20]

  switch (ctrl5.odr) {
 80073f0:	7b3b      	ldrb	r3, [r7, #12]
 80073f2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80073f6:	b2db      	uxtb	r3, r3
 80073f8:	2b0b      	cmp	r3, #11
 80073fa:	f200 8083 	bhi.w	8007504 <lis2duxs12_mode_get+0x144>
 80073fe:	a201      	add	r2, pc, #4	@ (adr r2, 8007404 <lis2duxs12_mode_get+0x44>)
 8007400:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007404:	08007435 	.word	0x08007435
 8007408:	0800743d 	.word	0x0800743d
 800740c:	08007445 	.word	0x08007445
 8007410:	0800744d 	.word	0x0800744d
 8007414:	08007455 	.word	0x08007455
 8007418:	0800745d 	.word	0x0800745d
 800741c:	08007475 	.word	0x08007475
 8007420:	0800748d 	.word	0x0800748d
 8007424:	080074a5 	.word	0x080074a5
 8007428:	080074bd 	.word	0x080074bd
 800742c:	080074d5 	.word	0x080074d5
 8007430:	080074ed 	.word	0x080074ed
    case LIS2DUXS12_OFF:
      val->odr = LIS2DUXS12_OFF;
 8007434:	683b      	ldr	r3, [r7, #0]
 8007436:	2200      	movs	r2, #0
 8007438:	701a      	strb	r2, [r3, #0]
      break;
 800743a:	e067      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_1Hz6_ULP:
      val->odr = LIS2DUXS12_1Hz6_ULP;
 800743c:	683b      	ldr	r3, [r7, #0]
 800743e:	2201      	movs	r2, #1
 8007440:	701a      	strb	r2, [r3, #0]
      break;
 8007442:	e063      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_3Hz_ULP:
      val->odr = LIS2DUXS12_3Hz_ULP;
 8007444:	683b      	ldr	r3, [r7, #0]
 8007446:	2202      	movs	r2, #2
 8007448:	701a      	strb	r2, [r3, #0]
      break;
 800744a:	e05f      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_25Hz_ULP:
      val->odr = LIS2DUXS12_25Hz_ULP;
 800744c:	683b      	ldr	r3, [r7, #0]
 800744e:	2203      	movs	r2, #3
 8007450:	701a      	strb	r2, [r3, #0]
      break;
 8007452:	e05b      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_6Hz_LP:
      val->odr = LIS2DUXS12_6Hz_LP;
 8007454:	683b      	ldr	r3, [r7, #0]
 8007456:	2204      	movs	r2, #4
 8007458:	701a      	strb	r2, [r3, #0]
      break;
 800745a:	e057      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_12Hz5_LP:
      val->odr = (ctrl3.hp_en == 0x1U) ? LIS2DUXS12_12Hz5_HP : LIS2DUXS12_12Hz5_LP;
 800745c:	7c3b      	ldrb	r3, [r7, #16]
 800745e:	f003 0304 	and.w	r3, r3, #4
 8007462:	b2db      	uxtb	r3, r3
 8007464:	2b00      	cmp	r3, #0
 8007466:	d001      	beq.n	800746c <lis2duxs12_mode_get+0xac>
 8007468:	2215      	movs	r2, #21
 800746a:	e000      	b.n	800746e <lis2duxs12_mode_get+0xae>
 800746c:	2205      	movs	r2, #5
 800746e:	683b      	ldr	r3, [r7, #0]
 8007470:	701a      	strb	r2, [r3, #0]
      break;
 8007472:	e04b      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_25Hz_LP:
      val->odr = (ctrl3.hp_en == 0x1U) ? LIS2DUXS12_25Hz_HP : LIS2DUXS12_25Hz_LP;
 8007474:	7c3b      	ldrb	r3, [r7, #16]
 8007476:	f003 0304 	and.w	r3, r3, #4
 800747a:	b2db      	uxtb	r3, r3
 800747c:	2b00      	cmp	r3, #0
 800747e:	d001      	beq.n	8007484 <lis2duxs12_mode_get+0xc4>
 8007480:	2216      	movs	r2, #22
 8007482:	e000      	b.n	8007486 <lis2duxs12_mode_get+0xc6>
 8007484:	2206      	movs	r2, #6
 8007486:	683b      	ldr	r3, [r7, #0]
 8007488:	701a      	strb	r2, [r3, #0]
      break;
 800748a:	e03f      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_50Hz_LP:
      val->odr = (ctrl3.hp_en == 0x1U) ? LIS2DUXS12_50Hz_HP : LIS2DUXS12_50Hz_LP;
 800748c:	7c3b      	ldrb	r3, [r7, #16]
 800748e:	f003 0304 	and.w	r3, r3, #4
 8007492:	b2db      	uxtb	r3, r3
 8007494:	2b00      	cmp	r3, #0
 8007496:	d001      	beq.n	800749c <lis2duxs12_mode_get+0xdc>
 8007498:	2217      	movs	r2, #23
 800749a:	e000      	b.n	800749e <lis2duxs12_mode_get+0xde>
 800749c:	2207      	movs	r2, #7
 800749e:	683b      	ldr	r3, [r7, #0]
 80074a0:	701a      	strb	r2, [r3, #0]
      break;
 80074a2:	e033      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_100Hz_LP:
      val->odr = (ctrl3.hp_en == 0x1U) ? LIS2DUXS12_100Hz_HP : LIS2DUXS12_100Hz_LP;
 80074a4:	7c3b      	ldrb	r3, [r7, #16]
 80074a6:	f003 0304 	and.w	r3, r3, #4
 80074aa:	b2db      	uxtb	r3, r3
 80074ac:	2b00      	cmp	r3, #0
 80074ae:	d001      	beq.n	80074b4 <lis2duxs12_mode_get+0xf4>
 80074b0:	2218      	movs	r2, #24
 80074b2:	e000      	b.n	80074b6 <lis2duxs12_mode_get+0xf6>
 80074b4:	2208      	movs	r2, #8
 80074b6:	683b      	ldr	r3, [r7, #0]
 80074b8:	701a      	strb	r2, [r3, #0]
      break;
 80074ba:	e027      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_200Hz_LP:
      val->odr = (ctrl3.hp_en == 0x1U) ? LIS2DUXS12_200Hz_HP : LIS2DUXS12_200Hz_LP;
 80074bc:	7c3b      	ldrb	r3, [r7, #16]
 80074be:	f003 0304 	and.w	r3, r3, #4
 80074c2:	b2db      	uxtb	r3, r3
 80074c4:	2b00      	cmp	r3, #0
 80074c6:	d001      	beq.n	80074cc <lis2duxs12_mode_get+0x10c>
 80074c8:	2219      	movs	r2, #25
 80074ca:	e000      	b.n	80074ce <lis2duxs12_mode_get+0x10e>
 80074cc:	2209      	movs	r2, #9
 80074ce:	683b      	ldr	r3, [r7, #0]
 80074d0:	701a      	strb	r2, [r3, #0]
      break;
 80074d2:	e01b      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_400Hz_LP:
      val->odr = (ctrl3.hp_en == 0x1U) ? LIS2DUXS12_400Hz_HP : LIS2DUXS12_400Hz_LP;
 80074d4:	7c3b      	ldrb	r3, [r7, #16]
 80074d6:	f003 0304 	and.w	r3, r3, #4
 80074da:	b2db      	uxtb	r3, r3
 80074dc:	2b00      	cmp	r3, #0
 80074de:	d001      	beq.n	80074e4 <lis2duxs12_mode_get+0x124>
 80074e0:	221a      	movs	r2, #26
 80074e2:	e000      	b.n	80074e6 <lis2duxs12_mode_get+0x126>
 80074e4:	220a      	movs	r2, #10
 80074e6:	683b      	ldr	r3, [r7, #0]
 80074e8:	701a      	strb	r2, [r3, #0]
      break;
 80074ea:	e00f      	b.n	800750c <lis2duxs12_mode_get+0x14c>
    case LIS2DUXS12_800Hz_LP:
      val->odr = (ctrl3.hp_en == 0x1U) ? LIS2DUXS12_800Hz_HP : LIS2DUXS12_800Hz_LP;
 80074ec:	7c3b      	ldrb	r3, [r7, #16]
 80074ee:	f003 0304 	and.w	r3, r3, #4
 80074f2:	b2db      	uxtb	r3, r3
 80074f4:	2b00      	cmp	r3, #0
 80074f6:	d001      	beq.n	80074fc <lis2duxs12_mode_get+0x13c>
 80074f8:	221b      	movs	r2, #27
 80074fa:	e000      	b.n	80074fe <lis2duxs12_mode_get+0x13e>
 80074fc:	220b      	movs	r2, #11
 80074fe:	683b      	ldr	r3, [r7, #0]
 8007500:	701a      	strb	r2, [r3, #0]
      break;
 8007502:	e003      	b.n	800750c <lis2duxs12_mode_get+0x14c>
      break;
    case LIS2DUXS12_TRIG_SW:
      val->odr = LIS2DUXS12_TRIG_SW;
      break;
    default:
      val->odr = LIS2DUXS12_OFF;
 8007504:	683b      	ldr	r3, [r7, #0]
 8007506:	2200      	movs	r2, #0
 8007508:	701a      	strb	r2, [r3, #0]
      break;
 800750a:	bf00      	nop
  }

  switch (ctrl5.fs) {
 800750c:	7b3b      	ldrb	r3, [r7, #12]
 800750e:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8007512:	b2db      	uxtb	r3, r3
 8007514:	2b03      	cmp	r3, #3
 8007516:	d81b      	bhi.n	8007550 <lis2duxs12_mode_get+0x190>
 8007518:	a201      	add	r2, pc, #4	@ (adr r2, 8007520 <lis2duxs12_mode_get+0x160>)
 800751a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800751e:	bf00      	nop
 8007520:	08007531 	.word	0x08007531
 8007524:	08007539 	.word	0x08007539
 8007528:	08007541 	.word	0x08007541
 800752c:	08007549 	.word	0x08007549
    case LIS2DUXS12_2g:
      val->fs = LIS2DUXS12_2g;
 8007530:	683b      	ldr	r3, [r7, #0]
 8007532:	2200      	movs	r2, #0
 8007534:	705a      	strb	r2, [r3, #1]
      break;
 8007536:	e00f      	b.n	8007558 <lis2duxs12_mode_get+0x198>
    case LIS2DUXS12_4g:
      val->fs = LIS2DUXS12_4g;
 8007538:	683b      	ldr	r3, [r7, #0]
 800753a:	2201      	movs	r2, #1
 800753c:	705a      	strb	r2, [r3, #1]
      break;
 800753e:	e00b      	b.n	8007558 <lis2duxs12_mode_get+0x198>
    case LIS2DUXS12_8g:
      val->fs = LIS2DUXS12_8g;
 8007540:	683b      	ldr	r3, [r7, #0]
 8007542:	2202      	movs	r2, #2
 8007544:	705a      	strb	r2, [r3, #1]
      break;
 8007546:	e007      	b.n	8007558 <lis2duxs12_mode_get+0x198>
    case LIS2DUXS12_16g:
      val->fs = LIS2DUXS12_16g;
 8007548:	683b      	ldr	r3, [r7, #0]
 800754a:	2203      	movs	r2, #3
 800754c:	705a      	strb	r2, [r3, #1]
      break;
 800754e:	e003      	b.n	8007558 <lis2duxs12_mode_get+0x198>
    default:
      val->fs = LIS2DUXS12_2g;
 8007550:	683b      	ldr	r3, [r7, #0]
 8007552:	2200      	movs	r2, #0
 8007554:	705a      	strb	r2, [r3, #1]
      break;
 8007556:	bf00      	nop
  }

  switch (ctrl5.bw) {
 8007558:	7b3b      	ldrb	r3, [r7, #12]
 800755a:	f3c3 0381 	ubfx	r3, r3, #2, #2
 800755e:	b2db      	uxtb	r3, r3
 8007560:	2b03      	cmp	r3, #3
 8007562:	d81b      	bhi.n	800759c <lis2duxs12_mode_get+0x1dc>
 8007564:	a201      	add	r2, pc, #4	@ (adr r2, 800756c <lis2duxs12_mode_get+0x1ac>)
 8007566:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800756a:	bf00      	nop
 800756c:	0800757d 	.word	0x0800757d
 8007570:	08007585 	.word	0x08007585
 8007574:	0800758d 	.word	0x0800758d
 8007578:	08007595 	.word	0x08007595
    case LIS2DUXS12_ODR_div_2:
      val->bw = LIS2DUXS12_ODR_div_2;
 800757c:	683b      	ldr	r3, [r7, #0]
 800757e:	2200      	movs	r2, #0
 8007580:	709a      	strb	r2, [r3, #2]
      break;
 8007582:	e00f      	b.n	80075a4 <lis2duxs12_mode_get+0x1e4>
    case LIS2DUXS12_ODR_div_4:
      val->bw = LIS2DUXS12_ODR_div_4;
 8007584:	683b      	ldr	r3, [r7, #0]
 8007586:	2201      	movs	r2, #1
 8007588:	709a      	strb	r2, [r3, #2]
      break;
 800758a:	e00b      	b.n	80075a4 <lis2duxs12_mode_get+0x1e4>
    case LIS2DUXS12_ODR_div_8:
      val->bw = LIS2DUXS12_ODR_div_8;
 800758c:	683b      	ldr	r3, [r7, #0]
 800758e:	2202      	movs	r2, #2
 8007590:	709a      	strb	r2, [r3, #2]
      break;
 8007592:	e007      	b.n	80075a4 <lis2duxs12_mode_get+0x1e4>
    case LIS2DUXS12_ODR_div_16:
      val->bw = LIS2DUXS12_ODR_div_16;
 8007594:	683b      	ldr	r3, [r7, #0]
 8007596:	2203      	movs	r2, #3
 8007598:	709a      	strb	r2, [r3, #2]
      break;
 800759a:	e003      	b.n	80075a4 <lis2duxs12_mode_get+0x1e4>
    default:
      val->bw = LIS2DUXS12_ODR_div_2;
 800759c:	683b      	ldr	r3, [r7, #0]
 800759e:	2200      	movs	r2, #0
 80075a0:	709a      	strb	r2, [r3, #2]
      break;
 80075a2:	bf00      	nop
  }

  return ret;
 80075a4:	697b      	ldr	r3, [r7, #20]
}
 80075a6:	4618      	mov	r0, r3
 80075a8:	3718      	adds	r7, #24
 80075aa:	46bd      	mov	sp, r7
 80075ac:	bd80      	pop	{r7, pc}
 80075ae:	bf00      	nop

080075b0 <lis2duxs12_exit_deep_power_down>:
  * @param  val      Enter soft power down in SPI case
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_exit_deep_power_down(stmdev_ctx_t *ctx)
{
 80075b0:	b580      	push	{r7, lr}
 80075b2:	b084      	sub	sp, #16
 80075b4:	af00      	add	r7, sp, #0
 80075b6:	6078      	str	r0, [r7, #4]
  lis2duxs12_if_wake_up_t if_wake_up = {0};
 80075b8:	2300      	movs	r3, #0
 80075ba:	723b      	strb	r3, [r7, #8]
  int32_t ret;

  if_wake_up.soft_pd = PROPERTY_ENABLE;
 80075bc:	7a3b      	ldrb	r3, [r7, #8]
 80075be:	f043 0301 	orr.w	r3, r3, #1
 80075c2:	723b      	strb	r3, [r7, #8]
  ret = lis2duxs12_write_reg(ctx, LIS2DUXS12_IF_WAKE_UP, (uint8_t *)&if_wake_up, 1);
 80075c4:	f107 0208 	add.w	r2, r7, #8
 80075c8:	2301      	movs	r3, #1
 80075ca:	213e      	movs	r1, #62	@ 0x3e
 80075cc:	6878      	ldr	r0, [r7, #4]
 80075ce:	f7ff fca5 	bl	8006f1c <lis2duxs12_write_reg>
 80075d2:	60f8      	str	r0, [r7, #12]

  return ret;
 80075d4:	68fb      	ldr	r3, [r7, #12]
}
 80075d6:	4618      	mov	r0, r3
 80075d8:	3710      	adds	r7, #16
 80075da:	46bd      	mov	sp, r7
 80075dc:	bd80      	pop	{r7, pc}
	...

080075e0 <lis2duxs12_xl_data_get>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_xl_data_get(stmdev_ctx_t *ctx, lis2duxs12_md_t *md,
                          lis2duxs12_xl_data_t *data)
{
 80075e0:	b590      	push	{r4, r7, lr}
 80075e2:	b089      	sub	sp, #36	@ 0x24
 80075e4:	af00      	add	r7, sp, #0
 80075e6:	60f8      	str	r0, [r7, #12]
 80075e8:	60b9      	str	r1, [r7, #8]
 80075ea:	607a      	str	r2, [r7, #4]
  uint8_t buff[6];
  int32_t ret;
  uint8_t i;
  uint8_t j;

  ret = lis2duxs12_read_reg(ctx, LIS2DUXS12_OUT_X_L, buff, 6);
 80075ec:	f107 0210 	add.w	r2, r7, #16
 80075f0:	2306      	movs	r3, #6
 80075f2:	2128      	movs	r1, #40	@ 0x28
 80075f4:	68f8      	ldr	r0, [r7, #12]
 80075f6:	f7ff fc79 	bl	8006eec <lis2duxs12_read_reg>
 80075fa:	61b8      	str	r0, [r7, #24]

  /* acceleration conversion */
  j = 0U;
 80075fc:	2300      	movs	r3, #0
 80075fe:	77bb      	strb	r3, [r7, #30]
  for (i = 0U; i < 3U; i++) {
 8007600:	2300      	movs	r3, #0
 8007602:	77fb      	strb	r3, [r7, #31]
 8007604:	e08f      	b.n	8007726 <lis2duxs12_xl_data_get+0x146>
    data->raw[i] = (int16_t)buff[j+1U];
 8007606:	7fbb      	ldrb	r3, [r7, #30]
 8007608:	3301      	adds	r3, #1
 800760a:	3320      	adds	r3, #32
 800760c:	443b      	add	r3, r7
 800760e:	f813 2c10 	ldrb.w	r2, [r3, #-16]
 8007612:	7ffb      	ldrb	r3, [r7, #31]
 8007614:	b211      	sxth	r1, r2
 8007616:	687a      	ldr	r2, [r7, #4]
 8007618:	3304      	adds	r3, #4
 800761a:	005b      	lsls	r3, r3, #1
 800761c:	4413      	add	r3, r2
 800761e:	460a      	mov	r2, r1
 8007620:	809a      	strh	r2, [r3, #4]
    data->raw[i] = (data->raw[i] * 256) + (int16_t) buff[j];
 8007622:	7ffb      	ldrb	r3, [r7, #31]
 8007624:	687a      	ldr	r2, [r7, #4]
 8007626:	3304      	adds	r3, #4
 8007628:	005b      	lsls	r3, r3, #1
 800762a:	4413      	add	r3, r2
 800762c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8007630:	b29b      	uxth	r3, r3
 8007632:	021b      	lsls	r3, r3, #8
 8007634:	b29b      	uxth	r3, r3
 8007636:	7fba      	ldrb	r2, [r7, #30]
 8007638:	3220      	adds	r2, #32
 800763a:	443a      	add	r2, r7
 800763c:	f812 2c10 	ldrb.w	r2, [r2, #-16]
 8007640:	4413      	add	r3, r2
 8007642:	b29a      	uxth	r2, r3
 8007644:	7ffb      	ldrb	r3, [r7, #31]
 8007646:	b211      	sxth	r1, r2
 8007648:	687a      	ldr	r2, [r7, #4]
 800764a:	3304      	adds	r3, #4
 800764c:	005b      	lsls	r3, r3, #1
 800764e:	4413      	add	r3, r2
 8007650:	460a      	mov	r2, r1
 8007652:	809a      	strh	r2, [r3, #4]
    j+=2U;
 8007654:	7fbb      	ldrb	r3, [r7, #30]
 8007656:	3302      	adds	r3, #2
 8007658:	77bb      	strb	r3, [r7, #30]
    switch ( md->fs ) {
 800765a:	68bb      	ldr	r3, [r7, #8]
 800765c:	785b      	ldrb	r3, [r3, #1]
 800765e:	2b03      	cmp	r3, #3
 8007660:	d856      	bhi.n	8007710 <lis2duxs12_xl_data_get+0x130>
 8007662:	a201      	add	r2, pc, #4	@ (adr r2, 8007668 <lis2duxs12_xl_data_get+0x88>)
 8007664:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007668:	08007679 	.word	0x08007679
 800766c:	0800769f 	.word	0x0800769f
 8007670:	080076c5 	.word	0x080076c5
 8007674:	080076eb 	.word	0x080076eb
      case LIS2DUXS12_2g:
        data->mg[i] =lis2duxs12_from_fs2g_to_mg(data->raw[i]);
 8007678:	7ffb      	ldrb	r3, [r7, #31]
 800767a:	687a      	ldr	r2, [r7, #4]
 800767c:	3304      	adds	r3, #4
 800767e:	005b      	lsls	r3, r3, #1
 8007680:	4413      	add	r3, r2
 8007682:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8007686:	7ffc      	ldrb	r4, [r7, #31]
 8007688:	4618      	mov	r0, r3
 800768a:	f7ff fc5f 	bl	8006f4c <lis2duxs12_from_fs2g_to_mg>
 800768e:	eef0 7a40 	vmov.f32	s15, s0
 8007692:	687a      	ldr	r2, [r7, #4]
 8007694:	00a3      	lsls	r3, r4, #2
 8007696:	4413      	add	r3, r2
 8007698:	edc3 7a00 	vstr	s15, [r3]
        break;
 800769c:	e040      	b.n	8007720 <lis2duxs12_xl_data_get+0x140>
      case LIS2DUXS12_4g:
        data->mg[i] =lis2duxs12_from_fs4g_to_mg(data->raw[i]);
 800769e:	7ffb      	ldrb	r3, [r7, #31]
 80076a0:	687a      	ldr	r2, [r7, #4]
 80076a2:	3304      	adds	r3, #4
 80076a4:	005b      	lsls	r3, r3, #1
 80076a6:	4413      	add	r3, r2
 80076a8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80076ac:	7ffc      	ldrb	r4, [r7, #31]
 80076ae:	4618      	mov	r0, r3
 80076b0:	f7ff fc64 	bl	8006f7c <lis2duxs12_from_fs4g_to_mg>
 80076b4:	eef0 7a40 	vmov.f32	s15, s0
 80076b8:	687a      	ldr	r2, [r7, #4]
 80076ba:	00a3      	lsls	r3, r4, #2
 80076bc:	4413      	add	r3, r2
 80076be:	edc3 7a00 	vstr	s15, [r3]
        break;
 80076c2:	e02d      	b.n	8007720 <lis2duxs12_xl_data_get+0x140>
      case LIS2DUXS12_8g:
        data->mg[i] =lis2duxs12_from_fs8g_to_mg(data->raw[i]);
 80076c4:	7ffb      	ldrb	r3, [r7, #31]
 80076c6:	687a      	ldr	r2, [r7, #4]
 80076c8:	3304      	adds	r3, #4
 80076ca:	005b      	lsls	r3, r3, #1
 80076cc:	4413      	add	r3, r2
 80076ce:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80076d2:	7ffc      	ldrb	r4, [r7, #31]
 80076d4:	4618      	mov	r0, r3
 80076d6:	f7ff fc69 	bl	8006fac <lis2duxs12_from_fs8g_to_mg>
 80076da:	eef0 7a40 	vmov.f32	s15, s0
 80076de:	687a      	ldr	r2, [r7, #4]
 80076e0:	00a3      	lsls	r3, r4, #2
 80076e2:	4413      	add	r3, r2
 80076e4:	edc3 7a00 	vstr	s15, [r3]
        break;
 80076e8:	e01a      	b.n	8007720 <lis2duxs12_xl_data_get+0x140>
      case LIS2DUXS12_16g:
        data->mg[i] =lis2duxs12_from_fs16g_to_mg(data->raw[i]);
 80076ea:	7ffb      	ldrb	r3, [r7, #31]
 80076ec:	687a      	ldr	r2, [r7, #4]
 80076ee:	3304      	adds	r3, #4
 80076f0:	005b      	lsls	r3, r3, #1
 80076f2:	4413      	add	r3, r2
 80076f4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80076f8:	7ffc      	ldrb	r4, [r7, #31]
 80076fa:	4618      	mov	r0, r3
 80076fc:	f7ff fc6e 	bl	8006fdc <lis2duxs12_from_fs16g_to_mg>
 8007700:	eef0 7a40 	vmov.f32	s15, s0
 8007704:	687a      	ldr	r2, [r7, #4]
 8007706:	00a3      	lsls	r3, r4, #2
 8007708:	4413      	add	r3, r2
 800770a:	edc3 7a00 	vstr	s15, [r3]
        break;
 800770e:	e007      	b.n	8007720 <lis2duxs12_xl_data_get+0x140>
      default:
        data->mg[i] = 0.0f;
 8007710:	7ffb      	ldrb	r3, [r7, #31]
 8007712:	687a      	ldr	r2, [r7, #4]
 8007714:	009b      	lsls	r3, r3, #2
 8007716:	4413      	add	r3, r2
 8007718:	f04f 0200 	mov.w	r2, #0
 800771c:	601a      	str	r2, [r3, #0]
        break;
 800771e:	bf00      	nop
  for (i = 0U; i < 3U; i++) {
 8007720:	7ffb      	ldrb	r3, [r7, #31]
 8007722:	3301      	adds	r3, #1
 8007724:	77fb      	strb	r3, [r7, #31]
 8007726:	7ffb      	ldrb	r3, [r7, #31]
 8007728:	2b02      	cmp	r3, #2
 800772a:	f67f af6c 	bls.w	8007606 <lis2duxs12_xl_data_get+0x26>
    }
  }

  return ret;
 800772e:	69bb      	ldr	r3, [r7, #24]
}
 8007730:	4618      	mov	r0, r3
 8007732:	3724      	adds	r7, #36	@ 0x24
 8007734:	46bd      	mov	sp, r7
 8007736:	bd90      	pop	{r4, r7, pc}

08007738 <lis2duxs12_i3c_configure_set>:
  * @param  val   configuration params
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_i3c_configure_set(stmdev_ctx_t *ctx, lis2duxs12_i3c_cfg_t *val)
{
 8007738:	b580      	push	{r7, lr}
 800773a:	b084      	sub	sp, #16
 800773c:	af00      	add	r7, sp, #0
 800773e:	6078      	str	r0, [r7, #4]
 8007740:	6039      	str	r1, [r7, #0]
  lis2duxs12_i3c_if_ctrl_t i3c_cfg;
  int32_t ret;

  ret = lis2duxs12_read_reg(ctx, LIS2DUXS12_I3C_IF_CTRL, (uint8_t *)&i3c_cfg, 1);
 8007742:	f107 0208 	add.w	r2, r7, #8
 8007746:	2301      	movs	r3, #1
 8007748:	2133      	movs	r1, #51	@ 0x33
 800774a:	6878      	ldr	r0, [r7, #4]
 800774c:	f7ff fbce 	bl	8006eec <lis2duxs12_read_reg>
 8007750:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 8007752:	68fb      	ldr	r3, [r7, #12]
 8007754:	2b00      	cmp	r3, #0
 8007756:	d122      	bne.n	800779e <lis2duxs12_i3c_configure_set+0x66>
  {
    i3c_cfg.bus_act_sel = (uint8_t)val->bus_act_sel;
 8007758:	683b      	ldr	r3, [r7, #0]
 800775a:	781b      	ldrb	r3, [r3, #0]
 800775c:	f003 0303 	and.w	r3, r3, #3
 8007760:	b2da      	uxtb	r2, r3
 8007762:	7a3b      	ldrb	r3, [r7, #8]
 8007764:	f362 0301 	bfi	r3, r2, #0, #2
 8007768:	723b      	strb	r3, [r7, #8]
    i3c_cfg.dis_drstdaa = val->drstdaa_en;
 800776a:	683b      	ldr	r3, [r7, #0]
 800776c:	785b      	ldrb	r3, [r3, #1]
 800776e:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8007772:	b2da      	uxtb	r2, r3
 8007774:	7a3b      	ldrb	r3, [r7, #8]
 8007776:	f362 1386 	bfi	r3, r2, #6, #1
 800777a:	723b      	strb	r3, [r7, #8]
    i3c_cfg.asf_on = val->asf_on;
 800777c:	683b      	ldr	r3, [r7, #0]
 800777e:	785b      	ldrb	r3, [r3, #1]
 8007780:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8007784:	b2da      	uxtb	r2, r3
 8007786:	7a3b      	ldrb	r3, [r7, #8]
 8007788:	f362 1345 	bfi	r3, r2, #5, #1
 800778c:	723b      	strb	r3, [r7, #8]
    ret = lis2duxs12_write_reg(ctx, LIS2DUXS12_I3C_IF_CTRL, (uint8_t *)&i3c_cfg, 1);
 800778e:	f107 0208 	add.w	r2, r7, #8
 8007792:	2301      	movs	r3, #1
 8007794:	2133      	movs	r1, #51	@ 0x33
 8007796:	6878      	ldr	r0, [r7, #4]
 8007798:	f7ff fbc0 	bl	8006f1c <lis2duxs12_write_reg>
 800779c:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800779e:	68fb      	ldr	r3, [r7, #12]
}
 80077a0:	4618      	mov	r0, r3
 80077a2:	3710      	adds	r7, #16
 80077a4:	46bd      	mov	sp, r7
 80077a6:	bd80      	pop	{r7, pc}

080077a8 <lis2duxs12_i3c_configure_get>:
  * @param  ctx   communication interface handler.(ptr)
  * @param  val   configuration params
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */int32_t lis2duxs12_i3c_configure_get(stmdev_ctx_t *ctx, lis2duxs12_i3c_cfg_t *val)
{
 80077a8:	b580      	push	{r7, lr}
 80077aa:	b084      	sub	sp, #16
 80077ac:	af00      	add	r7, sp, #0
 80077ae:	6078      	str	r0, [r7, #4]
 80077b0:	6039      	str	r1, [r7, #0]
  lis2duxs12_i3c_if_ctrl_t i3c_cfg;
  int32_t ret;

  ret = lis2duxs12_read_reg(ctx, LIS2DUXS12_I3C_IF_CTRL, (uint8_t *)&i3c_cfg, 1);
 80077b2:	f107 0208 	add.w	r2, r7, #8
 80077b6:	2301      	movs	r3, #1
 80077b8:	2133      	movs	r1, #51	@ 0x33
 80077ba:	6878      	ldr	r0, [r7, #4]
 80077bc:	f7ff fb96 	bl	8006eec <lis2duxs12_read_reg>
 80077c0:	60f8      	str	r0, [r7, #12]

  val->drstdaa_en = i3c_cfg.dis_drstdaa;
 80077c2:	7a3b      	ldrb	r3, [r7, #8]
 80077c4:	f3c3 1380 	ubfx	r3, r3, #6, #1
 80077c8:	b2d9      	uxtb	r1, r3
 80077ca:	683a      	ldr	r2, [r7, #0]
 80077cc:	7853      	ldrb	r3, [r2, #1]
 80077ce:	f361 0341 	bfi	r3, r1, #1, #1
 80077d2:	7053      	strb	r3, [r2, #1]
  val->asf_on = i3c_cfg.asf_on;
 80077d4:	7a3b      	ldrb	r3, [r7, #8]
 80077d6:	f3c3 1340 	ubfx	r3, r3, #5, #1
 80077da:	b2d9      	uxtb	r1, r3
 80077dc:	683a      	ldr	r2, [r7, #0]
 80077de:	7853      	ldrb	r3, [r2, #1]
 80077e0:	f361 0300 	bfi	r3, r1, #0, #1
 80077e4:	7053      	strb	r3, [r2, #1]

  switch (val->bus_act_sel) {
 80077e6:	683b      	ldr	r3, [r7, #0]
 80077e8:	781b      	ldrb	r3, [r3, #0]
 80077ea:	2b02      	cmp	r3, #2
 80077ec:	d00e      	beq.n	800780c <lis2duxs12_i3c_configure_get+0x64>
 80077ee:	2b02      	cmp	r3, #2
 80077f0:	dc10      	bgt.n	8007814 <lis2duxs12_i3c_configure_get+0x6c>
 80077f2:	2b00      	cmp	r3, #0
 80077f4:	d002      	beq.n	80077fc <lis2duxs12_i3c_configure_get+0x54>
 80077f6:	2b01      	cmp	r3, #1
 80077f8:	d004      	beq.n	8007804 <lis2duxs12_i3c_configure_get+0x5c>
 80077fa:	e00b      	b.n	8007814 <lis2duxs12_i3c_configure_get+0x6c>
    case LIS2DUXS12_I3C_BUS_AVAIL_TIME_20US:
     val->bus_act_sel = LIS2DUXS12_I3C_BUS_AVAIL_TIME_20US;
 80077fc:	683b      	ldr	r3, [r7, #0]
 80077fe:	2200      	movs	r2, #0
 8007800:	701a      	strb	r2, [r3, #0]
     break;
 8007802:	e00b      	b.n	800781c <lis2duxs12_i3c_configure_get+0x74>

    case LIS2DUXS12_I3C_BUS_AVAIL_TIME_50US:
     val->bus_act_sel = LIS2DUXS12_I3C_BUS_AVAIL_TIME_50US;
 8007804:	683b      	ldr	r3, [r7, #0]
 8007806:	2201      	movs	r2, #1
 8007808:	701a      	strb	r2, [r3, #0]
     break;
 800780a:	e007      	b.n	800781c <lis2duxs12_i3c_configure_get+0x74>

    case LIS2DUXS12_I3C_BUS_AVAIL_TIME_1MS:
     val->bus_act_sel = LIS2DUXS12_I3C_BUS_AVAIL_TIME_1MS;
 800780c:	683b      	ldr	r3, [r7, #0]
 800780e:	2202      	movs	r2, #2
 8007810:	701a      	strb	r2, [r3, #0]
     break;
 8007812:	e003      	b.n	800781c <lis2duxs12_i3c_configure_get+0x74>

    case LIS2DUXS12_I3C_BUS_AVAIL_TIME_25MS:
    default:
     val->bus_act_sel = LIS2DUXS12_I3C_BUS_AVAIL_TIME_25MS;
 8007814:	683b      	ldr	r3, [r7, #0]
 8007816:	2203      	movs	r2, #3
 8007818:	701a      	strb	r2, [r3, #0]
     break;
 800781a:	bf00      	nop
  }

 return ret;
 800781c:	68fb      	ldr	r3, [r7, #12]
}
 800781e:	4618      	mov	r0, r3
 8007820:	3710      	adds	r7, #16
 8007822:	46bd      	mov	sp, r7
 8007824:	bd80      	pop	{r7, pc}

08007826 <lis2duxs12_fifo_mode_set>:
  * @param  val      BYPASS_MODE, FIFO_MODE, STREAM_TO_FIFO_MODE, BYPASS_TO_STREAM_MODE, STREAM_MODE, BYPASS_TO_FIFO_MODE,
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2duxs12_fifo_mode_set(stmdev_ctx_t *ctx, lis2duxs12_fifo_mode_t val)
{
 8007826:	b580      	push	{r7, lr}
 8007828:	b08a      	sub	sp, #40	@ 0x28
 800782a:	af00      	add	r7, sp, #0
 800782c:	60f8      	str	r0, [r7, #12]
 800782e:	1d3b      	adds	r3, r7, #4
 8007830:	e883 0006 	stmia.w	r3, {r1, r2}
  lis2duxs12_fifo_ctrl_t fifo_ctrl;
  lis2duxs12_fifo_wtm_t fifo_wtm;
  lis2duxs12_fifo_batch_dec_t fifo_batch;
  int32_t ret;

  ret = lis2duxs12_read_reg(ctx, LIS2DUXS12_CTRL4, (uint8_t *)&ctrl4, 1);
 8007834:	f107 0220 	add.w	r2, r7, #32
 8007838:	2301      	movs	r3, #1
 800783a:	2113      	movs	r1, #19
 800783c:	68f8      	ldr	r0, [r7, #12]
 800783e:	f7ff fb55 	bl	8006eec <lis2duxs12_read_reg>
 8007842:	6278      	str	r0, [r7, #36]	@ 0x24
  ret += lis2duxs12_read_reg(ctx, LIS2DUXS12_FIFO_CTRL, (uint8_t *)&fifo_ctrl, 1);
 8007844:	f107 021c 	add.w	r2, r7, #28
 8007848:	2301      	movs	r3, #1
 800784a:	2115      	movs	r1, #21
 800784c:	68f8      	ldr	r0, [r7, #12]
 800784e:	f7ff fb4d 	bl	8006eec <lis2duxs12_read_reg>
 8007852:	4602      	mov	r2, r0
 8007854:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007856:	4413      	add	r3, r2
 8007858:	627b      	str	r3, [r7, #36]	@ 0x24
  ret += lis2duxs12_read_reg(ctx, LIS2DUXS12_FIFO_BATCH_DEC, (uint8_t *)&fifo_batch, 1);
 800785a:	f107 0214 	add.w	r2, r7, #20
 800785e:	2301      	movs	r3, #1
 8007860:	2147      	movs	r1, #71	@ 0x47
 8007862:	68f8      	ldr	r0, [r7, #12]
 8007864:	f7ff fb42 	bl	8006eec <lis2duxs12_read_reg>
 8007868:	4602      	mov	r2, r0
 800786a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800786c:	4413      	add	r3, r2
 800786e:	627b      	str	r3, [r7, #36]	@ 0x24
  ret += lis2duxs12_read_reg(ctx, LIS2DUXS12_FIFO_WTM, (uint8_t *)&fifo_wtm, 1);
 8007870:	f107 0218 	add.w	r2, r7, #24
 8007874:	2301      	movs	r3, #1
 8007876:	2116      	movs	r1, #22
 8007878:	68f8      	ldr	r0, [r7, #12]
 800787a:	f7ff fb37 	bl	8006eec <lis2duxs12_read_reg>
 800787e:	4602      	mov	r2, r0
 8007880:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007882:	4413      	add	r3, r2
 8007884:	627b      	str	r3, [r7, #36]	@ 0x24

  if (ret == 0)
 8007886:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007888:	2b00      	cmp	r3, #0
 800788a:	f040 8081 	bne.w	8007990 <lis2duxs12_fifo_mode_set+0x16a>
  {
    /* set FIFO mode */
    if (val.operation != LIS2DUXS12_FIFO_OFF)
 800788e:	793b      	ldrb	r3, [r7, #4]
 8007890:	2b08      	cmp	r3, #8
 8007892:	d00e      	beq.n	80078b2 <lis2duxs12_fifo_mode_set+0x8c>
    {
      ctrl4.fifo_en = 1;
 8007894:	f897 3020 	ldrb.w	r3, [r7, #32]
 8007898:	f043 0308 	orr.w	r3, r3, #8
 800789c:	f887 3020 	strb.w	r3, [r7, #32]
      fifo_ctrl.fifo_mode = ((uint8_t)val.operation & 0x7U);
 80078a0:	793b      	ldrb	r3, [r7, #4]
 80078a2:	f003 0307 	and.w	r3, r3, #7
 80078a6:	b2da      	uxtb	r2, r3
 80078a8:	7f3b      	ldrb	r3, [r7, #28]
 80078aa:	f362 0302 	bfi	r3, r2, #0, #3
 80078ae:	773b      	strb	r3, [r7, #28]
 80078b0:	e005      	b.n	80078be <lis2duxs12_fifo_mode_set+0x98>
    }
    else {
      ctrl4.fifo_en = 0;
 80078b2:	f897 3020 	ldrb.w	r3, [r7, #32]
 80078b6:	f36f 03c3 	bfc	r3, #3, #1
 80078ba:	f887 3020 	strb.w	r3, [r7, #32]
    }

    /* set fifo depth (1X/2X) */
    fifo_ctrl.fifo_depth = (uint8_t)val.store;
 80078be:	797b      	ldrb	r3, [r7, #5]
 80078c0:	f003 0301 	and.w	r3, r3, #1
 80078c4:	b2da      	uxtb	r2, r3
 80078c6:	7f3b      	ldrb	r3, [r7, #28]
 80078c8:	f362 1386 	bfi	r3, r2, #6, #1
 80078cc:	773b      	strb	r3, [r7, #28]

    /* Set xl_only_fifo */
    fifo_wtm.xl_only_fifo = val.xl_only;
 80078ce:	79bb      	ldrb	r3, [r7, #6]
 80078d0:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80078d4:	b2da      	uxtb	r2, r3
 80078d6:	7e3b      	ldrb	r3, [r7, #24]
 80078d8:	f362 13c7 	bfi	r3, r2, #7, #1
 80078dc:	763b      	strb	r3, [r7, #24]

    /* set batching info */
    if (val.batch.dec_ts != LIS2DUXS12_DEC_TS_OFF)
 80078de:	7a3b      	ldrb	r3, [r7, #8]
 80078e0:	2b00      	cmp	r3, #0
 80078e2:	d00f      	beq.n	8007904 <lis2duxs12_fifo_mode_set+0xde>
    {
      fifo_batch.dec_ts_batch = (uint8_t)val.batch.dec_ts;
 80078e4:	7a3b      	ldrb	r3, [r7, #8]
 80078e6:	f003 0303 	and.w	r3, r3, #3
 80078ea:	b2da      	uxtb	r2, r3
 80078ec:	7d3b      	ldrb	r3, [r7, #20]
 80078ee:	f362 03c4 	bfi	r3, r2, #3, #2
 80078f2:	753b      	strb	r3, [r7, #20]
      fifo_batch.bdr_xl = (uint8_t)val.batch.bdr_xl;
 80078f4:	7a7b      	ldrb	r3, [r7, #9]
 80078f6:	f003 0307 	and.w	r3, r3, #7
 80078fa:	b2da      	uxtb	r2, r3
 80078fc:	7d3b      	ldrb	r3, [r7, #20]
 80078fe:	f362 0302 	bfi	r3, r2, #0, #3
 8007902:	753b      	strb	r3, [r7, #20]
    }

    fifo_ctrl.cfg_chg_en = val.cfg_change_in_fifo;
 8007904:	79fb      	ldrb	r3, [r7, #7]
 8007906:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800790a:	b2da      	uxtb	r2, r3
 800790c:	7f3b      	ldrb	r3, [r7, #28]
 800790e:	f362 13c7 	bfi	r3, r2, #7, #1
 8007912:	773b      	strb	r3, [r7, #28]

    /* set watermark */
    if (val.watermark > 0U) {
 8007914:	79bb      	ldrb	r3, [r7, #6]
 8007916:	f023 0301 	bic.w	r3, r3, #1
 800791a:	b2db      	uxtb	r3, r3
 800791c:	2b00      	cmp	r3, #0
 800791e:	d00b      	beq.n	8007938 <lis2duxs12_fifo_mode_set+0x112>
      fifo_ctrl.stop_on_fth = 1;
 8007920:	7f3b      	ldrb	r3, [r7, #28]
 8007922:	f043 0308 	orr.w	r3, r3, #8
 8007926:	773b      	strb	r3, [r7, #28]
      fifo_wtm.fth = val.watermark;
 8007928:	79bb      	ldrb	r3, [r7, #6]
 800792a:	f3c3 0346 	ubfx	r3, r3, #1, #7
 800792e:	b2da      	uxtb	r2, r3
 8007930:	7e3b      	ldrb	r3, [r7, #24]
 8007932:	f362 0306 	bfi	r3, r2, #0, #7
 8007936:	763b      	strb	r3, [r7, #24]
    }

    ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_FIFO_BATCH_DEC, (uint8_t *)&fifo_batch, 1);
 8007938:	f107 0214 	add.w	r2, r7, #20
 800793c:	2301      	movs	r3, #1
 800793e:	2147      	movs	r1, #71	@ 0x47
 8007940:	68f8      	ldr	r0, [r7, #12]
 8007942:	f7ff faeb 	bl	8006f1c <lis2duxs12_write_reg>
 8007946:	4602      	mov	r2, r0
 8007948:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800794a:	4413      	add	r3, r2
 800794c:	627b      	str	r3, [r7, #36]	@ 0x24
    ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_FIFO_WTM, (uint8_t *)&fifo_wtm, 1);
 800794e:	f107 0218 	add.w	r2, r7, #24
 8007952:	2301      	movs	r3, #1
 8007954:	2116      	movs	r1, #22
 8007956:	68f8      	ldr	r0, [r7, #12]
 8007958:	f7ff fae0 	bl	8006f1c <lis2duxs12_write_reg>
 800795c:	4602      	mov	r2, r0
 800795e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007960:	4413      	add	r3, r2
 8007962:	627b      	str	r3, [r7, #36]	@ 0x24
    ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_FIFO_CTRL, (uint8_t *)&fifo_ctrl, 1);
 8007964:	f107 021c 	add.w	r2, r7, #28
 8007968:	2301      	movs	r3, #1
 800796a:	2115      	movs	r1, #21
 800796c:	68f8      	ldr	r0, [r7, #12]
 800796e:	f7ff fad5 	bl	8006f1c <lis2duxs12_write_reg>
 8007972:	4602      	mov	r2, r0
 8007974:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007976:	4413      	add	r3, r2
 8007978:	627b      	str	r3, [r7, #36]	@ 0x24
    ret += lis2duxs12_write_reg(ctx, LIS2DUXS12_CTRL4, (uint8_t *)&ctrl4, 1);
 800797a:	f107 0220 	add.w	r2, r7, #32
 800797e:	2301      	movs	r3, #1
 8007980:	2113      	movs	r1, #19
 8007982:	68f8      	ldr	r0, [r7, #12]
 8007984:	f7ff faca 	bl	8006f1c <lis2duxs12_write_reg>
 8007988:	4602      	mov	r2, r0
 800798a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800798c:	4413      	add	r3, r2
 800798e:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  return ret;
 8007990:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8007992:	4618      	mov	r0, r3
 8007994:	3728      	adds	r7, #40	@ 0x28
 8007996:	46bd      	mov	sp, r7
 8007998:	bd80      	pop	{r7, pc}
	...

0800799c <LIS2MDL_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_RegisterBusIO(LIS2MDL_Object_t *pObj, LIS2MDL_IO_t *pIO)
{
 800799c:	b580      	push	{r7, lr}
 800799e:	b084      	sub	sp, #16
 80079a0:	af00      	add	r7, sp, #0
 80079a2:	6078      	str	r0, [r7, #4]
 80079a4:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2MDL_OK;
 80079a6:	2300      	movs	r3, #0
 80079a8:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 80079aa:	687b      	ldr	r3, [r7, #4]
 80079ac:	2b00      	cmp	r3, #0
 80079ae:	d103      	bne.n	80079b8 <LIS2MDL_RegisterBusIO+0x1c>
  {
    ret = LIS2MDL_ERROR;
 80079b0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80079b4:	60fb      	str	r3, [r7, #12]
 80079b6:	e067      	b.n	8007a88 <LIS2MDL_RegisterBusIO+0xec>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 80079b8:	683b      	ldr	r3, [r7, #0]
 80079ba:	681a      	ldr	r2, [r3, #0]
 80079bc:	687b      	ldr	r3, [r7, #4]
 80079be:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 80079c0:	683b      	ldr	r3, [r7, #0]
 80079c2:	685a      	ldr	r2, [r3, #4]
 80079c4:	687b      	ldr	r3, [r7, #4]
 80079c6:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 80079c8:	683b      	ldr	r3, [r7, #0]
 80079ca:	689a      	ldr	r2, [r3, #8]
 80079cc:	687b      	ldr	r3, [r7, #4]
 80079ce:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 80079d0:	683b      	ldr	r3, [r7, #0]
 80079d2:	7b1a      	ldrb	r2, [r3, #12]
 80079d4:	687b      	ldr	r3, [r7, #4]
 80079d6:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 80079d8:	683b      	ldr	r3, [r7, #0]
 80079da:	691a      	ldr	r2, [r3, #16]
 80079dc:	687b      	ldr	r3, [r7, #4]
 80079de:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 80079e0:	683b      	ldr	r3, [r7, #0]
 80079e2:	695a      	ldr	r2, [r3, #20]
 80079e4:	687b      	ldr	r3, [r7, #4]
 80079e6:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 80079e8:	683b      	ldr	r3, [r7, #0]
 80079ea:	699a      	ldr	r2, [r3, #24]
 80079ec:	687b      	ldr	r3, [r7, #4]
 80079ee:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadMagRegWrap;
 80079f0:	687b      	ldr	r3, [r7, #4]
 80079f2:	4a28      	ldr	r2, [pc, #160]	@ (8007a94 <LIS2MDL_RegisterBusIO+0xf8>)
 80079f4:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteMagRegWrap;
 80079f6:	687b      	ldr	r3, [r7, #4]
 80079f8:	4a27      	ldr	r2, [pc, #156]	@ (8007a98 <LIS2MDL_RegisterBusIO+0xfc>)
 80079fa:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 80079fc:	683b      	ldr	r3, [r7, #0]
 80079fe:	69da      	ldr	r2, [r3, #28]
 8007a00:	687b      	ldr	r3, [r7, #4]
 8007a02:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 8007a04:	687b      	ldr	r3, [r7, #4]
 8007a06:	687a      	ldr	r2, [r7, #4]
 8007a08:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 8007a0a:	687b      	ldr	r3, [r7, #4]
 8007a0c:	681b      	ldr	r3, [r3, #0]
 8007a0e:	2b00      	cmp	r3, #0
 8007a10:	d103      	bne.n	8007a1a <LIS2MDL_RegisterBusIO+0x7e>
    {
      ret = LIS2MDL_ERROR;
 8007a12:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007a16:	60fb      	str	r3, [r7, #12]
 8007a18:	e036      	b.n	8007a88 <LIS2MDL_RegisterBusIO+0xec>
    }
    else if (pObj->IO.Init() != LIS2MDL_OK)
 8007a1a:	687b      	ldr	r3, [r7, #4]
 8007a1c:	681b      	ldr	r3, [r3, #0]
 8007a1e:	4798      	blx	r3
 8007a20:	4603      	mov	r3, r0
 8007a22:	2b00      	cmp	r3, #0
 8007a24:	d003      	beq.n	8007a2e <LIS2MDL_RegisterBusIO+0x92>
    {
      ret = LIS2MDL_ERROR;
 8007a26:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007a2a:	60fb      	str	r3, [r7, #12]
 8007a2c:	e02c      	b.n	8007a88 <LIS2MDL_RegisterBusIO+0xec>
    }
    else
    {
      if (pObj->IO.BusType != LIS2MDL_I2C_BUS) /* If the bus type is not I2C */
 8007a2e:	687b      	ldr	r3, [r7, #4]
 8007a30:	689b      	ldr	r3, [r3, #8]
 8007a32:	2b00      	cmp	r3, #0
 8007a34:	d028      	beq.n	8007a88 <LIS2MDL_RegisterBusIO+0xec>
      {
        /* Disable I2C interface support and enable eventually SPI 4-Wires only the first time */
        if (pObj->is_initialized == 0U)
 8007a36:	687b      	ldr	r3, [r7, #4]
 8007a38:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8007a3c:	2b00      	cmp	r3, #0
 8007a3e:	d123      	bne.n	8007a88 <LIS2MDL_RegisterBusIO+0xec>
        {
          if (pObj->IO.BusType == LIS2MDL_SPI_4WIRES_BUS) /* SPI 4-Wires */
 8007a40:	687b      	ldr	r3, [r7, #4]
 8007a42:	689b      	ldr	r3, [r3, #8]
 8007a44:	2b01      	cmp	r3, #1
 8007a46:	d10d      	bne.n	8007a64 <LIS2MDL_RegisterBusIO+0xc8>
          {
            /* Enable SPI 4-Wires and disable I2C support on the component */
            uint8_t data = 0x34;
 8007a48:	2334      	movs	r3, #52	@ 0x34
 8007a4a:	72fb      	strb	r3, [r7, #11]

            if (LIS2MDL_Write_Reg(pObj, LIS2MDL_CFG_REG_C, data) != LIS2MDL_OK)
 8007a4c:	7afb      	ldrb	r3, [r7, #11]
 8007a4e:	461a      	mov	r2, r3
 8007a50:	2162      	movs	r1, #98	@ 0x62
 8007a52:	6878      	ldr	r0, [r7, #4]
 8007a54:	f000 fb18 	bl	8008088 <LIS2MDL_Write_Reg>
 8007a58:	4603      	mov	r3, r0
 8007a5a:	2b00      	cmp	r3, #0
 8007a5c:	d014      	beq.n	8007a88 <LIS2MDL_RegisterBusIO+0xec>
            {
              return LIS2MDL_ERROR;
 8007a5e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007a62:	e012      	b.n	8007a8a <LIS2MDL_RegisterBusIO+0xee>
            }
          }
          else if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8007a64:	687b      	ldr	r3, [r7, #4]
 8007a66:	689b      	ldr	r3, [r3, #8]
 8007a68:	2b03      	cmp	r3, #3
 8007a6a:	d101      	bne.n	8007a70 <LIS2MDL_RegisterBusIO+0xd4>
          {
            /* Do nothing, just keep I2C support on the component */
            return ret;
 8007a6c:	68fb      	ldr	r3, [r7, #12]
 8007a6e:	e00c      	b.n	8007a8a <LIS2MDL_RegisterBusIO+0xee>
          }
          else
          {
            /* Disable I2C interface on the component */
            if (lis2mdl_i2c_interface_set(&(pObj->Ctx), LIS2MDL_I2C_DISABLE) != LIS2MDL_OK)
 8007a70:	687b      	ldr	r3, [r7, #4]
 8007a72:	3320      	adds	r3, #32
 8007a74:	2101      	movs	r1, #1
 8007a76:	4618      	mov	r0, r3
 8007a78:	f000 ff69 	bl	800894e <lis2mdl_i2c_interface_set>
 8007a7c:	4603      	mov	r3, r0
 8007a7e:	2b00      	cmp	r3, #0
 8007a80:	d002      	beq.n	8007a88 <LIS2MDL_RegisterBusIO+0xec>
            {
              return LIS2MDL_ERROR;
 8007a82:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007a86:	e000      	b.n	8007a8a <LIS2MDL_RegisterBusIO+0xee>
        }
      }
    }
  }

  return ret;
 8007a88:	68fb      	ldr	r3, [r7, #12]
}
 8007a8a:	4618      	mov	r0, r3
 8007a8c:	3710      	adds	r7, #16
 8007a8e:	46bd      	mov	sp, r7
 8007a90:	bd80      	pop	{r7, pc}
 8007a92:	bf00      	nop
 8007a94:	080080df 	.word	0x080080df
 8007a98:	08008161 	.word	0x08008161

08007a9c <LIS2MDL_Init>:
  * @brief  Initialize the LIS2MDL sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_Init(LIS2MDL_Object_t *pObj)
{
 8007a9c:	b580      	push	{r7, lr}
 8007a9e:	b084      	sub	sp, #16
 8007aa0:	af00      	add	r7, sp, #0
 8007aa2:	6078      	str	r0, [r7, #4]
  lis2mdl_cfg_reg_a_t reg_a;
  lis2mdl_cfg_reg_c_t reg_c;

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8007aa4:	687b      	ldr	r3, [r7, #4]
 8007aa6:	689b      	ldr	r3, [r3, #8]
 8007aa8:	2b03      	cmp	r3, #3
 8007aaa:	d144      	bne.n	8007b36 <LIS2MDL_Init+0x9a>
  {
    /* Read configuration from CFG_REG_C & CFG_REG_A regs */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_C, (uint8_t *)&reg_c, 1) != LIS2MDL_OK)
 8007aac:	f107 0208 	add.w	r2, r7, #8
 8007ab0:	2301      	movs	r3, #1
 8007ab2:	2162      	movs	r1, #98	@ 0x62
 8007ab4:	6878      	ldr	r0, [r7, #4]
 8007ab6:	f000 fb94 	bl	80081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8007aba:	4603      	mov	r3, r0
 8007abc:	2b00      	cmp	r3, #0
 8007abe:	d002      	beq.n	8007ac6 <LIS2MDL_Init+0x2a>
    {
      return LIS2MDL_ERROR;
 8007ac0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007ac4:	e06c      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007ac6:	f107 020c 	add.w	r2, r7, #12
 8007aca:	2301      	movs	r3, #1
 8007acc:	2160      	movs	r1, #96	@ 0x60
 8007ace:	6878      	ldr	r0, [r7, #4]
 8007ad0:	f000 fb87 	bl	80081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8007ad4:	4603      	mov	r3, r0
 8007ad6:	2b00      	cmp	r3, #0
 8007ad8:	d002      	beq.n	8007ae0 <LIS2MDL_Init+0x44>
    {
      return LIS2MDL_ERROR;
 8007ada:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007ade:	e05f      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }

    /* Enable BDU */
    reg_c.bdu = PROPERTY_ENABLE;
 8007ae0:	7a3b      	ldrb	r3, [r7, #8]
 8007ae2:	f043 0310 	orr.w	r3, r3, #16
 8007ae6:	723b      	strb	r3, [r7, #8]

    /* Self Test disabled. */
    reg_c.self_test = PROPERTY_DISABLE;
 8007ae8:	7a3b      	ldrb	r3, [r7, #8]
 8007aea:	f36f 0341 	bfc	r3, #1, #1
 8007aee:	723b      	strb	r3, [r7, #8]

    /* Operating mode selection - power down */
    reg_a.md = LIS2MDL_POWER_DOWN;
 8007af0:	7b3b      	ldrb	r3, [r7, #12]
 8007af2:	2202      	movs	r2, #2
 8007af4:	f362 0301 	bfi	r3, r2, #0, #2
 8007af8:	733b      	strb	r3, [r7, #12]

    /* Output data rate selection */
    reg_a.odr = LIS2MDL_ODR_100Hz;
 8007afa:	7b3b      	ldrb	r3, [r7, #12]
 8007afc:	f043 030c 	orr.w	r3, r3, #12
 8007b00:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_C & CFG_REG_A regs */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_C, (uint8_t *)&reg_c, 1) != LIS2MDL_OK)
 8007b02:	f107 0208 	add.w	r2, r7, #8
 8007b06:	2301      	movs	r3, #1
 8007b08:	2162      	movs	r1, #98	@ 0x62
 8007b0a:	6878      	ldr	r0, [r7, #4]
 8007b0c:	f000 fca8 	bl	8008460 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8007b10:	4603      	mov	r3, r0
 8007b12:	2b00      	cmp	r3, #0
 8007b14:	d002      	beq.n	8007b1c <LIS2MDL_Init+0x80>
    {
      return LIS2MDL_ERROR;
 8007b16:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007b1a:	e041      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007b1c:	f107 020c 	add.w	r2, r7, #12
 8007b20:	2301      	movs	r3, #1
 8007b22:	2160      	movs	r1, #96	@ 0x60
 8007b24:	6878      	ldr	r0, [r7, #4]
 8007b26:	f000 fc9b 	bl	8008460 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8007b2a:	4603      	mov	r3, r0
 8007b2c:	2b00      	cmp	r3, #0
 8007b2e:	d032      	beq.n	8007b96 <LIS2MDL_Init+0xfa>
    {
      return LIS2MDL_ERROR;
 8007b30:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007b34:	e034      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }
  }
  else
  {
    /* Enable BDU */
    if (lis2mdl_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LIS2MDL_OK)
 8007b36:	687b      	ldr	r3, [r7, #4]
 8007b38:	3320      	adds	r3, #32
 8007b3a:	2101      	movs	r1, #1
 8007b3c:	4618      	mov	r0, r3
 8007b3e:	f000 fe61 	bl	8008804 <lis2mdl_block_data_update_set>
 8007b42:	4603      	mov	r3, r0
 8007b44:	2b00      	cmp	r3, #0
 8007b46:	d002      	beq.n	8007b4e <LIS2MDL_Init+0xb2>
    {
      return LIS2MDL_ERROR;
 8007b48:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007b4c:	e028      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }

    /* Operating mode selection - power down */
    if (lis2mdl_operating_mode_set(&(pObj->Ctx), LIS2MDL_POWER_DOWN) != LIS2MDL_OK)
 8007b4e:	687b      	ldr	r3, [r7, #4]
 8007b50:	3320      	adds	r3, #32
 8007b52:	2102      	movs	r1, #2
 8007b54:	4618      	mov	r0, r3
 8007b56:	f000 fdd1 	bl	80086fc <lis2mdl_operating_mode_set>
 8007b5a:	4603      	mov	r3, r0
 8007b5c:	2b00      	cmp	r3, #0
 8007b5e:	d002      	beq.n	8007b66 <LIS2MDL_Init+0xca>
    {
      return LIS2MDL_ERROR;
 8007b60:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007b64:	e01c      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }

    /* Output data rate selection */
    if (lis2mdl_data_rate_set(&(pObj->Ctx), LIS2MDL_ODR_100Hz) != LIS2MDL_OK)
 8007b66:	687b      	ldr	r3, [r7, #4]
 8007b68:	3320      	adds	r3, #32
 8007b6a:	2103      	movs	r1, #3
 8007b6c:	4618      	mov	r0, r3
 8007b6e:	f000 fdeb 	bl	8008748 <lis2mdl_data_rate_set>
 8007b72:	4603      	mov	r3, r0
 8007b74:	2b00      	cmp	r3, #0
 8007b76:	d002      	beq.n	8007b7e <LIS2MDL_Init+0xe2>
    {
      return LIS2MDL_ERROR;
 8007b78:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007b7c:	e010      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }

    /* Self Test disabled. */
    if (lis2mdl_self_test_set(&(pObj->Ctx), PROPERTY_DISABLE) != LIS2MDL_OK)
 8007b7e:	687b      	ldr	r3, [r7, #4]
 8007b80:	3320      	adds	r3, #32
 8007b82:	2100      	movs	r1, #0
 8007b84:	4618      	mov	r0, r3
 8007b86:	f000 febc 	bl	8008902 <lis2mdl_self_test_set>
 8007b8a:	4603      	mov	r3, r0
 8007b8c:	2b00      	cmp	r3, #0
 8007b8e:	d002      	beq.n	8007b96 <LIS2MDL_Init+0xfa>
    {
      return LIS2MDL_ERROR;
 8007b90:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007b94:	e004      	b.n	8007ba0 <LIS2MDL_Init+0x104>
    }
  }

  pObj->is_initialized = 1;
 8007b96:	687b      	ldr	r3, [r7, #4]
 8007b98:	2201      	movs	r2, #1
 8007b9a:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2MDL_OK;
 8007b9e:	2300      	movs	r3, #0
}
 8007ba0:	4618      	mov	r0, r3
 8007ba2:	3710      	adds	r7, #16
 8007ba4:	46bd      	mov	sp, r7
 8007ba6:	bd80      	pop	{r7, pc}

08007ba8 <LIS2MDL_DeInit>:
  * @brief  Deinitialize the LIS2MDL magnetometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_DeInit(LIS2MDL_Object_t *pObj)
{
 8007ba8:	b580      	push	{r7, lr}
 8007baa:	b082      	sub	sp, #8
 8007bac:	af00      	add	r7, sp, #0
 8007bae:	6078      	str	r0, [r7, #4]
  /* Disable the component */
  if (LIS2MDL_MAG_Disable(pObj) != LIS2MDL_OK)
 8007bb0:	6878      	ldr	r0, [r7, #4]
 8007bb2:	f000 f8a5 	bl	8007d00 <LIS2MDL_MAG_Disable>
 8007bb6:	4603      	mov	r3, r0
 8007bb8:	2b00      	cmp	r3, #0
 8007bba:	d002      	beq.n	8007bc2 <LIS2MDL_DeInit+0x1a>
  {
    return LIS2MDL_ERROR;
 8007bbc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007bc0:	e004      	b.n	8007bcc <LIS2MDL_DeInit+0x24>
  }

  pObj->is_initialized = 0;
 8007bc2:	687b      	ldr	r3, [r7, #4]
 8007bc4:	2200      	movs	r2, #0
 8007bc6:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LIS2MDL_OK;
 8007bca:	2300      	movs	r3, #0
}
 8007bcc:	4618      	mov	r0, r3
 8007bce:	3708      	adds	r7, #8
 8007bd0:	46bd      	mov	sp, r7
 8007bd2:	bd80      	pop	{r7, pc}

08007bd4 <LIS2MDL_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_ReadID(LIS2MDL_Object_t *pObj, uint8_t *Id)
{
 8007bd4:	b580      	push	{r7, lr}
 8007bd6:	b082      	sub	sp, #8
 8007bd8:	af00      	add	r7, sp, #0
 8007bda:	6078      	str	r0, [r7, #4]
 8007bdc:	6039      	str	r1, [r7, #0]
  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8007bde:	687b      	ldr	r3, [r7, #4]
 8007be0:	689b      	ldr	r3, [r3, #8]
 8007be2:	2b03      	cmp	r3, #3
 8007be4:	d10b      	bne.n	8007bfe <LIS2MDL_ReadID+0x2a>
  {
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_WHO_AM_I, Id, 1) != LIS2MDL_OK)
 8007be6:	2301      	movs	r3, #1
 8007be8:	683a      	ldr	r2, [r7, #0]
 8007bea:	214f      	movs	r1, #79	@ 0x4f
 8007bec:	6878      	ldr	r0, [r7, #4]
 8007bee:	f000 faf8 	bl	80081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8007bf2:	4603      	mov	r3, r0
 8007bf4:	2b00      	cmp	r3, #0
 8007bf6:	d00e      	beq.n	8007c16 <LIS2MDL_ReadID+0x42>
    {
      return LIS2MDL_ERROR;
 8007bf8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007bfc:	e00c      	b.n	8007c18 <LIS2MDL_ReadID+0x44>
    }
  }
  else
  {
    if (lis2mdl_device_id_get(&(pObj->Ctx), Id) != LIS2MDL_OK)
 8007bfe:	687b      	ldr	r3, [r7, #4]
 8007c00:	3320      	adds	r3, #32
 8007c02:	6839      	ldr	r1, [r7, #0]
 8007c04:	4618      	mov	r0, r3
 8007c06:	f000 fe6b 	bl	80088e0 <lis2mdl_device_id_get>
 8007c0a:	4603      	mov	r3, r0
 8007c0c:	2b00      	cmp	r3, #0
 8007c0e:	d002      	beq.n	8007c16 <LIS2MDL_ReadID+0x42>
    {
      return LIS2MDL_ERROR;
 8007c10:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007c14:	e000      	b.n	8007c18 <LIS2MDL_ReadID+0x44>
    }
  }

  return LIS2MDL_OK;
 8007c16:	2300      	movs	r3, #0
}
 8007c18:	4618      	mov	r0, r3
 8007c1a:	3708      	adds	r7, #8
 8007c1c:	46bd      	mov	sp, r7
 8007c1e:	bd80      	pop	{r7, pc}

08007c20 <LIS2MDL_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LIS2MDL magnetometer sensor capabilities
  * @retval Component status
  */
int32_t LIS2MDL_GetCapabilities(LIS2MDL_Object_t *pObj, LIS2MDL_Capabilities_t *Capabilities)
{
 8007c20:	b480      	push	{r7}
 8007c22:	b083      	sub	sp, #12
 8007c24:	af00      	add	r7, sp, #0
 8007c26:	6078      	str	r0, [r7, #4]
 8007c28:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc          = 0;
 8007c2a:	683b      	ldr	r3, [r7, #0]
 8007c2c:	2200      	movs	r2, #0
 8007c2e:	701a      	strb	r2, [r3, #0]
  Capabilities->Gyro         = 0;
 8007c30:	683b      	ldr	r3, [r7, #0]
 8007c32:	2200      	movs	r2, #0
 8007c34:	705a      	strb	r2, [r3, #1]
  Capabilities->Magneto      = 1;
 8007c36:	683b      	ldr	r3, [r7, #0]
 8007c38:	2201      	movs	r2, #1
 8007c3a:	709a      	strb	r2, [r3, #2]
  Capabilities->LowPower     = 0;
 8007c3c:	683b      	ldr	r3, [r7, #0]
 8007c3e:	2200      	movs	r2, #0
 8007c40:	70da      	strb	r2, [r3, #3]
  Capabilities->GyroMaxFS    = 0;
 8007c42:	683b      	ldr	r3, [r7, #0]
 8007c44:	2200      	movs	r2, #0
 8007c46:	605a      	str	r2, [r3, #4]
  Capabilities->AccMaxFS     = 0;
 8007c48:	683b      	ldr	r3, [r7, #0]
 8007c4a:	2200      	movs	r2, #0
 8007c4c:	609a      	str	r2, [r3, #8]
  Capabilities->MagMaxFS     = 50;
 8007c4e:	683b      	ldr	r3, [r7, #0]
 8007c50:	2232      	movs	r2, #50	@ 0x32
 8007c52:	60da      	str	r2, [r3, #12]
  Capabilities->GyroMaxOdr   = 0.0f;
 8007c54:	683b      	ldr	r3, [r7, #0]
 8007c56:	f04f 0200 	mov.w	r2, #0
 8007c5a:	611a      	str	r2, [r3, #16]
  Capabilities->AccMaxOdr    = 0.0f;
 8007c5c:	683b      	ldr	r3, [r7, #0]
 8007c5e:	f04f 0200 	mov.w	r2, #0
 8007c62:	615a      	str	r2, [r3, #20]
  Capabilities->MagMaxOdr    = 100.0f;
 8007c64:	683b      	ldr	r3, [r7, #0]
 8007c66:	4a04      	ldr	r2, [pc, #16]	@ (8007c78 <LIS2MDL_GetCapabilities+0x58>)
 8007c68:	619a      	str	r2, [r3, #24]
  return LIS2MDL_OK;
 8007c6a:	2300      	movs	r3, #0
}
 8007c6c:	4618      	mov	r0, r3
 8007c6e:	370c      	adds	r7, #12
 8007c70:	46bd      	mov	sp, r7
 8007c72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007c76:	4770      	bx	lr
 8007c78:	42c80000 	.word	0x42c80000

08007c7c <LIS2MDL_MAG_Enable>:
  * @brief Enable the LIS2MDL magnetometer sensor
  * @param pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_Enable(LIS2MDL_Object_t *pObj)
{
 8007c7c:	b580      	push	{r7, lr}
 8007c7e:	b084      	sub	sp, #16
 8007c80:	af00      	add	r7, sp, #0
 8007c82:	6078      	str	r0, [r7, #4]
  lis2mdl_cfg_reg_a_t reg_a;

  /* Check if the component is already enabled */
  if (pObj->mag_is_enabled == 1U)
 8007c84:	687b      	ldr	r3, [r7, #4]
 8007c86:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8007c8a:	2b01      	cmp	r3, #1
 8007c8c:	d101      	bne.n	8007c92 <LIS2MDL_MAG_Enable+0x16>
  {
    return LIS2MDL_OK;
 8007c8e:	2300      	movs	r3, #0
 8007c90:	e032      	b.n	8007cf8 <LIS2MDL_MAG_Enable+0x7c>
  }

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8007c92:	687b      	ldr	r3, [r7, #4]
 8007c94:	689b      	ldr	r3, [r3, #8]
 8007c96:	2b03      	cmp	r3, #3
 8007c98:	d11d      	bne.n	8007cd6 <LIS2MDL_MAG_Enable+0x5a>
  {
    /* Read configuration from CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007c9a:	f107 020c 	add.w	r2, r7, #12
 8007c9e:	2301      	movs	r3, #1
 8007ca0:	2160      	movs	r1, #96	@ 0x60
 8007ca2:	6878      	ldr	r0, [r7, #4]
 8007ca4:	f000 fa9d 	bl	80081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8007ca8:	4603      	mov	r3, r0
 8007caa:	2b00      	cmp	r3, #0
 8007cac:	d002      	beq.n	8007cb4 <LIS2MDL_MAG_Enable+0x38>
    {
      return LIS2MDL_ERROR;
 8007cae:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007cb2:	e021      	b.n	8007cf8 <LIS2MDL_MAG_Enable+0x7c>
    }

    /* Operation mode selection. */
    reg_a.md = LIS2MDL_CONTINUOUS_MODE;
 8007cb4:	7b3b      	ldrb	r3, [r7, #12]
 8007cb6:	f36f 0301 	bfc	r3, #0, #2
 8007cba:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007cbc:	f107 020c 	add.w	r2, r7, #12
 8007cc0:	2301      	movs	r3, #1
 8007cc2:	2160      	movs	r1, #96	@ 0x60
 8007cc4:	6878      	ldr	r0, [r7, #4]
 8007cc6:	f000 fbcb 	bl	8008460 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8007cca:	4603      	mov	r3, r0
 8007ccc:	2b00      	cmp	r3, #0
 8007cce:	d00e      	beq.n	8007cee <LIS2MDL_MAG_Enable+0x72>
    {
      return LIS2MDL_ERROR;
 8007cd0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007cd4:	e010      	b.n	8007cf8 <LIS2MDL_MAG_Enable+0x7c>
    }
  }
  else
  {
    /* Operation mode selection. */
    if (lis2mdl_operating_mode_set(&(pObj->Ctx), LIS2MDL_CONTINUOUS_MODE) != LIS2MDL_OK)
 8007cd6:	687b      	ldr	r3, [r7, #4]
 8007cd8:	3320      	adds	r3, #32
 8007cda:	2100      	movs	r1, #0
 8007cdc:	4618      	mov	r0, r3
 8007cde:	f000 fd0d 	bl	80086fc <lis2mdl_operating_mode_set>
 8007ce2:	4603      	mov	r3, r0
 8007ce4:	2b00      	cmp	r3, #0
 8007ce6:	d002      	beq.n	8007cee <LIS2MDL_MAG_Enable+0x72>
    {
      return LIS2MDL_ERROR;
 8007ce8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007cec:	e004      	b.n	8007cf8 <LIS2MDL_MAG_Enable+0x7c>
    }
  }

  pObj->mag_is_enabled = 1;
 8007cee:	687b      	ldr	r3, [r7, #4]
 8007cf0:	2201      	movs	r2, #1
 8007cf2:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2MDL_OK;
 8007cf6:	2300      	movs	r3, #0
}
 8007cf8:	4618      	mov	r0, r3
 8007cfa:	3710      	adds	r7, #16
 8007cfc:	46bd      	mov	sp, r7
 8007cfe:	bd80      	pop	{r7, pc}

08007d00 <LIS2MDL_MAG_Disable>:
  * @brief Disable the LIS2MDL magnetometer sensor
  * @param pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_Disable(LIS2MDL_Object_t *pObj)
{
 8007d00:	b580      	push	{r7, lr}
 8007d02:	b084      	sub	sp, #16
 8007d04:	af00      	add	r7, sp, #0
 8007d06:	6078      	str	r0, [r7, #4]
  lis2mdl_cfg_reg_a_t reg_a;

  /* Check if the component is already disabled */
  if (pObj->mag_is_enabled == 0U)
 8007d08:	687b      	ldr	r3, [r7, #4]
 8007d0a:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8007d0e:	2b00      	cmp	r3, #0
 8007d10:	d101      	bne.n	8007d16 <LIS2MDL_MAG_Disable+0x16>
  {
    return LIS2MDL_OK;
 8007d12:	2300      	movs	r3, #0
 8007d14:	e033      	b.n	8007d7e <LIS2MDL_MAG_Disable+0x7e>
  }

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8007d16:	687b      	ldr	r3, [r7, #4]
 8007d18:	689b      	ldr	r3, [r3, #8]
 8007d1a:	2b03      	cmp	r3, #3
 8007d1c:	d11e      	bne.n	8007d5c <LIS2MDL_MAG_Disable+0x5c>
  {
    /* Read configuration from CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007d1e:	f107 020c 	add.w	r2, r7, #12
 8007d22:	2301      	movs	r3, #1
 8007d24:	2160      	movs	r1, #96	@ 0x60
 8007d26:	6878      	ldr	r0, [r7, #4]
 8007d28:	f000 fa5b 	bl	80081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8007d2c:	4603      	mov	r3, r0
 8007d2e:	2b00      	cmp	r3, #0
 8007d30:	d002      	beq.n	8007d38 <LIS2MDL_MAG_Disable+0x38>
    {
      return LIS2MDL_ERROR;
 8007d32:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007d36:	e022      	b.n	8007d7e <LIS2MDL_MAG_Disable+0x7e>
    }

    /* Operation mode selection. */
    reg_a.md = LIS2MDL_POWER_DOWN;
 8007d38:	7b3b      	ldrb	r3, [r7, #12]
 8007d3a:	2202      	movs	r2, #2
 8007d3c:	f362 0301 	bfi	r3, r2, #0, #2
 8007d40:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007d42:	f107 020c 	add.w	r2, r7, #12
 8007d46:	2301      	movs	r3, #1
 8007d48:	2160      	movs	r1, #96	@ 0x60
 8007d4a:	6878      	ldr	r0, [r7, #4]
 8007d4c:	f000 fb88 	bl	8008460 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8007d50:	4603      	mov	r3, r0
 8007d52:	2b00      	cmp	r3, #0
 8007d54:	d00e      	beq.n	8007d74 <LIS2MDL_MAG_Disable+0x74>
    {
      return LIS2MDL_ERROR;
 8007d56:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007d5a:	e010      	b.n	8007d7e <LIS2MDL_MAG_Disable+0x7e>
    }
  }
  else
  {
    /* Operation mode selection. */
    if (lis2mdl_operating_mode_set(&(pObj->Ctx), LIS2MDL_POWER_DOWN) != LIS2MDL_OK)
 8007d5c:	687b      	ldr	r3, [r7, #4]
 8007d5e:	3320      	adds	r3, #32
 8007d60:	2102      	movs	r1, #2
 8007d62:	4618      	mov	r0, r3
 8007d64:	f000 fcca 	bl	80086fc <lis2mdl_operating_mode_set>
 8007d68:	4603      	mov	r3, r0
 8007d6a:	2b00      	cmp	r3, #0
 8007d6c:	d002      	beq.n	8007d74 <LIS2MDL_MAG_Disable+0x74>
    {
      return LIS2MDL_ERROR;
 8007d6e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007d72:	e004      	b.n	8007d7e <LIS2MDL_MAG_Disable+0x7e>
    }
  }

  pObj->mag_is_enabled = 0;
 8007d74:	687b      	ldr	r3, [r7, #4]
 8007d76:	2200      	movs	r2, #0
 8007d78:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LIS2MDL_OK;
 8007d7c:	2300      	movs	r3, #0
}
 8007d7e:	4618      	mov	r0, r3
 8007d80:	3710      	adds	r7, #16
 8007d82:	46bd      	mov	sp, r7
 8007d84:	bd80      	pop	{r7, pc}

08007d86 <LIS2MDL_MAG_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetSensitivity(LIS2MDL_Object_t *pObj, float *Sensitivity)
{
 8007d86:	b480      	push	{r7}
 8007d88:	b083      	sub	sp, #12
 8007d8a:	af00      	add	r7, sp, #0
 8007d8c:	6078      	str	r0, [r7, #4]
 8007d8e:	6039      	str	r1, [r7, #0]
  *Sensitivity = LIS2MDL_MAG_SENSITIVITY_FS_50GAUSS;
 8007d90:	683b      	ldr	r3, [r7, #0]
 8007d92:	f04f 527f 	mov.w	r2, #1069547520	@ 0x3fc00000
 8007d96:	601a      	str	r2, [r3, #0]

  return LIS2MDL_OK;
 8007d98:	2300      	movs	r3, #0
}
 8007d9a:	4618      	mov	r0, r3
 8007d9c:	370c      	adds	r7, #12
 8007d9e:	46bd      	mov	sp, r7
 8007da0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007da4:	4770      	bx	lr
	...

08007da8 <LIS2MDL_MAG_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetOutputDataRate(LIS2MDL_Object_t *pObj, float *Odr)
{
 8007da8:	b580      	push	{r7, lr}
 8007daa:	b084      	sub	sp, #16
 8007dac:	af00      	add	r7, sp, #0
 8007dae:	6078      	str	r0, [r7, #4]
 8007db0:	6039      	str	r1, [r7, #0]
  int32_t ret = LIS2MDL_OK;
 8007db2:	2300      	movs	r3, #0
 8007db4:	60fb      	str	r3, [r7, #12]
  lis2mdl_odr_t odr_low_level;

  /* Get current output data rate. */
  if (lis2mdl_data_rate_get(&(pObj->Ctx), &odr_low_level) != LIS2MDL_OK)
 8007db6:	687b      	ldr	r3, [r7, #4]
 8007db8:	3320      	adds	r3, #32
 8007dba:	f107 020b 	add.w	r2, r7, #11
 8007dbe:	4611      	mov	r1, r2
 8007dc0:	4618      	mov	r0, r3
 8007dc2:	f000 fce7 	bl	8008794 <lis2mdl_data_rate_get>
 8007dc6:	4603      	mov	r3, r0
 8007dc8:	2b00      	cmp	r3, #0
 8007dca:	d002      	beq.n	8007dd2 <LIS2MDL_MAG_GetOutputDataRate+0x2a>
  {
    return LIS2MDL_ERROR;
 8007dcc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007dd0:	e023      	b.n	8007e1a <LIS2MDL_MAG_GetOutputDataRate+0x72>
  }

  switch (odr_low_level)
 8007dd2:	7afb      	ldrb	r3, [r7, #11]
 8007dd4:	2b03      	cmp	r3, #3
 8007dd6:	d81b      	bhi.n	8007e10 <LIS2MDL_MAG_GetOutputDataRate+0x68>
 8007dd8:	a201      	add	r2, pc, #4	@ (adr r2, 8007de0 <LIS2MDL_MAG_GetOutputDataRate+0x38>)
 8007dda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007dde:	bf00      	nop
 8007de0:	08007df1 	.word	0x08007df1
 8007de4:	08007df9 	.word	0x08007df9
 8007de8:	08007e01 	.word	0x08007e01
 8007dec:	08007e09 	.word	0x08007e09
  {
    case LIS2MDL_ODR_10Hz:
      *Odr = 10.0f;
 8007df0:	683b      	ldr	r3, [r7, #0]
 8007df2:	4a0c      	ldr	r2, [pc, #48]	@ (8007e24 <LIS2MDL_MAG_GetOutputDataRate+0x7c>)
 8007df4:	601a      	str	r2, [r3, #0]
      break;
 8007df6:	e00f      	b.n	8007e18 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    case LIS2MDL_ODR_20Hz:
      *Odr = 20.0f;
 8007df8:	683b      	ldr	r3, [r7, #0]
 8007dfa:	4a0b      	ldr	r2, [pc, #44]	@ (8007e28 <LIS2MDL_MAG_GetOutputDataRate+0x80>)
 8007dfc:	601a      	str	r2, [r3, #0]
      break;
 8007dfe:	e00b      	b.n	8007e18 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    case LIS2MDL_ODR_50Hz:
      *Odr = 50.0f;
 8007e00:	683b      	ldr	r3, [r7, #0]
 8007e02:	4a0a      	ldr	r2, [pc, #40]	@ (8007e2c <LIS2MDL_MAG_GetOutputDataRate+0x84>)
 8007e04:	601a      	str	r2, [r3, #0]
      break;
 8007e06:	e007      	b.n	8007e18 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    case LIS2MDL_ODR_100Hz:
      *Odr = 100.0f;
 8007e08:	683b      	ldr	r3, [r7, #0]
 8007e0a:	4a09      	ldr	r2, [pc, #36]	@ (8007e30 <LIS2MDL_MAG_GetOutputDataRate+0x88>)
 8007e0c:	601a      	str	r2, [r3, #0]
      break;
 8007e0e:	e003      	b.n	8007e18 <LIS2MDL_MAG_GetOutputDataRate+0x70>

    default:
      ret = LIS2MDL_ERROR;
 8007e10:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007e14:	60fb      	str	r3, [r7, #12]
      break;
 8007e16:	bf00      	nop
  }

  return ret;
 8007e18:	68fb      	ldr	r3, [r7, #12]
}
 8007e1a:	4618      	mov	r0, r3
 8007e1c:	3710      	adds	r7, #16
 8007e1e:	46bd      	mov	sp, r7
 8007e20:	bd80      	pop	{r7, pc}
 8007e22:	bf00      	nop
 8007e24:	41200000 	.word	0x41200000
 8007e28:	41a00000 	.word	0x41a00000
 8007e2c:	42480000 	.word	0x42480000
 8007e30:	42c80000 	.word	0x42c80000

08007e34 <LIS2MDL_MAG_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_SetOutputDataRate(LIS2MDL_Object_t *pObj, float Odr)
{
 8007e34:	b580      	push	{r7, lr}
 8007e36:	b084      	sub	sp, #16
 8007e38:	af00      	add	r7, sp, #0
 8007e3a:	6078      	str	r0, [r7, #4]
 8007e3c:	ed87 0a00 	vstr	s0, [r7]
  lis2mdl_odr_t new_odr;
  lis2mdl_cfg_reg_a_t reg_a;

  new_odr = (Odr <= 10.000f) ? LIS2MDL_ODR_10Hz
            : (Odr <= 20.000f) ? LIS2MDL_ODR_20Hz
 8007e40:	edd7 7a00 	vldr	s15, [r7]
 8007e44:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8007e48:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007e4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007e50:	d801      	bhi.n	8007e56 <LIS2MDL_MAG_SetOutputDataRate+0x22>
 8007e52:	2300      	movs	r3, #0
 8007e54:	e016      	b.n	8007e84 <LIS2MDL_MAG_SetOutputDataRate+0x50>
 8007e56:	edd7 7a00 	vldr	s15, [r7]
 8007e5a:	eeb3 7a04 	vmov.f32	s14, #52	@ 0x41a00000  20.0
 8007e5e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007e62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007e66:	d801      	bhi.n	8007e6c <LIS2MDL_MAG_SetOutputDataRate+0x38>
 8007e68:	2301      	movs	r3, #1
 8007e6a:	e00b      	b.n	8007e84 <LIS2MDL_MAG_SetOutputDataRate+0x50>
 8007e6c:	edd7 7a00 	vldr	s15, [r7]
 8007e70:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 8007ef8 <LIS2MDL_MAG_SetOutputDataRate+0xc4>
 8007e74:	eef4 7ac7 	vcmpe.f32	s15, s14
 8007e78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007e7c:	d801      	bhi.n	8007e82 <LIS2MDL_MAG_SetOutputDataRate+0x4e>
 8007e7e:	2302      	movs	r3, #2
 8007e80:	e000      	b.n	8007e84 <LIS2MDL_MAG_SetOutputDataRate+0x50>
 8007e82:	2303      	movs	r3, #3
  new_odr = (Odr <= 10.000f) ? LIS2MDL_ODR_10Hz
 8007e84:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 50.000f) ? LIS2MDL_ODR_50Hz
            :                    LIS2MDL_ODR_100Hz;

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8007e86:	687b      	ldr	r3, [r7, #4]
 8007e88:	689b      	ldr	r3, [r3, #8]
 8007e8a:	2b03      	cmp	r3, #3
 8007e8c:	d121      	bne.n	8007ed2 <LIS2MDL_MAG_SetOutputDataRate+0x9e>
  {
    /* Read configuration from CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007e8e:	f107 020c 	add.w	r2, r7, #12
 8007e92:	2301      	movs	r3, #1
 8007e94:	2160      	movs	r1, #96	@ 0x60
 8007e96:	6878      	ldr	r0, [r7, #4]
 8007e98:	f000 f9a3 	bl	80081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8007e9c:	4603      	mov	r3, r0
 8007e9e:	2b00      	cmp	r3, #0
 8007ea0:	d002      	beq.n	8007ea8 <LIS2MDL_MAG_SetOutputDataRate+0x74>
    {
      return LIS2MDL_ERROR;
 8007ea2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007ea6:	e022      	b.n	8007eee <LIS2MDL_MAG_SetOutputDataRate+0xba>
    }

    /* Output data rate selection */
    reg_a.odr = new_odr;
 8007ea8:	7bfb      	ldrb	r3, [r7, #15]
 8007eaa:	f003 0303 	and.w	r3, r3, #3
 8007eae:	b2da      	uxtb	r2, r3
 8007eb0:	7b3b      	ldrb	r3, [r7, #12]
 8007eb2:	f362 0383 	bfi	r3, r2, #2, #2
 8007eb6:	733b      	strb	r3, [r7, #12]

    /* Write configuration to CFG_REG_A reg */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, LIS2MDL_CFG_REG_A, (uint8_t *)&reg_a, 1) != LIS2MDL_OK)
 8007eb8:	f107 020c 	add.w	r2, r7, #12
 8007ebc:	2301      	movs	r3, #1
 8007ebe:	2160      	movs	r1, #96	@ 0x60
 8007ec0:	6878      	ldr	r0, [r7, #4]
 8007ec2:	f000 facd 	bl	8008460 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 8007ec6:	4603      	mov	r3, r0
 8007ec8:	2b00      	cmp	r3, #0
 8007eca:	d00f      	beq.n	8007eec <LIS2MDL_MAG_SetOutputDataRate+0xb8>
    {
      return LIS2MDL_ERROR;
 8007ecc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007ed0:	e00d      	b.n	8007eee <LIS2MDL_MAG_SetOutputDataRate+0xba>
    }
  }
  else
  {
    if (lis2mdl_data_rate_set(&(pObj->Ctx), new_odr) != LIS2MDL_OK)
 8007ed2:	687b      	ldr	r3, [r7, #4]
 8007ed4:	3320      	adds	r3, #32
 8007ed6:	7bfa      	ldrb	r2, [r7, #15]
 8007ed8:	4611      	mov	r1, r2
 8007eda:	4618      	mov	r0, r3
 8007edc:	f000 fc34 	bl	8008748 <lis2mdl_data_rate_set>
 8007ee0:	4603      	mov	r3, r0
 8007ee2:	2b00      	cmp	r3, #0
 8007ee4:	d002      	beq.n	8007eec <LIS2MDL_MAG_SetOutputDataRate+0xb8>
    {
      return LIS2MDL_ERROR;
 8007ee6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007eea:	e000      	b.n	8007eee <LIS2MDL_MAG_SetOutputDataRate+0xba>
    }
  }

  return LIS2MDL_OK;
 8007eec:	2300      	movs	r3, #0
}
 8007eee:	4618      	mov	r0, r3
 8007ef0:	3710      	adds	r7, #16
 8007ef2:	46bd      	mov	sp, r7
 8007ef4:	bd80      	pop	{r7, pc}
 8007ef6:	bf00      	nop
 8007ef8:	42480000 	.word	0x42480000

08007efc <LIS2MDL_MAG_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetFullScale(LIS2MDL_Object_t *pObj, int32_t *FullScale)
{
 8007efc:	b480      	push	{r7}
 8007efe:	b083      	sub	sp, #12
 8007f00:	af00      	add	r7, sp, #0
 8007f02:	6078      	str	r0, [r7, #4]
 8007f04:	6039      	str	r1, [r7, #0]
  *FullScale = 50;
 8007f06:	683b      	ldr	r3, [r7, #0]
 8007f08:	2232      	movs	r2, #50	@ 0x32
 8007f0a:	601a      	str	r2, [r3, #0]

  return LIS2MDL_OK;
 8007f0c:	2300      	movs	r3, #0
}
 8007f0e:	4618      	mov	r0, r3
 8007f10:	370c      	adds	r7, #12
 8007f12:	46bd      	mov	sp, r7
 8007f14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f18:	4770      	bx	lr

08007f1a <LIS2MDL_MAG_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_SetFullScale(LIS2MDL_Object_t *pObj, int32_t FullScale)
{
 8007f1a:	b480      	push	{r7}
 8007f1c:	b083      	sub	sp, #12
 8007f1e:	af00      	add	r7, sp, #0
 8007f20:	6078      	str	r0, [r7, #4]
 8007f22:	6039      	str	r1, [r7, #0]
  return LIS2MDL_OK;
 8007f24:	2300      	movs	r3, #0
}
 8007f26:	4618      	mov	r0, r3
 8007f28:	370c      	adds	r7, #12
 8007f2a:	46bd      	mov	sp, r7
 8007f2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f30:	4770      	bx	lr

08007f32 <LIS2MDL_MAG_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetAxesRaw(LIS2MDL_Object_t *pObj, LIS2MDL_AxesRaw_t *Value)
{
 8007f32:	b580      	push	{r7, lr}
 8007f34:	b084      	sub	sp, #16
 8007f36:	af00      	add	r7, sp, #0
 8007f38:	6078      	str	r0, [r7, #4]
 8007f3a:	6039      	str	r1, [r7, #0]
  lis2mdl_axis3bit16_t data_raw;

  /* Read raw data values. */
  if (lis2mdl_magnetic_raw_get(&(pObj->Ctx), data_raw.i16bit) != LIS2MDL_OK)
 8007f3c:	687b      	ldr	r3, [r7, #4]
 8007f3e:	3320      	adds	r3, #32
 8007f40:	f107 0208 	add.w	r2, r7, #8
 8007f44:	4611      	mov	r1, r2
 8007f46:	4618      	mov	r0, r3
 8007f48:	f000 fc82 	bl	8008850 <lis2mdl_magnetic_raw_get>
 8007f4c:	4603      	mov	r3, r0
 8007f4e:	2b00      	cmp	r3, #0
 8007f50:	d002      	beq.n	8007f58 <LIS2MDL_MAG_GetAxesRaw+0x26>
  {
    return LIS2MDL_ERROR;
 8007f52:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007f56:	e00c      	b.n	8007f72 <LIS2MDL_MAG_GetAxesRaw+0x40>
  }

  /* Format the data. */
  Value->x = data_raw.i16bit[0];
 8007f58:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8007f5c:	683b      	ldr	r3, [r7, #0]
 8007f5e:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw.i16bit[1];
 8007f60:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8007f64:	683b      	ldr	r3, [r7, #0]
 8007f66:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw.i16bit[2];
 8007f68:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8007f6c:	683b      	ldr	r3, [r7, #0]
 8007f6e:	809a      	strh	r2, [r3, #4]

  return LIS2MDL_OK;
 8007f70:	2300      	movs	r3, #0
}
 8007f72:	4618      	mov	r0, r3
 8007f74:	3710      	adds	r7, #16
 8007f76:	46bd      	mov	sp, r7
 8007f78:	bd80      	pop	{r7, pc}

08007f7a <LIS2MDL_MAG_GetAxes>:
  * @param  pObj the device pObj
  * @param  MagneticField pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_MAG_GetAxes(LIS2MDL_Object_t *pObj, LIS2MDL_Axes_t *MagneticField)
{
 8007f7a:	b580      	push	{r7, lr}
 8007f7c:	b088      	sub	sp, #32
 8007f7e:	af00      	add	r7, sp, #0
 8007f80:	6078      	str	r0, [r7, #4]
 8007f82:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  lis2mdl_axis3bit16_t data_raw;
  float sensitivity;

  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8007f84:	687b      	ldr	r3, [r7, #4]
 8007f86:	689b      	ldr	r3, [r3, #8]
 8007f88:	2b03      	cmp	r3, #3
 8007f8a:	d134      	bne.n	8007ff6 <LIS2MDL_MAG_GetAxes+0x7c>
  {
    /* Read raw data values. */
    if (LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(pObj, LIS2MDL_OUTX_L_REG, buff, 6) != LIS2MDL_OK)
 8007f8c:	f107 0218 	add.w	r2, r7, #24
 8007f90:	2306      	movs	r3, #6
 8007f92:	2168      	movs	r1, #104	@ 0x68
 8007f94:	6878      	ldr	r0, [r7, #4]
 8007f96:	f000 f924 	bl	80081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>
 8007f9a:	4603      	mov	r3, r0
 8007f9c:	2b00      	cmp	r3, #0
 8007f9e:	d002      	beq.n	8007fa6 <LIS2MDL_MAG_GetAxes+0x2c>
    {
      return LIS2MDL_ERROR;
 8007fa0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8007fa4:	e06c      	b.n	8008080 <LIS2MDL_MAG_GetAxes+0x106>
    }
    data_raw.i16bit[0] = (int16_t)buff[1];
 8007fa6:	7e7b      	ldrb	r3, [r7, #25]
 8007fa8:	b21b      	sxth	r3, r3
 8007faa:	823b      	strh	r3, [r7, #16]
    data_raw.i16bit[0] = (data_raw.i16bit[0] * 256) + (int16_t)buff[0];
 8007fac:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8007fb0:	b29b      	uxth	r3, r3
 8007fb2:	021b      	lsls	r3, r3, #8
 8007fb4:	b29b      	uxth	r3, r3
 8007fb6:	7e3a      	ldrb	r2, [r7, #24]
 8007fb8:	4413      	add	r3, r2
 8007fba:	b29b      	uxth	r3, r3
 8007fbc:	b21b      	sxth	r3, r3
 8007fbe:	823b      	strh	r3, [r7, #16]
    data_raw.i16bit[1] = (int16_t)buff[3];
 8007fc0:	7efb      	ldrb	r3, [r7, #27]
 8007fc2:	b21b      	sxth	r3, r3
 8007fc4:	827b      	strh	r3, [r7, #18]
    data_raw.i16bit[1] = (data_raw.i16bit[1] * 256) + (int16_t)buff[2];
 8007fc6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8007fca:	b29b      	uxth	r3, r3
 8007fcc:	021b      	lsls	r3, r3, #8
 8007fce:	b29b      	uxth	r3, r3
 8007fd0:	7eba      	ldrb	r2, [r7, #26]
 8007fd2:	4413      	add	r3, r2
 8007fd4:	b29b      	uxth	r3, r3
 8007fd6:	b21b      	sxth	r3, r3
 8007fd8:	827b      	strh	r3, [r7, #18]
    data_raw.i16bit[2] = (int16_t)buff[5];
 8007fda:	7f7b      	ldrb	r3, [r7, #29]
 8007fdc:	b21b      	sxth	r3, r3
 8007fde:	82bb      	strh	r3, [r7, #20]
    data_raw.i16bit[2] = (data_raw.i16bit[2] * 256) + (int16_t)buff[4];
 8007fe0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8007fe4:	b29b      	uxth	r3, r3
 8007fe6:	021b      	lsls	r3, r3, #8
 8007fe8:	b29b      	uxth	r3, r3
 8007fea:	7f3a      	ldrb	r2, [r7, #28]
 8007fec:	4413      	add	r3, r2
 8007fee:	b29b      	uxth	r3, r3
 8007ff0:	b21b      	sxth	r3, r3
 8007ff2:	82bb      	strh	r3, [r7, #20]
 8007ff4:	e00d      	b.n	8008012 <LIS2MDL_MAG_GetAxes+0x98>
  }
  else
  {
    /* Read raw data values. */
    if (lis2mdl_magnetic_raw_get(&(pObj->Ctx), data_raw.i16bit) != LIS2MDL_OK)
 8007ff6:	687b      	ldr	r3, [r7, #4]
 8007ff8:	3320      	adds	r3, #32
 8007ffa:	f107 0210 	add.w	r2, r7, #16
 8007ffe:	4611      	mov	r1, r2
 8008000:	4618      	mov	r0, r3
 8008002:	f000 fc25 	bl	8008850 <lis2mdl_magnetic_raw_get>
 8008006:	4603      	mov	r3, r0
 8008008:	2b00      	cmp	r3, #0
 800800a:	d002      	beq.n	8008012 <LIS2MDL_MAG_GetAxes+0x98>
    {
      return LIS2MDL_ERROR;
 800800c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008010:	e036      	b.n	8008080 <LIS2MDL_MAG_GetAxes+0x106>
    }
  }

  /* Get LIS2MDL actual sensitivity. */
  (void)LIS2MDL_MAG_GetSensitivity(pObj, &sensitivity);
 8008012:	f107 030c 	add.w	r3, r7, #12
 8008016:	4619      	mov	r1, r3
 8008018:	6878      	ldr	r0, [r7, #4]
 800801a:	f7ff feb4 	bl	8007d86 <LIS2MDL_MAG_GetSensitivity>

  /* Calculate the data. */
  MagneticField->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800801e:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8008022:	ee07 3a90 	vmov	s15, r3
 8008026:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800802a:	edd7 7a03 	vldr	s15, [r7, #12]
 800802e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008032:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8008036:	ee17 2a90 	vmov	r2, s15
 800803a:	683b      	ldr	r3, [r7, #0]
 800803c:	601a      	str	r2, [r3, #0]
  MagneticField->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800803e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8008042:	ee07 3a90 	vmov	s15, r3
 8008046:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800804a:	edd7 7a03 	vldr	s15, [r7, #12]
 800804e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008052:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8008056:	ee17 2a90 	vmov	r2, s15
 800805a:	683b      	ldr	r3, [r7, #0]
 800805c:	605a      	str	r2, [r3, #4]
  MagneticField->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800805e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8008062:	ee07 3a90 	vmov	s15, r3
 8008066:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800806a:	edd7 7a03 	vldr	s15, [r7, #12]
 800806e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008072:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8008076:	ee17 2a90 	vmov	r2, s15
 800807a:	683b      	ldr	r3, [r7, #0]
 800807c:	609a      	str	r2, [r3, #8]

  return LIS2MDL_OK;
 800807e:	2300      	movs	r3, #0
}
 8008080:	4618      	mov	r0, r3
 8008082:	3720      	adds	r7, #32
 8008084:	46bd      	mov	sp, r7
 8008086:	bd80      	pop	{r7, pc}

08008088 <LIS2MDL_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LIS2MDL_Write_Reg(LIS2MDL_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 8008088:	b580      	push	{r7, lr}
 800808a:	b082      	sub	sp, #8
 800808c:	af00      	add	r7, sp, #0
 800808e:	6078      	str	r0, [r7, #4]
 8008090:	460b      	mov	r3, r1
 8008092:	70fb      	strb	r3, [r7, #3]
 8008094:	4613      	mov	r3, r2
 8008096:	70bb      	strb	r3, [r7, #2]
  if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 8008098:	687b      	ldr	r3, [r7, #4]
 800809a:	689b      	ldr	r3, [r3, #8]
 800809c:	2b03      	cmp	r3, #3
 800809e:	d10b      	bne.n	80080b8 <LIS2MDL_Write_Reg+0x30>
  {
    if (LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(pObj, Reg, (uint8_t *)&Data, 1) != LIS2MDL_OK)
 80080a0:	1cba      	adds	r2, r7, #2
 80080a2:	78f9      	ldrb	r1, [r7, #3]
 80080a4:	2301      	movs	r3, #1
 80080a6:	6878      	ldr	r0, [r7, #4]
 80080a8:	f000 f9da 	bl	8008460 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>
 80080ac:	4603      	mov	r3, r0
 80080ae:	2b00      	cmp	r3, #0
 80080b0:	d010      	beq.n	80080d4 <LIS2MDL_Write_Reg+0x4c>
    {
      return LIS2MDL_ERROR;
 80080b2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80080b6:	e00e      	b.n	80080d6 <LIS2MDL_Write_Reg+0x4e>
    }
  }
  else
  {
    if (lis2mdl_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LIS2MDL_OK)
 80080b8:	687b      	ldr	r3, [r7, #4]
 80080ba:	f103 0020 	add.w	r0, r3, #32
 80080be:	1cba      	adds	r2, r7, #2
 80080c0:	78f9      	ldrb	r1, [r7, #3]
 80080c2:	2301      	movs	r3, #1
 80080c4:	f000 fb02 	bl	80086cc <lis2mdl_write_reg>
 80080c8:	4603      	mov	r3, r0
 80080ca:	2b00      	cmp	r3, #0
 80080cc:	d002      	beq.n	80080d4 <LIS2MDL_Write_Reg+0x4c>
    {
      return LIS2MDL_ERROR;
 80080ce:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80080d2:	e000      	b.n	80080d6 <LIS2MDL_Write_Reg+0x4e>
    }
  }

  return LIS2MDL_OK;
 80080d4:	2300      	movs	r3, #0
}
 80080d6:	4618      	mov	r0, r3
 80080d8:	3708      	adds	r7, #8
 80080da:	46bd      	mov	sp, r7
 80080dc:	bd80      	pop	{r7, pc}

080080de <ReadMagRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadMagRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 80080de:	b590      	push	{r4, r7, lr}
 80080e0:	b087      	sub	sp, #28
 80080e2:	af00      	add	r7, sp, #0
 80080e4:	60f8      	str	r0, [r7, #12]
 80080e6:	607a      	str	r2, [r7, #4]
 80080e8:	461a      	mov	r2, r3
 80080ea:	460b      	mov	r3, r1
 80080ec:	72fb      	strb	r3, [r7, #11]
 80080ee:	4613      	mov	r3, r2
 80080f0:	813b      	strh	r3, [r7, #8]
  LIS2MDL_Object_t *pObj = (LIS2MDL_Object_t *)Handle;
 80080f2:	68fb      	ldr	r3, [r7, #12]
 80080f4:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == LIS2MDL_I2C_BUS) /* I2C */
 80080f6:	697b      	ldr	r3, [r7, #20]
 80080f8:	689b      	ldr	r3, [r3, #8]
 80080fa:	2b00      	cmp	r3, #0
 80080fc:	d10e      	bne.n	800811c <ReadMagRegWrap+0x3e>
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 80080fe:	697b      	ldr	r3, [r7, #20]
 8008100:	695c      	ldr	r4, [r3, #20]
 8008102:	697b      	ldr	r3, [r7, #20]
 8008104:	7b1b      	ldrb	r3, [r3, #12]
 8008106:	4618      	mov	r0, r3
 8008108:	7afb      	ldrb	r3, [r7, #11]
 800810a:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 800810e:	b2db      	uxtb	r3, r3
 8008110:	4619      	mov	r1, r3
 8008112:	893b      	ldrh	r3, [r7, #8]
 8008114:	687a      	ldr	r2, [r7, #4]
 8008116:	47a0      	blx	r4
 8008118:	4603      	mov	r3, r0
 800811a:	e01d      	b.n	8008158 <ReadMagRegWrap+0x7a>
  }
  else if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 800811c:	697b      	ldr	r3, [r7, #20]
 800811e:	689b      	ldr	r3, [r3, #8]
 8008120:	2b03      	cmp	r3, #3
 8008122:	d10b      	bne.n	800813c <ReadMagRegWrap+0x5e>
  {
    return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 8008124:	697b      	ldr	r3, [r7, #20]
 8008126:	695c      	ldr	r4, [r3, #20]
 8008128:	697b      	ldr	r3, [r7, #20]
 800812a:	7b1b      	ldrb	r3, [r3, #12]
 800812c:	4618      	mov	r0, r3
 800812e:	7afb      	ldrb	r3, [r7, #11]
 8008130:	b299      	uxth	r1, r3
 8008132:	893b      	ldrh	r3, [r7, #8]
 8008134:	687a      	ldr	r2, [r7, #4]
 8008136:	47a0      	blx	r4
 8008138:	4603      	mov	r3, r0
 800813a:	e00d      	b.n	8008158 <ReadMagRegWrap+0x7a>
  }
  else   /* SPI 3-Wires or SPI 4-Wires */
  {
    /* Enable Multi-byte read */
    return pObj->IO.ReadReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 800813c:	697b      	ldr	r3, [r7, #20]
 800813e:	695c      	ldr	r4, [r3, #20]
 8008140:	697b      	ldr	r3, [r7, #20]
 8008142:	7b1b      	ldrb	r3, [r3, #12]
 8008144:	4618      	mov	r0, r3
 8008146:	7afb      	ldrb	r3, [r7, #11]
 8008148:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800814c:	b2db      	uxtb	r3, r3
 800814e:	4619      	mov	r1, r3
 8008150:	893b      	ldrh	r3, [r7, #8]
 8008152:	687a      	ldr	r2, [r7, #4]
 8008154:	47a0      	blx	r4
 8008156:	4603      	mov	r3, r0
  }
}
 8008158:	4618      	mov	r0, r3
 800815a:	371c      	adds	r7, #28
 800815c:	46bd      	mov	sp, r7
 800815e:	bd90      	pop	{r4, r7, pc}

08008160 <WriteMagRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteMagRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 8008160:	b590      	push	{r4, r7, lr}
 8008162:	b087      	sub	sp, #28
 8008164:	af00      	add	r7, sp, #0
 8008166:	60f8      	str	r0, [r7, #12]
 8008168:	607a      	str	r2, [r7, #4]
 800816a:	461a      	mov	r2, r3
 800816c:	460b      	mov	r3, r1
 800816e:	72fb      	strb	r3, [r7, #11]
 8008170:	4613      	mov	r3, r2
 8008172:	813b      	strh	r3, [r7, #8]
  LIS2MDL_Object_t *pObj = (LIS2MDL_Object_t *)Handle;
 8008174:	68fb      	ldr	r3, [r7, #12]
 8008176:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == LIS2MDL_I2C_BUS) /* I2C */
 8008178:	697b      	ldr	r3, [r7, #20]
 800817a:	689b      	ldr	r3, [r3, #8]
 800817c:	2b00      	cmp	r3, #0
 800817e:	d10e      	bne.n	800819e <WriteMagRegWrap+0x3e>
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x80U), pData, Length);
 8008180:	697b      	ldr	r3, [r7, #20]
 8008182:	691c      	ldr	r4, [r3, #16]
 8008184:	697b      	ldr	r3, [r7, #20]
 8008186:	7b1b      	ldrb	r3, [r3, #12]
 8008188:	4618      	mov	r0, r3
 800818a:	7afb      	ldrb	r3, [r7, #11]
 800818c:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8008190:	b2db      	uxtb	r3, r3
 8008192:	4619      	mov	r1, r3
 8008194:	893b      	ldrh	r3, [r7, #8]
 8008196:	687a      	ldr	r2, [r7, #4]
 8008198:	47a0      	blx	r4
 800819a:	4603      	mov	r3, r0
 800819c:	e01d      	b.n	80081da <WriteMagRegWrap+0x7a>
  }
  else if (pObj->IO.BusType == LSM6DSOX_SENSORHUB_LIS2MDL_I2C_BUS) /* LSM6DSOX SensorHub with LIS2MDL example */
 800819e:	697b      	ldr	r3, [r7, #20]
 80081a0:	689b      	ldr	r3, [r3, #8]
 80081a2:	2b03      	cmp	r3, #3
 80081a4:	d10b      	bne.n	80081be <WriteMagRegWrap+0x5e>
  {
    return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 80081a6:	697b      	ldr	r3, [r7, #20]
 80081a8:	691c      	ldr	r4, [r3, #16]
 80081aa:	697b      	ldr	r3, [r7, #20]
 80081ac:	7b1b      	ldrb	r3, [r3, #12]
 80081ae:	4618      	mov	r0, r3
 80081b0:	7afb      	ldrb	r3, [r7, #11]
 80081b2:	b299      	uxth	r1, r3
 80081b4:	893b      	ldrh	r3, [r7, #8]
 80081b6:	687a      	ldr	r2, [r7, #4]
 80081b8:	47a0      	blx	r4
 80081ba:	4603      	mov	r3, r0
 80081bc:	e00d      	b.n	80081da <WriteMagRegWrap+0x7a>
  }
  else   /* SPI 3-Wires or SPI 4-Wires */
  {
    /* Enable Multi-byte write */
    return pObj->IO.WriteReg(pObj->IO.Address, (Reg | 0x40U), pData, Length);
 80081be:	697b      	ldr	r3, [r7, #20]
 80081c0:	691c      	ldr	r4, [r3, #16]
 80081c2:	697b      	ldr	r3, [r7, #20]
 80081c4:	7b1b      	ldrb	r3, [r3, #12]
 80081c6:	4618      	mov	r0, r3
 80081c8:	7afb      	ldrb	r3, [r7, #11]
 80081ca:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80081ce:	b2db      	uxtb	r3, r3
 80081d0:	4619      	mov	r1, r3
 80081d2:	893b      	ldrh	r3, [r7, #8]
 80081d4:	687a      	ldr	r2, [r7, #4]
 80081d6:	47a0      	blx	r4
 80081d8:	4603      	mov	r3, r0
  }
}
 80081da:	4618      	mov	r0, r3
 80081dc:	371c      	adds	r7, #28
 80081de:	46bd      	mov	sp, r7
 80081e0:	bd90      	pop	{r4, r7, pc}

080081e2 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData>:
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData(LIS2MDL_Object_t *pObj, uint8_t Reg, uint8_t *pData,
                                                     uint16_t Length)
{
 80081e2:	b580      	push	{r7, lr}
 80081e4:	b08c      	sub	sp, #48	@ 0x30
 80081e6:	af00      	add	r7, sp, #0
 80081e8:	60f8      	str	r0, [r7, #12]
 80081ea:	607a      	str	r2, [r7, #4]
 80081ec:	461a      	mov	r2, r3
 80081ee:	460b      	mov	r3, r1
 80081f0:	72fb      	strb	r3, [r7, #11]
 80081f2:	4613      	mov	r3, r2
 80081f4:	813b      	strh	r3, [r7, #8]
  uint8_t lsm6dsox_func_cfg_access = 0x01U;
 80081f6:	2301      	movs	r3, #1
 80081f8:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint8_t shub_reg_access_en = 0x40U;
 80081fc:	2340      	movs	r3, #64	@ 0x40
 80081fe:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
  uint8_t shub_reg_access_dis = 0x00U;
 8008202:	2300      	movs	r3, #0
 8008204:	f887 3020 	strb.w	r3, [r7, #32]
  uint8_t ext_sens_addr_read = LIS2MDL_I2C_ADD | 0x01U;
 8008208:	233d      	movs	r3, #61	@ 0x3d
 800820a:	77fb      	strb	r3, [r7, #31]
  uint8_t slv0_add = 0x15U;
 800820c:	2315      	movs	r3, #21
 800820e:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
  uint8_t slv0_subadd = 0x16U;
 8008212:	2316      	movs	r3, #22
 8008214:	f887 302d 	strb.w	r3, [r7, #45]	@ 0x2d
  uint8_t slave0_config = 0x17U;
 8008218:	2317      	movs	r3, #23
 800821a:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c
  uint8_t master_config = 0x14U;
 800821e:	2314      	movs	r3, #20
 8008220:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
  uint8_t write_once_i2c_en = 0x44U;
 8008224:	2344      	movs	r3, #68	@ 0x44
 8008226:	77bb      	strb	r3, [r7, #30]
  uint8_t sensor_hub_1 = 0x02U;
 8008228:	2302      	movs	r3, #2
 800822a:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
  uint8_t status_master_mainpage = 0x39U;
 800822e:	2339      	movs	r3, #57	@ 0x39
 8008230:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
  uint8_t sens_hub_endop = 0x01U;
 8008234:	2301      	movs	r3, #1
 8008236:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
  uint8_t lsm6dsox_outx_h_a = 0x29U;
 800823a:	2329      	movs	r3, #41	@ 0x29
 800823c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint8_t lsm6dsox_status_reg = 0x1EU;
 8008240:	231e      	movs	r3, #30
 8008242:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  uint8_t xlda = 0x01U;
 8008246:	2301      	movs	r3, #1
 8008248:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
  uint8_t len = (uint8_t)Length;
 800824c:	893b      	ldrh	r3, [r7, #8]
 800824e:	b2db      	uxtb	r3, r3
 8008250:	777b      	strb	r3, [r7, #29]
  uint8_t lsm6dsox_ctrl1_xl = 0x10U;
 8008252:	2310      	movs	r3, #16
 8008254:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
  uint8_t lsm6dsox_xl_prev_odr;
  uint8_t lsm6dsox_xl_odr_off = 0x00U;
 8008258:	2300      	movs	r3, #0
 800825a:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
  uint8_t lsm6dsox_xl_odr_104hz = 0x40U;
 800825e:	2340      	movs	r3, #64	@ 0x40
 8008260:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
  uint8_t data;
  uint8_t data_array[6];

  /* Enable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_en, 1) != LIS2MDL_OK)
 8008264:	68fb      	ldr	r3, [r7, #12]
 8008266:	f103 0020 	add.w	r0, r3, #32
 800826a:	f107 0221 	add.w	r2, r7, #33	@ 0x21
 800826e:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 8008272:	2301      	movs	r3, #1
 8008274:	f000 fa2a 	bl	80086cc <lis2mdl_write_reg>
 8008278:	4603      	mov	r3, r0
 800827a:	2b00      	cmp	r3, #0
 800827c:	d002      	beq.n	8008284 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0xa2>
  {
    return LIS2MDL_ERROR;
 800827e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008282:	e0e9      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Configure external device address, Enable read operation (rw_0 = 1) */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_add, &ext_sens_addr_read, 1) != LIS2MDL_OK)
 8008284:	68fb      	ldr	r3, [r7, #12]
 8008286:	f103 0020 	add.w	r0, r3, #32
 800828a:	f107 021f 	add.w	r2, r7, #31
 800828e:	f897 102e 	ldrb.w	r1, [r7, #46]	@ 0x2e
 8008292:	2301      	movs	r3, #1
 8008294:	f000 fa1a 	bl	80086cc <lis2mdl_write_reg>
 8008298:	4603      	mov	r3, r0
 800829a:	2b00      	cmp	r3, #0
 800829c:	d002      	beq.n	80082a4 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0xc2>
  {
    return LIS2MDL_ERROR;
 800829e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80082a2:	e0d9      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Configure address of the LIS2MDL register to be read */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_subadd, &Reg, 1) != LIS2MDL_OK)
 80082a4:	68fb      	ldr	r3, [r7, #12]
 80082a6:	f103 0020 	add.w	r0, r3, #32
 80082aa:	f107 020b 	add.w	r2, r7, #11
 80082ae:	f897 102d 	ldrb.w	r1, [r7, #45]	@ 0x2d
 80082b2:	2301      	movs	r3, #1
 80082b4:	f000 fa0a 	bl	80086cc <lis2mdl_write_reg>
 80082b8:	4603      	mov	r3, r0
 80082ba:	2b00      	cmp	r3, #0
 80082bc:	d002      	beq.n	80082c4 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0xe2>
  {
    return LIS2MDL_ERROR;
 80082be:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80082c2:	e0c9      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read required number of bytes (up to 6), SHUB_ODR = 104 Hz */
  if (lis2mdl_write_reg(&(pObj->Ctx), slave0_config, &len, 1) != LIS2MDL_OK)
 80082c4:	68fb      	ldr	r3, [r7, #12]
 80082c6:	f103 0020 	add.w	r0, r3, #32
 80082ca:	f107 021d 	add.w	r2, r7, #29
 80082ce:	f897 102c 	ldrb.w	r1, [r7, #44]	@ 0x2c
 80082d2:	2301      	movs	r3, #1
 80082d4:	f000 f9fa 	bl	80086cc <lis2mdl_write_reg>
 80082d8:	4603      	mov	r3, r0
 80082da:	2b00      	cmp	r3, #0
 80082dc:	d002      	beq.n	80082e4 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x102>
  {
    return LIS2MDL_ERROR;
 80082de:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80082e2:	e0b9      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* WRITE_ONCE is mandatory for read, I2C master enabled using slave 0, I2C pull-ups disabled */
  if (lis2mdl_write_reg(&(pObj->Ctx), master_config, &write_once_i2c_en, 1) != LIS2MDL_OK)
 80082e4:	68fb      	ldr	r3, [r7, #12]
 80082e6:	f103 0020 	add.w	r0, r3, #32
 80082ea:	f107 021e 	add.w	r2, r7, #30
 80082ee:	f897 102b 	ldrb.w	r1, [r7, #43]	@ 0x2b
 80082f2:	2301      	movs	r3, #1
 80082f4:	f000 f9ea 	bl	80086cc <lis2mdl_write_reg>
 80082f8:	4603      	mov	r3, r0
 80082fa:	2b00      	cmp	r3, #0
 80082fc:	d002      	beq.n	8008304 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x122>
  {
    return LIS2MDL_ERROR;
 80082fe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008302:	e0a9      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Disable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_dis, 1) != LIS2MDL_OK)
 8008304:	68fb      	ldr	r3, [r7, #12]
 8008306:	f103 0020 	add.w	r0, r3, #32
 800830a:	f107 0220 	add.w	r2, r7, #32
 800830e:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 8008312:	2301      	movs	r3, #1
 8008314:	f000 f9da 	bl	80086cc <lis2mdl_write_reg>
 8008318:	4603      	mov	r3, r0
 800831a:	2b00      	cmp	r3, #0
 800831c:	d002      	beq.n	8008324 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x142>
  {
    return LIS2MDL_ERROR;
 800831e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008322:	e099      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read LSM6DSOX ODR */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 8008324:	68fb      	ldr	r3, [r7, #12]
 8008326:	f103 0020 	add.w	r0, r3, #32
 800832a:	f107 021c 	add.w	r2, r7, #28
 800832e:	f897 1024 	ldrb.w	r1, [r7, #36]	@ 0x24
 8008332:	2301      	movs	r3, #1
 8008334:	f000 f9b2 	bl	800869c <lis2mdl_read_reg>
 8008338:	4603      	mov	r3, r0
 800833a:	2b00      	cmp	r3, #0
 800833c:	d002      	beq.n	8008344 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x162>
  {
    return LIS2MDL_ERROR;
 800833e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008342:	e089      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Set XL_ODR_104HZ if the accelerometer is disabled */
  if (lsm6dsox_xl_prev_odr == lsm6dsox_xl_odr_off)
 8008344:	7f3b      	ldrb	r3, [r7, #28]
 8008346:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
 800834a:	429a      	cmp	r2, r3
 800834c:	d102      	bne.n	8008354 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x172>
  {
    lsm6dsox_xl_prev_odr = lsm6dsox_xl_odr_104hz;
 800834e:	f897 3022 	ldrb.w	r3, [r7, #34]	@ 0x22
 8008352:	773b      	strb	r3, [r7, #28]
  }

  /* Enable accelerometer to trigger Sensor Hub operation */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 8008354:	68fb      	ldr	r3, [r7, #12]
 8008356:	f103 0020 	add.w	r0, r3, #32
 800835a:	f107 021c 	add.w	r2, r7, #28
 800835e:	f897 1024 	ldrb.w	r1, [r7, #36]	@ 0x24
 8008362:	2301      	movs	r3, #1
 8008364:	f000 f9b2 	bl	80086cc <lis2mdl_write_reg>
 8008368:	4603      	mov	r3, r0
 800836a:	2b00      	cmp	r3, #0
 800836c:	d002      	beq.n	8008374 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x192>
  {
    return LIS2MDL_ERROR;
 800836e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008372:	e071      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read ACC data starting from LSM6DSOX OUTX_H_A register to clear accelerometer data-ready XLDA */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_outx_h_a, data_array, 6) != LIS2MDL_OK)
 8008374:	68fb      	ldr	r3, [r7, #12]
 8008376:	f103 0020 	add.w	r0, r3, #32
 800837a:	f107 0214 	add.w	r2, r7, #20
 800837e:	f897 1027 	ldrb.w	r1, [r7, #39]	@ 0x27
 8008382:	2306      	movs	r3, #6
 8008384:	f000 f98a 	bl	800869c <lis2mdl_read_reg>
 8008388:	4603      	mov	r3, r0
 800838a:	2b00      	cmp	r3, #0
 800838c:	d002      	beq.n	8008394 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1b2>
  {
    return LIS2MDL_ERROR;
 800838e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008392:	e061      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Poll LSM6DSOX LSM6DSOX_STATUS_REG until XLDA = 1 (Wait for sensor hub trigger) */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_status_reg, &data, 1) != LIS2MDL_OK)
 8008394:	68fb      	ldr	r3, [r7, #12]
 8008396:	f103 0020 	add.w	r0, r3, #32
 800839a:	f107 021b 	add.w	r2, r7, #27
 800839e:	f897 1026 	ldrb.w	r1, [r7, #38]	@ 0x26
 80083a2:	2301      	movs	r3, #1
 80083a4:	f000 f97a 	bl	800869c <lis2mdl_read_reg>
 80083a8:	4603      	mov	r3, r0
 80083aa:	2b00      	cmp	r3, #0
 80083ac:	d002      	beq.n	80083b4 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1d2>
    {
      return LIS2MDL_ERROR;
 80083ae:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80083b2:	e051      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
    }
  } while ((data & xlda) != xlda);
 80083b4:	7efa      	ldrb	r2, [r7, #27]
 80083b6:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 80083ba:	4013      	ands	r3, r2
 80083bc:	b2db      	uxtb	r3, r3
 80083be:	f897 2025 	ldrb.w	r2, [r7, #37]	@ 0x25
 80083c2:	429a      	cmp	r2, r3
 80083c4:	d1e6      	bne.n	8008394 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1b2>

  /* Poll LSM6DSOX SensorHub SENS_HUB_ENDOP bit in STATUS_MASTER_MAINPAGE reg until the end of SW write operations */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), status_master_mainpage, &data, 1) != LIS2MDL_OK)
 80083c6:	68fb      	ldr	r3, [r7, #12]
 80083c8:	f103 0020 	add.w	r0, r3, #32
 80083cc:	f107 021b 	add.w	r2, r7, #27
 80083d0:	f897 1029 	ldrb.w	r1, [r7, #41]	@ 0x29
 80083d4:	2301      	movs	r3, #1
 80083d6:	f000 f961 	bl	800869c <lis2mdl_read_reg>
 80083da:	4603      	mov	r3, r0
 80083dc:	2b00      	cmp	r3, #0
 80083de:	d002      	beq.n	80083e6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x204>
    {
      return LIS2MDL_ERROR;
 80083e0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80083e4:	e038      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
    }
  } while ((data & sens_hub_endop) != sens_hub_endop);
 80083e6:	7efa      	ldrb	r2, [r7, #27]
 80083e8:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 80083ec:	4013      	ands	r3, r2
 80083ee:	b2db      	uxtb	r3, r3
 80083f0:	f897 2028 	ldrb.w	r2, [r7, #40]	@ 0x28
 80083f4:	429a      	cmp	r2, r3
 80083f6:	d1e6      	bne.n	80083c6 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x1e4>

  /* Enable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_en, 1) != LIS2MDL_OK)
 80083f8:	68fb      	ldr	r3, [r7, #12]
 80083fa:	f103 0020 	add.w	r0, r3, #32
 80083fe:	f107 0221 	add.w	r2, r7, #33	@ 0x21
 8008402:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 8008406:	2301      	movs	r3, #1
 8008408:	f000 f960 	bl	80086cc <lis2mdl_write_reg>
 800840c:	4603      	mov	r3, r0
 800840e:	2b00      	cmp	r3, #0
 8008410:	d002      	beq.n	8008418 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x236>
  {
    return LIS2MDL_ERROR;
 8008412:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008416:	e01f      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Read data from LSM6DSOX SensorHub regs containing values from required LIS2MDL regs */
  if (lis2mdl_read_reg(&(pObj->Ctx), sensor_hub_1, pData, Length) != LIS2MDL_OK)
 8008418:	68fb      	ldr	r3, [r7, #12]
 800841a:	f103 0020 	add.w	r0, r3, #32
 800841e:	893b      	ldrh	r3, [r7, #8]
 8008420:	f897 102a 	ldrb.w	r1, [r7, #42]	@ 0x2a
 8008424:	687a      	ldr	r2, [r7, #4]
 8008426:	f000 f939 	bl	800869c <lis2mdl_read_reg>
 800842a:	4603      	mov	r3, r0
 800842c:	2b00      	cmp	r3, #0
 800842e:	d002      	beq.n	8008436 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x254>
  {
    return LIS2MDL_ERROR;
 8008430:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008434:	e010      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  /* Disable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_dis, 1) != LIS2MDL_OK)
 8008436:	68fb      	ldr	r3, [r7, #12]
 8008438:	f103 0020 	add.w	r0, r3, #32
 800843c:	f107 0220 	add.w	r2, r7, #32
 8008440:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 8008444:	2301      	movs	r3, #1
 8008446:	f000 f941 	bl	80086cc <lis2mdl_write_reg>
 800844a:	4603      	mov	r3, r0
 800844c:	2b00      	cmp	r3, #0
 800844e:	d002      	beq.n	8008456 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x274>
  {
    return LIS2MDL_ERROR;
 8008450:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008454:	e000      	b.n	8008458 <LSM6DSOX_SENSORHUB_LIS2MDL_ReadShData+0x276>
  }

  return LIS2MDL_OK;
 8008456:	2300      	movs	r3, #0
}
 8008458:	4618      	mov	r0, r3
 800845a:	3730      	adds	r7, #48	@ 0x30
 800845c:	46bd      	mov	sp, r7
 800845e:	bd80      	pop	{r7, pc}

08008460 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData>:
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData(LIS2MDL_Object_t *pObj, uint8_t Reg, uint8_t *pData,
                                                      uint16_t Length)
{
 8008460:	b580      	push	{r7, lr}
 8008462:	b08c      	sub	sp, #48	@ 0x30
 8008464:	af00      	add	r7, sp, #0
 8008466:	60f8      	str	r0, [r7, #12]
 8008468:	607a      	str	r2, [r7, #4]
 800846a:	461a      	mov	r2, r3
 800846c:	460b      	mov	r3, r1
 800846e:	72fb      	strb	r3, [r7, #11]
 8008470:	4613      	mov	r3, r2
 8008472:	813b      	strh	r3, [r7, #8]
  uint8_t lsm6dsox_func_cfg_access = 0x01U;
 8008474:	2301      	movs	r3, #1
 8008476:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint8_t shub_reg_access_en = 0x40U;
 800847a:	2340      	movs	r3, #64	@ 0x40
 800847c:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
  uint8_t shub_reg_access_dis = 0x00U;
 8008480:	2300      	movs	r3, #0
 8008482:	f887 3020 	strb.w	r3, [r7, #32]
  uint8_t ext_sens_addr_write = LIS2MDL_I2C_ADD & 0xFEU;
 8008486:	233c      	movs	r3, #60	@ 0x3c
 8008488:	77fb      	strb	r3, [r7, #31]
  uint8_t slv0_add = 0x15U;
 800848a:	2315      	movs	r3, #21
 800848c:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
  uint8_t slv0_subadd = 0x16U;
 8008490:	2316      	movs	r3, #22
 8008492:	f887 302d 	strb.w	r3, [r7, #45]	@ 0x2d
  uint8_t slave0_config = 0x17U;
 8008496:	2317      	movs	r3, #23
 8008498:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c
  uint8_t shub_odr_104 = 0x00U;
 800849c:	2300      	movs	r3, #0
 800849e:	77bb      	strb	r3, [r7, #30]
  uint8_t master_config = 0x14U;
 80084a0:	2314      	movs	r3, #20
 80084a2:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
  uint8_t write_once_i2c_en = 0x44U;
 80084a6:	2344      	movs	r3, #68	@ 0x44
 80084a8:	777b      	strb	r3, [r7, #29]
  uint8_t status_master_mainpage = 0x39U;
 80084aa:	2339      	movs	r3, #57	@ 0x39
 80084ac:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
  uint8_t wr_once_done = 0x80U;
 80084b0:	2380      	movs	r3, #128	@ 0x80
 80084b2:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
  uint8_t lsm6dsox_outx_h_a = 0x29U;
 80084b6:	2329      	movs	r3, #41	@ 0x29
 80084b8:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
  uint8_t lsm6dsox_status_reg = 0x1EU;
 80084bc:	231e      	movs	r3, #30
 80084be:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint8_t xlda = 0x01U;
 80084c2:	2301      	movs	r3, #1
 80084c4:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  uint8_t lsm6dsox_ctrl1_xl = 0x10U;
 80084c8:	2310      	movs	r3, #16
 80084ca:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
  uint8_t lsm6dsox_xl_prev_odr;
  uint8_t lsm6dsox_xl_odr_off = 0x00U;
 80084ce:	2300      	movs	r3, #0
 80084d0:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
  uint8_t lsm6dsox_xl_odr_104hz = 0x40U;
 80084d4:	2340      	movs	r3, #64	@ 0x40
 80084d6:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
  uint8_t datawrite_slv0 = 0x0EU;
 80084da:	230e      	movs	r3, #14
 80084dc:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
  uint8_t data;
  uint8_t data_array[6];

  /* Enable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_en, 1) != LIS2MDL_OK)
 80084e0:	68fb      	ldr	r3, [r7, #12]
 80084e2:	f103 0020 	add.w	r0, r3, #32
 80084e6:	f107 0221 	add.w	r2, r7, #33	@ 0x21
 80084ea:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 80084ee:	2301      	movs	r3, #1
 80084f0:	f000 f8ec 	bl	80086cc <lis2mdl_write_reg>
 80084f4:	4603      	mov	r3, r0
 80084f6:	2b00      	cmp	r3, #0
 80084f8:	d002      	beq.n	8008500 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0xa0>
  {
    return LIS2MDL_ERROR;
 80084fa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80084fe:	e0c9      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Configure external device address, Enable write operation (rw_0 = 0) */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_add, &ext_sens_addr_write, 1) != LIS2MDL_OK)
 8008500:	68fb      	ldr	r3, [r7, #12]
 8008502:	f103 0020 	add.w	r0, r3, #32
 8008506:	f107 021f 	add.w	r2, r7, #31
 800850a:	f897 102e 	ldrb.w	r1, [r7, #46]	@ 0x2e
 800850e:	2301      	movs	r3, #1
 8008510:	f000 f8dc 	bl	80086cc <lis2mdl_write_reg>
 8008514:	4603      	mov	r3, r0
 8008516:	2b00      	cmp	r3, #0
 8008518:	d002      	beq.n	8008520 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0xc0>
  {
    return LIS2MDL_ERROR;
 800851a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800851e:	e0b9      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Configure address of the LIS2MDL register to be written to */
  if (lis2mdl_write_reg(&(pObj->Ctx), slv0_subadd, &Reg, 1) != LIS2MDL_OK)
 8008520:	68fb      	ldr	r3, [r7, #12]
 8008522:	f103 0020 	add.w	r0, r3, #32
 8008526:	f107 020b 	add.w	r2, r7, #11
 800852a:	f897 102d 	ldrb.w	r1, [r7, #45]	@ 0x2d
 800852e:	2301      	movs	r3, #1
 8008530:	f000 f8cc 	bl	80086cc <lis2mdl_write_reg>
 8008534:	4603      	mov	r3, r0
 8008536:	2b00      	cmp	r3, #0
 8008538:	d002      	beq.n	8008540 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0xe0>
  {
    return LIS2MDL_ERROR;
 800853a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800853e:	e0a9      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Set SHUB_ODR = 104 Hz */
  if (lis2mdl_write_reg(&(pObj->Ctx), slave0_config, &shub_odr_104, 1) != LIS2MDL_OK)
 8008540:	68fb      	ldr	r3, [r7, #12]
 8008542:	f103 0020 	add.w	r0, r3, #32
 8008546:	f107 021e 	add.w	r2, r7, #30
 800854a:	f897 102c 	ldrb.w	r1, [r7, #44]	@ 0x2c
 800854e:	2301      	movs	r3, #1
 8008550:	f000 f8bc 	bl	80086cc <lis2mdl_write_reg>
 8008554:	4603      	mov	r3, r0
 8008556:	2b00      	cmp	r3, #0
 8008558:	d002      	beq.n	8008560 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x100>
  {
    return LIS2MDL_ERROR;
 800855a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800855e:	e099      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Store data to be written to LIS2MDL in LSM6DSOX SH reg */
  if (lis2mdl_write_reg(&(pObj->Ctx), datawrite_slv0, pData, 1) != LIS2MDL_OK)
 8008560:	68fb      	ldr	r3, [r7, #12]
 8008562:	f103 0020 	add.w	r0, r3, #32
 8008566:	f897 1022 	ldrb.w	r1, [r7, #34]	@ 0x22
 800856a:	2301      	movs	r3, #1
 800856c:	687a      	ldr	r2, [r7, #4]
 800856e:	f000 f8ad 	bl	80086cc <lis2mdl_write_reg>
 8008572:	4603      	mov	r3, r0
 8008574:	2b00      	cmp	r3, #0
 8008576:	d002      	beq.n	800857e <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x11e>
  {
    return LIS2MDL_ERROR;
 8008578:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800857c:	e08a      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* WRITE_ONCE enabled for single write, I2C master enabled using slave 0, I2C pull-ups disabled */
  if (lis2mdl_write_reg(&(pObj->Ctx), master_config, &write_once_i2c_en, 1) != LIS2MDL_OK)
 800857e:	68fb      	ldr	r3, [r7, #12]
 8008580:	f103 0020 	add.w	r0, r3, #32
 8008584:	f107 021d 	add.w	r2, r7, #29
 8008588:	f897 102b 	ldrb.w	r1, [r7, #43]	@ 0x2b
 800858c:	2301      	movs	r3, #1
 800858e:	f000 f89d 	bl	80086cc <lis2mdl_write_reg>
 8008592:	4603      	mov	r3, r0
 8008594:	2b00      	cmp	r3, #0
 8008596:	d002      	beq.n	800859e <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x13e>
  {
    return LIS2MDL_ERROR;
 8008598:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800859c:	e07a      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Disable access to sensor hub registers */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_func_cfg_access, &shub_reg_access_dis, 1) != LIS2MDL_OK)
 800859e:	68fb      	ldr	r3, [r7, #12]
 80085a0:	f103 0020 	add.w	r0, r3, #32
 80085a4:	f107 0220 	add.w	r2, r7, #32
 80085a8:	f897 102f 	ldrb.w	r1, [r7, #47]	@ 0x2f
 80085ac:	2301      	movs	r3, #1
 80085ae:	f000 f88d 	bl	80086cc <lis2mdl_write_reg>
 80085b2:	4603      	mov	r3, r0
 80085b4:	2b00      	cmp	r3, #0
 80085b6:	d002      	beq.n	80085be <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x15e>
  {
    return LIS2MDL_ERROR;
 80085b8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80085bc:	e06a      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Read LSM6DSOX ODR */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 80085be:	68fb      	ldr	r3, [r7, #12]
 80085c0:	f103 0020 	add.w	r0, r3, #32
 80085c4:	f107 021c 	add.w	r2, r7, #28
 80085c8:	f897 1025 	ldrb.w	r1, [r7, #37]	@ 0x25
 80085cc:	2301      	movs	r3, #1
 80085ce:	f000 f865 	bl	800869c <lis2mdl_read_reg>
 80085d2:	4603      	mov	r3, r0
 80085d4:	2b00      	cmp	r3, #0
 80085d6:	d002      	beq.n	80085de <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x17e>
  {
    return LIS2MDL_ERROR;
 80085d8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80085dc:	e05a      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Set XL_ODR_104HZ if the accelerometer is disabled */
  if (lsm6dsox_xl_prev_odr == lsm6dsox_xl_odr_off)
 80085de:	7f3b      	ldrb	r3, [r7, #28]
 80085e0:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
 80085e4:	429a      	cmp	r2, r3
 80085e6:	d102      	bne.n	80085ee <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x18e>
  {
    lsm6dsox_xl_prev_odr = lsm6dsox_xl_odr_104hz;
 80085e8:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 80085ec:	773b      	strb	r3, [r7, #28]
  }

  /* Enable accelerometer to trigger Sensor Hub operation */
  if (lis2mdl_write_reg(&(pObj->Ctx), lsm6dsox_ctrl1_xl, &lsm6dsox_xl_prev_odr, 1) != LIS2MDL_OK)
 80085ee:	68fb      	ldr	r3, [r7, #12]
 80085f0:	f103 0020 	add.w	r0, r3, #32
 80085f4:	f107 021c 	add.w	r2, r7, #28
 80085f8:	f897 1025 	ldrb.w	r1, [r7, #37]	@ 0x25
 80085fc:	2301      	movs	r3, #1
 80085fe:	f000 f865 	bl	80086cc <lis2mdl_write_reg>
 8008602:	4603      	mov	r3, r0
 8008604:	2b00      	cmp	r3, #0
 8008606:	d002      	beq.n	800860e <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ae>
  {
    return LIS2MDL_ERROR;
 8008608:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800860c:	e042      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Read ACC data starting from LSM6DSOX OUTX_H_A register to clear accelerometer data-ready XLDA */
  if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_outx_h_a, data_array, 6) != LIS2MDL_OK)
 800860e:	68fb      	ldr	r3, [r7, #12]
 8008610:	f103 0020 	add.w	r0, r3, #32
 8008614:	f107 0214 	add.w	r2, r7, #20
 8008618:	f897 1028 	ldrb.w	r1, [r7, #40]	@ 0x28
 800861c:	2306      	movs	r3, #6
 800861e:	f000 f83d 	bl	800869c <lis2mdl_read_reg>
 8008622:	4603      	mov	r3, r0
 8008624:	2b00      	cmp	r3, #0
 8008626:	d002      	beq.n	800862e <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ce>
  {
    return LIS2MDL_ERROR;
 8008628:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800862c:	e032      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
  }

  /* Poll LSM6DSOX LSM6DSOX_STATUS_REG until XLDA = 1 (Wait for sensor hub trigger) */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), lsm6dsox_status_reg, &data, 1) != LIS2MDL_OK)
 800862e:	68fb      	ldr	r3, [r7, #12]
 8008630:	f103 0020 	add.w	r0, r3, #32
 8008634:	f107 021b 	add.w	r2, r7, #27
 8008638:	f897 1027 	ldrb.w	r1, [r7, #39]	@ 0x27
 800863c:	2301      	movs	r3, #1
 800863e:	f000 f82d 	bl	800869c <lis2mdl_read_reg>
 8008642:	4603      	mov	r3, r0
 8008644:	2b00      	cmp	r3, #0
 8008646:	d002      	beq.n	800864e <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ee>
    {
      return LIS2MDL_ERROR;
 8008648:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800864c:	e022      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
    }
  } while ((data & xlda) != xlda);
 800864e:	7efa      	ldrb	r2, [r7, #27]
 8008650:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8008654:	4013      	ands	r3, r2
 8008656:	b2db      	uxtb	r3, r3
 8008658:	f897 2026 	ldrb.w	r2, [r7, #38]	@ 0x26
 800865c:	429a      	cmp	r2, r3
 800865e:	d1e6      	bne.n	800862e <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x1ce>

  /* Poll LSM6DSOX SensorHub WR_ONCE_DONE bit in STATUS_MASTER_MAINPAGE reg until the end of SW write operations */
  do
  {
    if (lis2mdl_read_reg(&(pObj->Ctx), status_master_mainpage, &data, 1) != LIS2MDL_OK)
 8008660:	68fb      	ldr	r3, [r7, #12]
 8008662:	f103 0020 	add.w	r0, r3, #32
 8008666:	f107 021b 	add.w	r2, r7, #27
 800866a:	f897 102a 	ldrb.w	r1, [r7, #42]	@ 0x2a
 800866e:	2301      	movs	r3, #1
 8008670:	f000 f814 	bl	800869c <lis2mdl_read_reg>
 8008674:	4603      	mov	r3, r0
 8008676:	2b00      	cmp	r3, #0
 8008678:	d002      	beq.n	8008680 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x220>
    {
      return LIS2MDL_ERROR;
 800867a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800867e:	e009      	b.n	8008694 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x234>
    }
  } while ((data & wr_once_done) != wr_once_done);
 8008680:	7efa      	ldrb	r2, [r7, #27]
 8008682:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 8008686:	4013      	ands	r3, r2
 8008688:	b2db      	uxtb	r3, r3
 800868a:	f897 2029 	ldrb.w	r2, [r7, #41]	@ 0x29
 800868e:	429a      	cmp	r2, r3
 8008690:	d1e6      	bne.n	8008660 <LSM6DSOX_SENSORHUB_LIS2MDL_WriteShData+0x200>

  return LIS2MDL_OK;
 8008692:	2300      	movs	r3, #0
}
 8008694:	4618      	mov	r0, r3
 8008696:	3730      	adds	r7, #48	@ 0x30
 8008698:	46bd      	mov	sp, r7
 800869a:	bd80      	pop	{r7, pc}

0800869c <lis2mdl_read_reg>:
  *
  */
int32_t lis2mdl_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                         uint8_t *data,
                         uint16_t len)
{
 800869c:	b590      	push	{r4, r7, lr}
 800869e:	b087      	sub	sp, #28
 80086a0:	af00      	add	r7, sp, #0
 80086a2:	60f8      	str	r0, [r7, #12]
 80086a4:	607a      	str	r2, [r7, #4]
 80086a6:	461a      	mov	r2, r3
 80086a8:	460b      	mov	r3, r1
 80086aa:	72fb      	strb	r3, [r7, #11]
 80086ac:	4613      	mov	r3, r2
 80086ae:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 80086b0:	68fb      	ldr	r3, [r7, #12]
 80086b2:	685c      	ldr	r4, [r3, #4]
 80086b4:	68fb      	ldr	r3, [r7, #12]
 80086b6:	68d8      	ldr	r0, [r3, #12]
 80086b8:	893b      	ldrh	r3, [r7, #8]
 80086ba:	7af9      	ldrb	r1, [r7, #11]
 80086bc:	687a      	ldr	r2, [r7, #4]
 80086be:	47a0      	blx	r4
 80086c0:	6178      	str	r0, [r7, #20]

  return ret;
 80086c2:	697b      	ldr	r3, [r7, #20]
}
 80086c4:	4618      	mov	r0, r3
 80086c6:	371c      	adds	r7, #28
 80086c8:	46bd      	mov	sp, r7
 80086ca:	bd90      	pop	{r4, r7, pc}

080086cc <lis2mdl_write_reg>:
  *
  */
int32_t lis2mdl_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                          uint8_t *data,
                          uint16_t len)
{
 80086cc:	b590      	push	{r4, r7, lr}
 80086ce:	b087      	sub	sp, #28
 80086d0:	af00      	add	r7, sp, #0
 80086d2:	60f8      	str	r0, [r7, #12]
 80086d4:	607a      	str	r2, [r7, #4]
 80086d6:	461a      	mov	r2, r3
 80086d8:	460b      	mov	r3, r1
 80086da:	72fb      	strb	r3, [r7, #11]
 80086dc:	4613      	mov	r3, r2
 80086de:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 80086e0:	68fb      	ldr	r3, [r7, #12]
 80086e2:	681c      	ldr	r4, [r3, #0]
 80086e4:	68fb      	ldr	r3, [r7, #12]
 80086e6:	68d8      	ldr	r0, [r3, #12]
 80086e8:	893b      	ldrh	r3, [r7, #8]
 80086ea:	7af9      	ldrb	r1, [r7, #11]
 80086ec:	687a      	ldr	r2, [r7, #4]
 80086ee:	47a0      	blx	r4
 80086f0:	6178      	str	r0, [r7, #20]

  return ret;
 80086f2:	697b      	ldr	r3, [r7, #20]
}
 80086f4:	4618      	mov	r0, r3
 80086f6:	371c      	adds	r7, #28
 80086f8:	46bd      	mov	sp, r7
 80086fa:	bd90      	pop	{r4, r7, pc}

080086fc <lis2mdl_operating_mode_set>:
  * @retval        interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_operating_mode_set(stmdev_ctx_t *ctx,
                                   lis2mdl_md_t val)
{
 80086fc:	b580      	push	{r7, lr}
 80086fe:	b084      	sub	sp, #16
 8008700:	af00      	add	r7, sp, #0
 8008702:	6078      	str	r0, [r7, #4]
 8008704:	460b      	mov	r3, r1
 8008706:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 8008708:	f107 0208 	add.w	r2, r7, #8
 800870c:	2301      	movs	r3, #1
 800870e:	2160      	movs	r1, #96	@ 0x60
 8008710:	6878      	ldr	r0, [r7, #4]
 8008712:	f7ff ffc3 	bl	800869c <lis2mdl_read_reg>
 8008716:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 8008718:	68fb      	ldr	r3, [r7, #12]
 800871a:	2b00      	cmp	r3, #0
 800871c:	d10f      	bne.n	800873e <lis2mdl_operating_mode_set+0x42>
  {
    reg.md = (uint8_t)val;
 800871e:	78fb      	ldrb	r3, [r7, #3]
 8008720:	f003 0303 	and.w	r3, r3, #3
 8008724:	b2da      	uxtb	r2, r3
 8008726:	7a3b      	ldrb	r3, [r7, #8]
 8008728:	f362 0301 	bfi	r3, r2, #0, #2
 800872c:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 800872e:	f107 0208 	add.w	r2, r7, #8
 8008732:	2301      	movs	r3, #1
 8008734:	2160      	movs	r1, #96	@ 0x60
 8008736:	6878      	ldr	r0, [r7, #4]
 8008738:	f7ff ffc8 	bl	80086cc <lis2mdl_write_reg>
 800873c:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800873e:	68fb      	ldr	r3, [r7, #12]
}
 8008740:	4618      	mov	r0, r3
 8008742:	3710      	adds	r7, #16
 8008744:	46bd      	mov	sp, r7
 8008746:	bd80      	pop	{r7, pc}

08008748 <lis2mdl_data_rate_set>:
  * @param  val   change the values of odr in reg CFG_REG_A
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_data_rate_set(stmdev_ctx_t *ctx, lis2mdl_odr_t val)
{
 8008748:	b580      	push	{r7, lr}
 800874a:	b084      	sub	sp, #16
 800874c:	af00      	add	r7, sp, #0
 800874e:	6078      	str	r0, [r7, #4]
 8008750:	460b      	mov	r3, r1
 8008752:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 8008754:	f107 0208 	add.w	r2, r7, #8
 8008758:	2301      	movs	r3, #1
 800875a:	2160      	movs	r1, #96	@ 0x60
 800875c:	6878      	ldr	r0, [r7, #4]
 800875e:	f7ff ff9d 	bl	800869c <lis2mdl_read_reg>
 8008762:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 8008764:	68fb      	ldr	r3, [r7, #12]
 8008766:	2b00      	cmp	r3, #0
 8008768:	d10f      	bne.n	800878a <lis2mdl_data_rate_set+0x42>
  {
    reg.odr = (uint8_t)val;
 800876a:	78fb      	ldrb	r3, [r7, #3]
 800876c:	f003 0303 	and.w	r3, r3, #3
 8008770:	b2da      	uxtb	r2, r3
 8008772:	7a3b      	ldrb	r3, [r7, #8]
 8008774:	f362 0383 	bfi	r3, r2, #2, #2
 8008778:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 800877a:	f107 0208 	add.w	r2, r7, #8
 800877e:	2301      	movs	r3, #1
 8008780:	2160      	movs	r1, #96	@ 0x60
 8008782:	6878      	ldr	r0, [r7, #4]
 8008784:	f7ff ffa2 	bl	80086cc <lis2mdl_write_reg>
 8008788:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800878a:	68fb      	ldr	r3, [r7, #12]
}
 800878c:	4618      	mov	r0, r3
 800878e:	3710      	adds	r7, #16
 8008790:	46bd      	mov	sp, r7
 8008792:	bd80      	pop	{r7, pc}

08008794 <lis2mdl_data_rate_get>:
  * @param  val   Get the values of odr in reg CFG_REG_A.(ptr)
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_data_rate_get(stmdev_ctx_t *ctx, lis2mdl_odr_t *val)
{
 8008794:	b580      	push	{r7, lr}
 8008796:	b084      	sub	sp, #16
 8008798:	af00      	add	r7, sp, #0
 800879a:	6078      	str	r0, [r7, #4]
 800879c:	6039      	str	r1, [r7, #0]
  lis2mdl_cfg_reg_a_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_A, (uint8_t *)&reg, 1);
 800879e:	f107 0208 	add.w	r2, r7, #8
 80087a2:	2301      	movs	r3, #1
 80087a4:	2160      	movs	r1, #96	@ 0x60
 80087a6:	6878      	ldr	r0, [r7, #4]
 80087a8:	f7ff ff78 	bl	800869c <lis2mdl_read_reg>
 80087ac:	60f8      	str	r0, [r7, #12]

  switch (reg.odr)
 80087ae:	7a3b      	ldrb	r3, [r7, #8]
 80087b0:	f3c3 0381 	ubfx	r3, r3, #2, #2
 80087b4:	b2db      	uxtb	r3, r3
 80087b6:	2b03      	cmp	r3, #3
 80087b8:	d81a      	bhi.n	80087f0 <lis2mdl_data_rate_get+0x5c>
 80087ba:	a201      	add	r2, pc, #4	@ (adr r2, 80087c0 <lis2mdl_data_rate_get+0x2c>)
 80087bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80087c0:	080087d1 	.word	0x080087d1
 80087c4:	080087d9 	.word	0x080087d9
 80087c8:	080087e1 	.word	0x080087e1
 80087cc:	080087e9 	.word	0x080087e9
  {
    case LIS2MDL_ODR_10Hz:
      *val = LIS2MDL_ODR_10Hz;
 80087d0:	683b      	ldr	r3, [r7, #0]
 80087d2:	2200      	movs	r2, #0
 80087d4:	701a      	strb	r2, [r3, #0]
      break;
 80087d6:	e00f      	b.n	80087f8 <lis2mdl_data_rate_get+0x64>

    case LIS2MDL_ODR_20Hz:
      *val = LIS2MDL_ODR_20Hz;
 80087d8:	683b      	ldr	r3, [r7, #0]
 80087da:	2201      	movs	r2, #1
 80087dc:	701a      	strb	r2, [r3, #0]
      break;
 80087de:	e00b      	b.n	80087f8 <lis2mdl_data_rate_get+0x64>

    case LIS2MDL_ODR_50Hz:
      *val = LIS2MDL_ODR_50Hz;
 80087e0:	683b      	ldr	r3, [r7, #0]
 80087e2:	2202      	movs	r2, #2
 80087e4:	701a      	strb	r2, [r3, #0]
      break;
 80087e6:	e007      	b.n	80087f8 <lis2mdl_data_rate_get+0x64>

    case LIS2MDL_ODR_100Hz:
      *val = LIS2MDL_ODR_100Hz;
 80087e8:	683b      	ldr	r3, [r7, #0]
 80087ea:	2203      	movs	r2, #3
 80087ec:	701a      	strb	r2, [r3, #0]
      break;
 80087ee:	e003      	b.n	80087f8 <lis2mdl_data_rate_get+0x64>

    default:
      *val = LIS2MDL_ODR_10Hz;
 80087f0:	683b      	ldr	r3, [r7, #0]
 80087f2:	2200      	movs	r2, #0
 80087f4:	701a      	strb	r2, [r3, #0]
      break;
 80087f6:	bf00      	nop
  }

  return ret;
 80087f8:	68fb      	ldr	r3, [r7, #12]
}
 80087fa:	4618      	mov	r0, r3
 80087fc:	3710      	adds	r7, #16
 80087fe:	46bd      	mov	sp, r7
 8008800:	bd80      	pop	{r7, pc}
 8008802:	bf00      	nop

08008804 <lis2mdl_block_data_update_set>:
  * @param  val   change the values of bdu in reg CFG_REG_C
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
 8008804:	b580      	push	{r7, lr}
 8008806:	b084      	sub	sp, #16
 8008808:	af00      	add	r7, sp, #0
 800880a:	6078      	str	r0, [r7, #4]
 800880c:	460b      	mov	r3, r1
 800880e:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 8008810:	f107 0208 	add.w	r2, r7, #8
 8008814:	2301      	movs	r3, #1
 8008816:	2162      	movs	r1, #98	@ 0x62
 8008818:	6878      	ldr	r0, [r7, #4]
 800881a:	f7ff ff3f 	bl	800869c <lis2mdl_read_reg>
 800881e:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 8008820:	68fb      	ldr	r3, [r7, #12]
 8008822:	2b00      	cmp	r3, #0
 8008824:	d10f      	bne.n	8008846 <lis2mdl_block_data_update_set+0x42>
  {
    reg.bdu = val;
 8008826:	78fb      	ldrb	r3, [r7, #3]
 8008828:	f003 0301 	and.w	r3, r3, #1
 800882c:	b2da      	uxtb	r2, r3
 800882e:	7a3b      	ldrb	r3, [r7, #8]
 8008830:	f362 1304 	bfi	r3, r2, #4, #1
 8008834:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 8008836:	f107 0208 	add.w	r2, r7, #8
 800883a:	2301      	movs	r3, #1
 800883c:	2162      	movs	r1, #98	@ 0x62
 800883e:	6878      	ldr	r0, [r7, #4]
 8008840:	f7ff ff44 	bl	80086cc <lis2mdl_write_reg>
 8008844:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 8008846:	68fb      	ldr	r3, [r7, #12]
}
 8008848:	4618      	mov	r0, r3
 800884a:	3710      	adds	r7, #16
 800884c:	46bd      	mov	sp, r7
 800884e:	bd80      	pop	{r7, pc}

08008850 <lis2mdl_magnetic_raw_get>:
  * @param  buff  that stores data read
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_magnetic_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 8008850:	b580      	push	{r7, lr}
 8008852:	b086      	sub	sp, #24
 8008854:	af00      	add	r7, sp, #0
 8008856:	6078      	str	r0, [r7, #4]
 8008858:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_OUTX_L_REG, buff, 6);
 800885a:	f107 020c 	add.w	r2, r7, #12
 800885e:	2306      	movs	r3, #6
 8008860:	2168      	movs	r1, #104	@ 0x68
 8008862:	6878      	ldr	r0, [r7, #4]
 8008864:	f7ff ff1a 	bl	800869c <lis2mdl_read_reg>
 8008868:	6178      	str	r0, [r7, #20]
  val[0] = (int16_t)buff[1];
 800886a:	7b7b      	ldrb	r3, [r7, #13]
 800886c:	b21a      	sxth	r2, r3
 800886e:	683b      	ldr	r3, [r7, #0]
 8008870:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 8008872:	683b      	ldr	r3, [r7, #0]
 8008874:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008878:	b29b      	uxth	r3, r3
 800887a:	021b      	lsls	r3, r3, #8
 800887c:	b29b      	uxth	r3, r3
 800887e:	7b3a      	ldrb	r2, [r7, #12]
 8008880:	4413      	add	r3, r2
 8008882:	b29b      	uxth	r3, r3
 8008884:	b21a      	sxth	r2, r3
 8008886:	683b      	ldr	r3, [r7, #0]
 8008888:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800888a:	7bfa      	ldrb	r2, [r7, #15]
 800888c:	683b      	ldr	r3, [r7, #0]
 800888e:	3302      	adds	r3, #2
 8008890:	b212      	sxth	r2, r2
 8008892:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 8008894:	683b      	ldr	r3, [r7, #0]
 8008896:	3302      	adds	r3, #2
 8008898:	f9b3 3000 	ldrsh.w	r3, [r3]
 800889c:	b29b      	uxth	r3, r3
 800889e:	021b      	lsls	r3, r3, #8
 80088a0:	b29b      	uxth	r3, r3
 80088a2:	7bba      	ldrb	r2, [r7, #14]
 80088a4:	4413      	add	r3, r2
 80088a6:	b29a      	uxth	r2, r3
 80088a8:	683b      	ldr	r3, [r7, #0]
 80088aa:	3302      	adds	r3, #2
 80088ac:	b212      	sxth	r2, r2
 80088ae:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 80088b0:	7c7a      	ldrb	r2, [r7, #17]
 80088b2:	683b      	ldr	r3, [r7, #0]
 80088b4:	3304      	adds	r3, #4
 80088b6:	b212      	sxth	r2, r2
 80088b8:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 80088ba:	683b      	ldr	r3, [r7, #0]
 80088bc:	3304      	adds	r3, #4
 80088be:	f9b3 3000 	ldrsh.w	r3, [r3]
 80088c2:	b29b      	uxth	r3, r3
 80088c4:	021b      	lsls	r3, r3, #8
 80088c6:	b29b      	uxth	r3, r3
 80088c8:	7c3a      	ldrb	r2, [r7, #16]
 80088ca:	4413      	add	r3, r2
 80088cc:	b29a      	uxth	r2, r3
 80088ce:	683b      	ldr	r3, [r7, #0]
 80088d0:	3304      	adds	r3, #4
 80088d2:	b212      	sxth	r2, r2
 80088d4:	801a      	strh	r2, [r3, #0]

  return ret;
 80088d6:	697b      	ldr	r3, [r7, #20]
}
 80088d8:	4618      	mov	r0, r3
 80088da:	3718      	adds	r7, #24
 80088dc:	46bd      	mov	sp, r7
 80088de:	bd80      	pop	{r7, pc}

080088e0 <lis2mdl_device_id_get>:
  * @param  buff  that stores data read
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_device_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
 80088e0:	b580      	push	{r7, lr}
 80088e2:	b084      	sub	sp, #16
 80088e4:	af00      	add	r7, sp, #0
 80088e6:	6078      	str	r0, [r7, #4]
 80088e8:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_WHO_AM_I, buff, 1);
 80088ea:	2301      	movs	r3, #1
 80088ec:	683a      	ldr	r2, [r7, #0]
 80088ee:	214f      	movs	r1, #79	@ 0x4f
 80088f0:	6878      	ldr	r0, [r7, #4]
 80088f2:	f7ff fed3 	bl	800869c <lis2mdl_read_reg>
 80088f6:	60f8      	str	r0, [r7, #12]

  return ret;
 80088f8:	68fb      	ldr	r3, [r7, #12]
}
 80088fa:	4618      	mov	r0, r3
 80088fc:	3710      	adds	r7, #16
 80088fe:	46bd      	mov	sp, r7
 8008900:	bd80      	pop	{r7, pc}

08008902 <lis2mdl_self_test_set>:
  * @param  val   change the values of self_test in reg CFG_REG_C
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_self_test_set(stmdev_ctx_t *ctx, uint8_t val)
{
 8008902:	b580      	push	{r7, lr}
 8008904:	b084      	sub	sp, #16
 8008906:	af00      	add	r7, sp, #0
 8008908:	6078      	str	r0, [r7, #4]
 800890a:	460b      	mov	r3, r1
 800890c:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 800890e:	f107 0208 	add.w	r2, r7, #8
 8008912:	2301      	movs	r3, #1
 8008914:	2162      	movs	r1, #98	@ 0x62
 8008916:	6878      	ldr	r0, [r7, #4]
 8008918:	f7ff fec0 	bl	800869c <lis2mdl_read_reg>
 800891c:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800891e:	68fb      	ldr	r3, [r7, #12]
 8008920:	2b00      	cmp	r3, #0
 8008922:	d10f      	bne.n	8008944 <lis2mdl_self_test_set+0x42>
  {
    reg.self_test = val;
 8008924:	78fb      	ldrb	r3, [r7, #3]
 8008926:	f003 0301 	and.w	r3, r3, #1
 800892a:	b2da      	uxtb	r2, r3
 800892c:	7a3b      	ldrb	r3, [r7, #8]
 800892e:	f362 0341 	bfi	r3, r2, #1, #1
 8008932:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 8008934:	f107 0208 	add.w	r2, r7, #8
 8008938:	2301      	movs	r3, #1
 800893a:	2162      	movs	r1, #98	@ 0x62
 800893c:	6878      	ldr	r0, [r7, #4]
 800893e:	f7ff fec5 	bl	80086cc <lis2mdl_write_reg>
 8008942:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 8008944:	68fb      	ldr	r3, [r7, #12]
}
 8008946:	4618      	mov	r0, r3
 8008948:	3710      	adds	r7, #16
 800894a:	46bd      	mov	sp, r7
 800894c:	bd80      	pop	{r7, pc}

0800894e <lis2mdl_i2c_interface_set>:
  * @retval       interface status.(MANDATORY: return 0 -> no Error)
  *
  */
int32_t lis2mdl_i2c_interface_set(stmdev_ctx_t *ctx,
                                  lis2mdl_i2c_dis_t val)
{
 800894e:	b580      	push	{r7, lr}
 8008950:	b084      	sub	sp, #16
 8008952:	af00      	add	r7, sp, #0
 8008954:	6078      	str	r0, [r7, #4]
 8008956:	460b      	mov	r3, r1
 8008958:	70fb      	strb	r3, [r7, #3]
  lis2mdl_cfg_reg_c_t reg;
  int32_t ret;

  ret = lis2mdl_read_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 800895a:	f107 0208 	add.w	r2, r7, #8
 800895e:	2301      	movs	r3, #1
 8008960:	2162      	movs	r1, #98	@ 0x62
 8008962:	6878      	ldr	r0, [r7, #4]
 8008964:	f7ff fe9a 	bl	800869c <lis2mdl_read_reg>
 8008968:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800896a:	68fb      	ldr	r3, [r7, #12]
 800896c:	2b00      	cmp	r3, #0
 800896e:	d10f      	bne.n	8008990 <lis2mdl_i2c_interface_set+0x42>
  {
    reg.i2c_dis = (uint8_t)val;
 8008970:	78fb      	ldrb	r3, [r7, #3]
 8008972:	f003 0301 	and.w	r3, r3, #1
 8008976:	b2da      	uxtb	r2, r3
 8008978:	7a3b      	ldrb	r3, [r7, #8]
 800897a:	f362 1345 	bfi	r3, r2, #5, #1
 800897e:	723b      	strb	r3, [r7, #8]
    ret = lis2mdl_write_reg(ctx, LIS2MDL_CFG_REG_C, (uint8_t *)&reg, 1);
 8008980:	f107 0208 	add.w	r2, r7, #8
 8008984:	2301      	movs	r3, #1
 8008986:	2162      	movs	r1, #98	@ 0x62
 8008988:	6878      	ldr	r0, [r7, #4]
 800898a:	f7ff fe9f 	bl	80086cc <lis2mdl_write_reg>
 800898e:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 8008990:	68fb      	ldr	r3, [r7, #12]
}
 8008992:	4618      	mov	r0, r3
 8008994:	3710      	adds	r7, #16
 8008996:	46bd      	mov	sp, r7
 8008998:	bd80      	pop	{r7, pc}
	...

0800899c <LPS22DF_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_RegisterBusIO(LPS22DF_Object_t *pObj, LPS22DF_IO_t *pIO)
{
 800899c:	b580      	push	{r7, lr}
 800899e:	b084      	sub	sp, #16
 80089a0:	af00      	add	r7, sp, #0
 80089a2:	6078      	str	r0, [r7, #4]
 80089a4:	6039      	str	r1, [r7, #0]
  int32_t ret = LPS22DF_OK;
 80089a6:	2300      	movs	r3, #0
 80089a8:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 80089aa:	687b      	ldr	r3, [r7, #4]
 80089ac:	2b00      	cmp	r3, #0
 80089ae:	d103      	bne.n	80089b8 <LPS22DF_RegisterBusIO+0x1c>
  {
    ret = LPS22DF_ERROR;
 80089b0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80089b4:	60fb      	str	r3, [r7, #12]
 80089b6:	e051      	b.n	8008a5c <LPS22DF_RegisterBusIO+0xc0>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 80089b8:	683b      	ldr	r3, [r7, #0]
 80089ba:	681a      	ldr	r2, [r3, #0]
 80089bc:	687b      	ldr	r3, [r7, #4]
 80089be:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 80089c0:	683b      	ldr	r3, [r7, #0]
 80089c2:	685a      	ldr	r2, [r3, #4]
 80089c4:	687b      	ldr	r3, [r7, #4]
 80089c6:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 80089c8:	683b      	ldr	r3, [r7, #0]
 80089ca:	689a      	ldr	r2, [r3, #8]
 80089cc:	687b      	ldr	r3, [r7, #4]
 80089ce:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 80089d0:	683b      	ldr	r3, [r7, #0]
 80089d2:	7b1a      	ldrb	r2, [r3, #12]
 80089d4:	687b      	ldr	r3, [r7, #4]
 80089d6:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 80089d8:	683b      	ldr	r3, [r7, #0]
 80089da:	691a      	ldr	r2, [r3, #16]
 80089dc:	687b      	ldr	r3, [r7, #4]
 80089de:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 80089e0:	683b      	ldr	r3, [r7, #0]
 80089e2:	695a      	ldr	r2, [r3, #20]
 80089e4:	687b      	ldr	r3, [r7, #4]
 80089e6:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 80089e8:	683b      	ldr	r3, [r7, #0]
 80089ea:	699a      	ldr	r2, [r3, #24]
 80089ec:	687b      	ldr	r3, [r7, #4]
 80089ee:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 80089f0:	687b      	ldr	r3, [r7, #4]
 80089f2:	4a1d      	ldr	r2, [pc, #116]	@ (8008a68 <LPS22DF_RegisterBusIO+0xcc>)
 80089f4:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 80089f6:	687b      	ldr	r3, [r7, #4]
 80089f8:	4a1c      	ldr	r2, [pc, #112]	@ (8008a6c <LPS22DF_RegisterBusIO+0xd0>)
 80089fa:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 80089fc:	683b      	ldr	r3, [r7, #0]
 80089fe:	69da      	ldr	r2, [r3, #28]
 8008a00:	687b      	ldr	r3, [r7, #4]
 8008a02:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 8008a04:	687b      	ldr	r3, [r7, #4]
 8008a06:	687a      	ldr	r2, [r7, #4]
 8008a08:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 8008a0a:	687b      	ldr	r3, [r7, #4]
 8008a0c:	681b      	ldr	r3, [r3, #0]
 8008a0e:	2b00      	cmp	r3, #0
 8008a10:	d103      	bne.n	8008a1a <LPS22DF_RegisterBusIO+0x7e>
    {
      ret = LPS22DF_ERROR;
 8008a12:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008a16:	60fb      	str	r3, [r7, #12]
 8008a18:	e020      	b.n	8008a5c <LPS22DF_RegisterBusIO+0xc0>
    }
    else if (pObj->IO.Init() != LPS22DF_OK)
 8008a1a:	687b      	ldr	r3, [r7, #4]
 8008a1c:	681b      	ldr	r3, [r3, #0]
 8008a1e:	4798      	blx	r3
 8008a20:	4603      	mov	r3, r0
 8008a22:	2b00      	cmp	r3, #0
 8008a24:	d003      	beq.n	8008a2e <LPS22DF_RegisterBusIO+0x92>
    {
      ret = LPS22DF_ERROR;
 8008a26:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008a2a:	60fb      	str	r3, [r7, #12]
 8008a2c:	e016      	b.n	8008a5c <LPS22DF_RegisterBusIO+0xc0>
    }
    else
    {
      if (pObj->IO.BusType == LPS22DF_SPI_3WIRES_BUS) /* SPI 3-Wires */
 8008a2e:	687b      	ldr	r3, [r7, #4]
 8008a30:	689b      	ldr	r3, [r3, #8]
 8008a32:	2b02      	cmp	r3, #2
 8008a34:	d112      	bne.n	8008a5c <LPS22DF_RegisterBusIO+0xc0>
      {
        /* Enable the SPI 3-Wires support only the first time */
        if (pObj->is_initialized == 0U)
 8008a36:	687b      	ldr	r3, [r7, #4]
 8008a38:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8008a3c:	2b00      	cmp	r3, #0
 8008a3e:	d10d      	bne.n	8008a5c <LPS22DF_RegisterBusIO+0xc0>
        {
          /* Enable SPI 3-Wires on the component */
          uint8_t data = 0x20;
 8008a40:	2320      	movs	r3, #32
 8008a42:	72fb      	strb	r3, [r7, #11]

          if (LPS22DF_Write_Reg(pObj, LPS22DF_IF_CTRL, data) != LPS22DF_OK)
 8008a44:	7afb      	ldrb	r3, [r7, #11]
 8008a46:	461a      	mov	r2, r3
 8008a48:	210e      	movs	r1, #14
 8008a4a:	6878      	ldr	r0, [r7, #4]
 8008a4c:	f000 f9e6 	bl	8008e1c <LPS22DF_Write_Reg>
 8008a50:	4603      	mov	r3, r0
 8008a52:	2b00      	cmp	r3, #0
 8008a54:	d002      	beq.n	8008a5c <LPS22DF_RegisterBusIO+0xc0>
          {
            ret = LPS22DF_ERROR;
 8008a56:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008a5a:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

  return ret;
 8008a5c:	68fb      	ldr	r3, [r7, #12]
}
 8008a5e:	4618      	mov	r0, r3
 8008a60:	3710      	adds	r7, #16
 8008a62:	46bd      	mov	sp, r7
 8008a64:	bd80      	pop	{r7, pc}
 8008a66:	bf00      	nop
 8008a68:	080091c1 	.word	0x080091c1
 8008a6c:	080091f7 	.word	0x080091f7

08008a70 <LPS22DF_Init>:
  * @brief  Initialize the LPS22DF sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_Init(LPS22DF_Object_t *pObj)
{
 8008a70:	b580      	push	{r7, lr}
 8008a72:	b082      	sub	sp, #8
 8008a74:	af00      	add	r7, sp, #0
 8008a76:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 0U)
 8008a78:	687b      	ldr	r3, [r7, #4]
 8008a7a:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8008a7e:	2b00      	cmp	r3, #0
 8008a80:	d108      	bne.n	8008a94 <LPS22DF_Init+0x24>
  {
    if (LPS22DF_Initialize(pObj) != LPS22DF_OK)
 8008a82:	6878      	ldr	r0, [r7, #4]
 8008a84:	f000 fb40 	bl	8009108 <LPS22DF_Initialize>
 8008a88:	4603      	mov	r3, r0
 8008a8a:	2b00      	cmp	r3, #0
 8008a8c:	d002      	beq.n	8008a94 <LPS22DF_Init+0x24>
    {
      return LPS22DF_ERROR;
 8008a8e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008a92:	e004      	b.n	8008a9e <LPS22DF_Init+0x2e>
    }
  }

  pObj->is_initialized = 1U;
 8008a94:	687b      	ldr	r3, [r7, #4]
 8008a96:	2201      	movs	r2, #1
 8008a98:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LPS22DF_OK;
 8008a9c:	2300      	movs	r3, #0
}
 8008a9e:	4618      	mov	r0, r3
 8008aa0:	3708      	adds	r7, #8
 8008aa2:	46bd      	mov	sp, r7
 8008aa4:	bd80      	pop	{r7, pc}

08008aa6 <LPS22DF_DeInit>:
  * @brief  Deinitialize the LPS22DF sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_DeInit(LPS22DF_Object_t *pObj)
{
 8008aa6:	b580      	push	{r7, lr}
 8008aa8:	b082      	sub	sp, #8
 8008aaa:	af00      	add	r7, sp, #0
 8008aac:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 1U)
 8008aae:	687b      	ldr	r3, [r7, #4]
 8008ab0:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8008ab4:	2b01      	cmp	r3, #1
 8008ab6:	d111      	bne.n	8008adc <LPS22DF_DeInit+0x36>
  {
    if (LPS22DF_PRESS_Disable(pObj) != LPS22DF_OK)
 8008ab8:	6878      	ldr	r0, [r7, #4]
 8008aba:	f000 f882 	bl	8008bc2 <LPS22DF_PRESS_Disable>
 8008abe:	4603      	mov	r3, r0
 8008ac0:	2b00      	cmp	r3, #0
 8008ac2:	d002      	beq.n	8008aca <LPS22DF_DeInit+0x24>
    {
      return LPS22DF_ERROR;
 8008ac4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008ac8:	e00d      	b.n	8008ae6 <LPS22DF_DeInit+0x40>
    }

    if (LPS22DF_TEMP_Disable(pObj) != LPS22DF_OK)
 8008aca:	6878      	ldr	r0, [r7, #4]
 8008acc:	f000 f921 	bl	8008d12 <LPS22DF_TEMP_Disable>
 8008ad0:	4603      	mov	r3, r0
 8008ad2:	2b00      	cmp	r3, #0
 8008ad4:	d002      	beq.n	8008adc <LPS22DF_DeInit+0x36>
    {
      return LPS22DF_ERROR;
 8008ad6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008ada:	e004      	b.n	8008ae6 <LPS22DF_DeInit+0x40>
    }
  }

  pObj->is_initialized = 0;
 8008adc:	687b      	ldr	r3, [r7, #4]
 8008ade:	2200      	movs	r2, #0
 8008ae0:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LPS22DF_OK;
 8008ae4:	2300      	movs	r3, #0
}
 8008ae6:	4618      	mov	r0, r3
 8008ae8:	3708      	adds	r7, #8
 8008aea:	46bd      	mov	sp, r7
 8008aec:	bd80      	pop	{r7, pc}

08008aee <LPS22DF_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_ReadID(LPS22DF_Object_t *pObj, uint8_t *Id)
{
 8008aee:	b580      	push	{r7, lr}
 8008af0:	b084      	sub	sp, #16
 8008af2:	af00      	add	r7, sp, #0
 8008af4:	6078      	str	r0, [r7, #4]
 8008af6:	6039      	str	r1, [r7, #0]
  lps22df_id_t val;
  if (lps22df_id_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 8008af8:	687b      	ldr	r3, [r7, #4]
 8008afa:	3320      	adds	r3, #32
 8008afc:	f107 020c 	add.w	r2, r7, #12
 8008b00:	4611      	mov	r1, r2
 8008b02:	4618      	mov	r0, r3
 8008b04:	f000 fc0a 	bl	800931c <lps22df_id_get>
 8008b08:	4603      	mov	r3, r0
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	d002      	beq.n	8008b14 <LPS22DF_ReadID+0x26>
  {
    return LPS22DF_ERROR;
 8008b0e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008b12:	e003      	b.n	8008b1c <LPS22DF_ReadID+0x2e>
  }

  *Id = val.whoami;
 8008b14:	7b3a      	ldrb	r2, [r7, #12]
 8008b16:	683b      	ldr	r3, [r7, #0]
 8008b18:	701a      	strb	r2, [r3, #0]

  return LPS22DF_OK;
 8008b1a:	2300      	movs	r3, #0
}
 8008b1c:	4618      	mov	r0, r3
 8008b1e:	3710      	adds	r7, #16
 8008b20:	46bd      	mov	sp, r7
 8008b22:	bd80      	pop	{r7, pc}

08008b24 <LPS22DF_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LPS22DF sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_GetCapabilities(LPS22DF_Object_t *pObj, LPS22DF_Capabilities_t *Capabilities)
{
 8008b24:	b480      	push	{r7}
 8008b26:	b083      	sub	sp, #12
 8008b28:	af00      	add	r7, sp, #0
 8008b2a:	6078      	str	r0, [r7, #4]
 8008b2c:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Humidity    = 0;
 8008b2e:	683b      	ldr	r3, [r7, #0]
 8008b30:	2200      	movs	r2, #0
 8008b32:	709a      	strb	r2, [r3, #2]
  Capabilities->Pressure    = 1;
 8008b34:	683b      	ldr	r3, [r7, #0]
 8008b36:	2201      	movs	r2, #1
 8008b38:	705a      	strb	r2, [r3, #1]
  Capabilities->Temperature = 1;
 8008b3a:	683b      	ldr	r3, [r7, #0]
 8008b3c:	2201      	movs	r2, #1
 8008b3e:	701a      	strb	r2, [r3, #0]
  Capabilities->Gas         = 0;
 8008b40:	683b      	ldr	r3, [r7, #0]
 8008b42:	2200      	movs	r2, #0
 8008b44:	70da      	strb	r2, [r3, #3]
  Capabilities->LowPower    = 0;
 8008b46:	683b      	ldr	r3, [r7, #0]
 8008b48:	2200      	movs	r2, #0
 8008b4a:	711a      	strb	r2, [r3, #4]
  Capabilities->HumMaxOdr   = 0.0f;
 8008b4c:	683b      	ldr	r3, [r7, #0]
 8008b4e:	f04f 0200 	mov.w	r2, #0
 8008b52:	609a      	str	r2, [r3, #8]
  Capabilities->TempMaxOdr  = 200.0f;
 8008b54:	683b      	ldr	r3, [r7, #0]
 8008b56:	4a08      	ldr	r2, [pc, #32]	@ (8008b78 <LPS22DF_GetCapabilities+0x54>)
 8008b58:	60da      	str	r2, [r3, #12]
  Capabilities->PressMaxOdr = 200.0f;
 8008b5a:	683b      	ldr	r3, [r7, #0]
 8008b5c:	4a06      	ldr	r2, [pc, #24]	@ (8008b78 <LPS22DF_GetCapabilities+0x54>)
 8008b5e:	611a      	str	r2, [r3, #16]
  Capabilities->GasMaxOdr   = 0.0f;
 8008b60:	683b      	ldr	r3, [r7, #0]
 8008b62:	f04f 0200 	mov.w	r2, #0
 8008b66:	615a      	str	r2, [r3, #20]
  return LPS22DF_OK;
 8008b68:	2300      	movs	r3, #0
}
 8008b6a:	4618      	mov	r0, r3
 8008b6c:	370c      	adds	r7, #12
 8008b6e:	46bd      	mov	sp, r7
 8008b70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b74:	4770      	bx	lr
 8008b76:	bf00      	nop
 8008b78:	43480000 	.word	0x43480000

08008b7c <LPS22DF_PRESS_Enable>:
  * @brief  Enable the LPS22DF pressure sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_Enable(LPS22DF_Object_t *pObj)
{
 8008b7c:	b580      	push	{r7, lr}
 8008b7e:	b082      	sub	sp, #8
 8008b80:	af00      	add	r7, sp, #0
 8008b82:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->press_is_enabled == 1U)
 8008b84:	687b      	ldr	r3, [r7, #4]
 8008b86:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8008b8a:	2b01      	cmp	r3, #1
 8008b8c:	d101      	bne.n	8008b92 <LPS22DF_PRESS_Enable+0x16>
  {
    return LPS22DF_OK;
 8008b8e:	2300      	movs	r3, #0
 8008b90:	e013      	b.n	8008bba <LPS22DF_PRESS_Enable+0x3e>
  }

  /* Output data rate selection. */
  if (lps22df_mode_set(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 8008b92:	687b      	ldr	r3, [r7, #4]
 8008b94:	f103 0220 	add.w	r2, r3, #32
 8008b98:	687b      	ldr	r3, [r7, #4]
 8008b9a:	3333      	adds	r3, #51	@ 0x33
 8008b9c:	4619      	mov	r1, r3
 8008b9e:	4610      	mov	r0, r2
 8008ba0:	f000 fcac 	bl	80094fc <lps22df_mode_set>
 8008ba4:	4603      	mov	r3, r0
 8008ba6:	2b00      	cmp	r3, #0
 8008ba8:	d002      	beq.n	8008bb0 <LPS22DF_PRESS_Enable+0x34>
  {
    return LPS22DF_ERROR;
 8008baa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008bae:	e004      	b.n	8008bba <LPS22DF_PRESS_Enable+0x3e>
  }

  pObj->press_is_enabled = 1;
 8008bb0:	687b      	ldr	r3, [r7, #4]
 8008bb2:	2201      	movs	r2, #1
 8008bb4:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LPS22DF_OK;
 8008bb8:	2300      	movs	r3, #0
}
 8008bba:	4618      	mov	r0, r3
 8008bbc:	3708      	adds	r7, #8
 8008bbe:	46bd      	mov	sp, r7
 8008bc0:	bd80      	pop	{r7, pc}

08008bc2 <LPS22DF_PRESS_Disable>:
  * @brief  Disable the LPS22DF pressure sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_Disable(LPS22DF_Object_t *pObj)
{
 8008bc2:	b580      	push	{r7, lr}
 8008bc4:	b084      	sub	sp, #16
 8008bc6:	af00      	add	r7, sp, #0
 8008bc8:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->press_is_enabled == 0U)
 8008bca:	687b      	ldr	r3, [r7, #4]
 8008bcc:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8008bd0:	2b00      	cmp	r3, #0
 8008bd2:	d101      	bne.n	8008bd8 <LPS22DF_PRESS_Disable+0x16>
  {
    return LPS22DF_OK;
 8008bd4:	2300      	movs	r3, #0
 8008bd6:	e030      	b.n	8008c3a <LPS22DF_PRESS_Disable+0x78>
  }

  /* Check if the LPS22DF temperature sensor is still enable. */
  /* If yes, skip the disable function, if not call disable function */
  if (pObj->temp_is_enabled == 0U)
 8008bd8:	687b      	ldr	r3, [r7, #4]
 8008bda:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8008bde:	2b00      	cmp	r3, #0
 8008be0:	d126      	bne.n	8008c30 <LPS22DF_PRESS_Disable+0x6e>
  {
    lps22df_md_t val;

    /* Get current output data rate. */
    if (lps22df_mode_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 8008be2:	687b      	ldr	r3, [r7, #4]
 8008be4:	3320      	adds	r3, #32
 8008be6:	f107 020c 	add.w	r2, r7, #12
 8008bea:	4611      	mov	r1, r2
 8008bec:	4618      	mov	r0, r3
 8008bee:	f000 fce3 	bl	80095b8 <lps22df_mode_get>
 8008bf2:	4603      	mov	r3, r0
 8008bf4:	2b00      	cmp	r3, #0
 8008bf6:	d002      	beq.n	8008bfe <LPS22DF_PRESS_Disable+0x3c>
    {
      return LPS22DF_ERROR;
 8008bf8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008bfc:	e01d      	b.n	8008c3a <LPS22DF_PRESS_Disable+0x78>
    }

    memcpy(&pObj->last_odr, &val, sizeof(lps22df_md_t));
 8008bfe:	687b      	ldr	r3, [r7, #4]
 8008c00:	3333      	adds	r3, #51	@ 0x33
 8008c02:	461a      	mov	r2, r3
 8008c04:	f107 030c 	add.w	r3, r7, #12
 8008c08:	8819      	ldrh	r1, [r3, #0]
 8008c0a:	789b      	ldrb	r3, [r3, #2]
 8008c0c:	8011      	strh	r1, [r2, #0]
 8008c0e:	7093      	strb	r3, [r2, #2]

    val.odr = LPS22DF_ONE_SHOT;
 8008c10:	2300      	movs	r3, #0
 8008c12:	733b      	strb	r3, [r7, #12]

    /* Output data rate selection - power down. */
    if (lps22df_mode_set(&(pObj->Ctx), &val) != LPS22DF_OK)
 8008c14:	687b      	ldr	r3, [r7, #4]
 8008c16:	3320      	adds	r3, #32
 8008c18:	f107 020c 	add.w	r2, r7, #12
 8008c1c:	4611      	mov	r1, r2
 8008c1e:	4618      	mov	r0, r3
 8008c20:	f000 fc6c 	bl	80094fc <lps22df_mode_set>
 8008c24:	4603      	mov	r3, r0
 8008c26:	2b00      	cmp	r3, #0
 8008c28:	d002      	beq.n	8008c30 <LPS22DF_PRESS_Disable+0x6e>
    {
      return LPS22DF_ERROR;
 8008c2a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008c2e:	e004      	b.n	8008c3a <LPS22DF_PRESS_Disable+0x78>
    }
  }

  pObj->press_is_enabled = 0;
 8008c30:	687b      	ldr	r3, [r7, #4]
 8008c32:	2200      	movs	r2, #0
 8008c34:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LPS22DF_OK;
 8008c38:	2300      	movs	r3, #0
}
 8008c3a:	4618      	mov	r0, r3
 8008c3c:	3710      	adds	r7, #16
 8008c3e:	46bd      	mov	sp, r7
 8008c40:	bd80      	pop	{r7, pc}

08008c42 <LPS22DF_PRESS_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_GetOutputDataRate(LPS22DF_Object_t *pObj, float *Odr)
{
 8008c42:	b580      	push	{r7, lr}
 8008c44:	b082      	sub	sp, #8
 8008c46:	af00      	add	r7, sp, #0
 8008c48:	6078      	str	r0, [r7, #4]
 8008c4a:	6039      	str	r1, [r7, #0]
  return LPS22DF_GetOutputDataRate(pObj, Odr);
 8008c4c:	6839      	ldr	r1, [r7, #0]
 8008c4e:	6878      	ldr	r0, [r7, #4]
 8008c50:	f000 f900 	bl	8008e54 <LPS22DF_GetOutputDataRate>
 8008c54:	4603      	mov	r3, r0
}
 8008c56:	4618      	mov	r0, r3
 8008c58:	3708      	adds	r7, #8
 8008c5a:	46bd      	mov	sp, r7
 8008c5c:	bd80      	pop	{r7, pc}

08008c5e <LPS22DF_PRESS_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_SetOutputDataRate(LPS22DF_Object_t *pObj, float Odr)
{
 8008c5e:	b580      	push	{r7, lr}
 8008c60:	b082      	sub	sp, #8
 8008c62:	af00      	add	r7, sp, #0
 8008c64:	6078      	str	r0, [r7, #4]
 8008c66:	ed87 0a00 	vstr	s0, [r7]
  /* Check if the component is enabled */
  if (pObj->press_is_enabled == 1U)
 8008c6a:	687b      	ldr	r3, [r7, #4]
 8008c6c:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8008c70:	2b01      	cmp	r3, #1
 8008c72:	d106      	bne.n	8008c82 <LPS22DF_PRESS_SetOutputDataRate+0x24>
  {
    return LPS22DF_SetOutputDataRate_When_Enabled(pObj, Odr);
 8008c74:	ed97 0a00 	vldr	s0, [r7]
 8008c78:	6878      	ldr	r0, [r7, #4]
 8008c7a:	f000 f955 	bl	8008f28 <LPS22DF_SetOutputDataRate_When_Enabled>
 8008c7e:	4603      	mov	r3, r0
 8008c80:	e005      	b.n	8008c8e <LPS22DF_PRESS_SetOutputDataRate+0x30>
  }
  else
  {
    return LPS22DF_SetOutputDataRate_When_Disabled(pObj, Odr);
 8008c82:	ed97 0a00 	vldr	s0, [r7]
 8008c86:	6878      	ldr	r0, [r7, #4]
 8008c88:	f000 f9da 	bl	8009040 <LPS22DF_SetOutputDataRate_When_Disabled>
 8008c8c:	4603      	mov	r3, r0
  }
}
 8008c8e:	4618      	mov	r0, r3
 8008c90:	3708      	adds	r7, #8
 8008c92:	46bd      	mov	sp, r7
 8008c94:	bd80      	pop	{r7, pc}

08008c96 <LPS22DF_PRESS_GetPressure>:
  * @param  pObj the device pObj
  * @param  Value pointer where the pressure value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_PRESS_GetPressure(LPS22DF_Object_t *pObj, float *Value)
{
 8008c96:	b580      	push	{r7, lr}
 8008c98:	b086      	sub	sp, #24
 8008c9a:	af00      	add	r7, sp, #0
 8008c9c:	6078      	str	r0, [r7, #4]
 8008c9e:	6039      	str	r1, [r7, #0]
  lps22df_data_t data;

  if (lps22df_data_get(&(pObj->Ctx), &data) != LPS22DF_OK)
 8008ca0:	687b      	ldr	r3, [r7, #4]
 8008ca2:	3320      	adds	r3, #32
 8008ca4:	f107 0208 	add.w	r2, r7, #8
 8008ca8:	4611      	mov	r1, r2
 8008caa:	4618      	mov	r0, r3
 8008cac:	f000 fd50 	bl	8009750 <lps22df_data_get>
 8008cb0:	4603      	mov	r3, r0
 8008cb2:	2b00      	cmp	r3, #0
 8008cb4:	d002      	beq.n	8008cbc <LPS22DF_PRESS_GetPressure+0x26>
  {
    return LPS22DF_ERROR;
 8008cb6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008cba:	e003      	b.n	8008cc4 <LPS22DF_PRESS_GetPressure+0x2e>
  }

  *Value = data.pressure.hpa;
 8008cbc:	68ba      	ldr	r2, [r7, #8]
 8008cbe:	683b      	ldr	r3, [r7, #0]
 8008cc0:	601a      	str	r2, [r3, #0]

  return LPS22DF_OK;
 8008cc2:	2300      	movs	r3, #0
}
 8008cc4:	4618      	mov	r0, r3
 8008cc6:	3718      	adds	r7, #24
 8008cc8:	46bd      	mov	sp, r7
 8008cca:	bd80      	pop	{r7, pc}

08008ccc <LPS22DF_TEMP_Enable>:
  * @brief  Enable the LPS22DF temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_Enable(LPS22DF_Object_t *pObj)
{
 8008ccc:	b580      	push	{r7, lr}
 8008cce:	b082      	sub	sp, #8
 8008cd0:	af00      	add	r7, sp, #0
 8008cd2:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->temp_is_enabled == 1U)
 8008cd4:	687b      	ldr	r3, [r7, #4]
 8008cd6:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8008cda:	2b01      	cmp	r3, #1
 8008cdc:	d101      	bne.n	8008ce2 <LPS22DF_TEMP_Enable+0x16>
  {
    return LPS22DF_OK;
 8008cde:	2300      	movs	r3, #0
 8008ce0:	e013      	b.n	8008d0a <LPS22DF_TEMP_Enable+0x3e>
  }

  /* Output data rate selection. */
  if (lps22df_mode_set(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 8008ce2:	687b      	ldr	r3, [r7, #4]
 8008ce4:	f103 0220 	add.w	r2, r3, #32
 8008ce8:	687b      	ldr	r3, [r7, #4]
 8008cea:	3333      	adds	r3, #51	@ 0x33
 8008cec:	4619      	mov	r1, r3
 8008cee:	4610      	mov	r0, r2
 8008cf0:	f000 fc04 	bl	80094fc <lps22df_mode_set>
 8008cf4:	4603      	mov	r3, r0
 8008cf6:	2b00      	cmp	r3, #0
 8008cf8:	d002      	beq.n	8008d00 <LPS22DF_TEMP_Enable+0x34>
  {
    return LPS22DF_ERROR;
 8008cfa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008cfe:	e004      	b.n	8008d0a <LPS22DF_TEMP_Enable+0x3e>
  }

  pObj->temp_is_enabled = 1;
 8008d00:	687b      	ldr	r3, [r7, #4]
 8008d02:	2201      	movs	r2, #1
 8008d04:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LPS22DF_OK;
 8008d08:	2300      	movs	r3, #0
}
 8008d0a:	4618      	mov	r0, r3
 8008d0c:	3708      	adds	r7, #8
 8008d0e:	46bd      	mov	sp, r7
 8008d10:	bd80      	pop	{r7, pc}

08008d12 <LPS22DF_TEMP_Disable>:
  * @brief  Disable the LPS22DF temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_Disable(LPS22DF_Object_t *pObj)
{
 8008d12:	b580      	push	{r7, lr}
 8008d14:	b084      	sub	sp, #16
 8008d16:	af00      	add	r7, sp, #0
 8008d18:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->temp_is_enabled == 0U)
 8008d1a:	687b      	ldr	r3, [r7, #4]
 8008d1c:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8008d20:	2b00      	cmp	r3, #0
 8008d22:	d101      	bne.n	8008d28 <LPS22DF_TEMP_Disable+0x16>
  {
    return LPS22DF_OK;
 8008d24:	2300      	movs	r3, #0
 8008d26:	e030      	b.n	8008d8a <LPS22DF_TEMP_Disable+0x78>
  }

  /* Check if the LPS22DF pressure sensor is still enable. */
  /* If yes, skip the disable function, if not call disable function */
  if (pObj->press_is_enabled == 0U)
 8008d28:	687b      	ldr	r3, [r7, #4]
 8008d2a:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8008d2e:	2b00      	cmp	r3, #0
 8008d30:	d126      	bne.n	8008d80 <LPS22DF_TEMP_Disable+0x6e>
  {
    lps22df_md_t val;

    /* Get current output data rate. */
    if (lps22df_mode_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 8008d32:	687b      	ldr	r3, [r7, #4]
 8008d34:	3320      	adds	r3, #32
 8008d36:	f107 020c 	add.w	r2, r7, #12
 8008d3a:	4611      	mov	r1, r2
 8008d3c:	4618      	mov	r0, r3
 8008d3e:	f000 fc3b 	bl	80095b8 <lps22df_mode_get>
 8008d42:	4603      	mov	r3, r0
 8008d44:	2b00      	cmp	r3, #0
 8008d46:	d002      	beq.n	8008d4e <LPS22DF_TEMP_Disable+0x3c>
    {
      return LPS22DF_ERROR;
 8008d48:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008d4c:	e01d      	b.n	8008d8a <LPS22DF_TEMP_Disable+0x78>
    }

    memcpy(&pObj->last_odr, &val, sizeof(lps22df_md_t));
 8008d4e:	687b      	ldr	r3, [r7, #4]
 8008d50:	3333      	adds	r3, #51	@ 0x33
 8008d52:	461a      	mov	r2, r3
 8008d54:	f107 030c 	add.w	r3, r7, #12
 8008d58:	8819      	ldrh	r1, [r3, #0]
 8008d5a:	789b      	ldrb	r3, [r3, #2]
 8008d5c:	8011      	strh	r1, [r2, #0]
 8008d5e:	7093      	strb	r3, [r2, #2]

    val.odr = LPS22DF_ONE_SHOT;
 8008d60:	2300      	movs	r3, #0
 8008d62:	733b      	strb	r3, [r7, #12]

    /* Output data rate selection - power down. */
    if (lps22df_mode_set(&(pObj->Ctx), &val) != LPS22DF_OK)
 8008d64:	687b      	ldr	r3, [r7, #4]
 8008d66:	3320      	adds	r3, #32
 8008d68:	f107 020c 	add.w	r2, r7, #12
 8008d6c:	4611      	mov	r1, r2
 8008d6e:	4618      	mov	r0, r3
 8008d70:	f000 fbc4 	bl	80094fc <lps22df_mode_set>
 8008d74:	4603      	mov	r3, r0
 8008d76:	2b00      	cmp	r3, #0
 8008d78:	d002      	beq.n	8008d80 <LPS22DF_TEMP_Disable+0x6e>
    {
      return LPS22DF_ERROR;
 8008d7a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008d7e:	e004      	b.n	8008d8a <LPS22DF_TEMP_Disable+0x78>
    }
  }

  pObj->temp_is_enabled = 0;
 8008d80:	687b      	ldr	r3, [r7, #4]
 8008d82:	2200      	movs	r2, #0
 8008d84:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LPS22DF_OK;
 8008d88:	2300      	movs	r3, #0
}
 8008d8a:	4618      	mov	r0, r3
 8008d8c:	3710      	adds	r7, #16
 8008d8e:	46bd      	mov	sp, r7
 8008d90:	bd80      	pop	{r7, pc}

08008d92 <LPS22DF_TEMP_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_GetOutputDataRate(LPS22DF_Object_t *pObj, float *Odr)
{
 8008d92:	b580      	push	{r7, lr}
 8008d94:	b082      	sub	sp, #8
 8008d96:	af00      	add	r7, sp, #0
 8008d98:	6078      	str	r0, [r7, #4]
 8008d9a:	6039      	str	r1, [r7, #0]
  return LPS22DF_GetOutputDataRate(pObj, Odr);
 8008d9c:	6839      	ldr	r1, [r7, #0]
 8008d9e:	6878      	ldr	r0, [r7, #4]
 8008da0:	f000 f858 	bl	8008e54 <LPS22DF_GetOutputDataRate>
 8008da4:	4603      	mov	r3, r0
}
 8008da6:	4618      	mov	r0, r3
 8008da8:	3708      	adds	r7, #8
 8008daa:	46bd      	mov	sp, r7
 8008dac:	bd80      	pop	{r7, pc}

08008dae <LPS22DF_TEMP_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_SetOutputDataRate(LPS22DF_Object_t *pObj, float Odr)
{
 8008dae:	b580      	push	{r7, lr}
 8008db0:	b082      	sub	sp, #8
 8008db2:	af00      	add	r7, sp, #0
 8008db4:	6078      	str	r0, [r7, #4]
 8008db6:	ed87 0a00 	vstr	s0, [r7]
  /* Check if the component is enabled */
  if (pObj->temp_is_enabled == 1U)
 8008dba:	687b      	ldr	r3, [r7, #4]
 8008dbc:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8008dc0:	2b01      	cmp	r3, #1
 8008dc2:	d106      	bne.n	8008dd2 <LPS22DF_TEMP_SetOutputDataRate+0x24>
  {
    return LPS22DF_SetOutputDataRate_When_Enabled(pObj, Odr);
 8008dc4:	ed97 0a00 	vldr	s0, [r7]
 8008dc8:	6878      	ldr	r0, [r7, #4]
 8008dca:	f000 f8ad 	bl	8008f28 <LPS22DF_SetOutputDataRate_When_Enabled>
 8008dce:	4603      	mov	r3, r0
 8008dd0:	e005      	b.n	8008dde <LPS22DF_TEMP_SetOutputDataRate+0x30>
  }
  else
  {
    return LPS22DF_SetOutputDataRate_When_Disabled(pObj, Odr);
 8008dd2:	ed97 0a00 	vldr	s0, [r7]
 8008dd6:	6878      	ldr	r0, [r7, #4]
 8008dd8:	f000 f932 	bl	8009040 <LPS22DF_SetOutputDataRate_When_Disabled>
 8008ddc:	4603      	mov	r3, r0
  }
}
 8008dde:	4618      	mov	r0, r3
 8008de0:	3708      	adds	r7, #8
 8008de2:	46bd      	mov	sp, r7
 8008de4:	bd80      	pop	{r7, pc}

08008de6 <LPS22DF_TEMP_GetTemperature>:
  * @param  pObj the device pObj
  * @param  Value pointer where the temperature value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_TEMP_GetTemperature(LPS22DF_Object_t *pObj, float *Value)
{
 8008de6:	b580      	push	{r7, lr}
 8008de8:	b086      	sub	sp, #24
 8008dea:	af00      	add	r7, sp, #0
 8008dec:	6078      	str	r0, [r7, #4]
 8008dee:	6039      	str	r1, [r7, #0]
  lps22df_data_t data;

  if (lps22df_data_get(&(pObj->Ctx), &data) != LPS22DF_OK)
 8008df0:	687b      	ldr	r3, [r7, #4]
 8008df2:	3320      	adds	r3, #32
 8008df4:	f107 0208 	add.w	r2, r7, #8
 8008df8:	4611      	mov	r1, r2
 8008dfa:	4618      	mov	r0, r3
 8008dfc:	f000 fca8 	bl	8009750 <lps22df_data_get>
 8008e00:	4603      	mov	r3, r0
 8008e02:	2b00      	cmp	r3, #0
 8008e04:	d002      	beq.n	8008e0c <LPS22DF_TEMP_GetTemperature+0x26>
  {
    return LPS22DF_ERROR;
 8008e06:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008e0a:	e003      	b.n	8008e14 <LPS22DF_TEMP_GetTemperature+0x2e>
  }

  *Value = data.heat.deg_c;
 8008e0c:	693a      	ldr	r2, [r7, #16]
 8008e0e:	683b      	ldr	r3, [r7, #0]
 8008e10:	601a      	str	r2, [r3, #0]

  return LPS22DF_OK;
 8008e12:	2300      	movs	r3, #0
}
 8008e14:	4618      	mov	r0, r3
 8008e16:	3718      	adds	r7, #24
 8008e18:	46bd      	mov	sp, r7
 8008e1a:	bd80      	pop	{r7, pc}

08008e1c <LPS22DF_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LPS22DF_Write_Reg(LPS22DF_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 8008e1c:	b580      	push	{r7, lr}
 8008e1e:	b082      	sub	sp, #8
 8008e20:	af00      	add	r7, sp, #0
 8008e22:	6078      	str	r0, [r7, #4]
 8008e24:	460b      	mov	r3, r1
 8008e26:	70fb      	strb	r3, [r7, #3]
 8008e28:	4613      	mov	r3, r2
 8008e2a:	70bb      	strb	r3, [r7, #2]
  if (lps22df_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LPS22DF_OK)
 8008e2c:	687b      	ldr	r3, [r7, #4]
 8008e2e:	f103 0020 	add.w	r0, r3, #32
 8008e32:	1cba      	adds	r2, r7, #2
 8008e34:	78f9      	ldrb	r1, [r7, #3]
 8008e36:	2301      	movs	r3, #1
 8008e38:	f000 fa10 	bl	800925c <lps22df_write_reg>
 8008e3c:	4603      	mov	r3, r0
 8008e3e:	2b00      	cmp	r3, #0
 8008e40:	d002      	beq.n	8008e48 <LPS22DF_Write_Reg+0x2c>
  {
    return LPS22DF_ERROR;
 8008e42:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008e46:	e000      	b.n	8008e4a <LPS22DF_Write_Reg+0x2e>
  }

  return LPS22DF_OK;
 8008e48:	2300      	movs	r3, #0
}
 8008e4a:	4618      	mov	r0, r3
 8008e4c:	3708      	adds	r7, #8
 8008e4e:	46bd      	mov	sp, r7
 8008e50:	bd80      	pop	{r7, pc}
	...

08008e54 <LPS22DF_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_GetOutputDataRate(LPS22DF_Object_t *pObj, float *Odr)
{
 8008e54:	b580      	push	{r7, lr}
 8008e56:	b084      	sub	sp, #16
 8008e58:	af00      	add	r7, sp, #0
 8008e5a:	6078      	str	r0, [r7, #4]
 8008e5c:	6039      	str	r1, [r7, #0]
  int32_t ret = LPS22DF_OK;
 8008e5e:	2300      	movs	r3, #0
 8008e60:	60fb      	str	r3, [r7, #12]
  lps22df_md_t val;

  if (lps22df_mode_get(&(pObj->Ctx), &val) != LPS22DF_OK)
 8008e62:	687b      	ldr	r3, [r7, #4]
 8008e64:	3320      	adds	r3, #32
 8008e66:	f107 0208 	add.w	r2, r7, #8
 8008e6a:	4611      	mov	r1, r2
 8008e6c:	4618      	mov	r0, r3
 8008e6e:	f000 fba3 	bl	80095b8 <lps22df_mode_get>
 8008e72:	4603      	mov	r3, r0
 8008e74:	2b00      	cmp	r3, #0
 8008e76:	d002      	beq.n	8008e7e <LPS22DF_GetOutputDataRate+0x2a>
  {
    return LPS22DF_ERROR;
 8008e78:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008e7c:	e044      	b.n	8008f08 <LPS22DF_GetOutputDataRate+0xb4>
  }

  switch (val.odr)
 8008e7e:	7a3b      	ldrb	r3, [r7, #8]
 8008e80:	2b08      	cmp	r3, #8
 8008e82:	d83c      	bhi.n	8008efe <LPS22DF_GetOutputDataRate+0xaa>
 8008e84:	a201      	add	r2, pc, #4	@ (adr r2, 8008e8c <LPS22DF_GetOutputDataRate+0x38>)
 8008e86:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008e8a:	bf00      	nop
 8008e8c:	08008eb1 	.word	0x08008eb1
 8008e90:	08008ebb 	.word	0x08008ebb
 8008e94:	08008ec5 	.word	0x08008ec5
 8008e98:	08008ecf 	.word	0x08008ecf
 8008e9c:	08008ed7 	.word	0x08008ed7
 8008ea0:	08008edf 	.word	0x08008edf
 8008ea4:	08008ee7 	.word	0x08008ee7
 8008ea8:	08008eef 	.word	0x08008eef
 8008eac:	08008ef7 	.word	0x08008ef7
  {
    case LPS22DF_ONE_SHOT:
      *Odr = 0.0f;
 8008eb0:	683b      	ldr	r3, [r7, #0]
 8008eb2:	f04f 0200 	mov.w	r2, #0
 8008eb6:	601a      	str	r2, [r3, #0]
      break;
 8008eb8:	e025      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_1Hz:
      *Odr = 1.0f;
 8008eba:	683b      	ldr	r3, [r7, #0]
 8008ebc:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8008ec0:	601a      	str	r2, [r3, #0]
      break;
 8008ec2:	e020      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_4Hz:
      *Odr = 4.0f;
 8008ec4:	683b      	ldr	r3, [r7, #0]
 8008ec6:	f04f 4281 	mov.w	r2, #1082130432	@ 0x40800000
 8008eca:	601a      	str	r2, [r3, #0]
      break;
 8008ecc:	e01b      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_10Hz:
      *Odr = 10.0f;
 8008ece:	683b      	ldr	r3, [r7, #0]
 8008ed0:	4a0f      	ldr	r2, [pc, #60]	@ (8008f10 <LPS22DF_GetOutputDataRate+0xbc>)
 8008ed2:	601a      	str	r2, [r3, #0]
      break;
 8008ed4:	e017      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_25Hz:
      *Odr = 25.0f;
 8008ed6:	683b      	ldr	r3, [r7, #0]
 8008ed8:	4a0e      	ldr	r2, [pc, #56]	@ (8008f14 <LPS22DF_GetOutputDataRate+0xc0>)
 8008eda:	601a      	str	r2, [r3, #0]
      break;
 8008edc:	e013      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_50Hz:
      *Odr = 50.0f;
 8008ede:	683b      	ldr	r3, [r7, #0]
 8008ee0:	4a0d      	ldr	r2, [pc, #52]	@ (8008f18 <LPS22DF_GetOutputDataRate+0xc4>)
 8008ee2:	601a      	str	r2, [r3, #0]
      break;
 8008ee4:	e00f      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_75Hz:
      *Odr = 75.0f;
 8008ee6:	683b      	ldr	r3, [r7, #0]
 8008ee8:	4a0c      	ldr	r2, [pc, #48]	@ (8008f1c <LPS22DF_GetOutputDataRate+0xc8>)
 8008eea:	601a      	str	r2, [r3, #0]
      break;
 8008eec:	e00b      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_100Hz:
      *Odr = 100.0f;
 8008eee:	683b      	ldr	r3, [r7, #0]
 8008ef0:	4a0b      	ldr	r2, [pc, #44]	@ (8008f20 <LPS22DF_GetOutputDataRate+0xcc>)
 8008ef2:	601a      	str	r2, [r3, #0]
      break;
 8008ef4:	e007      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    case LPS22DF_200Hz:
      *Odr = 200.0f;
 8008ef6:	683b      	ldr	r3, [r7, #0]
 8008ef8:	4a0a      	ldr	r2, [pc, #40]	@ (8008f24 <LPS22DF_GetOutputDataRate+0xd0>)
 8008efa:	601a      	str	r2, [r3, #0]
      break;
 8008efc:	e003      	b.n	8008f06 <LPS22DF_GetOutputDataRate+0xb2>

    default:
      ret = LPS22DF_ERROR;
 8008efe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008f02:	60fb      	str	r3, [r7, #12]
      break;
 8008f04:	bf00      	nop
  }

  return ret;
 8008f06:	68fb      	ldr	r3, [r7, #12]
}
 8008f08:	4618      	mov	r0, r3
 8008f0a:	3710      	adds	r7, #16
 8008f0c:	46bd      	mov	sp, r7
 8008f0e:	bd80      	pop	{r7, pc}
 8008f10:	41200000 	.word	0x41200000
 8008f14:	41c80000 	.word	0x41c80000
 8008f18:	42480000 	.word	0x42480000
 8008f1c:	42960000 	.word	0x42960000
 8008f20:	42c80000 	.word	0x42c80000
 8008f24:	43480000 	.word	0x43480000

08008f28 <LPS22DF_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_SetOutputDataRate_When_Enabled(LPS22DF_Object_t *pObj, float Odr)
{
 8008f28:	b580      	push	{r7, lr}
 8008f2a:	b084      	sub	sp, #16
 8008f2c:	af00      	add	r7, sp, #0
 8008f2e:	6078      	str	r0, [r7, #4]
 8008f30:	ed87 0a00 	vstr	s0, [r7]
  lps22df_md_t new_val;

  if (lps22df_mode_get(&(pObj->Ctx), &new_val) != LPS22DF_OK)
 8008f34:	687b      	ldr	r3, [r7, #4]
 8008f36:	3320      	adds	r3, #32
 8008f38:	f107 020c 	add.w	r2, r7, #12
 8008f3c:	4611      	mov	r1, r2
 8008f3e:	4618      	mov	r0, r3
 8008f40:	f000 fb3a 	bl	80095b8 <lps22df_mode_get>
 8008f44:	4603      	mov	r3, r0
 8008f46:	2b00      	cmp	r3, #0
 8008f48:	d002      	beq.n	8008f50 <LPS22DF_SetOutputDataRate_When_Enabled+0x28>
  {
    return LPS22DF_ERROR;
 8008f4a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8008f4e:	e06c      	b.n	800902a <LPS22DF_SetOutputDataRate_When_Enabled+0x102>
  }

  new_val.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
                : (Odr <=   4.0f) ? LPS22DF_4Hz
 8008f50:	edd7 7a00 	vldr	s15, [r7]
 8008f54:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8008f58:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008f5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008f60:	d801      	bhi.n	8008f66 <LPS22DF_SetOutputDataRate_When_Enabled+0x3e>
 8008f62:	2301      	movs	r3, #1
 8008f64:	e042      	b.n	8008fec <LPS22DF_SetOutputDataRate_When_Enabled+0xc4>
 8008f66:	edd7 7a00 	vldr	s15, [r7]
 8008f6a:	eeb1 7a00 	vmov.f32	s14, #16	@ 0x40800000  4.0
 8008f6e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008f72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008f76:	d801      	bhi.n	8008f7c <LPS22DF_SetOutputDataRate_When_Enabled+0x54>
 8008f78:	2302      	movs	r3, #2
 8008f7a:	e037      	b.n	8008fec <LPS22DF_SetOutputDataRate_When_Enabled+0xc4>
 8008f7c:	edd7 7a00 	vldr	s15, [r7]
 8008f80:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8008f84:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008f88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008f8c:	d801      	bhi.n	8008f92 <LPS22DF_SetOutputDataRate_When_Enabled+0x6a>
 8008f8e:	2303      	movs	r3, #3
 8008f90:	e02c      	b.n	8008fec <LPS22DF_SetOutputDataRate_When_Enabled+0xc4>
 8008f92:	edd7 7a00 	vldr	s15, [r7]
 8008f96:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8008f9a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008f9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fa2:	d801      	bhi.n	8008fa8 <LPS22DF_SetOutputDataRate_When_Enabled+0x80>
 8008fa4:	2304      	movs	r3, #4
 8008fa6:	e021      	b.n	8008fec <LPS22DF_SetOutputDataRate_When_Enabled+0xc4>
 8008fa8:	edd7 7a00 	vldr	s15, [r7]
 8008fac:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 8009034 <LPS22DF_SetOutputDataRate_When_Enabled+0x10c>
 8008fb0:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008fb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fb8:	d801      	bhi.n	8008fbe <LPS22DF_SetOutputDataRate_When_Enabled+0x96>
 8008fba:	2305      	movs	r3, #5
 8008fbc:	e016      	b.n	8008fec <LPS22DF_SetOutputDataRate_When_Enabled+0xc4>
 8008fbe:	edd7 7a00 	vldr	s15, [r7]
 8008fc2:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 8009038 <LPS22DF_SetOutputDataRate_When_Enabled+0x110>
 8008fc6:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008fca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fce:	d801      	bhi.n	8008fd4 <LPS22DF_SetOutputDataRate_When_Enabled+0xac>
 8008fd0:	2306      	movs	r3, #6
 8008fd2:	e00b      	b.n	8008fec <LPS22DF_SetOutputDataRate_When_Enabled+0xc4>
 8008fd4:	edd7 7a00 	vldr	s15, [r7]
 8008fd8:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800903c <LPS22DF_SetOutputDataRate_When_Enabled+0x114>
 8008fdc:	eef4 7ac7 	vcmpe.f32	s15, s14
 8008fe0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fe4:	d801      	bhi.n	8008fea <LPS22DF_SetOutputDataRate_When_Enabled+0xc2>
 8008fe6:	2307      	movs	r3, #7
 8008fe8:	e000      	b.n	8008fec <LPS22DF_SetOutputDataRate_When_Enabled+0xc4>
 8008fea:	2308      	movs	r3, #8
  new_val.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
 8008fec:	733b      	strb	r3, [r7, #12]
                : (Odr <=  50.0f) ? LPS22DF_50Hz
                : (Odr <=  75.0f) ? LPS22DF_75Hz
                : (Odr <= 100.0f) ? LPS22DF_100Hz
                :                   LPS22DF_200Hz;

  if (lps22df_mode_set(&(pObj->Ctx), &new_val) != LPS22DF_OK)
 8008fee:	687b      	ldr	r3, [r7, #4]
 8008ff0:	3320      	adds	r3, #32
 8008ff2:	f107 020c 	add.w	r2, r7, #12
 8008ff6:	4611      	mov	r1, r2
 8008ff8:	4618      	mov	r0, r3
 8008ffa:	f000 fa7f 	bl	80094fc <lps22df_mode_set>
 8008ffe:	4603      	mov	r3, r0
 8009000:	2b00      	cmp	r3, #0
 8009002:	d002      	beq.n	800900a <LPS22DF_SetOutputDataRate_When_Enabled+0xe2>
  {
    return LPS22DF_ERROR;
 8009004:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009008:	e00f      	b.n	800902a <LPS22DF_SetOutputDataRate_When_Enabled+0x102>
  }

  if (lps22df_mode_get(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 800900a:	687b      	ldr	r3, [r7, #4]
 800900c:	f103 0220 	add.w	r2, r3, #32
 8009010:	687b      	ldr	r3, [r7, #4]
 8009012:	3333      	adds	r3, #51	@ 0x33
 8009014:	4619      	mov	r1, r3
 8009016:	4610      	mov	r0, r2
 8009018:	f000 face 	bl	80095b8 <lps22df_mode_get>
 800901c:	4603      	mov	r3, r0
 800901e:	2b00      	cmp	r3, #0
 8009020:	d002      	beq.n	8009028 <LPS22DF_SetOutputDataRate_When_Enabled+0x100>
  {
    return LPS22DF_ERROR;
 8009022:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009026:	e000      	b.n	800902a <LPS22DF_SetOutputDataRate_When_Enabled+0x102>
  }

  return LPS22DF_OK;
 8009028:	2300      	movs	r3, #0
}
 800902a:	4618      	mov	r0, r3
 800902c:	3710      	adds	r7, #16
 800902e:	46bd      	mov	sp, r7
 8009030:	bd80      	pop	{r7, pc}
 8009032:	bf00      	nop
 8009034:	42480000 	.word	0x42480000
 8009038:	42960000 	.word	0x42960000
 800903c:	42c80000 	.word	0x42c80000

08009040 <LPS22DF_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_SetOutputDataRate_When_Disabled(LPS22DF_Object_t *pObj, float Odr)
{
 8009040:	b480      	push	{r7}
 8009042:	b083      	sub	sp, #12
 8009044:	af00      	add	r7, sp, #0
 8009046:	6078      	str	r0, [r7, #4]
 8009048:	ed87 0a00 	vstr	s0, [r7]
  pObj->last_odr.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
                       : (Odr <=   4.0f) ? LPS22DF_4Hz
 800904c:	edd7 7a00 	vldr	s15, [r7]
 8009050:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8009054:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800905c:	d801      	bhi.n	8009062 <LPS22DF_SetOutputDataRate_When_Disabled+0x22>
 800905e:	2301      	movs	r3, #1
 8009060:	e042      	b.n	80090e8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa8>
 8009062:	edd7 7a00 	vldr	s15, [r7]
 8009066:	eeb1 7a00 	vmov.f32	s14, #16	@ 0x40800000  4.0
 800906a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800906e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009072:	d801      	bhi.n	8009078 <LPS22DF_SetOutputDataRate_When_Disabled+0x38>
 8009074:	2302      	movs	r3, #2
 8009076:	e037      	b.n	80090e8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa8>
 8009078:	edd7 7a00 	vldr	s15, [r7]
 800907c:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 8009080:	eef4 7ac7 	vcmpe.f32	s15, s14
 8009084:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009088:	d801      	bhi.n	800908e <LPS22DF_SetOutputDataRate_When_Disabled+0x4e>
 800908a:	2303      	movs	r3, #3
 800908c:	e02c      	b.n	80090e8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa8>
 800908e:	edd7 7a00 	vldr	s15, [r7]
 8009092:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 8009096:	eef4 7ac7 	vcmpe.f32	s15, s14
 800909a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800909e:	d801      	bhi.n	80090a4 <LPS22DF_SetOutputDataRate_When_Disabled+0x64>
 80090a0:	2304      	movs	r3, #4
 80090a2:	e021      	b.n	80090e8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa8>
 80090a4:	edd7 7a00 	vldr	s15, [r7]
 80090a8:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 80090fc <LPS22DF_SetOutputDataRate_When_Disabled+0xbc>
 80090ac:	eef4 7ac7 	vcmpe.f32	s15, s14
 80090b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090b4:	d801      	bhi.n	80090ba <LPS22DF_SetOutputDataRate_When_Disabled+0x7a>
 80090b6:	2305      	movs	r3, #5
 80090b8:	e016      	b.n	80090e8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa8>
 80090ba:	edd7 7a00 	vldr	s15, [r7]
 80090be:	ed9f 7a10 	vldr	s14, [pc, #64]	@ 8009100 <LPS22DF_SetOutputDataRate_When_Disabled+0xc0>
 80090c2:	eef4 7ac7 	vcmpe.f32	s15, s14
 80090c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090ca:	d801      	bhi.n	80090d0 <LPS22DF_SetOutputDataRate_When_Disabled+0x90>
 80090cc:	2306      	movs	r3, #6
 80090ce:	e00b      	b.n	80090e8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa8>
 80090d0:	edd7 7a00 	vldr	s15, [r7]
 80090d4:	ed9f 7a0b 	vldr	s14, [pc, #44]	@ 8009104 <LPS22DF_SetOutputDataRate_When_Disabled+0xc4>
 80090d8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80090dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090e0:	d801      	bhi.n	80090e6 <LPS22DF_SetOutputDataRate_When_Disabled+0xa6>
 80090e2:	2307      	movs	r3, #7
 80090e4:	e000      	b.n	80090e8 <LPS22DF_SetOutputDataRate_When_Disabled+0xa8>
 80090e6:	2308      	movs	r3, #8
  pObj->last_odr.odr = (Odr <=   1.0f) ? LPS22DF_1Hz
 80090e8:	687a      	ldr	r2, [r7, #4]
 80090ea:	f882 3033 	strb.w	r3, [r2, #51]	@ 0x33
                       : (Odr <=  50.0f) ? LPS22DF_50Hz
                       : (Odr <=  75.0f) ? LPS22DF_75Hz
                       : (Odr <= 100.0f) ? LPS22DF_100Hz
                       :                   LPS22DF_200Hz;

  return LPS22DF_OK;
 80090ee:	2300      	movs	r3, #0
}
 80090f0:	4618      	mov	r0, r3
 80090f2:	370c      	adds	r7, #12
 80090f4:	46bd      	mov	sp, r7
 80090f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80090fa:	4770      	bx	lr
 80090fc:	42480000 	.word	0x42480000
 8009100:	42960000 	.word	0x42960000
 8009104:	42c80000 	.word	0x42c80000

08009108 <LPS22DF_Initialize>:
  * @brief  Initialize the LPS22DF sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LPS22DF_Initialize(LPS22DF_Object_t *pObj)
{
 8009108:	b580      	push	{r7, lr}
 800910a:	b084      	sub	sp, #16
 800910c:	af00      	add	r7, sp, #0
 800910e:	6078      	str	r0, [r7, #4]
  lps22df_md_t md;
  lps22df_bus_mode_t bus_mode;

  /* Set bdu and if_inc recommended for driver usage */
  if (lps22df_init_set(&(pObj->Ctx), LPS22DF_DRV_RDY) != LPS22DF_OK)
 8009110:	687b      	ldr	r3, [r7, #4]
 8009112:	3320      	adds	r3, #32
 8009114:	2100      	movs	r1, #0
 8009116:	4618      	mov	r0, r3
 8009118:	f000 f977 	bl	800940a <lps22df_init_set>
 800911c:	4603      	mov	r3, r0
 800911e:	2b00      	cmp	r3, #0
 8009120:	d002      	beq.n	8009128 <LPS22DF_Initialize+0x20>
  {
    return LPS22DF_ERROR;
 8009122:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009126:	e047      	b.n	80091b8 <LPS22DF_Initialize+0xb0>
  }

  /* Select bus interface */
  if (pObj->IO.BusType == LPS22DF_SPI_3WIRES_BUS) /* SPI 3-Wires */
 8009128:	687b      	ldr	r3, [r7, #4]
 800912a:	689b      	ldr	r3, [r3, #8]
 800912c:	2b02      	cmp	r3, #2
 800912e:	d102      	bne.n	8009136 <LPS22DF_Initialize+0x2e>
  {
    bus_mode.interface = LPS22DF_SPI_3W;
 8009130:	2303      	movs	r3, #3
 8009132:	723b      	strb	r3, [r7, #8]
 8009134:	e008      	b.n	8009148 <LPS22DF_Initialize+0x40>
  }
  else if (pObj->IO.BusType == LPS22DF_SPI_4WIRES_BUS) /* SPI 4-Wires */
 8009136:	687b      	ldr	r3, [r7, #4]
 8009138:	689b      	ldr	r3, [r3, #8]
 800913a:	2b01      	cmp	r3, #1
 800913c:	d102      	bne.n	8009144 <LPS22DF_Initialize+0x3c>
  {
    bus_mode.interface = LPS22DF_SPI_4W;
 800913e:	2302      	movs	r3, #2
 8009140:	723b      	strb	r3, [r7, #8]
 8009142:	e001      	b.n	8009148 <LPS22DF_Initialize+0x40>
  }
  else
  {
    bus_mode.interface = LPS22DF_SEL_BY_HW;
 8009144:	2300      	movs	r3, #0
 8009146:	723b      	strb	r3, [r7, #8]
  }

  bus_mode.filter = LPS22DF_AUTO;
 8009148:	2300      	movs	r3, #0
 800914a:	727b      	strb	r3, [r7, #9]
  if (lps22df_bus_mode_set(&(pObj->Ctx), &bus_mode) != LPS22DF_OK)
 800914c:	687b      	ldr	r3, [r7, #4]
 800914e:	3320      	adds	r3, #32
 8009150:	f107 0208 	add.w	r2, r7, #8
 8009154:	4611      	mov	r1, r2
 8009156:	4618      	mov	r0, r3
 8009158:	f000 f8f5 	bl	8009346 <lps22df_bus_mode_set>
 800915c:	4603      	mov	r3, r0
 800915e:	2b00      	cmp	r3, #0
 8009160:	d002      	beq.n	8009168 <LPS22DF_Initialize+0x60>
  {
    return LPS22DF_ERROR;
 8009162:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009166:	e027      	b.n	80091b8 <LPS22DF_Initialize+0xb0>
  }

  /* Set Output Data Rate in Power Down */
  md.odr = LPS22DF_ONE_SHOT;
 8009168:	2300      	movs	r3, #0
 800916a:	733b      	strb	r3, [r7, #12]
  md.avg = LPS22DF_4_AVG;
 800916c:	2300      	movs	r3, #0
 800916e:	737b      	strb	r3, [r7, #13]
  md.lpf = LPS22DF_LPF_ODR_DIV_4;
 8009170:	2301      	movs	r3, #1
 8009172:	73bb      	strb	r3, [r7, #14]

  /* Power down the device */
  if (lps22df_mode_set(&(pObj->Ctx), &md) != LPS22DF_OK)
 8009174:	687b      	ldr	r3, [r7, #4]
 8009176:	3320      	adds	r3, #32
 8009178:	f107 020c 	add.w	r2, r7, #12
 800917c:	4611      	mov	r1, r2
 800917e:	4618      	mov	r0, r3
 8009180:	f000 f9bc 	bl	80094fc <lps22df_mode_set>
 8009184:	4603      	mov	r3, r0
 8009186:	2b00      	cmp	r3, #0
 8009188:	d002      	beq.n	8009190 <LPS22DF_Initialize+0x88>
  {
    return LPS22DF_ERROR;
 800918a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800918e:	e013      	b.n	80091b8 <LPS22DF_Initialize+0xb0>
  }

  if (lps22df_mode_get(&(pObj->Ctx), &pObj->last_odr) != LPS22DF_OK)
 8009190:	687b      	ldr	r3, [r7, #4]
 8009192:	f103 0220 	add.w	r2, r3, #32
 8009196:	687b      	ldr	r3, [r7, #4]
 8009198:	3333      	adds	r3, #51	@ 0x33
 800919a:	4619      	mov	r1, r3
 800919c:	4610      	mov	r0, r2
 800919e:	f000 fa0b 	bl	80095b8 <lps22df_mode_get>
 80091a2:	4603      	mov	r3, r0
 80091a4:	2b00      	cmp	r3, #0
 80091a6:	d002      	beq.n	80091ae <LPS22DF_Initialize+0xa6>
  {
    return LPS22DF_ERROR;
 80091a8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80091ac:	e004      	b.n	80091b8 <LPS22DF_Initialize+0xb0>
  }

  pObj->last_odr.odr = LPS22DF_25Hz;
 80091ae:	687b      	ldr	r3, [r7, #4]
 80091b0:	2204      	movs	r2, #4
 80091b2:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33

  return LPS22DF_OK;
 80091b6:	2300      	movs	r3, #0
}
 80091b8:	4618      	mov	r0, r3
 80091ba:	3710      	adds	r7, #16
 80091bc:	46bd      	mov	sp, r7
 80091be:	bd80      	pop	{r7, pc}

080091c0 <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 80091c0:	b590      	push	{r4, r7, lr}
 80091c2:	b087      	sub	sp, #28
 80091c4:	af00      	add	r7, sp, #0
 80091c6:	60f8      	str	r0, [r7, #12]
 80091c8:	607a      	str	r2, [r7, #4]
 80091ca:	461a      	mov	r2, r3
 80091cc:	460b      	mov	r3, r1
 80091ce:	72fb      	strb	r3, [r7, #11]
 80091d0:	4613      	mov	r3, r2
 80091d2:	813b      	strh	r3, [r7, #8]
  LPS22DF_Object_t *pObj = (LPS22DF_Object_t *)Handle;
 80091d4:	68fb      	ldr	r3, [r7, #12]
 80091d6:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 80091d8:	697b      	ldr	r3, [r7, #20]
 80091da:	695c      	ldr	r4, [r3, #20]
 80091dc:	697b      	ldr	r3, [r7, #20]
 80091de:	7b1b      	ldrb	r3, [r3, #12]
 80091e0:	4618      	mov	r0, r3
 80091e2:	7afb      	ldrb	r3, [r7, #11]
 80091e4:	b299      	uxth	r1, r3
 80091e6:	893b      	ldrh	r3, [r7, #8]
 80091e8:	687a      	ldr	r2, [r7, #4]
 80091ea:	47a0      	blx	r4
 80091ec:	4603      	mov	r3, r0
}
 80091ee:	4618      	mov	r0, r3
 80091f0:	371c      	adds	r7, #28
 80091f2:	46bd      	mov	sp, r7
 80091f4:	bd90      	pop	{r4, r7, pc}

080091f6 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 80091f6:	b590      	push	{r4, r7, lr}
 80091f8:	b087      	sub	sp, #28
 80091fa:	af00      	add	r7, sp, #0
 80091fc:	60f8      	str	r0, [r7, #12]
 80091fe:	607a      	str	r2, [r7, #4]
 8009200:	461a      	mov	r2, r3
 8009202:	460b      	mov	r3, r1
 8009204:	72fb      	strb	r3, [r7, #11]
 8009206:	4613      	mov	r3, r2
 8009208:	813b      	strh	r3, [r7, #8]
  LPS22DF_Object_t *pObj = (LPS22DF_Object_t *)Handle;
 800920a:	68fb      	ldr	r3, [r7, #12]
 800920c:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800920e:	697b      	ldr	r3, [r7, #20]
 8009210:	691c      	ldr	r4, [r3, #16]
 8009212:	697b      	ldr	r3, [r7, #20]
 8009214:	7b1b      	ldrb	r3, [r3, #12]
 8009216:	4618      	mov	r0, r3
 8009218:	7afb      	ldrb	r3, [r7, #11]
 800921a:	b299      	uxth	r1, r3
 800921c:	893b      	ldrh	r3, [r7, #8]
 800921e:	687a      	ldr	r2, [r7, #4]
 8009220:	47a0      	blx	r4
 8009222:	4603      	mov	r3, r0
}
 8009224:	4618      	mov	r0, r3
 8009226:	371c      	adds	r7, #28
 8009228:	46bd      	mov	sp, r7
 800922a:	bd90      	pop	{r4, r7, pc}

0800922c <lps22df_read_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_read_reg(stmdev_ctx_t *ctx, uint8_t reg, uint8_t *data,
                         uint16_t len)
{
 800922c:	b590      	push	{r4, r7, lr}
 800922e:	b087      	sub	sp, #28
 8009230:	af00      	add	r7, sp, #0
 8009232:	60f8      	str	r0, [r7, #12]
 8009234:	607a      	str	r2, [r7, #4]
 8009236:	461a      	mov	r2, r3
 8009238:	460b      	mov	r3, r1
 800923a:	72fb      	strb	r3, [r7, #11]
 800923c:	4613      	mov	r3, r2
 800923e:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 8009240:	68fb      	ldr	r3, [r7, #12]
 8009242:	685c      	ldr	r4, [r3, #4]
 8009244:	68fb      	ldr	r3, [r7, #12]
 8009246:	68d8      	ldr	r0, [r3, #12]
 8009248:	893b      	ldrh	r3, [r7, #8]
 800924a:	7af9      	ldrb	r1, [r7, #11]
 800924c:	687a      	ldr	r2, [r7, #4]
 800924e:	47a0      	blx	r4
 8009250:	6178      	str	r0, [r7, #20]
  return ret;
 8009252:	697b      	ldr	r3, [r7, #20]
}
 8009254:	4618      	mov	r0, r3
 8009256:	371c      	adds	r7, #28
 8009258:	46bd      	mov	sp, r7
 800925a:	bd90      	pop	{r4, r7, pc}

0800925c <lps22df_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_write_reg(stmdev_ctx_t *ctx, uint8_t reg, uint8_t *data,
                          uint16_t len)
{
 800925c:	b590      	push	{r4, r7, lr}
 800925e:	b087      	sub	sp, #28
 8009260:	af00      	add	r7, sp, #0
 8009262:	60f8      	str	r0, [r7, #12]
 8009264:	607a      	str	r2, [r7, #4]
 8009266:	461a      	mov	r2, r3
 8009268:	460b      	mov	r3, r1
 800926a:	72fb      	strb	r3, [r7, #11]
 800926c:	4613      	mov	r3, r2
 800926e:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 8009270:	68fb      	ldr	r3, [r7, #12]
 8009272:	681c      	ldr	r4, [r3, #0]
 8009274:	68fb      	ldr	r3, [r7, #12]
 8009276:	68d8      	ldr	r0, [r3, #12]
 8009278:	893b      	ldrh	r3, [r7, #8]
 800927a:	7af9      	ldrb	r1, [r7, #11]
 800927c:	687a      	ldr	r2, [r7, #4]
 800927e:	47a0      	blx	r4
 8009280:	6178      	str	r0, [r7, #20]
  return ret;
 8009282:	697b      	ldr	r3, [r7, #20]
}
 8009284:	4618      	mov	r0, r3
 8009286:	371c      	adds	r7, #28
 8009288:	46bd      	mov	sp, r7
 800928a:	bd90      	pop	{r4, r7, pc}

0800928c <bytecpy>:
  * @{
  *
  */

static void bytecpy(uint8_t *target, uint8_t *source)
{
 800928c:	b480      	push	{r7}
 800928e:	b083      	sub	sp, #12
 8009290:	af00      	add	r7, sp, #0
 8009292:	6078      	str	r0, [r7, #4]
 8009294:	6039      	str	r1, [r7, #0]
  if ((target != NULL) && (source != NULL))
 8009296:	687b      	ldr	r3, [r7, #4]
 8009298:	2b00      	cmp	r3, #0
 800929a:	d006      	beq.n	80092aa <bytecpy+0x1e>
 800929c:	683b      	ldr	r3, [r7, #0]
 800929e:	2b00      	cmp	r3, #0
 80092a0:	d003      	beq.n	80092aa <bytecpy+0x1e>
  {
    *target = *source;
 80092a2:	683b      	ldr	r3, [r7, #0]
 80092a4:	781a      	ldrb	r2, [r3, #0]
 80092a6:	687b      	ldr	r3, [r7, #4]
 80092a8:	701a      	strb	r2, [r3, #0]
  }
}
 80092aa:	bf00      	nop
 80092ac:	370c      	adds	r7, #12
 80092ae:	46bd      	mov	sp, r7
 80092b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092b4:	4770      	bx	lr
	...

080092b8 <lps22df_from_lsb_to_hPa>:
  * @{
  *
  */

float_t lps22df_from_lsb_to_hPa(int32_t lsb)
{
 80092b8:	b480      	push	{r7}
 80092ba:	b083      	sub	sp, #12
 80092bc:	af00      	add	r7, sp, #0
 80092be:	6078      	str	r0, [r7, #4]
  return ((float_t)lsb / 1048576.0f);   /* 4096.0f * 256 */
 80092c0:	687b      	ldr	r3, [r7, #4]
 80092c2:	ee07 3a90 	vmov	s15, r3
 80092c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80092ca:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 80092e4 <lps22df_from_lsb_to_hPa+0x2c>
 80092ce:	eec7 6a87 	vdiv.f32	s13, s15, s14
 80092d2:	eef0 7a66 	vmov.f32	s15, s13
}
 80092d6:	eeb0 0a67 	vmov.f32	s0, s15
 80092da:	370c      	adds	r7, #12
 80092dc:	46bd      	mov	sp, r7
 80092de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80092e2:	4770      	bx	lr
 80092e4:	49800000 	.word	0x49800000

080092e8 <lps22df_from_lsb_to_celsius>:

float_t lps22df_from_lsb_to_celsius(int16_t lsb)
{
 80092e8:	b480      	push	{r7}
 80092ea:	b083      	sub	sp, #12
 80092ec:	af00      	add	r7, sp, #0
 80092ee:	4603      	mov	r3, r0
 80092f0:	80fb      	strh	r3, [r7, #6]
  return ((float_t)lsb / 100.0f);
 80092f2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80092f6:	ee07 3a90 	vmov	s15, r3
 80092fa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80092fe:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 8009318 <lps22df_from_lsb_to_celsius+0x30>
 8009302:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8009306:	eef0 7a66 	vmov.f32	s15, s13
}
 800930a:	eeb0 0a67 	vmov.f32	s0, s15
 800930e:	370c      	adds	r7, #12
 8009310:	46bd      	mov	sp, r7
 8009312:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009316:	4770      	bx	lr
 8009318:	42c80000 	.word	0x42c80000

0800931c <lps22df_id_get>:
  * @param  val   ID values.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_id_get(stmdev_ctx_t *ctx, lps22df_id_t *val)
{
 800931c:	b580      	push	{r7, lr}
 800931e:	b084      	sub	sp, #16
 8009320:	af00      	add	r7, sp, #0
 8009322:	6078      	str	r0, [r7, #4]
 8009324:	6039      	str	r1, [r7, #0]
  uint8_t reg;
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_WHO_AM_I, &reg, 1);
 8009326:	f107 020b 	add.w	r2, r7, #11
 800932a:	2301      	movs	r3, #1
 800932c:	210f      	movs	r1, #15
 800932e:	6878      	ldr	r0, [r7, #4]
 8009330:	f7ff ff7c 	bl	800922c <lps22df_read_reg>
 8009334:	60f8      	str	r0, [r7, #12]
  val->whoami = reg;
 8009336:	7afa      	ldrb	r2, [r7, #11]
 8009338:	683b      	ldr	r3, [r7, #0]
 800933a:	701a      	strb	r2, [r3, #0]

  return ret;
 800933c:	68fb      	ldr	r3, [r7, #12]
}
 800933e:	4618      	mov	r0, r3
 8009340:	3710      	adds	r7, #16
 8009342:	46bd      	mov	sp, r7
 8009344:	bd80      	pop	{r7, pc}

08009346 <lps22df_bus_mode_set>:
  * @param  val   configures the bus operating mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_bus_mode_set(stmdev_ctx_t *ctx, lps22df_bus_mode_t *val)
{
 8009346:	b580      	push	{r7, lr}
 8009348:	b086      	sub	sp, #24
 800934a:	af00      	add	r7, sp, #0
 800934c:	6078      	str	r0, [r7, #4]
 800934e:	6039      	str	r1, [r7, #0]
  lps22df_i3c_if_ctrl_add_t i3c_if_ctrl_add;
  lps22df_if_ctrl_t if_ctrl;
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_IF_CTRL, (uint8_t *)&if_ctrl, 1);
 8009350:	f107 020c 	add.w	r2, r7, #12
 8009354:	2301      	movs	r3, #1
 8009356:	210e      	movs	r1, #14
 8009358:	6878      	ldr	r0, [r7, #4]
 800935a:	f7ff ff67 	bl	800922c <lps22df_read_reg>
 800935e:	6178      	str	r0, [r7, #20]
  if (ret == 0)
 8009360:	697b      	ldr	r3, [r7, #20]
 8009362:	2b00      	cmp	r3, #0
 8009364:	d124      	bne.n	80093b0 <lps22df_bus_mode_set+0x6a>
  {
    if_ctrl.int_en_i3c = ((uint8_t)val->interface & 0x04U) >> 2;
 8009366:	683b      	ldr	r3, [r7, #0]
 8009368:	781b      	ldrb	r3, [r3, #0]
 800936a:	089b      	lsrs	r3, r3, #2
 800936c:	f003 0301 	and.w	r3, r3, #1
 8009370:	b2da      	uxtb	r2, r3
 8009372:	7b3b      	ldrb	r3, [r7, #12]
 8009374:	f362 13c7 	bfi	r3, r2, #7, #1
 8009378:	733b      	strb	r3, [r7, #12]
    if_ctrl.i2c_i3c_dis = ((uint8_t)val->interface & 0x02U) >> 1;
 800937a:	683b      	ldr	r3, [r7, #0]
 800937c:	781b      	ldrb	r3, [r3, #0]
 800937e:	085b      	lsrs	r3, r3, #1
 8009380:	f003 0301 	and.w	r3, r3, #1
 8009384:	b2da      	uxtb	r2, r3
 8009386:	7b3b      	ldrb	r3, [r7, #12]
 8009388:	f362 1386 	bfi	r3, r2, #6, #1
 800938c:	733b      	strb	r3, [r7, #12]
    if_ctrl.sim = ((uint8_t)val->interface & 0x01U);
 800938e:	683b      	ldr	r3, [r7, #0]
 8009390:	781b      	ldrb	r3, [r3, #0]
 8009392:	f003 0301 	and.w	r3, r3, #1
 8009396:	b2da      	uxtb	r2, r3
 8009398:	7b3b      	ldrb	r3, [r7, #12]
 800939a:	f362 1345 	bfi	r3, r2, #5, #1
 800939e:	733b      	strb	r3, [r7, #12]
    ret = lps22df_write_reg(ctx, LPS22DF_IF_CTRL, (uint8_t *)&if_ctrl, 1);
 80093a0:	f107 020c 	add.w	r2, r7, #12
 80093a4:	2301      	movs	r3, #1
 80093a6:	210e      	movs	r1, #14
 80093a8:	6878      	ldr	r0, [r7, #4]
 80093aa:	f7ff ff57 	bl	800925c <lps22df_write_reg>
 80093ae:	6178      	str	r0, [r7, #20]
  }
  if (ret == 0)
 80093b0:	697b      	ldr	r3, [r7, #20]
 80093b2:	2b00      	cmp	r3, #0
 80093b4:	d107      	bne.n	80093c6 <lps22df_bus_mode_set+0x80>
  {
    ret = lps22df_read_reg(ctx, LPS22DF_I3C_IF_CTRL_ADD,
 80093b6:	f107 0210 	add.w	r2, r7, #16
 80093ba:	2301      	movs	r3, #1
 80093bc:	2119      	movs	r1, #25
 80093be:	6878      	ldr	r0, [r7, #4]
 80093c0:	f7ff ff34 	bl	800922c <lps22df_read_reg>
 80093c4:	6178      	str	r0, [r7, #20]
                           (uint8_t *)&i3c_if_ctrl_add, 1);
  }
  if (ret == 0)
 80093c6:	697b      	ldr	r3, [r7, #20]
 80093c8:	2b00      	cmp	r3, #0
 80093ca:	d119      	bne.n	8009400 <lps22df_bus_mode_set+0xba>
  {
    i3c_if_ctrl_add.asf_on = (uint8_t)val->filter & 0x01U;
 80093cc:	683b      	ldr	r3, [r7, #0]
 80093ce:	785b      	ldrb	r3, [r3, #1]
 80093d0:	f003 0301 	and.w	r3, r3, #1
 80093d4:	b2da      	uxtb	r2, r3
 80093d6:	7c3b      	ldrb	r3, [r7, #16]
 80093d8:	f362 1345 	bfi	r3, r2, #5, #1
 80093dc:	743b      	strb	r3, [r7, #16]
    i3c_if_ctrl_add.i3c_bus_avb_sel = (uint8_t)val->i3c_ibi_time & 0x03U;
 80093de:	683b      	ldr	r3, [r7, #0]
 80093e0:	789b      	ldrb	r3, [r3, #2]
 80093e2:	f003 0303 	and.w	r3, r3, #3
 80093e6:	b2da      	uxtb	r2, r3
 80093e8:	7c3b      	ldrb	r3, [r7, #16]
 80093ea:	f362 0301 	bfi	r3, r2, #0, #2
 80093ee:	743b      	strb	r3, [r7, #16]
    ret = lps22df_write_reg(ctx, LPS22DF_I3C_IF_CTRL_ADD,
 80093f0:	f107 0210 	add.w	r2, r7, #16
 80093f4:	2301      	movs	r3, #1
 80093f6:	2119      	movs	r1, #25
 80093f8:	6878      	ldr	r0, [r7, #4]
 80093fa:	f7ff ff2f 	bl	800925c <lps22df_write_reg>
 80093fe:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&i3c_if_ctrl_add, 1);
  }
  return ret;
 8009400:	697b      	ldr	r3, [r7, #20]
}
 8009402:	4618      	mov	r0, r3
 8009404:	3718      	adds	r7, #24
 8009406:	46bd      	mov	sp, r7
 8009408:	bd80      	pop	{r7, pc}

0800940a <lps22df_init_set>:
  * @param  val   configures the bus operating mode.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_init_set(stmdev_ctx_t *ctx, lps22df_init_t val)
{
 800940a:	b580      	push	{r7, lr}
 800940c:	b086      	sub	sp, #24
 800940e:	af00      	add	r7, sp, #0
 8009410:	6078      	str	r0, [r7, #4]
 8009412:	460b      	mov	r3, r1
 8009414:	70fb      	strb	r3, [r7, #3]
  lps22df_ctrl_reg2_t ctrl_reg2;
  lps22df_ctrl_reg3_t ctrl_reg3;
  uint8_t reg[2];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_CTRL_REG2, reg, 2);
 8009416:	f107 0208 	add.w	r2, r7, #8
 800941a:	2302      	movs	r3, #2
 800941c:	2111      	movs	r1, #17
 800941e:	6878      	ldr	r0, [r7, #4]
 8009420:	f7ff ff04 	bl	800922c <lps22df_read_reg>
 8009424:	6178      	str	r0, [r7, #20]
  if (ret == 0)
 8009426:	697b      	ldr	r3, [r7, #20]
 8009428:	2b00      	cmp	r3, #0
 800942a:	d162      	bne.n	80094f2 <lps22df_init_set+0xe8>
  {
    bytecpy((uint8_t *)&ctrl_reg2, &reg[0]);
 800942c:	f107 0208 	add.w	r2, r7, #8
 8009430:	f107 0310 	add.w	r3, r7, #16
 8009434:	4611      	mov	r1, r2
 8009436:	4618      	mov	r0, r3
 8009438:	f7ff ff28 	bl	800928c <bytecpy>
    bytecpy((uint8_t *)&ctrl_reg3, &reg[1]);
 800943c:	f107 0308 	add.w	r3, r7, #8
 8009440:	1c5a      	adds	r2, r3, #1
 8009442:	f107 030c 	add.w	r3, r7, #12
 8009446:	4611      	mov	r1, r2
 8009448:	4618      	mov	r0, r3
 800944a:	f7ff ff1f 	bl	800928c <bytecpy>

    switch (val)
 800944e:	78fb      	ldrb	r3, [r7, #3]
 8009450:	2b02      	cmp	r3, #2
 8009452:	d012      	beq.n	800947a <lps22df_init_set+0x70>
 8009454:	2b02      	cmp	r3, #2
 8009456:	dc3f      	bgt.n	80094d8 <lps22df_init_set+0xce>
 8009458:	2b00      	cmp	r3, #0
 800945a:	d01b      	beq.n	8009494 <lps22df_init_set+0x8a>
 800945c:	2b01      	cmp	r3, #1
 800945e:	d13b      	bne.n	80094d8 <lps22df_init_set+0xce>
    {
      case LPS22DF_BOOT:
        ctrl_reg2.boot = PROPERTY_ENABLE;
 8009460:	7c3b      	ldrb	r3, [r7, #16]
 8009462:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8009466:	743b      	strb	r3, [r7, #16]
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2,
 8009468:	f107 0210 	add.w	r2, r7, #16
 800946c:	2301      	movs	r3, #1
 800946e:	2111      	movs	r1, #17
 8009470:	6878      	ldr	r0, [r7, #4]
 8009472:	f7ff fef3 	bl	800925c <lps22df_write_reg>
 8009476:	6178      	str	r0, [r7, #20]
                                (uint8_t *)&ctrl_reg2, 1);
        break;
 8009478:	e03b      	b.n	80094f2 <lps22df_init_set+0xe8>
      case LPS22DF_RESET:
        ctrl_reg2.swreset = PROPERTY_ENABLE;
 800947a:	7c3b      	ldrb	r3, [r7, #16]
 800947c:	f043 0304 	orr.w	r3, r3, #4
 8009480:	743b      	strb	r3, [r7, #16]
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2,
 8009482:	f107 0210 	add.w	r2, r7, #16
 8009486:	2301      	movs	r3, #1
 8009488:	2111      	movs	r1, #17
 800948a:	6878      	ldr	r0, [r7, #4]
 800948c:	f7ff fee6 	bl	800925c <lps22df_write_reg>
 8009490:	6178      	str	r0, [r7, #20]
                                (uint8_t *)&ctrl_reg2, 1);
        break;
 8009492:	e02e      	b.n	80094f2 <lps22df_init_set+0xe8>
      case LPS22DF_DRV_RDY:
        ctrl_reg2.bdu = PROPERTY_ENABLE;
 8009494:	7c3b      	ldrb	r3, [r7, #16]
 8009496:	f043 0308 	orr.w	r3, r3, #8
 800949a:	743b      	strb	r3, [r7, #16]
        ctrl_reg3.if_add_inc = PROPERTY_ENABLE;
 800949c:	7b3b      	ldrb	r3, [r7, #12]
 800949e:	f043 0301 	orr.w	r3, r3, #1
 80094a2:	733b      	strb	r3, [r7, #12]
        bytecpy(&reg[0], (uint8_t *)&ctrl_reg2);
 80094a4:	f107 0210 	add.w	r2, r7, #16
 80094a8:	f107 0308 	add.w	r3, r7, #8
 80094ac:	4611      	mov	r1, r2
 80094ae:	4618      	mov	r0, r3
 80094b0:	f7ff feec 	bl	800928c <bytecpy>
        bytecpy(&reg[1], (uint8_t *)&ctrl_reg3);
 80094b4:	f107 020c 	add.w	r2, r7, #12
 80094b8:	f107 0308 	add.w	r3, r7, #8
 80094bc:	3301      	adds	r3, #1
 80094be:	4611      	mov	r1, r2
 80094c0:	4618      	mov	r0, r3
 80094c2:	f7ff fee3 	bl	800928c <bytecpy>
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2, reg, 2);
 80094c6:	f107 0208 	add.w	r2, r7, #8
 80094ca:	2302      	movs	r3, #2
 80094cc:	2111      	movs	r1, #17
 80094ce:	6878      	ldr	r0, [r7, #4]
 80094d0:	f7ff fec4 	bl	800925c <lps22df_write_reg>
 80094d4:	6178      	str	r0, [r7, #20]
        break;
 80094d6:	e00c      	b.n	80094f2 <lps22df_init_set+0xe8>
      default:
        ctrl_reg2.swreset = PROPERTY_ENABLE;
 80094d8:	7c3b      	ldrb	r3, [r7, #16]
 80094da:	f043 0304 	orr.w	r3, r3, #4
 80094de:	743b      	strb	r3, [r7, #16]
        ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG2,
 80094e0:	f107 0210 	add.w	r2, r7, #16
 80094e4:	2301      	movs	r3, #1
 80094e6:	2111      	movs	r1, #17
 80094e8:	6878      	ldr	r0, [r7, #4]
 80094ea:	f7ff feb7 	bl	800925c <lps22df_write_reg>
 80094ee:	6178      	str	r0, [r7, #20]
                                (uint8_t *)&ctrl_reg2, 1);
        break;
 80094f0:	bf00      	nop
    }
  }
  return ret;
 80094f2:	697b      	ldr	r3, [r7, #20]
}
 80094f4:	4618      	mov	r0, r3
 80094f6:	3718      	adds	r7, #24
 80094f8:	46bd      	mov	sp, r7
 80094fa:	bd80      	pop	{r7, pc}

080094fc <lps22df_mode_set>:
  * @param  val   set the sensor conversion parameters.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_mode_set(stmdev_ctx_t *ctx, lps22df_md_t *val)
{
 80094fc:	b580      	push	{r7, lr}
 80094fe:	b086      	sub	sp, #24
 8009500:	af00      	add	r7, sp, #0
 8009502:	6078      	str	r0, [r7, #4]
 8009504:	6039      	str	r1, [r7, #0]
  lps22df_ctrl_reg1_t ctrl_reg1;
  lps22df_ctrl_reg2_t ctrl_reg2;
  uint8_t reg[2];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_CTRL_REG1, reg, 2);
 8009506:	f107 0208 	add.w	r2, r7, #8
 800950a:	2302      	movs	r3, #2
 800950c:	2110      	movs	r1, #16
 800950e:	6878      	ldr	r0, [r7, #4]
 8009510:	f7ff fe8c 	bl	800922c <lps22df_read_reg>
 8009514:	6178      	str	r0, [r7, #20]

  if (ret == 0)
 8009516:	697b      	ldr	r3, [r7, #20]
 8009518:	2b00      	cmp	r3, #0
 800951a:	d148      	bne.n	80095ae <lps22df_mode_set+0xb2>
  {
    bytecpy((uint8_t *)&ctrl_reg1, &reg[0]);
 800951c:	f107 0208 	add.w	r2, r7, #8
 8009520:	f107 0310 	add.w	r3, r7, #16
 8009524:	4611      	mov	r1, r2
 8009526:	4618      	mov	r0, r3
 8009528:	f7ff feb0 	bl	800928c <bytecpy>
    bytecpy((uint8_t *)&ctrl_reg2, &reg[1]);
 800952c:	f107 0308 	add.w	r3, r7, #8
 8009530:	1c5a      	adds	r2, r3, #1
 8009532:	f107 030c 	add.w	r3, r7, #12
 8009536:	4611      	mov	r1, r2
 8009538:	4618      	mov	r0, r3
 800953a:	f7ff fea7 	bl	800928c <bytecpy>

    ctrl_reg1.odr = (uint8_t)val->odr;
 800953e:	683b      	ldr	r3, [r7, #0]
 8009540:	781b      	ldrb	r3, [r3, #0]
 8009542:	f003 030f 	and.w	r3, r3, #15
 8009546:	b2da      	uxtb	r2, r3
 8009548:	7c3b      	ldrb	r3, [r7, #16]
 800954a:	f362 03c6 	bfi	r3, r2, #3, #4
 800954e:	743b      	strb	r3, [r7, #16]
    ctrl_reg1.avg = (uint8_t)val->avg;
 8009550:	683b      	ldr	r3, [r7, #0]
 8009552:	785b      	ldrb	r3, [r3, #1]
 8009554:	f003 0307 	and.w	r3, r3, #7
 8009558:	b2da      	uxtb	r2, r3
 800955a:	7c3b      	ldrb	r3, [r7, #16]
 800955c:	f362 0302 	bfi	r3, r2, #0, #3
 8009560:	743b      	strb	r3, [r7, #16]
    ctrl_reg2.en_lpfp = (uint8_t)val->lpf & 0x01U;
 8009562:	683b      	ldr	r3, [r7, #0]
 8009564:	789b      	ldrb	r3, [r3, #2]
 8009566:	f003 0301 	and.w	r3, r3, #1
 800956a:	b2da      	uxtb	r2, r3
 800956c:	7b3b      	ldrb	r3, [r7, #12]
 800956e:	f362 1304 	bfi	r3, r2, #4, #1
 8009572:	733b      	strb	r3, [r7, #12]
    ctrl_reg2.lfpf_cfg = ((uint8_t)val->lpf & 0x02U) >> 2;
 8009574:	7b3b      	ldrb	r3, [r7, #12]
 8009576:	f36f 1345 	bfc	r3, #5, #1
 800957a:	733b      	strb	r3, [r7, #12]

    bytecpy(&reg[0], (uint8_t *)&ctrl_reg1);
 800957c:	f107 0210 	add.w	r2, r7, #16
 8009580:	f107 0308 	add.w	r3, r7, #8
 8009584:	4611      	mov	r1, r2
 8009586:	4618      	mov	r0, r3
 8009588:	f7ff fe80 	bl	800928c <bytecpy>
    bytecpy(&reg[1], (uint8_t *)&ctrl_reg2);
 800958c:	f107 020c 	add.w	r2, r7, #12
 8009590:	f107 0308 	add.w	r3, r7, #8
 8009594:	3301      	adds	r3, #1
 8009596:	4611      	mov	r1, r2
 8009598:	4618      	mov	r0, r3
 800959a:	f7ff fe77 	bl	800928c <bytecpy>
    ret = lps22df_write_reg(ctx, LPS22DF_CTRL_REG1, reg, 2);
 800959e:	f107 0208 	add.w	r2, r7, #8
 80095a2:	2302      	movs	r3, #2
 80095a4:	2110      	movs	r1, #16
 80095a6:	6878      	ldr	r0, [r7, #4]
 80095a8:	f7ff fe58 	bl	800925c <lps22df_write_reg>
 80095ac:	6178      	str	r0, [r7, #20]
  }

  return ret;
 80095ae:	697b      	ldr	r3, [r7, #20]
}
 80095b0:	4618      	mov	r0, r3
 80095b2:	3718      	adds	r7, #24
 80095b4:	46bd      	mov	sp, r7
 80095b6:	bd80      	pop	{r7, pc}

080095b8 <lps22df_mode_get>:
  * @param  val   get the sensor conversion parameters.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_mode_get(stmdev_ctx_t *ctx, lps22df_md_t *val)
{
 80095b8:	b580      	push	{r7, lr}
 80095ba:	b086      	sub	sp, #24
 80095bc:	af00      	add	r7, sp, #0
 80095be:	6078      	str	r0, [r7, #4]
 80095c0:	6039      	str	r1, [r7, #0]
  lps22df_ctrl_reg1_t ctrl_reg1;
  lps22df_ctrl_reg2_t ctrl_reg2;
  uint8_t reg[2];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_CTRL_REG1, reg, 2);
 80095c2:	f107 0208 	add.w	r2, r7, #8
 80095c6:	2302      	movs	r3, #2
 80095c8:	2110      	movs	r1, #16
 80095ca:	6878      	ldr	r0, [r7, #4]
 80095cc:	f7ff fe2e 	bl	800922c <lps22df_read_reg>
 80095d0:	6178      	str	r0, [r7, #20]

  if (ret == 0)
 80095d2:	697b      	ldr	r3, [r7, #20]
 80095d4:	2b00      	cmp	r3, #0
 80095d6:	f040 80b6 	bne.w	8009746 <lps22df_mode_get+0x18e>
  {
    bytecpy((uint8_t *)&ctrl_reg1, &reg[0]);
 80095da:	f107 0208 	add.w	r2, r7, #8
 80095de:	f107 0310 	add.w	r3, r7, #16
 80095e2:	4611      	mov	r1, r2
 80095e4:	4618      	mov	r0, r3
 80095e6:	f7ff fe51 	bl	800928c <bytecpy>
    bytecpy((uint8_t *)&ctrl_reg2, &reg[1]);
 80095ea:	f107 0308 	add.w	r3, r7, #8
 80095ee:	1c5a      	adds	r2, r3, #1
 80095f0:	f107 030c 	add.w	r3, r7, #12
 80095f4:	4611      	mov	r1, r2
 80095f6:	4618      	mov	r0, r3
 80095f8:	f7ff fe48 	bl	800928c <bytecpy>

    switch (ctrl_reg1.odr)
 80095fc:	7c3b      	ldrb	r3, [r7, #16]
 80095fe:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 8009602:	b2db      	uxtb	r3, r3
 8009604:	2b08      	cmp	r3, #8
 8009606:	d839      	bhi.n	800967c <lps22df_mode_get+0xc4>
 8009608:	a201      	add	r2, pc, #4	@ (adr r2, 8009610 <lps22df_mode_get+0x58>)
 800960a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800960e:	bf00      	nop
 8009610:	08009635 	.word	0x08009635
 8009614:	0800963d 	.word	0x0800963d
 8009618:	08009645 	.word	0x08009645
 800961c:	0800964d 	.word	0x0800964d
 8009620:	08009655 	.word	0x08009655
 8009624:	0800965d 	.word	0x0800965d
 8009628:	08009665 	.word	0x08009665
 800962c:	0800966d 	.word	0x0800966d
 8009630:	08009675 	.word	0x08009675
    {
      case LPS22DF_ONE_SHOT:
        val->odr = LPS22DF_ONE_SHOT;
 8009634:	683b      	ldr	r3, [r7, #0]
 8009636:	2200      	movs	r2, #0
 8009638:	701a      	strb	r2, [r3, #0]
        break;
 800963a:	e023      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_1Hz:
        val->odr = LPS22DF_1Hz;
 800963c:	683b      	ldr	r3, [r7, #0]
 800963e:	2201      	movs	r2, #1
 8009640:	701a      	strb	r2, [r3, #0]
        break;
 8009642:	e01f      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_4Hz:
        val->odr = LPS22DF_4Hz;
 8009644:	683b      	ldr	r3, [r7, #0]
 8009646:	2202      	movs	r2, #2
 8009648:	701a      	strb	r2, [r3, #0]
        break;
 800964a:	e01b      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_10Hz:
        val->odr = LPS22DF_10Hz;
 800964c:	683b      	ldr	r3, [r7, #0]
 800964e:	2203      	movs	r2, #3
 8009650:	701a      	strb	r2, [r3, #0]
        break;
 8009652:	e017      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_25Hz:
        val->odr = LPS22DF_25Hz;
 8009654:	683b      	ldr	r3, [r7, #0]
 8009656:	2204      	movs	r2, #4
 8009658:	701a      	strb	r2, [r3, #0]
        break;
 800965a:	e013      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_50Hz:
        val->odr = LPS22DF_50Hz;
 800965c:	683b      	ldr	r3, [r7, #0]
 800965e:	2205      	movs	r2, #5
 8009660:	701a      	strb	r2, [r3, #0]
        break;
 8009662:	e00f      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_75Hz:
        val->odr = LPS22DF_75Hz;
 8009664:	683b      	ldr	r3, [r7, #0]
 8009666:	2206      	movs	r2, #6
 8009668:	701a      	strb	r2, [r3, #0]
        break;
 800966a:	e00b      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_100Hz:
        val->odr = LPS22DF_100Hz;
 800966c:	683b      	ldr	r3, [r7, #0]
 800966e:	2207      	movs	r2, #7
 8009670:	701a      	strb	r2, [r3, #0]
        break;
 8009672:	e007      	b.n	8009684 <lps22df_mode_get+0xcc>
      case LPS22DF_200Hz:
        val->odr = LPS22DF_200Hz;
 8009674:	683b      	ldr	r3, [r7, #0]
 8009676:	2208      	movs	r2, #8
 8009678:	701a      	strb	r2, [r3, #0]
        break;
 800967a:	e003      	b.n	8009684 <lps22df_mode_get+0xcc>
      default:
        val->odr = LPS22DF_ONE_SHOT;
 800967c:	683b      	ldr	r3, [r7, #0]
 800967e:	2200      	movs	r2, #0
 8009680:	701a      	strb	r2, [r3, #0]
        break;
 8009682:	bf00      	nop
    }

    switch (ctrl_reg1.avg)
 8009684:	7c3b      	ldrb	r3, [r7, #16]
 8009686:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800968a:	b2db      	uxtb	r3, r3
 800968c:	2b07      	cmp	r3, #7
 800968e:	d833      	bhi.n	80096f8 <lps22df_mode_get+0x140>
 8009690:	a201      	add	r2, pc, #4	@ (adr r2, 8009698 <lps22df_mode_get+0xe0>)
 8009692:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009696:	bf00      	nop
 8009698:	080096b9 	.word	0x080096b9
 800969c:	080096c1 	.word	0x080096c1
 80096a0:	080096c9 	.word	0x080096c9
 80096a4:	080096d1 	.word	0x080096d1
 80096a8:	080096d9 	.word	0x080096d9
 80096ac:	080096e1 	.word	0x080096e1
 80096b0:	080096e9 	.word	0x080096e9
 80096b4:	080096f1 	.word	0x080096f1
    {
      case LPS22DF_4_AVG:
        val->avg = LPS22DF_4_AVG;
 80096b8:	683b      	ldr	r3, [r7, #0]
 80096ba:	2200      	movs	r2, #0
 80096bc:	705a      	strb	r2, [r3, #1]
        break;
 80096be:	e01f      	b.n	8009700 <lps22df_mode_get+0x148>
      case LPS22DF_8_AVG:
        val->avg = LPS22DF_8_AVG;
 80096c0:	683b      	ldr	r3, [r7, #0]
 80096c2:	2201      	movs	r2, #1
 80096c4:	705a      	strb	r2, [r3, #1]
        break;
 80096c6:	e01b      	b.n	8009700 <lps22df_mode_get+0x148>
      case LPS22DF_16_AVG:
        val->avg = LPS22DF_16_AVG;
 80096c8:	683b      	ldr	r3, [r7, #0]
 80096ca:	2202      	movs	r2, #2
 80096cc:	705a      	strb	r2, [r3, #1]
        break;
 80096ce:	e017      	b.n	8009700 <lps22df_mode_get+0x148>
      case LPS22DF_32_AVG:
        val->avg = LPS22DF_32_AVG;
 80096d0:	683b      	ldr	r3, [r7, #0]
 80096d2:	2203      	movs	r2, #3
 80096d4:	705a      	strb	r2, [r3, #1]
        break;
 80096d6:	e013      	b.n	8009700 <lps22df_mode_get+0x148>
      case LPS22DF_64_AVG:
        val->avg = LPS22DF_64_AVG;
 80096d8:	683b      	ldr	r3, [r7, #0]
 80096da:	2204      	movs	r2, #4
 80096dc:	705a      	strb	r2, [r3, #1]
        break;
 80096de:	e00f      	b.n	8009700 <lps22df_mode_get+0x148>
      case LPS22DF_128_AVG:
        val->avg = LPS22DF_128_AVG;
 80096e0:	683b      	ldr	r3, [r7, #0]
 80096e2:	2205      	movs	r2, #5
 80096e4:	705a      	strb	r2, [r3, #1]
        break;
 80096e6:	e00b      	b.n	8009700 <lps22df_mode_get+0x148>
      case LPS22DF_256_AVG:
        val->avg = LPS22DF_256_AVG;
 80096e8:	683b      	ldr	r3, [r7, #0]
 80096ea:	2206      	movs	r2, #6
 80096ec:	705a      	strb	r2, [r3, #1]
        break;
 80096ee:	e007      	b.n	8009700 <lps22df_mode_get+0x148>
      case LPS22DF_512_AVG:
        val->avg = LPS22DF_512_AVG;
 80096f0:	683b      	ldr	r3, [r7, #0]
 80096f2:	2207      	movs	r2, #7
 80096f4:	705a      	strb	r2, [r3, #1]
        break;
 80096f6:	e003      	b.n	8009700 <lps22df_mode_get+0x148>
      default:
        val->avg = LPS22DF_4_AVG;
 80096f8:	683b      	ldr	r3, [r7, #0]
 80096fa:	2200      	movs	r2, #0
 80096fc:	705a      	strb	r2, [r3, #1]
        break;
 80096fe:	bf00      	nop
    }

    switch ((ctrl_reg2.lfpf_cfg << 2) | ctrl_reg2.en_lpfp)
 8009700:	7b3b      	ldrb	r3, [r7, #12]
 8009702:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8009706:	b2db      	uxtb	r3, r3
 8009708:	009b      	lsls	r3, r3, #2
 800970a:	7b3a      	ldrb	r2, [r7, #12]
 800970c:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8009710:	b2d2      	uxtb	r2, r2
 8009712:	4313      	orrs	r3, r2
 8009714:	2b03      	cmp	r3, #3
 8009716:	d00e      	beq.n	8009736 <lps22df_mode_get+0x17e>
 8009718:	2b03      	cmp	r3, #3
 800971a:	dc10      	bgt.n	800973e <lps22df_mode_get+0x186>
 800971c:	2b00      	cmp	r3, #0
 800971e:	d002      	beq.n	8009726 <lps22df_mode_get+0x16e>
 8009720:	2b01      	cmp	r3, #1
 8009722:	d004      	beq.n	800972e <lps22df_mode_get+0x176>
 8009724:	e00b      	b.n	800973e <lps22df_mode_get+0x186>
    {
      case LPS22DF_LPF_DISABLE:
        val->lpf = LPS22DF_LPF_DISABLE;
 8009726:	683b      	ldr	r3, [r7, #0]
 8009728:	2200      	movs	r2, #0
 800972a:	709a      	strb	r2, [r3, #2]
        break;
 800972c:	e00b      	b.n	8009746 <lps22df_mode_get+0x18e>
      case LPS22DF_LPF_ODR_DIV_4:
        val->lpf = LPS22DF_LPF_ODR_DIV_4;
 800972e:	683b      	ldr	r3, [r7, #0]
 8009730:	2201      	movs	r2, #1
 8009732:	709a      	strb	r2, [r3, #2]
        break;
 8009734:	e007      	b.n	8009746 <lps22df_mode_get+0x18e>
      case LPS22DF_LPF_ODR_DIV_9:
        val->lpf = LPS22DF_LPF_ODR_DIV_9;
 8009736:	683b      	ldr	r3, [r7, #0]
 8009738:	2203      	movs	r2, #3
 800973a:	709a      	strb	r2, [r3, #2]
        break;
 800973c:	e003      	b.n	8009746 <lps22df_mode_get+0x18e>
      default:
        val->lpf = LPS22DF_LPF_DISABLE;
 800973e:	683b      	ldr	r3, [r7, #0]
 8009740:	2200      	movs	r2, #0
 8009742:	709a      	strb	r2, [r3, #2]
        break;
 8009744:	bf00      	nop
    }
  }
  return ret;
 8009746:	697b      	ldr	r3, [r7, #20]
}
 8009748:	4618      	mov	r0, r3
 800974a:	3718      	adds	r7, #24
 800974c:	46bd      	mov	sp, r7
 800974e:	bd80      	pop	{r7, pc}

08009750 <lps22df_data_get>:
  * @param  data  data retrieved from the sensor.(ptr)
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lps22df_data_get(stmdev_ctx_t *ctx, lps22df_data_t *data)
{
 8009750:	b580      	push	{r7, lr}
 8009752:	b086      	sub	sp, #24
 8009754:	af00      	add	r7, sp, #0
 8009756:	6078      	str	r0, [r7, #4]
 8009758:	6039      	str	r1, [r7, #0]
  uint8_t buff[5];
  int32_t ret;

  ret = lps22df_read_reg(ctx, LPS22DF_PRESS_OUT_XL, buff, 5);
 800975a:	f107 020c 	add.w	r2, r7, #12
 800975e:	2305      	movs	r3, #5
 8009760:	2128      	movs	r1, #40	@ 0x28
 8009762:	6878      	ldr	r0, [r7, #4]
 8009764:	f7ff fd62 	bl	800922c <lps22df_read_reg>
 8009768:	6178      	str	r0, [r7, #20]

  /* pressure conversion */
  data->pressure.raw = (int32_t)buff[2];
 800976a:	7bbb      	ldrb	r3, [r7, #14]
 800976c:	461a      	mov	r2, r3
 800976e:	683b      	ldr	r3, [r7, #0]
 8009770:	605a      	str	r2, [r3, #4]
  data->pressure.raw = (data->pressure.raw * 256) + (int32_t) buff[1];
 8009772:	683b      	ldr	r3, [r7, #0]
 8009774:	685b      	ldr	r3, [r3, #4]
 8009776:	021b      	lsls	r3, r3, #8
 8009778:	7b7a      	ldrb	r2, [r7, #13]
 800977a:	441a      	add	r2, r3
 800977c:	683b      	ldr	r3, [r7, #0]
 800977e:	605a      	str	r2, [r3, #4]
  data->pressure.raw = (data->pressure.raw * 256) + (int32_t) buff[0];
 8009780:	683b      	ldr	r3, [r7, #0]
 8009782:	685b      	ldr	r3, [r3, #4]
 8009784:	021b      	lsls	r3, r3, #8
 8009786:	7b3a      	ldrb	r2, [r7, #12]
 8009788:	441a      	add	r2, r3
 800978a:	683b      	ldr	r3, [r7, #0]
 800978c:	605a      	str	r2, [r3, #4]
  data->pressure.raw = data->pressure.raw * 256;
 800978e:	683b      	ldr	r3, [r7, #0]
 8009790:	685b      	ldr	r3, [r3, #4]
 8009792:	021a      	lsls	r2, r3, #8
 8009794:	683b      	ldr	r3, [r7, #0]
 8009796:	605a      	str	r2, [r3, #4]

  data->pressure.hpa = lps22df_from_lsb_to_hPa(data->pressure.raw);
 8009798:	683b      	ldr	r3, [r7, #0]
 800979a:	685b      	ldr	r3, [r3, #4]
 800979c:	4618      	mov	r0, r3
 800979e:	f7ff fd8b 	bl	80092b8 <lps22df_from_lsb_to_hPa>
 80097a2:	eef0 7a40 	vmov.f32	s15, s0
 80097a6:	683b      	ldr	r3, [r7, #0]
 80097a8:	edc3 7a00 	vstr	s15, [r3]


  /* temperature conversion */
  data->heat.raw = (int16_t)buff[4];
 80097ac:	7c3b      	ldrb	r3, [r7, #16]
 80097ae:	b21a      	sxth	r2, r3
 80097b0:	683b      	ldr	r3, [r7, #0]
 80097b2:	819a      	strh	r2, [r3, #12]
  data->heat.raw = (data->heat.raw * 256) + (int16_t) buff[3];
 80097b4:	683b      	ldr	r3, [r7, #0]
 80097b6:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80097ba:	b29b      	uxth	r3, r3
 80097bc:	021b      	lsls	r3, r3, #8
 80097be:	b29b      	uxth	r3, r3
 80097c0:	7bfa      	ldrb	r2, [r7, #15]
 80097c2:	4413      	add	r3, r2
 80097c4:	b29b      	uxth	r3, r3
 80097c6:	b21a      	sxth	r2, r3
 80097c8:	683b      	ldr	r3, [r7, #0]
 80097ca:	819a      	strh	r2, [r3, #12]
  data->heat.deg_c = lps22df_from_lsb_to_celsius(data->heat.raw);
 80097cc:	683b      	ldr	r3, [r7, #0]
 80097ce:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80097d2:	4618      	mov	r0, r3
 80097d4:	f7ff fd88 	bl	80092e8 <lps22df_from_lsb_to_celsius>
 80097d8:	eef0 7a40 	vmov.f32	s15, s0
 80097dc:	683b      	ldr	r3, [r7, #0]
 80097de:	edc3 7a02 	vstr	s15, [r3, #8]

  return ret;
 80097e2:	697b      	ldr	r3, [r7, #20]
}
 80097e4:	4618      	mov	r0, r3
 80097e6:	3718      	adds	r7, #24
 80097e8:	46bd      	mov	sp, r7
 80097ea:	bd80      	pop	{r7, pc}

080097ec <LSM6DSO16IS_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_RegisterBusIO(LSM6DSO16IS_Object_t *pObj, LSM6DSO16IS_IO_t *pIO)
{
 80097ec:	b580      	push	{r7, lr}
 80097ee:	b084      	sub	sp, #16
 80097f0:	af00      	add	r7, sp, #0
 80097f2:	6078      	str	r0, [r7, #4]
 80097f4:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 80097f6:	2300      	movs	r3, #0
 80097f8:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 80097fa:	687b      	ldr	r3, [r7, #4]
 80097fc:	2b00      	cmp	r3, #0
 80097fe:	d103      	bne.n	8009808 <LSM6DSO16IS_RegisterBusIO+0x1c>
  {
    ret = LSM6DSO16IS_ERROR;
 8009800:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009804:	60fb      	str	r3, [r7, #12]
 8009806:	e04d      	b.n	80098a4 <LSM6DSO16IS_RegisterBusIO+0xb8>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 8009808:	683b      	ldr	r3, [r7, #0]
 800980a:	681a      	ldr	r2, [r3, #0]
 800980c:	687b      	ldr	r3, [r7, #4]
 800980e:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 8009810:	683b      	ldr	r3, [r7, #0]
 8009812:	685a      	ldr	r2, [r3, #4]
 8009814:	687b      	ldr	r3, [r7, #4]
 8009816:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 8009818:	683b      	ldr	r3, [r7, #0]
 800981a:	689a      	ldr	r2, [r3, #8]
 800981c:	687b      	ldr	r3, [r7, #4]
 800981e:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 8009820:	683b      	ldr	r3, [r7, #0]
 8009822:	7b1a      	ldrb	r2, [r3, #12]
 8009824:	687b      	ldr	r3, [r7, #4]
 8009826:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 8009828:	683b      	ldr	r3, [r7, #0]
 800982a:	691a      	ldr	r2, [r3, #16]
 800982c:	687b      	ldr	r3, [r7, #4]
 800982e:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 8009830:	683b      	ldr	r3, [r7, #0]
 8009832:	695a      	ldr	r2, [r3, #20]
 8009834:	687b      	ldr	r3, [r7, #4]
 8009836:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 8009838:	683b      	ldr	r3, [r7, #0]
 800983a:	699a      	ldr	r2, [r3, #24]
 800983c:	687b      	ldr	r3, [r7, #4]
 800983e:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 8009840:	687b      	ldr	r3, [r7, #4]
 8009842:	4a1b      	ldr	r2, [pc, #108]	@ (80098b0 <LSM6DSO16IS_RegisterBusIO+0xc4>)
 8009844:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 8009846:	687b      	ldr	r3, [r7, #4]
 8009848:	4a1a      	ldr	r2, [pc, #104]	@ (80098b4 <LSM6DSO16IS_RegisterBusIO+0xc8>)
 800984a:	621a      	str	r2, [r3, #32]
    pObj->Ctx.handle    = pObj;
 800984c:	687b      	ldr	r3, [r7, #4]
 800984e:	687a      	ldr	r2, [r7, #4]
 8009850:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 8009852:	687b      	ldr	r3, [r7, #4]
 8009854:	681b      	ldr	r3, [r3, #0]
 8009856:	2b00      	cmp	r3, #0
 8009858:	d103      	bne.n	8009862 <LSM6DSO16IS_RegisterBusIO+0x76>
    {
      ret = LSM6DSO16IS_ERROR;
 800985a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800985e:	60fb      	str	r3, [r7, #12]
 8009860:	e020      	b.n	80098a4 <LSM6DSO16IS_RegisterBusIO+0xb8>
    }
    else if (pObj->IO.Init() != LSM6DSO16IS_OK)
 8009862:	687b      	ldr	r3, [r7, #4]
 8009864:	681b      	ldr	r3, [r3, #0]
 8009866:	4798      	blx	r3
 8009868:	4603      	mov	r3, r0
 800986a:	2b00      	cmp	r3, #0
 800986c:	d003      	beq.n	8009876 <LSM6DSO16IS_RegisterBusIO+0x8a>
    {
      ret = LSM6DSO16IS_ERROR;
 800986e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009872:	60fb      	str	r3, [r7, #12]
 8009874:	e016      	b.n	80098a4 <LSM6DSO16IS_RegisterBusIO+0xb8>
    }
    else
    {
      if (pObj->IO.BusType == LSM6DSO16IS_SPI_3WIRES_BUS) /* SPI 3-Wires */
 8009876:	687b      	ldr	r3, [r7, #4]
 8009878:	689b      	ldr	r3, [r3, #8]
 800987a:	2b02      	cmp	r3, #2
 800987c:	d112      	bne.n	80098a4 <LSM6DSO16IS_RegisterBusIO+0xb8>
      {
        /* Enable the SPI 3-Wires support only the first time */
        if (pObj->is_initialized == 0U)
 800987e:	687b      	ldr	r3, [r7, #4]
 8009880:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 8009884:	2b00      	cmp	r3, #0
 8009886:	d10d      	bne.n	80098a4 <LSM6DSO16IS_RegisterBusIO+0xb8>
        {
          /* Enable SPI 3-Wires on the component */
          uint8_t data = 0x0C;
 8009888:	230c      	movs	r3, #12
 800988a:	72fb      	strb	r3, [r7, #11]

          if (LSM6DSO16IS_Write_Reg(pObj, LSM6DSO16IS_CTRL3_C, data) != LSM6DSO16IS_OK)
 800988c:	7afb      	ldrb	r3, [r7, #11]
 800988e:	461a      	mov	r2, r3
 8009890:	2112      	movs	r1, #18
 8009892:	6878      	ldr	r0, [r7, #4]
 8009894:	f000 fdbe 	bl	800a414 <LSM6DSO16IS_Write_Reg>
 8009898:	4603      	mov	r3, r0
 800989a:	2b00      	cmp	r3, #0
 800989c:	d002      	beq.n	80098a4 <LSM6DSO16IS_RegisterBusIO+0xb8>
          {
            ret = LSM6DSO16IS_ERROR;
 800989e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80098a2:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

  return ret;
 80098a4:	68fb      	ldr	r3, [r7, #12]
}
 80098a6:	4618      	mov	r0, r3
 80098a8:	3710      	adds	r7, #16
 80098aa:	46bd      	mov	sp, r7
 80098ac:	bd80      	pop	{r7, pc}
 80098ae:	bf00      	nop
 80098b0:	0800a8dd 	.word	0x0800a8dd
 80098b4:	0800a913 	.word	0x0800a913

080098b8 <LSM6DSO16IS_Init>:
  * @brief  Initialize the LSM6DSO16IS sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_Init(LSM6DSO16IS_Object_t *pObj)
{
 80098b8:	b580      	push	{r7, lr}
 80098ba:	b084      	sub	sp, #16
 80098bc:	af00      	add	r7, sp, #0
 80098be:	6078      	str	r0, [r7, #4]
  int32_t ret = LSM6DSO16IS_OK;
 80098c0:	2300      	movs	r3, #0
 80098c2:	60fb      	str	r3, [r7, #12]

  /* Set main memory bank */
  if (LSM6DSO16IS_Set_Mem_Bank(pObj, (uint8_t)LSM6DSO16IS_MAIN_MEM_BANK) != LSM6DSO16IS_OK)
 80098c4:	2100      	movs	r1, #0
 80098c6:	6878      	ldr	r0, [r7, #4]
 80098c8:	f000 fdc1 	bl	800a44e <LSM6DSO16IS_Set_Mem_Bank>
 80098cc:	4603      	mov	r3, r0
 80098ce:	2b00      	cmp	r3, #0
 80098d0:	d002      	beq.n	80098d8 <LSM6DSO16IS_Init+0x20>
  {
    ret = LSM6DSO16IS_ERROR;
 80098d2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80098d6:	60fb      	str	r3, [r7, #12]
  }

  /* Enable register address automatically incremented during a multiple byte
  access with a serial interface. */
  if (lsm6dso16is_auto_increment_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSO16IS_OK)
 80098d8:	687b      	ldr	r3, [r7, #4]
 80098da:	3320      	adds	r3, #32
 80098dc:	2101      	movs	r1, #1
 80098de:	4618      	mov	r0, r3
 80098e0:	f001 fbd0 	bl	800b084 <lsm6dso16is_auto_increment_set>
 80098e4:	4603      	mov	r3, r0
 80098e6:	2b00      	cmp	r3, #0
 80098e8:	d002      	beq.n	80098f0 <LSM6DSO16IS_Init+0x38>
  {
    ret = LSM6DSO16IS_ERROR;
 80098ea:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80098ee:	60fb      	str	r3, [r7, #12]
  }

  /* Enable BDU */
  if (lsm6dso16is_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSO16IS_OK)
 80098f0:	687b      	ldr	r3, [r7, #4]
 80098f2:	3320      	adds	r3, #32
 80098f4:	2101      	movs	r1, #1
 80098f6:	4618      	mov	r0, r3
 80098f8:	f001 fbea 	bl	800b0d0 <lsm6dso16is_block_data_update_set>
 80098fc:	4603      	mov	r3, r0
 80098fe:	2b00      	cmp	r3, #0
 8009900:	d002      	beq.n	8009908 <LSM6DSO16IS_Init+0x50>
  {
    ret = LSM6DSO16IS_ERROR;
 8009902:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009906:	60fb      	str	r3, [r7, #12]
  }

  /* Select default output data rate. */
  pObj->acc_odr = LSM6DSO16IS_XL_ODR_AT_104Hz_HP;
 8009908:	687b      	ldr	r3, [r7, #4]
 800990a:	2204      	movs	r2, #4
 800990c:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33

  /* Output data rate selection - power down. */
  if (lsm6dso16is_xl_data_rate_set(&(pObj->Ctx), LSM6DSO16IS_XL_ODR_OFF) != LSM6DSO16IS_OK)
 8009910:	687b      	ldr	r3, [r7, #4]
 8009912:	3320      	adds	r3, #32
 8009914:	2100      	movs	r1, #0
 8009916:	4618      	mov	r0, r3
 8009918:	f001 f904 	bl	800ab24 <lsm6dso16is_xl_data_rate_set>
 800991c:	4603      	mov	r3, r0
 800991e:	2b00      	cmp	r3, #0
 8009920:	d002      	beq.n	8009928 <LSM6DSO16IS_Init+0x70>
  {
    ret = LSM6DSO16IS_ERROR;
 8009922:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009926:	60fb      	str	r3, [r7, #12]
  }

  /* Full scale selection. */
  if (lsm6dso16is_xl_full_scale_set(&(pObj->Ctx), LSM6DSO16IS_2g) != LSM6DSO16IS_OK)
 8009928:	687b      	ldr	r3, [r7, #4]
 800992a:	3320      	adds	r3, #32
 800992c:	2100      	movs	r1, #0
 800992e:	4618      	mov	r0, r3
 8009930:	f001 f89a 	bl	800aa68 <lsm6dso16is_xl_full_scale_set>
 8009934:	4603      	mov	r3, r0
 8009936:	2b00      	cmp	r3, #0
 8009938:	d002      	beq.n	8009940 <LSM6DSO16IS_Init+0x88>
  {
    ret = LSM6DSO16IS_ERROR;
 800993a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800993e:	60fb      	str	r3, [r7, #12]
  }

  /* Select default output data rate. */
  pObj->gyro_odr = LSM6DSO16IS_GY_ODR_AT_104Hz_HP;
 8009940:	687b      	ldr	r3, [r7, #4]
 8009942:	2204      	movs	r2, #4
 8009944:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  /* Output data rate selection - power down. */
  if (lsm6dso16is_gy_data_rate_set(&(pObj->Ctx), LSM6DSO16IS_GY_ODR_OFF) != LSM6DSO16IS_OK)
 8009948:	687b      	ldr	r3, [r7, #4]
 800994a:	3320      	adds	r3, #32
 800994c:	2100      	movs	r1, #0
 800994e:	4618      	mov	r0, r3
 8009950:	f001 fa9c 	bl	800ae8c <lsm6dso16is_gy_data_rate_set>
 8009954:	4603      	mov	r3, r0
 8009956:	2b00      	cmp	r3, #0
 8009958:	d002      	beq.n	8009960 <LSM6DSO16IS_Init+0xa8>
  {
    ret = LSM6DSO16IS_ERROR;
 800995a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800995e:	60fb      	str	r3, [r7, #12]
  }

  /* Full scale selection. */
  if (lsm6dso16is_gy_full_scale_set(&(pObj->Ctx), LSM6DSO16IS_2000dps) != LSM6DSO16IS_OK)
 8009960:	687b      	ldr	r3, [r7, #4]
 8009962:	3320      	adds	r3, #32
 8009964:	2103      	movs	r1, #3
 8009966:	4618      	mov	r0, r3
 8009968:	f001 fa04 	bl	800ad74 <lsm6dso16is_gy_full_scale_set>
 800996c:	4603      	mov	r3, r0
 800996e:	2b00      	cmp	r3, #0
 8009970:	d002      	beq.n	8009978 <LSM6DSO16IS_Init+0xc0>
  {
    ret = LSM6DSO16IS_ERROR;
 8009972:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009976:	60fb      	str	r3, [r7, #12]
  }

  if (ret == LSM6DSO16IS_OK)
 8009978:	68fb      	ldr	r3, [r7, #12]
 800997a:	2b00      	cmp	r3, #0
 800997c:	d103      	bne.n	8009986 <LSM6DSO16IS_Init+0xce>
  {
    pObj->is_initialized = 1;
 800997e:	687b      	ldr	r3, [r7, #4]
 8009980:	2201      	movs	r2, #1
 8009982:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
  }

  return ret;
 8009986:	68fb      	ldr	r3, [r7, #12]
}
 8009988:	4618      	mov	r0, r3
 800998a:	3710      	adds	r7, #16
 800998c:	46bd      	mov	sp, r7
 800998e:	bd80      	pop	{r7, pc}

08009990 <LSM6DSO16IS_DeInit>:
  * @brief  Deinitialize the LSM6DSO16IS sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_DeInit(LSM6DSO16IS_Object_t *pObj)
{
 8009990:	b580      	push	{r7, lr}
 8009992:	b084      	sub	sp, #16
 8009994:	af00      	add	r7, sp, #0
 8009996:	6078      	str	r0, [r7, #4]
  int32_t ret = LSM6DSO16IS_OK;
 8009998:	2300      	movs	r3, #0
 800999a:	60fb      	str	r3, [r7, #12]

  /* Disable the component */
  if (LSM6DSO16IS_ACC_Disable(pObj) != LSM6DSO16IS_OK)
 800999c:	6878      	ldr	r0, [r7, #4]
 800999e:	f000 f890 	bl	8009ac2 <LSM6DSO16IS_ACC_Disable>
 80099a2:	4603      	mov	r3, r0
 80099a4:	2b00      	cmp	r3, #0
 80099a6:	d002      	beq.n	80099ae <LSM6DSO16IS_DeInit+0x1e>
  {
    ret = LSM6DSO16IS_ERROR;
 80099a8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80099ac:	60fb      	str	r3, [r7, #12]
  }

  if (LSM6DSO16IS_GYRO_Disable(pObj) != LSM6DSO16IS_OK)
 80099ae:	6878      	ldr	r0, [r7, #4]
 80099b0:	f000 fad0 	bl	8009f54 <LSM6DSO16IS_GYRO_Disable>
 80099b4:	4603      	mov	r3, r0
 80099b6:	2b00      	cmp	r3, #0
 80099b8:	d002      	beq.n	80099c0 <LSM6DSO16IS_DeInit+0x30>
  {
    ret = LSM6DSO16IS_ERROR;
 80099ba:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80099be:	60fb      	str	r3, [r7, #12]
  }

  if (ret == LSM6DSO16IS_OK)
 80099c0:	68fb      	ldr	r3, [r7, #12]
 80099c2:	2b00      	cmp	r3, #0
 80099c4:	d10b      	bne.n	80099de <LSM6DSO16IS_DeInit+0x4e>
  {
    /* Reset output data rate. */
    pObj->acc_odr = LSM6DSO16IS_XL_ODR_OFF;
 80099c6:	687b      	ldr	r3, [r7, #4]
 80099c8:	2200      	movs	r2, #0
 80099ca:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33
    pObj->gyro_odr = LSM6DSO16IS_GY_ODR_OFF;
 80099ce:	687b      	ldr	r3, [r7, #4]
 80099d0:	2200      	movs	r2, #0
 80099d2:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    pObj->is_initialized = 0;
 80099d6:	687b      	ldr	r3, [r7, #4]
 80099d8:	2200      	movs	r2, #0
 80099da:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30
  }

  return ret;
 80099de:	68fb      	ldr	r3, [r7, #12]
}
 80099e0:	4618      	mov	r0, r3
 80099e2:	3710      	adds	r7, #16
 80099e4:	46bd      	mov	sp, r7
 80099e6:	bd80      	pop	{r7, pc}

080099e8 <LSM6DSO16IS_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ReadID(LSM6DSO16IS_Object_t *pObj, uint8_t *Id)
{
 80099e8:	b580      	push	{r7, lr}
 80099ea:	b084      	sub	sp, #16
 80099ec:	af00      	add	r7, sp, #0
 80099ee:	6078      	str	r0, [r7, #4]
 80099f0:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 80099f2:	2300      	movs	r3, #0
 80099f4:	60fb      	str	r3, [r7, #12]

  if (lsm6dso16is_device_id_get(&(pObj->Ctx), Id) != LSM6DSO16IS_OK)
 80099f6:	687b      	ldr	r3, [r7, #4]
 80099f8:	3320      	adds	r3, #32
 80099fa:	6839      	ldr	r1, [r7, #0]
 80099fc:	4618      	mov	r0, r3
 80099fe:	f000 fffc 	bl	800a9fa <lsm6dso16is_device_id_get>
 8009a02:	4603      	mov	r3, r0
 8009a04:	2b00      	cmp	r3, #0
 8009a06:	d002      	beq.n	8009a0e <LSM6DSO16IS_ReadID+0x26>
  {
    ret = LSM6DSO16IS_ERROR;
 8009a08:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009a0c:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 8009a0e:	68fb      	ldr	r3, [r7, #12]
}
 8009a10:	4618      	mov	r0, r3
 8009a12:	3710      	adds	r7, #16
 8009a14:	46bd      	mov	sp, r7
 8009a16:	bd80      	pop	{r7, pc}

08009a18 <LSM6DSO16IS_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LSM6DSO16IS sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GetCapabilities(LSM6DSO16IS_Object_t *pObj, LSM6DSO16IS_Capabilities_t *Capabilities)
{
 8009a18:	b480      	push	{r7}
 8009a1a:	b083      	sub	sp, #12
 8009a1c:	af00      	add	r7, sp, #0
 8009a1e:	6078      	str	r0, [r7, #4]
 8009a20:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc          = 1;
 8009a22:	683b      	ldr	r3, [r7, #0]
 8009a24:	2201      	movs	r2, #1
 8009a26:	701a      	strb	r2, [r3, #0]
  Capabilities->Gyro         = 1;
 8009a28:	683b      	ldr	r3, [r7, #0]
 8009a2a:	2201      	movs	r2, #1
 8009a2c:	705a      	strb	r2, [r3, #1]
  Capabilities->Magneto      = 0;
 8009a2e:	683b      	ldr	r3, [r7, #0]
 8009a30:	2200      	movs	r2, #0
 8009a32:	709a      	strb	r2, [r3, #2]
  Capabilities->LowPower     = 0;
 8009a34:	683b      	ldr	r3, [r7, #0]
 8009a36:	2200      	movs	r2, #0
 8009a38:	70da      	strb	r2, [r3, #3]
  Capabilities->GyroMaxFS    = 2000;
 8009a3a:	683b      	ldr	r3, [r7, #0]
 8009a3c:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 8009a40:	605a      	str	r2, [r3, #4]
  Capabilities->AccMaxFS     = 16;
 8009a42:	683b      	ldr	r3, [r7, #0]
 8009a44:	2210      	movs	r2, #16
 8009a46:	609a      	str	r2, [r3, #8]
  Capabilities->MagMaxFS     = 0;
 8009a48:	683b      	ldr	r3, [r7, #0]
 8009a4a:	2200      	movs	r2, #0
 8009a4c:	60da      	str	r2, [r3, #12]
  Capabilities->GyroMaxOdr   = 3333.0f;
 8009a4e:	683b      	ldr	r3, [r7, #0]
 8009a50:	4a07      	ldr	r2, [pc, #28]	@ (8009a70 <LSM6DSO16IS_GetCapabilities+0x58>)
 8009a52:	611a      	str	r2, [r3, #16]
  Capabilities->AccMaxOdr    = 3333.0f;
 8009a54:	683b      	ldr	r3, [r7, #0]
 8009a56:	4a06      	ldr	r2, [pc, #24]	@ (8009a70 <LSM6DSO16IS_GetCapabilities+0x58>)
 8009a58:	615a      	str	r2, [r3, #20]
  Capabilities->MagMaxOdr    = 0.0f;
 8009a5a:	683b      	ldr	r3, [r7, #0]
 8009a5c:	f04f 0200 	mov.w	r2, #0
 8009a60:	619a      	str	r2, [r3, #24]

  return LSM6DSO16IS_OK;
 8009a62:	2300      	movs	r3, #0
}
 8009a64:	4618      	mov	r0, r3
 8009a66:	370c      	adds	r7, #12
 8009a68:	46bd      	mov	sp, r7
 8009a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a6e:	4770      	bx	lr
 8009a70:	45505000 	.word	0x45505000

08009a74 <LSM6DSO16IS_ACC_Enable>:
  * @brief  Enable the LSM6DSO16IS accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_Enable(LSM6DSO16IS_Object_t *pObj)
{
 8009a74:	b580      	push	{r7, lr}
 8009a76:	b084      	sub	sp, #16
 8009a78:	af00      	add	r7, sp, #0
 8009a7a:	6078      	str	r0, [r7, #4]
  int32_t ret = LSM6DSO16IS_OK;
 8009a7c:	2300      	movs	r3, #0
 8009a7e:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already enabled */
  if (pObj->acc_is_enabled == 1U)
 8009a80:	687b      	ldr	r3, [r7, #4]
 8009a82:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8009a86:	2b01      	cmp	r3, #1
 8009a88:	d102      	bne.n	8009a90 <LSM6DSO16IS_ACC_Enable+0x1c>
  {
    ret = LSM6DSO16IS_OK;
 8009a8a:	2300      	movs	r3, #0
 8009a8c:	60fb      	str	r3, [r7, #12]
 8009a8e:	e013      	b.n	8009ab8 <LSM6DSO16IS_ACC_Enable+0x44>
  }
  else
  {
    /* Output data rate selection. */
    if (lsm6dso16is_xl_data_rate_set(&(pObj->Ctx), pObj->acc_odr) != LSM6DSO16IS_OK)
 8009a90:	687b      	ldr	r3, [r7, #4]
 8009a92:	f103 0220 	add.w	r2, r3, #32
 8009a96:	687b      	ldr	r3, [r7, #4]
 8009a98:	f893 3033 	ldrb.w	r3, [r3, #51]	@ 0x33
 8009a9c:	4619      	mov	r1, r3
 8009a9e:	4610      	mov	r0, r2
 8009aa0:	f001 f840 	bl	800ab24 <lsm6dso16is_xl_data_rate_set>
 8009aa4:	4603      	mov	r3, r0
 8009aa6:	2b00      	cmp	r3, #0
 8009aa8:	d002      	beq.n	8009ab0 <LSM6DSO16IS_ACC_Enable+0x3c>
    {
      ret = LSM6DSO16IS_ERROR;
 8009aaa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009aae:	60fb      	str	r3, [r7, #12]
    }

    pObj->acc_is_enabled = 1;
 8009ab0:	687b      	ldr	r3, [r7, #4]
 8009ab2:	2201      	movs	r2, #1
 8009ab4:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
  }

  return ret;
 8009ab8:	68fb      	ldr	r3, [r7, #12]
}
 8009aba:	4618      	mov	r0, r3
 8009abc:	3710      	adds	r7, #16
 8009abe:	46bd      	mov	sp, r7
 8009ac0:	bd80      	pop	{r7, pc}

08009ac2 <LSM6DSO16IS_ACC_Disable>:
  * @brief  Disable the LSM6DSO16IS accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_Disable(LSM6DSO16IS_Object_t *pObj)
{
 8009ac2:	b580      	push	{r7, lr}
 8009ac4:	b084      	sub	sp, #16
 8009ac6:	af00      	add	r7, sp, #0
 8009ac8:	6078      	str	r0, [r7, #4]
  int32_t ret = LSM6DSO16IS_OK;
 8009aca:	2300      	movs	r3, #0
 8009acc:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already disabled */
  if (pObj->acc_is_enabled == 0U)
 8009ace:	687b      	ldr	r3, [r7, #4]
 8009ad0:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8009ad4:	2b00      	cmp	r3, #0
 8009ad6:	d102      	bne.n	8009ade <LSM6DSO16IS_ACC_Disable+0x1c>
  {
    ret = LSM6DSO16IS_OK;
 8009ad8:	2300      	movs	r3, #0
 8009ada:	60fb      	str	r3, [r7, #12]
 8009adc:	e01e      	b.n	8009b1c <LSM6DSO16IS_ACC_Disable+0x5a>
  }
  else
  {
    /* Get current output data rate. */
    if (lsm6dso16is_xl_data_rate_get(&(pObj->Ctx), &pObj->acc_odr) != LSM6DSO16IS_OK)
 8009ade:	687b      	ldr	r3, [r7, #4]
 8009ae0:	f103 0220 	add.w	r2, r3, #32
 8009ae4:	687b      	ldr	r3, [r7, #4]
 8009ae6:	3333      	adds	r3, #51	@ 0x33
 8009ae8:	4619      	mov	r1, r3
 8009aea:	4610      	mov	r0, r2
 8009aec:	f001 f85a 	bl	800aba4 <lsm6dso16is_xl_data_rate_get>
 8009af0:	4603      	mov	r3, r0
 8009af2:	2b00      	cmp	r3, #0
 8009af4:	d002      	beq.n	8009afc <LSM6DSO16IS_ACC_Disable+0x3a>
    {
      ret = LSM6DSO16IS_ERROR;
 8009af6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009afa:	60fb      	str	r3, [r7, #12]
    }

    /* Output data rate selection - power down. */
    if (lsm6dso16is_xl_data_rate_set(&(pObj->Ctx), LSM6DSO16IS_XL_ODR_OFF) != LSM6DSO16IS_OK)
 8009afc:	687b      	ldr	r3, [r7, #4]
 8009afe:	3320      	adds	r3, #32
 8009b00:	2100      	movs	r1, #0
 8009b02:	4618      	mov	r0, r3
 8009b04:	f001 f80e 	bl	800ab24 <lsm6dso16is_xl_data_rate_set>
 8009b08:	4603      	mov	r3, r0
 8009b0a:	2b00      	cmp	r3, #0
 8009b0c:	d002      	beq.n	8009b14 <LSM6DSO16IS_ACC_Disable+0x52>
    {
      ret = LSM6DSO16IS_ERROR;
 8009b0e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009b12:	60fb      	str	r3, [r7, #12]
    }

    pObj->acc_is_enabled = 0;
 8009b14:	687b      	ldr	r3, [r7, #4]
 8009b16:	2200      	movs	r2, #0
 8009b18:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31
  }

  return ret;
 8009b1c:	68fb      	ldr	r3, [r7, #12]
}
 8009b1e:	4618      	mov	r0, r3
 8009b20:	3710      	adds	r7, #16
 8009b22:	46bd      	mov	sp, r7
 8009b24:	bd80      	pop	{r7, pc}
	...

08009b28 <LSM6DSO16IS_ACC_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_GetSensitivity(LSM6DSO16IS_Object_t *pObj, float_t *Sensitivity)
{
 8009b28:	b580      	push	{r7, lr}
 8009b2a:	b084      	sub	sp, #16
 8009b2c:	af00      	add	r7, sp, #0
 8009b2e:	6078      	str	r0, [r7, #4]
 8009b30:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 8009b32:	2300      	movs	r3, #0
 8009b34:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_xl_full_scale_t full_scale;

  /* Read actual full scale selection from sensor. */
  if (lsm6dso16is_xl_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSO16IS_OK)
 8009b36:	687b      	ldr	r3, [r7, #4]
 8009b38:	3320      	adds	r3, #32
 8009b3a:	f107 020b 	add.w	r2, r7, #11
 8009b3e:	4611      	mov	r1, r2
 8009b40:	4618      	mov	r0, r3
 8009b42:	f000 ffb7 	bl	800aab4 <lsm6dso16is_xl_full_scale_get>
 8009b46:	4603      	mov	r3, r0
 8009b48:	2b00      	cmp	r3, #0
 8009b4a:	d002      	beq.n	8009b52 <LSM6DSO16IS_ACC_GetSensitivity+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 8009b4c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009b50:	60fb      	str	r3, [r7, #12]
  }

  /* Store the Sensitivity based on actual full scale. */
  switch (full_scale)
 8009b52:	7afb      	ldrb	r3, [r7, #11]
 8009b54:	2b03      	cmp	r3, #3
 8009b56:	d81b      	bhi.n	8009b90 <LSM6DSO16IS_ACC_GetSensitivity+0x68>
 8009b58:	a201      	add	r2, pc, #4	@ (adr r2, 8009b60 <LSM6DSO16IS_ACC_GetSensitivity+0x38>)
 8009b5a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009b5e:	bf00      	nop
 8009b60:	08009b71 	.word	0x08009b71
 8009b64:	08009b89 	.word	0x08009b89
 8009b68:	08009b79 	.word	0x08009b79
 8009b6c:	08009b81 	.word	0x08009b81
  {
    case LSM6DSO16IS_2g:
      *Sensitivity = LSM6DSO16IS_ACC_SENSITIVITY_FS_2G;
 8009b70:	683b      	ldr	r3, [r7, #0]
 8009b72:	4a0c      	ldr	r2, [pc, #48]	@ (8009ba4 <LSM6DSO16IS_ACC_GetSensitivity+0x7c>)
 8009b74:	601a      	str	r2, [r3, #0]
      break;
 8009b76:	e00f      	b.n	8009b98 <LSM6DSO16IS_ACC_GetSensitivity+0x70>

    case LSM6DSO16IS_4g:
      *Sensitivity = LSM6DSO16IS_ACC_SENSITIVITY_FS_4G;
 8009b78:	683b      	ldr	r3, [r7, #0]
 8009b7a:	4a0b      	ldr	r2, [pc, #44]	@ (8009ba8 <LSM6DSO16IS_ACC_GetSensitivity+0x80>)
 8009b7c:	601a      	str	r2, [r3, #0]
      break;
 8009b7e:	e00b      	b.n	8009b98 <LSM6DSO16IS_ACC_GetSensitivity+0x70>

    case LSM6DSO16IS_8g:
      *Sensitivity = LSM6DSO16IS_ACC_SENSITIVITY_FS_8G;
 8009b80:	683b      	ldr	r3, [r7, #0]
 8009b82:	4a0a      	ldr	r2, [pc, #40]	@ (8009bac <LSM6DSO16IS_ACC_GetSensitivity+0x84>)
 8009b84:	601a      	str	r2, [r3, #0]
      break;
 8009b86:	e007      	b.n	8009b98 <LSM6DSO16IS_ACC_GetSensitivity+0x70>

    case LSM6DSO16IS_16g:
      *Sensitivity = LSM6DSO16IS_ACC_SENSITIVITY_FS_16G;
 8009b88:	683b      	ldr	r3, [r7, #0]
 8009b8a:	4a09      	ldr	r2, [pc, #36]	@ (8009bb0 <LSM6DSO16IS_ACC_GetSensitivity+0x88>)
 8009b8c:	601a      	str	r2, [r3, #0]
      break;
 8009b8e:	e003      	b.n	8009b98 <LSM6DSO16IS_ACC_GetSensitivity+0x70>

    default:
      ret = LSM6DSO16IS_ERROR;
 8009b90:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009b94:	60fb      	str	r3, [r7, #12]
      break;
 8009b96:	bf00      	nop
  }

  return ret;
 8009b98:	68fb      	ldr	r3, [r7, #12]
}
 8009b9a:	4618      	mov	r0, r3
 8009b9c:	3710      	adds	r7, #16
 8009b9e:	46bd      	mov	sp, r7
 8009ba0:	bd80      	pop	{r7, pc}
 8009ba2:	bf00      	nop
 8009ba4:	3d79db23 	.word	0x3d79db23
 8009ba8:	3df9db23 	.word	0x3df9db23
 8009bac:	3e79db23 	.word	0x3e79db23
 8009bb0:	3ef9db23 	.word	0x3ef9db23

08009bb4 <LSM6DSO16IS_ACC_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_GetOutputDataRate(LSM6DSO16IS_Object_t *pObj, float_t *Odr)
{
 8009bb4:	b580      	push	{r7, lr}
 8009bb6:	b084      	sub	sp, #16
 8009bb8:	af00      	add	r7, sp, #0
 8009bba:	6078      	str	r0, [r7, #4]
 8009bbc:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 8009bbe:	2300      	movs	r3, #0
 8009bc0:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_xl_data_rate_t odr_low_level;

  /* Get current output data rate. */
  if (lsm6dso16is_xl_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSO16IS_OK)
 8009bc2:	687b      	ldr	r3, [r7, #4]
 8009bc4:	3320      	adds	r3, #32
 8009bc6:	f107 020b 	add.w	r2, r7, #11
 8009bca:	4611      	mov	r1, r2
 8009bcc:	4618      	mov	r0, r3
 8009bce:	f000 ffe9 	bl	800aba4 <lsm6dso16is_xl_data_rate_get>
 8009bd2:	4603      	mov	r3, r0
 8009bd4:	2b00      	cmp	r3, #0
 8009bd6:	d002      	beq.n	8009bde <LSM6DSO16IS_ACC_GetOutputDataRate+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 8009bd8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009bdc:	60fb      	str	r3, [r7, #12]
  }

  switch (odr_low_level)
 8009bde:	7afb      	ldrb	r3, [r7, #11]
 8009be0:	2b1b      	cmp	r3, #27
 8009be2:	d86c      	bhi.n	8009cbe <LSM6DSO16IS_ACC_GetOutputDataRate+0x10a>
 8009be4:	a201      	add	r2, pc, #4	@ (adr r2, 8009bec <LSM6DSO16IS_ACC_GetOutputDataRate+0x38>)
 8009be6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009bea:	bf00      	nop
 8009bec:	08009c5d 	.word	0x08009c5d
 8009bf0:	08009c6f 	.word	0x08009c6f
 8009bf4:	08009c77 	.word	0x08009c77
 8009bf8:	08009c7f 	.word	0x08009c7f
 8009bfc:	08009c87 	.word	0x08009c87
 8009c00:	08009c8f 	.word	0x08009c8f
 8009c04:	08009c97 	.word	0x08009c97
 8009c08:	08009c9f 	.word	0x08009c9f
 8009c0c:	08009ca7 	.word	0x08009ca7
 8009c10:	08009caf 	.word	0x08009caf
 8009c14:	08009cb7 	.word	0x08009cb7
 8009c18:	08009cbf 	.word	0x08009cbf
 8009c1c:	08009cbf 	.word	0x08009cbf
 8009c20:	08009cbf 	.word	0x08009cbf
 8009c24:	08009cbf 	.word	0x08009cbf
 8009c28:	08009cbf 	.word	0x08009cbf
 8009c2c:	08009cbf 	.word	0x08009cbf
 8009c30:	08009c6f 	.word	0x08009c6f
 8009c34:	08009c77 	.word	0x08009c77
 8009c38:	08009c7f 	.word	0x08009c7f
 8009c3c:	08009c87 	.word	0x08009c87
 8009c40:	08009c8f 	.word	0x08009c8f
 8009c44:	08009c97 	.word	0x08009c97
 8009c48:	08009c9f 	.word	0x08009c9f
 8009c4c:	08009ca7 	.word	0x08009ca7
 8009c50:	08009caf 	.word	0x08009caf
 8009c54:	08009cb7 	.word	0x08009cb7
 8009c58:	08009c67 	.word	0x08009c67
  {
    case LSM6DSO16IS_XL_ODR_OFF:
      *Odr = 0.0f;
 8009c5c:	683b      	ldr	r3, [r7, #0]
 8009c5e:	f04f 0200 	mov.w	r2, #0
 8009c62:	601a      	str	r2, [r3, #0]
      break;
 8009c64:	e02f      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_1Hz6_LP:
      *Odr = 1.6f;
 8009c66:	683b      	ldr	r3, [r7, #0]
 8009c68:	4a19      	ldr	r2, [pc, #100]	@ (8009cd0 <LSM6DSO16IS_ACC_GetOutputDataRate+0x11c>)
 8009c6a:	601a      	str	r2, [r3, #0]
      break;
 8009c6c:	e02b      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_12Hz5_LP:
    case LSM6DSO16IS_XL_ODR_AT_12Hz5_HP:
      *Odr = 12.5f;
 8009c6e:	683b      	ldr	r3, [r7, #0]
 8009c70:	4a18      	ldr	r2, [pc, #96]	@ (8009cd4 <LSM6DSO16IS_ACC_GetOutputDataRate+0x120>)
 8009c72:	601a      	str	r2, [r3, #0]
      break;
 8009c74:	e027      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_26H_LP:
    case LSM6DSO16IS_XL_ODR_AT_26H_HP:
      *Odr = 26.0f;
 8009c76:	683b      	ldr	r3, [r7, #0]
 8009c78:	4a17      	ldr	r2, [pc, #92]	@ (8009cd8 <LSM6DSO16IS_ACC_GetOutputDataRate+0x124>)
 8009c7a:	601a      	str	r2, [r3, #0]
      break;
 8009c7c:	e023      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_52Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_52Hz_HP:
      *Odr = 52.0f;
 8009c7e:	683b      	ldr	r3, [r7, #0]
 8009c80:	4a16      	ldr	r2, [pc, #88]	@ (8009cdc <LSM6DSO16IS_ACC_GetOutputDataRate+0x128>)
 8009c82:	601a      	str	r2, [r3, #0]
      break;
 8009c84:	e01f      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_104Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_104Hz_HP:
      *Odr = 104.0f;
 8009c86:	683b      	ldr	r3, [r7, #0]
 8009c88:	4a15      	ldr	r2, [pc, #84]	@ (8009ce0 <LSM6DSO16IS_ACC_GetOutputDataRate+0x12c>)
 8009c8a:	601a      	str	r2, [r3, #0]
      break;
 8009c8c:	e01b      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_208Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_208Hz_HP:
      *Odr = 208.0f;
 8009c8e:	683b      	ldr	r3, [r7, #0]
 8009c90:	4a14      	ldr	r2, [pc, #80]	@ (8009ce4 <LSM6DSO16IS_ACC_GetOutputDataRate+0x130>)
 8009c92:	601a      	str	r2, [r3, #0]
      break;
 8009c94:	e017      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_416Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_416Hz_HP:
      *Odr = 416.0f;
 8009c96:	683b      	ldr	r3, [r7, #0]
 8009c98:	4a13      	ldr	r2, [pc, #76]	@ (8009ce8 <LSM6DSO16IS_ACC_GetOutputDataRate+0x134>)
 8009c9a:	601a      	str	r2, [r3, #0]
      break;
 8009c9c:	e013      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_833Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_833Hz_HP:
      *Odr = 833.0f;
 8009c9e:	683b      	ldr	r3, [r7, #0]
 8009ca0:	4a12      	ldr	r2, [pc, #72]	@ (8009cec <LSM6DSO16IS_ACC_GetOutputDataRate+0x138>)
 8009ca2:	601a      	str	r2, [r3, #0]
      break;
 8009ca4:	e00f      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_1667Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_1667Hz_HP:
      *Odr = 1667.0f;
 8009ca6:	683b      	ldr	r3, [r7, #0]
 8009ca8:	4a11      	ldr	r2, [pc, #68]	@ (8009cf0 <LSM6DSO16IS_ACC_GetOutputDataRate+0x13c>)
 8009caa:	601a      	str	r2, [r3, #0]
      break;
 8009cac:	e00b      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_3333Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_3333Hz_HP:
      *Odr = 3333.0f;
 8009cae:	683b      	ldr	r3, [r7, #0]
 8009cb0:	4a10      	ldr	r2, [pc, #64]	@ (8009cf4 <LSM6DSO16IS_ACC_GetOutputDataRate+0x140>)
 8009cb2:	601a      	str	r2, [r3, #0]
      break;
 8009cb4:	e007      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    case LSM6DSO16IS_XL_ODR_AT_6667Hz_LP:
    case LSM6DSO16IS_XL_ODR_AT_6667Hz_HP:
      *Odr = 6667.0f;
 8009cb6:	683b      	ldr	r3, [r7, #0]
 8009cb8:	4a0f      	ldr	r2, [pc, #60]	@ (8009cf8 <LSM6DSO16IS_ACC_GetOutputDataRate+0x144>)
 8009cba:	601a      	str	r2, [r3, #0]
      break;
 8009cbc:	e003      	b.n	8009cc6 <LSM6DSO16IS_ACC_GetOutputDataRate+0x112>

    default:
      ret = LSM6DSO16IS_ERROR;
 8009cbe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009cc2:	60fb      	str	r3, [r7, #12]
      break;
 8009cc4:	bf00      	nop
  }

  return ret;
 8009cc6:	68fb      	ldr	r3, [r7, #12]
}
 8009cc8:	4618      	mov	r0, r3
 8009cca:	3710      	adds	r7, #16
 8009ccc:	46bd      	mov	sp, r7
 8009cce:	bd80      	pop	{r7, pc}
 8009cd0:	3fcccccd 	.word	0x3fcccccd
 8009cd4:	41480000 	.word	0x41480000
 8009cd8:	41d00000 	.word	0x41d00000
 8009cdc:	42500000 	.word	0x42500000
 8009ce0:	42d00000 	.word	0x42d00000
 8009ce4:	43500000 	.word	0x43500000
 8009ce8:	43d00000 	.word	0x43d00000
 8009cec:	44504000 	.word	0x44504000
 8009cf0:	44d06000 	.word	0x44d06000
 8009cf4:	45505000 	.word	0x45505000
 8009cf8:	45d05800 	.word	0x45d05800

08009cfc <LSM6DSO16IS_ACC_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_SetOutputDataRate(LSM6DSO16IS_Object_t *pObj, float_t Odr)
{
 8009cfc:	b580      	push	{r7, lr}
 8009cfe:	b084      	sub	sp, #16
 8009d00:	af00      	add	r7, sp, #0
 8009d02:	6078      	str	r0, [r7, #4]
 8009d04:	ed87 0a00 	vstr	s0, [r7]
  int32_t ret;

  /* Check if the component is enabled */
  if (pObj->acc_is_enabled == 1U)
 8009d08:	687b      	ldr	r3, [r7, #4]
 8009d0a:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 8009d0e:	2b01      	cmp	r3, #1
 8009d10:	d106      	bne.n	8009d20 <LSM6DSO16IS_ACC_SetOutputDataRate+0x24>
  {
    ret = LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled(pObj, Odr);
 8009d12:	ed97 0a00 	vldr	s0, [r7]
 8009d16:	6878      	ldr	r0, [r7, #4]
 8009d18:	f000 fbc0 	bl	800a49c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled>
 8009d1c:	60f8      	str	r0, [r7, #12]
 8009d1e:	e005      	b.n	8009d2c <LSM6DSO16IS_ACC_SetOutputDataRate+0x30>
  }
  else
  {
    ret = LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled(pObj, Odr);
 8009d20:	ed97 0a00 	vldr	s0, [r7]
 8009d24:	6878      	ldr	r0, [r7, #4]
 8009d26:	f000 fc47 	bl	800a5b8 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled>
 8009d2a:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 8009d2c:	68fb      	ldr	r3, [r7, #12]
}
 8009d2e:	4618      	mov	r0, r3
 8009d30:	3710      	adds	r7, #16
 8009d32:	46bd      	mov	sp, r7
 8009d34:	bd80      	pop	{r7, pc}
	...

08009d38 <LSM6DSO16IS_ACC_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_GetFullScale(LSM6DSO16IS_Object_t *pObj, int32_t *FullScale)
{
 8009d38:	b580      	push	{r7, lr}
 8009d3a:	b084      	sub	sp, #16
 8009d3c:	af00      	add	r7, sp, #0
 8009d3e:	6078      	str	r0, [r7, #4]
 8009d40:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 8009d42:	2300      	movs	r3, #0
 8009d44:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_xl_full_scale_t fs_low_level;

  /* Read actual full scale selection from sensor. */
  if (lsm6dso16is_xl_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSO16IS_OK)
 8009d46:	687b      	ldr	r3, [r7, #4]
 8009d48:	3320      	adds	r3, #32
 8009d4a:	f107 020b 	add.w	r2, r7, #11
 8009d4e:	4611      	mov	r1, r2
 8009d50:	4618      	mov	r0, r3
 8009d52:	f000 feaf 	bl	800aab4 <lsm6dso16is_xl_full_scale_get>
 8009d56:	4603      	mov	r3, r0
 8009d58:	2b00      	cmp	r3, #0
 8009d5a:	d002      	beq.n	8009d62 <LSM6DSO16IS_ACC_GetFullScale+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 8009d5c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009d60:	60fb      	str	r3, [r7, #12]
  }

  switch (fs_low_level)
 8009d62:	7afb      	ldrb	r3, [r7, #11]
 8009d64:	2b03      	cmp	r3, #3
 8009d66:	d81b      	bhi.n	8009da0 <LSM6DSO16IS_ACC_GetFullScale+0x68>
 8009d68:	a201      	add	r2, pc, #4	@ (adr r2, 8009d70 <LSM6DSO16IS_ACC_GetFullScale+0x38>)
 8009d6a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009d6e:	bf00      	nop
 8009d70:	08009d81 	.word	0x08009d81
 8009d74:	08009d99 	.word	0x08009d99
 8009d78:	08009d89 	.word	0x08009d89
 8009d7c:	08009d91 	.word	0x08009d91
  {
    case LSM6DSO16IS_2g:
      *FullScale =  2;
 8009d80:	683b      	ldr	r3, [r7, #0]
 8009d82:	2202      	movs	r2, #2
 8009d84:	601a      	str	r2, [r3, #0]
      break;
 8009d86:	e00f      	b.n	8009da8 <LSM6DSO16IS_ACC_GetFullScale+0x70>

    case LSM6DSO16IS_4g:
      *FullScale =  4;
 8009d88:	683b      	ldr	r3, [r7, #0]
 8009d8a:	2204      	movs	r2, #4
 8009d8c:	601a      	str	r2, [r3, #0]
      break;
 8009d8e:	e00b      	b.n	8009da8 <LSM6DSO16IS_ACC_GetFullScale+0x70>

    case LSM6DSO16IS_8g:
      *FullScale =  8;
 8009d90:	683b      	ldr	r3, [r7, #0]
 8009d92:	2208      	movs	r2, #8
 8009d94:	601a      	str	r2, [r3, #0]
      break;
 8009d96:	e007      	b.n	8009da8 <LSM6DSO16IS_ACC_GetFullScale+0x70>

    case LSM6DSO16IS_16g:
      *FullScale = 16;
 8009d98:	683b      	ldr	r3, [r7, #0]
 8009d9a:	2210      	movs	r2, #16
 8009d9c:	601a      	str	r2, [r3, #0]
      break;
 8009d9e:	e003      	b.n	8009da8 <LSM6DSO16IS_ACC_GetFullScale+0x70>

    default:
      ret = LSM6DSO16IS_ERROR;
 8009da0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009da4:	60fb      	str	r3, [r7, #12]
      break;
 8009da6:	bf00      	nop
  }

  return ret;
 8009da8:	68fb      	ldr	r3, [r7, #12]
}
 8009daa:	4618      	mov	r0, r3
 8009dac:	3710      	adds	r7, #16
 8009dae:	46bd      	mov	sp, r7
 8009db0:	bd80      	pop	{r7, pc}
 8009db2:	bf00      	nop

08009db4 <LSM6DSO16IS_ACC_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_SetFullScale(LSM6DSO16IS_Object_t *pObj, int32_t FullScale)
{
 8009db4:	b580      	push	{r7, lr}
 8009db6:	b084      	sub	sp, #16
 8009db8:	af00      	add	r7, sp, #0
 8009dba:	6078      	str	r0, [r7, #4]
 8009dbc:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 8009dbe:	2300      	movs	r3, #0
 8009dc0:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_xl_full_scale_t new_fs;

  new_fs = (FullScale <= 2) ? LSM6DSO16IS_2g
           : (FullScale <= 4) ? LSM6DSO16IS_4g
 8009dc2:	683b      	ldr	r3, [r7, #0]
 8009dc4:	2b02      	cmp	r3, #2
 8009dc6:	dd0b      	ble.n	8009de0 <LSM6DSO16IS_ACC_SetFullScale+0x2c>
 8009dc8:	683b      	ldr	r3, [r7, #0]
 8009dca:	2b04      	cmp	r3, #4
 8009dcc:	dd06      	ble.n	8009ddc <LSM6DSO16IS_ACC_SetFullScale+0x28>
 8009dce:	683b      	ldr	r3, [r7, #0]
 8009dd0:	2b08      	cmp	r3, #8
 8009dd2:	dc01      	bgt.n	8009dd8 <LSM6DSO16IS_ACC_SetFullScale+0x24>
 8009dd4:	2303      	movs	r3, #3
 8009dd6:	e004      	b.n	8009de2 <LSM6DSO16IS_ACC_SetFullScale+0x2e>
 8009dd8:	2301      	movs	r3, #1
 8009dda:	e002      	b.n	8009de2 <LSM6DSO16IS_ACC_SetFullScale+0x2e>
 8009ddc:	2302      	movs	r3, #2
 8009dde:	e000      	b.n	8009de2 <LSM6DSO16IS_ACC_SetFullScale+0x2e>
 8009de0:	2300      	movs	r3, #0
  new_fs = (FullScale <= 2) ? LSM6DSO16IS_2g
 8009de2:	72fb      	strb	r3, [r7, #11]
           : (FullScale <= 8) ? LSM6DSO16IS_8g
           :                    LSM6DSO16IS_16g;

  if (lsm6dso16is_xl_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSO16IS_OK)
 8009de4:	687b      	ldr	r3, [r7, #4]
 8009de6:	3320      	adds	r3, #32
 8009de8:	7afa      	ldrb	r2, [r7, #11]
 8009dea:	4611      	mov	r1, r2
 8009dec:	4618      	mov	r0, r3
 8009dee:	f000 fe3b 	bl	800aa68 <lsm6dso16is_xl_full_scale_set>
 8009df2:	4603      	mov	r3, r0
 8009df4:	2b00      	cmp	r3, #0
 8009df6:	d002      	beq.n	8009dfe <LSM6DSO16IS_ACC_SetFullScale+0x4a>
  {
    ret = LSM6DSO16IS_ERROR;
 8009df8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009dfc:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 8009dfe:	68fb      	ldr	r3, [r7, #12]
}
 8009e00:	4618      	mov	r0, r3
 8009e02:	3710      	adds	r7, #16
 8009e04:	46bd      	mov	sp, r7
 8009e06:	bd80      	pop	{r7, pc}

08009e08 <LSM6DSO16IS_ACC_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_GetAxesRaw(LSM6DSO16IS_Object_t *pObj, LSM6DSO16IS_AxesRaw_t *Value)
{
 8009e08:	b580      	push	{r7, lr}
 8009e0a:	b086      	sub	sp, #24
 8009e0c:	af00      	add	r7, sp, #0
 8009e0e:	6078      	str	r0, [r7, #4]
 8009e10:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 8009e12:	2300      	movs	r3, #0
 8009e14:	617b      	str	r3, [r7, #20]
  int16_t data_raw[3];

  /* Read raw data values. */
  if (lsm6dso16is_acceleration_raw_get(&(pObj->Ctx), data_raw) != LSM6DSO16IS_OK)
 8009e16:	687b      	ldr	r3, [r7, #4]
 8009e18:	3320      	adds	r3, #32
 8009e1a:	f107 020c 	add.w	r2, r7, #12
 8009e1e:	4611      	mov	r1, r2
 8009e20:	4618      	mov	r0, r3
 8009e22:	f001 f9c3 	bl	800b1ac <lsm6dso16is_acceleration_raw_get>
 8009e26:	4603      	mov	r3, r0
 8009e28:	2b00      	cmp	r3, #0
 8009e2a:	d002      	beq.n	8009e32 <LSM6DSO16IS_ACC_GetAxesRaw+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 8009e2c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009e30:	617b      	str	r3, [r7, #20]
  }

  /* Format the data. */
  Value->x = data_raw[0];
 8009e32:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8009e36:	683b      	ldr	r3, [r7, #0]
 8009e38:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw[1];
 8009e3a:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8009e3e:	683b      	ldr	r3, [r7, #0]
 8009e40:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw[2];
 8009e42:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 8009e46:	683b      	ldr	r3, [r7, #0]
 8009e48:	809a      	strh	r2, [r3, #4]

  return ret;
 8009e4a:	697b      	ldr	r3, [r7, #20]
}
 8009e4c:	4618      	mov	r0, r3
 8009e4e:	3718      	adds	r7, #24
 8009e50:	46bd      	mov	sp, r7
 8009e52:	bd80      	pop	{r7, pc}

08009e54 <LSM6DSO16IS_ACC_GetAxes>:
  * @param  pObj the device pObj
  * @param  Acceleration pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_ACC_GetAxes(LSM6DSO16IS_Object_t *pObj, LSM6DSO16IS_Axes_t *Acceleration)
{
 8009e54:	b580      	push	{r7, lr}
 8009e56:	b086      	sub	sp, #24
 8009e58:	af00      	add	r7, sp, #0
 8009e5a:	6078      	str	r0, [r7, #4]
 8009e5c:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 8009e5e:	2300      	movs	r3, #0
 8009e60:	617b      	str	r3, [r7, #20]
  int16_t data_raw[3];
  float_t sensitivity = 0.0f;
 8009e62:	f04f 0300 	mov.w	r3, #0
 8009e66:	60bb      	str	r3, [r7, #8]

  /* Read raw data values. */
  if (lsm6dso16is_acceleration_raw_get(&(pObj->Ctx), data_raw) != LSM6DSO16IS_OK)
 8009e68:	687b      	ldr	r3, [r7, #4]
 8009e6a:	3320      	adds	r3, #32
 8009e6c:	f107 020c 	add.w	r2, r7, #12
 8009e70:	4611      	mov	r1, r2
 8009e72:	4618      	mov	r0, r3
 8009e74:	f001 f99a 	bl	800b1ac <lsm6dso16is_acceleration_raw_get>
 8009e78:	4603      	mov	r3, r0
 8009e7a:	2b00      	cmp	r3, #0
 8009e7c:	d002      	beq.n	8009e84 <LSM6DSO16IS_ACC_GetAxes+0x30>
  {
    ret = LSM6DSO16IS_ERROR;
 8009e7e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009e82:	617b      	str	r3, [r7, #20]
  }

  /* Get LSM6DSO16IS actual sensitivity. */
  if (LSM6DSO16IS_ACC_GetSensitivity(pObj, &sensitivity) != LSM6DSO16IS_OK)
 8009e84:	f107 0308 	add.w	r3, r7, #8
 8009e88:	4619      	mov	r1, r3
 8009e8a:	6878      	ldr	r0, [r7, #4]
 8009e8c:	f7ff fe4c 	bl	8009b28 <LSM6DSO16IS_ACC_GetSensitivity>
 8009e90:	4603      	mov	r3, r0
 8009e92:	2b00      	cmp	r3, #0
 8009e94:	d002      	beq.n	8009e9c <LSM6DSO16IS_ACC_GetAxes+0x48>
  {
    ret = LSM6DSO16IS_ERROR;
 8009e96:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009e9a:	617b      	str	r3, [r7, #20]
  }

  /* Calculate the data. */
  Acceleration->x = (int32_t)((float_t)((float_t)data_raw[0] * sensitivity));
 8009e9c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8009ea0:	ee07 3a90 	vmov	s15, r3
 8009ea4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8009ea8:	edd7 7a02 	vldr	s15, [r7, #8]
 8009eac:	ee67 7a27 	vmul.f32	s15, s14, s15
 8009eb0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8009eb4:	ee17 2a90 	vmov	r2, s15
 8009eb8:	683b      	ldr	r3, [r7, #0]
 8009eba:	601a      	str	r2, [r3, #0]
  Acceleration->y = (int32_t)((float_t)((float_t)data_raw[1] * sensitivity));
 8009ebc:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8009ec0:	ee07 3a90 	vmov	s15, r3
 8009ec4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8009ec8:	edd7 7a02 	vldr	s15, [r7, #8]
 8009ecc:	ee67 7a27 	vmul.f32	s15, s14, s15
 8009ed0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8009ed4:	ee17 2a90 	vmov	r2, s15
 8009ed8:	683b      	ldr	r3, [r7, #0]
 8009eda:	605a      	str	r2, [r3, #4]
  Acceleration->z = (int32_t)((float_t)((float_t)data_raw[2] * sensitivity));
 8009edc:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8009ee0:	ee07 3a90 	vmov	s15, r3
 8009ee4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8009ee8:	edd7 7a02 	vldr	s15, [r7, #8]
 8009eec:	ee67 7a27 	vmul.f32	s15, s14, s15
 8009ef0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8009ef4:	ee17 2a90 	vmov	r2, s15
 8009ef8:	683b      	ldr	r3, [r7, #0]
 8009efa:	609a      	str	r2, [r3, #8]

  return ret;
 8009efc:	697b      	ldr	r3, [r7, #20]
}
 8009efe:	4618      	mov	r0, r3
 8009f00:	3718      	adds	r7, #24
 8009f02:	46bd      	mov	sp, r7
 8009f04:	bd80      	pop	{r7, pc}

08009f06 <LSM6DSO16IS_GYRO_Enable>:
  * @brief  Enable the LSM6DSO16IS gyroscope sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_Enable(LSM6DSO16IS_Object_t *pObj)
{
 8009f06:	b580      	push	{r7, lr}
 8009f08:	b084      	sub	sp, #16
 8009f0a:	af00      	add	r7, sp, #0
 8009f0c:	6078      	str	r0, [r7, #4]
  int32_t ret = LSM6DSO16IS_OK;
 8009f0e:	2300      	movs	r3, #0
 8009f10:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already enabled */
  if (pObj->gyro_is_enabled == 1U)
 8009f12:	687b      	ldr	r3, [r7, #4]
 8009f14:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8009f18:	2b01      	cmp	r3, #1
 8009f1a:	d102      	bne.n	8009f22 <LSM6DSO16IS_GYRO_Enable+0x1c>
  {
    ret = LSM6DSO16IS_OK;
 8009f1c:	2300      	movs	r3, #0
 8009f1e:	60fb      	str	r3, [r7, #12]
 8009f20:	e013      	b.n	8009f4a <LSM6DSO16IS_GYRO_Enable+0x44>
  }
  else
  {
    /* Output data rate selection. */
    if (lsm6dso16is_gy_data_rate_set(&(pObj->Ctx), pObj->gyro_odr) != LSM6DSO16IS_OK)
 8009f22:	687b      	ldr	r3, [r7, #4]
 8009f24:	f103 0220 	add.w	r2, r3, #32
 8009f28:	687b      	ldr	r3, [r7, #4]
 8009f2a:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8009f2e:	4619      	mov	r1, r3
 8009f30:	4610      	mov	r0, r2
 8009f32:	f000 ffab 	bl	800ae8c <lsm6dso16is_gy_data_rate_set>
 8009f36:	4603      	mov	r3, r0
 8009f38:	2b00      	cmp	r3, #0
 8009f3a:	d002      	beq.n	8009f42 <LSM6DSO16IS_GYRO_Enable+0x3c>
    {
      ret = LSM6DSO16IS_ERROR;
 8009f3c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009f40:	60fb      	str	r3, [r7, #12]
    }

    pObj->gyro_is_enabled = 1;
 8009f42:	687b      	ldr	r3, [r7, #4]
 8009f44:	2201      	movs	r2, #1
 8009f46:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32
  }

  return ret;
 8009f4a:	68fb      	ldr	r3, [r7, #12]
}
 8009f4c:	4618      	mov	r0, r3
 8009f4e:	3710      	adds	r7, #16
 8009f50:	46bd      	mov	sp, r7
 8009f52:	bd80      	pop	{r7, pc}

08009f54 <LSM6DSO16IS_GYRO_Disable>:
  * @brief  Disable the LSM6DSO16IS gyroscope sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_Disable(LSM6DSO16IS_Object_t *pObj)
{
 8009f54:	b580      	push	{r7, lr}
 8009f56:	b084      	sub	sp, #16
 8009f58:	af00      	add	r7, sp, #0
 8009f5a:	6078      	str	r0, [r7, #4]
  int32_t ret = LSM6DSO16IS_OK;
 8009f5c:	2300      	movs	r3, #0
 8009f5e:	60fb      	str	r3, [r7, #12]

  /* Check if the component is already disabled */
  if (pObj->gyro_is_enabled == 0U)
 8009f60:	687b      	ldr	r3, [r7, #4]
 8009f62:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 8009f66:	2b00      	cmp	r3, #0
 8009f68:	d102      	bne.n	8009f70 <LSM6DSO16IS_GYRO_Disable+0x1c>
  {
    ret = LSM6DSO16IS_OK;
 8009f6a:	2300      	movs	r3, #0
 8009f6c:	60fb      	str	r3, [r7, #12]
 8009f6e:	e01e      	b.n	8009fae <LSM6DSO16IS_GYRO_Disable+0x5a>
  }
  else
  {
    /* Get current output data rate. */
    if (lsm6dso16is_gy_data_rate_get(&(pObj->Ctx), &pObj->gyro_odr) != LSM6DSO16IS_OK)
 8009f70:	687b      	ldr	r3, [r7, #4]
 8009f72:	f103 0220 	add.w	r2, r3, #32
 8009f76:	687b      	ldr	r3, [r7, #4]
 8009f78:	3334      	adds	r3, #52	@ 0x34
 8009f7a:	4619      	mov	r1, r3
 8009f7c:	4610      	mov	r0, r2
 8009f7e:	f000 ffc5 	bl	800af0c <lsm6dso16is_gy_data_rate_get>
 8009f82:	4603      	mov	r3, r0
 8009f84:	2b00      	cmp	r3, #0
 8009f86:	d002      	beq.n	8009f8e <LSM6DSO16IS_GYRO_Disable+0x3a>
    {
      ret = LSM6DSO16IS_ERROR;
 8009f88:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009f8c:	60fb      	str	r3, [r7, #12]
    }

    /* Output data rate selection - power down. */
    if (lsm6dso16is_gy_data_rate_set(&(pObj->Ctx), LSM6DSO16IS_GY_ODR_OFF) != LSM6DSO16IS_OK)
 8009f8e:	687b      	ldr	r3, [r7, #4]
 8009f90:	3320      	adds	r3, #32
 8009f92:	2100      	movs	r1, #0
 8009f94:	4618      	mov	r0, r3
 8009f96:	f000 ff79 	bl	800ae8c <lsm6dso16is_gy_data_rate_set>
 8009f9a:	4603      	mov	r3, r0
 8009f9c:	2b00      	cmp	r3, #0
 8009f9e:	d002      	beq.n	8009fa6 <LSM6DSO16IS_GYRO_Disable+0x52>
    {
      ret = LSM6DSO16IS_ERROR;
 8009fa0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009fa4:	60fb      	str	r3, [r7, #12]
    }

    pObj->gyro_is_enabled = 0;
 8009fa6:	687b      	ldr	r3, [r7, #4]
 8009fa8:	2200      	movs	r2, #0
 8009faa:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32
  }

  return ret;
 8009fae:	68fb      	ldr	r3, [r7, #12]
}
 8009fb0:	4618      	mov	r0, r3
 8009fb2:	3710      	adds	r7, #16
 8009fb4:	46bd      	mov	sp, r7
 8009fb6:	bd80      	pop	{r7, pc}

08009fb8 <LSM6DSO16IS_GYRO_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_GetSensitivity(LSM6DSO16IS_Object_t *pObj, float_t *Sensitivity)
{
 8009fb8:	b580      	push	{r7, lr}
 8009fba:	b084      	sub	sp, #16
 8009fbc:	af00      	add	r7, sp, #0
 8009fbe:	6078      	str	r0, [r7, #4]
 8009fc0:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 8009fc2:	2300      	movs	r3, #0
 8009fc4:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_gy_full_scale_t full_scale;

  /* Read actual full scale selection from sensor. */
  if (lsm6dso16is_gy_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSO16IS_OK)
 8009fc6:	687b      	ldr	r3, [r7, #4]
 8009fc8:	3320      	adds	r3, #32
 8009fca:	f107 020b 	add.w	r2, r7, #11
 8009fce:	4611      	mov	r1, r2
 8009fd0:	4618      	mov	r0, r3
 8009fd2:	f000 feff 	bl	800add4 <lsm6dso16is_gy_full_scale_get>
 8009fd6:	4603      	mov	r3, r0
 8009fd8:	2b00      	cmp	r3, #0
 8009fda:	d002      	beq.n	8009fe2 <LSM6DSO16IS_GYRO_GetSensitivity+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 8009fdc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 8009fe0:	60fb      	str	r3, [r7, #12]
  }

  /* Store the sensitivity based on actual full scale. */
  switch (full_scale)
 8009fe2:	7afb      	ldrb	r3, [r7, #11]
 8009fe4:	2b10      	cmp	r3, #16
 8009fe6:	d839      	bhi.n	800a05c <LSM6DSO16IS_GYRO_GetSensitivity+0xa4>
 8009fe8:	a201      	add	r2, pc, #4	@ (adr r2, 8009ff0 <LSM6DSO16IS_GYRO_GetSensitivity+0x38>)
 8009fea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009fee:	bf00      	nop
 8009ff0:	0800a03d 	.word	0x0800a03d
 8009ff4:	0800a045 	.word	0x0800a045
 8009ff8:	0800a04d 	.word	0x0800a04d
 8009ffc:	0800a055 	.word	0x0800a055
 800a000:	0800a05d 	.word	0x0800a05d
 800a004:	0800a05d 	.word	0x0800a05d
 800a008:	0800a05d 	.word	0x0800a05d
 800a00c:	0800a05d 	.word	0x0800a05d
 800a010:	0800a05d 	.word	0x0800a05d
 800a014:	0800a05d 	.word	0x0800a05d
 800a018:	0800a05d 	.word	0x0800a05d
 800a01c:	0800a05d 	.word	0x0800a05d
 800a020:	0800a05d 	.word	0x0800a05d
 800a024:	0800a05d 	.word	0x0800a05d
 800a028:	0800a05d 	.word	0x0800a05d
 800a02c:	0800a05d 	.word	0x0800a05d
 800a030:	0800a035 	.word	0x0800a035
  {
    case LSM6DSO16IS_125dps:
      *Sensitivity = LSM6DSO16IS_GYRO_SENSITIVITY_FS_125DPS;
 800a034:	683b      	ldr	r3, [r7, #0]
 800a036:	4a0e      	ldr	r2, [pc, #56]	@ (800a070 <LSM6DSO16IS_GYRO_GetSensitivity+0xb8>)
 800a038:	601a      	str	r2, [r3, #0]
      break;
 800a03a:	e013      	b.n	800a064 <LSM6DSO16IS_GYRO_GetSensitivity+0xac>

    case LSM6DSO16IS_250dps:
      *Sensitivity = LSM6DSO16IS_GYRO_SENSITIVITY_FS_250DPS;
 800a03c:	683b      	ldr	r3, [r7, #0]
 800a03e:	4a0d      	ldr	r2, [pc, #52]	@ (800a074 <LSM6DSO16IS_GYRO_GetSensitivity+0xbc>)
 800a040:	601a      	str	r2, [r3, #0]
      break;
 800a042:	e00f      	b.n	800a064 <LSM6DSO16IS_GYRO_GetSensitivity+0xac>

    case LSM6DSO16IS_500dps:
      *Sensitivity = LSM6DSO16IS_GYRO_SENSITIVITY_FS_500DPS;
 800a044:	683b      	ldr	r3, [r7, #0]
 800a046:	4a0c      	ldr	r2, [pc, #48]	@ (800a078 <LSM6DSO16IS_GYRO_GetSensitivity+0xc0>)
 800a048:	601a      	str	r2, [r3, #0]
      break;
 800a04a:	e00b      	b.n	800a064 <LSM6DSO16IS_GYRO_GetSensitivity+0xac>

    case LSM6DSO16IS_1000dps:
      *Sensitivity = LSM6DSO16IS_GYRO_SENSITIVITY_FS_1000DPS;
 800a04c:	683b      	ldr	r3, [r7, #0]
 800a04e:	4a0b      	ldr	r2, [pc, #44]	@ (800a07c <LSM6DSO16IS_GYRO_GetSensitivity+0xc4>)
 800a050:	601a      	str	r2, [r3, #0]
      break;
 800a052:	e007      	b.n	800a064 <LSM6DSO16IS_GYRO_GetSensitivity+0xac>

    case LSM6DSO16IS_2000dps:
      *Sensitivity = LSM6DSO16IS_GYRO_SENSITIVITY_FS_2000DPS;
 800a054:	683b      	ldr	r3, [r7, #0]
 800a056:	4a0a      	ldr	r2, [pc, #40]	@ (800a080 <LSM6DSO16IS_GYRO_GetSensitivity+0xc8>)
 800a058:	601a      	str	r2, [r3, #0]
      break;
 800a05a:	e003      	b.n	800a064 <LSM6DSO16IS_GYRO_GetSensitivity+0xac>

    default:
      ret = LSM6DSO16IS_ERROR;
 800a05c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a060:	60fb      	str	r3, [r7, #12]
      break;
 800a062:	bf00      	nop
  }

  return ret;
 800a064:	68fb      	ldr	r3, [r7, #12]
}
 800a066:	4618      	mov	r0, r3
 800a068:	3710      	adds	r7, #16
 800a06a:	46bd      	mov	sp, r7
 800a06c:	bd80      	pop	{r7, pc}
 800a06e:	bf00      	nop
 800a070:	408c0000 	.word	0x408c0000
 800a074:	410c0000 	.word	0x410c0000
 800a078:	418c0000 	.word	0x418c0000
 800a07c:	420c0000 	.word	0x420c0000
 800a080:	428c0000 	.word	0x428c0000

0800a084 <LSM6DSO16IS_GYRO_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_GetOutputDataRate(LSM6DSO16IS_Object_t *pObj, float_t *Odr)
{
 800a084:	b580      	push	{r7, lr}
 800a086:	b084      	sub	sp, #16
 800a088:	af00      	add	r7, sp, #0
 800a08a:	6078      	str	r0, [r7, #4]
 800a08c:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 800a08e:	2300      	movs	r3, #0
 800a090:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_gy_data_rate_t odr_low_level;

  /* Get current output data rate. */
  if (lsm6dso16is_gy_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSO16IS_OK)
 800a092:	687b      	ldr	r3, [r7, #4]
 800a094:	3320      	adds	r3, #32
 800a096:	f107 020b 	add.w	r2, r7, #11
 800a09a:	4611      	mov	r1, r2
 800a09c:	4618      	mov	r0, r3
 800a09e:	f000 ff35 	bl	800af0c <lsm6dso16is_gy_data_rate_get>
 800a0a2:	4603      	mov	r3, r0
 800a0a4:	2b00      	cmp	r3, #0
 800a0a6:	d002      	beq.n	800a0ae <LSM6DSO16IS_GYRO_GetOutputDataRate+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 800a0a8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a0ac:	60fb      	str	r3, [r7, #12]
  }

  switch (odr_low_level)
 800a0ae:	7afb      	ldrb	r3, [r7, #11]
 800a0b0:	2b1a      	cmp	r3, #26
 800a0b2:	d866      	bhi.n	800a182 <LSM6DSO16IS_GYRO_GetOutputDataRate+0xfe>
 800a0b4:	a201      	add	r2, pc, #4	@ (adr r2, 800a0bc <LSM6DSO16IS_GYRO_GetOutputDataRate+0x38>)
 800a0b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a0ba:	bf00      	nop
 800a0bc:	0800a129 	.word	0x0800a129
 800a0c0:	0800a133 	.word	0x0800a133
 800a0c4:	0800a13b 	.word	0x0800a13b
 800a0c8:	0800a143 	.word	0x0800a143
 800a0cc:	0800a14b 	.word	0x0800a14b
 800a0d0:	0800a153 	.word	0x0800a153
 800a0d4:	0800a15b 	.word	0x0800a15b
 800a0d8:	0800a163 	.word	0x0800a163
 800a0dc:	0800a16b 	.word	0x0800a16b
 800a0e0:	0800a173 	.word	0x0800a173
 800a0e4:	0800a17b 	.word	0x0800a17b
 800a0e8:	0800a183 	.word	0x0800a183
 800a0ec:	0800a183 	.word	0x0800a183
 800a0f0:	0800a183 	.word	0x0800a183
 800a0f4:	0800a183 	.word	0x0800a183
 800a0f8:	0800a183 	.word	0x0800a183
 800a0fc:	0800a183 	.word	0x0800a183
 800a100:	0800a133 	.word	0x0800a133
 800a104:	0800a13b 	.word	0x0800a13b
 800a108:	0800a143 	.word	0x0800a143
 800a10c:	0800a14b 	.word	0x0800a14b
 800a110:	0800a153 	.word	0x0800a153
 800a114:	0800a15b 	.word	0x0800a15b
 800a118:	0800a163 	.word	0x0800a163
 800a11c:	0800a16b 	.word	0x0800a16b
 800a120:	0800a173 	.word	0x0800a173
 800a124:	0800a17b 	.word	0x0800a17b
  {
    case LSM6DSO16IS_GY_ODR_OFF:
      *Odr = 0.0f;
 800a128:	683b      	ldr	r3, [r7, #0]
 800a12a:	f04f 0200 	mov.w	r2, #0
 800a12e:	601a      	str	r2, [r3, #0]
      break;
 800a130:	e02b      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_12Hz5_LP:
    case LSM6DSO16IS_GY_ODR_AT_12Hz5_HP:
      *Odr = 12.5f;
 800a132:	683b      	ldr	r3, [r7, #0]
 800a134:	4a17      	ldr	r2, [pc, #92]	@ (800a194 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x110>)
 800a136:	601a      	str	r2, [r3, #0]
      break;
 800a138:	e027      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_26H_LP:
    case LSM6DSO16IS_GY_ODR_AT_26H_HP:
      *Odr = 26.0f;
 800a13a:	683b      	ldr	r3, [r7, #0]
 800a13c:	4a16      	ldr	r2, [pc, #88]	@ (800a198 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x114>)
 800a13e:	601a      	str	r2, [r3, #0]
      break;
 800a140:	e023      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_52Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_52Hz_HP:
      *Odr = 52.0f;
 800a142:	683b      	ldr	r3, [r7, #0]
 800a144:	4a15      	ldr	r2, [pc, #84]	@ (800a19c <LSM6DSO16IS_GYRO_GetOutputDataRate+0x118>)
 800a146:	601a      	str	r2, [r3, #0]
      break;
 800a148:	e01f      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_104Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_104Hz_HP:
      *Odr = 104.0f;
 800a14a:	683b      	ldr	r3, [r7, #0]
 800a14c:	4a14      	ldr	r2, [pc, #80]	@ (800a1a0 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x11c>)
 800a14e:	601a      	str	r2, [r3, #0]
      break;
 800a150:	e01b      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_208Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_208Hz_HP:
      *Odr = 208.0f;
 800a152:	683b      	ldr	r3, [r7, #0]
 800a154:	4a13      	ldr	r2, [pc, #76]	@ (800a1a4 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x120>)
 800a156:	601a      	str	r2, [r3, #0]
      break;
 800a158:	e017      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_416Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_416Hz_HP:
      *Odr = 416.0f;
 800a15a:	683b      	ldr	r3, [r7, #0]
 800a15c:	4a12      	ldr	r2, [pc, #72]	@ (800a1a8 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x124>)
 800a15e:	601a      	str	r2, [r3, #0]
      break;
 800a160:	e013      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_833Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_833Hz_HP:
      *Odr = 833.0f;
 800a162:	683b      	ldr	r3, [r7, #0]
 800a164:	4a11      	ldr	r2, [pc, #68]	@ (800a1ac <LSM6DSO16IS_GYRO_GetOutputDataRate+0x128>)
 800a166:	601a      	str	r2, [r3, #0]
      break;
 800a168:	e00f      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_1667Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_1667Hz_HP:
      *Odr =  1667.0f;
 800a16a:	683b      	ldr	r3, [r7, #0]
 800a16c:	4a10      	ldr	r2, [pc, #64]	@ (800a1b0 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x12c>)
 800a16e:	601a      	str	r2, [r3, #0]
      break;
 800a170:	e00b      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_3333Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_3333Hz_HP:
      *Odr =  3333.0f;
 800a172:	683b      	ldr	r3, [r7, #0]
 800a174:	4a0f      	ldr	r2, [pc, #60]	@ (800a1b4 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x130>)
 800a176:	601a      	str	r2, [r3, #0]
      break;
 800a178:	e007      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    case LSM6DSO16IS_GY_ODR_AT_6667Hz_LP:
    case LSM6DSO16IS_GY_ODR_AT_6667Hz_HP:
      *Odr =  6667.0f;
 800a17a:	683b      	ldr	r3, [r7, #0]
 800a17c:	4a0e      	ldr	r2, [pc, #56]	@ (800a1b8 <LSM6DSO16IS_GYRO_GetOutputDataRate+0x134>)
 800a17e:	601a      	str	r2, [r3, #0]
      break;
 800a180:	e003      	b.n	800a18a <LSM6DSO16IS_GYRO_GetOutputDataRate+0x106>

    default:
      ret = LSM6DSO16IS_ERROR;
 800a182:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a186:	60fb      	str	r3, [r7, #12]
      break;
 800a188:	bf00      	nop
  }

  return ret;
 800a18a:	68fb      	ldr	r3, [r7, #12]
}
 800a18c:	4618      	mov	r0, r3
 800a18e:	3710      	adds	r7, #16
 800a190:	46bd      	mov	sp, r7
 800a192:	bd80      	pop	{r7, pc}
 800a194:	41480000 	.word	0x41480000
 800a198:	41d00000 	.word	0x41d00000
 800a19c:	42500000 	.word	0x42500000
 800a1a0:	42d00000 	.word	0x42d00000
 800a1a4:	43500000 	.word	0x43500000
 800a1a8:	43d00000 	.word	0x43d00000
 800a1ac:	44504000 	.word	0x44504000
 800a1b0:	44d06000 	.word	0x44d06000
 800a1b4:	45505000 	.word	0x45505000
 800a1b8:	45d05800 	.word	0x45d05800

0800a1bc <LSM6DSO16IS_GYRO_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_SetOutputDataRate(LSM6DSO16IS_Object_t *pObj, float_t Odr)
{
 800a1bc:	b580      	push	{r7, lr}
 800a1be:	b084      	sub	sp, #16
 800a1c0:	af00      	add	r7, sp, #0
 800a1c2:	6078      	str	r0, [r7, #4]
 800a1c4:	ed87 0a00 	vstr	s0, [r7]
  int32_t ret;

  /* Check if the component is enabled */
  if (pObj->gyro_is_enabled == 1U)
 800a1c8:	687b      	ldr	r3, [r7, #4]
 800a1ca:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800a1ce:	2b01      	cmp	r3, #1
 800a1d0:	d106      	bne.n	800a1e0 <LSM6DSO16IS_GYRO_SetOutputDataRate+0x24>
  {
    ret = LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled(pObj, Odr);
 800a1d2:	ed97 0a00 	vldr	s0, [r7]
 800a1d6:	6878      	ldr	r0, [r7, #4]
 800a1d8:	f000 fa70 	bl	800a6bc <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled>
 800a1dc:	60f8      	str	r0, [r7, #12]
 800a1de:	e005      	b.n	800a1ec <LSM6DSO16IS_GYRO_SetOutputDataRate+0x30>
  }
  else
  {
    ret = LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled(pObj, Odr);
 800a1e0:	ed97 0a00 	vldr	s0, [r7]
 800a1e4:	6878      	ldr	r0, [r7, #4]
 800a1e6:	f000 faf7 	bl	800a7d8 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled>
 800a1ea:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800a1ec:	68fb      	ldr	r3, [r7, #12]
}
 800a1ee:	4618      	mov	r0, r3
 800a1f0:	3710      	adds	r7, #16
 800a1f2:	46bd      	mov	sp, r7
 800a1f4:	bd80      	pop	{r7, pc}
	...

0800a1f8 <LSM6DSO16IS_GYRO_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_GetFullScale(LSM6DSO16IS_Object_t *pObj, int32_t  *FullScale)
{
 800a1f8:	b580      	push	{r7, lr}
 800a1fa:	b084      	sub	sp, #16
 800a1fc:	af00      	add	r7, sp, #0
 800a1fe:	6078      	str	r0, [r7, #4]
 800a200:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 800a202:	2300      	movs	r3, #0
 800a204:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_gy_full_scale_t fs_low_level;

  /* Read actual full scale selection from sensor. */
  if (lsm6dso16is_gy_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSO16IS_OK)
 800a206:	687b      	ldr	r3, [r7, #4]
 800a208:	3320      	adds	r3, #32
 800a20a:	f107 020b 	add.w	r2, r7, #11
 800a20e:	4611      	mov	r1, r2
 800a210:	4618      	mov	r0, r3
 800a212:	f000 fddf 	bl	800add4 <lsm6dso16is_gy_full_scale_get>
 800a216:	4603      	mov	r3, r0
 800a218:	2b00      	cmp	r3, #0
 800a21a:	d002      	beq.n	800a222 <LSM6DSO16IS_GYRO_GetFullScale+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 800a21c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a220:	60fb      	str	r3, [r7, #12]
  }

  switch (fs_low_level)
 800a222:	7afb      	ldrb	r3, [r7, #11]
 800a224:	2b10      	cmp	r3, #16
 800a226:	d83c      	bhi.n	800a2a2 <LSM6DSO16IS_GYRO_GetFullScale+0xaa>
 800a228:	a201      	add	r2, pc, #4	@ (adr r2, 800a230 <LSM6DSO16IS_GYRO_GetFullScale+0x38>)
 800a22a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a22e:	bf00      	nop
 800a230:	0800a27d 	.word	0x0800a27d
 800a234:	0800a285 	.word	0x0800a285
 800a238:	0800a28f 	.word	0x0800a28f
 800a23c:	0800a299 	.word	0x0800a299
 800a240:	0800a2a3 	.word	0x0800a2a3
 800a244:	0800a2a3 	.word	0x0800a2a3
 800a248:	0800a2a3 	.word	0x0800a2a3
 800a24c:	0800a2a3 	.word	0x0800a2a3
 800a250:	0800a2a3 	.word	0x0800a2a3
 800a254:	0800a2a3 	.word	0x0800a2a3
 800a258:	0800a2a3 	.word	0x0800a2a3
 800a25c:	0800a2a3 	.word	0x0800a2a3
 800a260:	0800a2a3 	.word	0x0800a2a3
 800a264:	0800a2a3 	.word	0x0800a2a3
 800a268:	0800a2a3 	.word	0x0800a2a3
 800a26c:	0800a2a3 	.word	0x0800a2a3
 800a270:	0800a275 	.word	0x0800a275
  {
    case LSM6DSO16IS_125dps:
      *FullScale =  125;
 800a274:	683b      	ldr	r3, [r7, #0]
 800a276:	227d      	movs	r2, #125	@ 0x7d
 800a278:	601a      	str	r2, [r3, #0]
      break;
 800a27a:	e016      	b.n	800a2aa <LSM6DSO16IS_GYRO_GetFullScale+0xb2>

    case LSM6DSO16IS_250dps:
      *FullScale =  250;
 800a27c:	683b      	ldr	r3, [r7, #0]
 800a27e:	22fa      	movs	r2, #250	@ 0xfa
 800a280:	601a      	str	r2, [r3, #0]
      break;
 800a282:	e012      	b.n	800a2aa <LSM6DSO16IS_GYRO_GetFullScale+0xb2>

    case LSM6DSO16IS_500dps:
      *FullScale =  500;
 800a284:	683b      	ldr	r3, [r7, #0]
 800a286:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
 800a28a:	601a      	str	r2, [r3, #0]
      break;
 800a28c:	e00d      	b.n	800a2aa <LSM6DSO16IS_GYRO_GetFullScale+0xb2>

    case LSM6DSO16IS_1000dps:
      *FullScale = 1000;
 800a28e:	683b      	ldr	r3, [r7, #0]
 800a290:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800a294:	601a      	str	r2, [r3, #0]
      break;
 800a296:	e008      	b.n	800a2aa <LSM6DSO16IS_GYRO_GetFullScale+0xb2>

    case LSM6DSO16IS_2000dps:
      *FullScale = 2000;
 800a298:	683b      	ldr	r3, [r7, #0]
 800a29a:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 800a29e:	601a      	str	r2, [r3, #0]
      break;
 800a2a0:	e003      	b.n	800a2aa <LSM6DSO16IS_GYRO_GetFullScale+0xb2>

    default:
      ret = LSM6DSO16IS_ERROR;
 800a2a2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a2a6:	60fb      	str	r3, [r7, #12]
      break;
 800a2a8:	bf00      	nop
  }

  return ret;
 800a2aa:	68fb      	ldr	r3, [r7, #12]
}
 800a2ac:	4618      	mov	r0, r3
 800a2ae:	3710      	adds	r7, #16
 800a2b0:	46bd      	mov	sp, r7
 800a2b2:	bd80      	pop	{r7, pc}

0800a2b4 <LSM6DSO16IS_GYRO_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_SetFullScale(LSM6DSO16IS_Object_t *pObj, int32_t FullScale)
{
 800a2b4:	b580      	push	{r7, lr}
 800a2b6:	b084      	sub	sp, #16
 800a2b8:	af00      	add	r7, sp, #0
 800a2ba:	6078      	str	r0, [r7, #4]
 800a2bc:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 800a2be:	2300      	movs	r3, #0
 800a2c0:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_gy_full_scale_t new_fs;

  new_fs = (FullScale <= 125)  ? LSM6DSO16IS_125dps
           : (FullScale <= 250)  ? LSM6DSO16IS_250dps
 800a2c2:	683b      	ldr	r3, [r7, #0]
 800a2c4:	2b7d      	cmp	r3, #125	@ 0x7d
 800a2c6:	dd12      	ble.n	800a2ee <LSM6DSO16IS_GYRO_SetFullScale+0x3a>
 800a2c8:	683b      	ldr	r3, [r7, #0]
 800a2ca:	2bfa      	cmp	r3, #250	@ 0xfa
 800a2cc:	dd0d      	ble.n	800a2ea <LSM6DSO16IS_GYRO_SetFullScale+0x36>
 800a2ce:	683b      	ldr	r3, [r7, #0]
 800a2d0:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
 800a2d4:	dd07      	ble.n	800a2e6 <LSM6DSO16IS_GYRO_SetFullScale+0x32>
 800a2d6:	683b      	ldr	r3, [r7, #0]
 800a2d8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800a2dc:	dc01      	bgt.n	800a2e2 <LSM6DSO16IS_GYRO_SetFullScale+0x2e>
 800a2de:	2302      	movs	r3, #2
 800a2e0:	e006      	b.n	800a2f0 <LSM6DSO16IS_GYRO_SetFullScale+0x3c>
 800a2e2:	2303      	movs	r3, #3
 800a2e4:	e004      	b.n	800a2f0 <LSM6DSO16IS_GYRO_SetFullScale+0x3c>
 800a2e6:	2301      	movs	r3, #1
 800a2e8:	e002      	b.n	800a2f0 <LSM6DSO16IS_GYRO_SetFullScale+0x3c>
 800a2ea:	2300      	movs	r3, #0
 800a2ec:	e000      	b.n	800a2f0 <LSM6DSO16IS_GYRO_SetFullScale+0x3c>
 800a2ee:	2310      	movs	r3, #16
  new_fs = (FullScale <= 125)  ? LSM6DSO16IS_125dps
 800a2f0:	72fb      	strb	r3, [r7, #11]
           : (FullScale <= 500)  ? LSM6DSO16IS_500dps
           : (FullScale <= 1000) ? LSM6DSO16IS_1000dps
           :                       LSM6DSO16IS_2000dps;

  if (lsm6dso16is_gy_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSO16IS_OK)
 800a2f2:	687b      	ldr	r3, [r7, #4]
 800a2f4:	3320      	adds	r3, #32
 800a2f6:	7afa      	ldrb	r2, [r7, #11]
 800a2f8:	4611      	mov	r1, r2
 800a2fa:	4618      	mov	r0, r3
 800a2fc:	f000 fd3a 	bl	800ad74 <lsm6dso16is_gy_full_scale_set>
 800a300:	4603      	mov	r3, r0
 800a302:	2b00      	cmp	r3, #0
 800a304:	d002      	beq.n	800a30c <LSM6DSO16IS_GYRO_SetFullScale+0x58>
  {
    ret = LSM6DSO16IS_ERROR;
 800a306:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a30a:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 800a30c:	68fb      	ldr	r3, [r7, #12]
}
 800a30e:	4618      	mov	r0, r3
 800a310:	3710      	adds	r7, #16
 800a312:	46bd      	mov	sp, r7
 800a314:	bd80      	pop	{r7, pc}

0800a316 <LSM6DSO16IS_GYRO_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_GetAxesRaw(LSM6DSO16IS_Object_t *pObj, LSM6DSO16IS_AxesRaw_t *Value)
{
 800a316:	b580      	push	{r7, lr}
 800a318:	b086      	sub	sp, #24
 800a31a:	af00      	add	r7, sp, #0
 800a31c:	6078      	str	r0, [r7, #4]
 800a31e:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 800a320:	2300      	movs	r3, #0
 800a322:	617b      	str	r3, [r7, #20]
  int16_t data_raw[3];

  /* Read raw data values. */
  if (lsm6dso16is_angular_rate_raw_get(&(pObj->Ctx), data_raw) != LSM6DSO16IS_OK)
 800a324:	687b      	ldr	r3, [r7, #4]
 800a326:	3320      	adds	r3, #32
 800a328:	f107 020c 	add.w	r2, r7, #12
 800a32c:	4611      	mov	r1, r2
 800a32e:	4618      	mov	r0, r3
 800a330:	f000 fef4 	bl	800b11c <lsm6dso16is_angular_rate_raw_get>
 800a334:	4603      	mov	r3, r0
 800a336:	2b00      	cmp	r3, #0
 800a338:	d002      	beq.n	800a340 <LSM6DSO16IS_GYRO_GetAxesRaw+0x2a>
  {
    ret = LSM6DSO16IS_ERROR;
 800a33a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a33e:	617b      	str	r3, [r7, #20]
  }

  /* Format the data. */
  Value->x = data_raw[0];
 800a340:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 800a344:	683b      	ldr	r3, [r7, #0]
 800a346:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw[1];
 800a348:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 800a34c:	683b      	ldr	r3, [r7, #0]
 800a34e:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw[2];
 800a350:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 800a354:	683b      	ldr	r3, [r7, #0]
 800a356:	809a      	strh	r2, [r3, #4]

  return ret;
 800a358:	697b      	ldr	r3, [r7, #20]
}
 800a35a:	4618      	mov	r0, r3
 800a35c:	3718      	adds	r7, #24
 800a35e:	46bd      	mov	sp, r7
 800a360:	bd80      	pop	{r7, pc}

0800a362 <LSM6DSO16IS_GYRO_GetAxes>:
  * @param  pObj the device pObj
  * @param  AngularRate pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_GYRO_GetAxes(LSM6DSO16IS_Object_t *pObj, LSM6DSO16IS_Axes_t *AngularRate)
{
 800a362:	b580      	push	{r7, lr}
 800a364:	b086      	sub	sp, #24
 800a366:	af00      	add	r7, sp, #0
 800a368:	6078      	str	r0, [r7, #4]
 800a36a:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSO16IS_OK;
 800a36c:	2300      	movs	r3, #0
 800a36e:	617b      	str	r3, [r7, #20]
  int16_t data_raw[3];
  float_t sensitivity = 0.0f;
 800a370:	f04f 0300 	mov.w	r3, #0
 800a374:	60bb      	str	r3, [r7, #8]

  /* Read raw data values. */
  if (lsm6dso16is_angular_rate_raw_get(&(pObj->Ctx), data_raw) != LSM6DSO16IS_OK)
 800a376:	687b      	ldr	r3, [r7, #4]
 800a378:	3320      	adds	r3, #32
 800a37a:	f107 020c 	add.w	r2, r7, #12
 800a37e:	4611      	mov	r1, r2
 800a380:	4618      	mov	r0, r3
 800a382:	f000 fecb 	bl	800b11c <lsm6dso16is_angular_rate_raw_get>
 800a386:	4603      	mov	r3, r0
 800a388:	2b00      	cmp	r3, #0
 800a38a:	d002      	beq.n	800a392 <LSM6DSO16IS_GYRO_GetAxes+0x30>
  {
    ret = LSM6DSO16IS_ERROR;
 800a38c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a390:	617b      	str	r3, [r7, #20]
  }

  /* Get LSM6DSO16IS actual sensitivity. */
  if (LSM6DSO16IS_GYRO_GetSensitivity(pObj, &sensitivity) != LSM6DSO16IS_OK)
 800a392:	f107 0308 	add.w	r3, r7, #8
 800a396:	4619      	mov	r1, r3
 800a398:	6878      	ldr	r0, [r7, #4]
 800a39a:	f7ff fe0d 	bl	8009fb8 <LSM6DSO16IS_GYRO_GetSensitivity>
 800a39e:	4603      	mov	r3, r0
 800a3a0:	2b00      	cmp	r3, #0
 800a3a2:	d002      	beq.n	800a3aa <LSM6DSO16IS_GYRO_GetAxes+0x48>
  {
    ret = LSM6DSO16IS_ERROR;
 800a3a4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a3a8:	617b      	str	r3, [r7, #20]
  }

  /* Calculate the data. */
  AngularRate->x = (int32_t)((float_t)((float_t)data_raw[0] * sensitivity));
 800a3aa:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800a3ae:	ee07 3a90 	vmov	s15, r3
 800a3b2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800a3b6:	edd7 7a02 	vldr	s15, [r7, #8]
 800a3ba:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a3be:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800a3c2:	ee17 2a90 	vmov	r2, s15
 800a3c6:	683b      	ldr	r3, [r7, #0]
 800a3c8:	601a      	str	r2, [r3, #0]
  AngularRate->y = (int32_t)((float_t)((float_t)data_raw[1] * sensitivity));
 800a3ca:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800a3ce:	ee07 3a90 	vmov	s15, r3
 800a3d2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800a3d6:	edd7 7a02 	vldr	s15, [r7, #8]
 800a3da:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a3de:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800a3e2:	ee17 2a90 	vmov	r2, s15
 800a3e6:	683b      	ldr	r3, [r7, #0]
 800a3e8:	605a      	str	r2, [r3, #4]
  AngularRate->z = (int32_t)((float_t)((float_t)data_raw[2] * sensitivity));
 800a3ea:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800a3ee:	ee07 3a90 	vmov	s15, r3
 800a3f2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800a3f6:	edd7 7a02 	vldr	s15, [r7, #8]
 800a3fa:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a3fe:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800a402:	ee17 2a90 	vmov	r2, s15
 800a406:	683b      	ldr	r3, [r7, #0]
 800a408:	609a      	str	r2, [r3, #8]

  return ret;
 800a40a:	697b      	ldr	r3, [r7, #20]
}
 800a40c:	4618      	mov	r0, r3
 800a40e:	3718      	adds	r7, #24
 800a410:	46bd      	mov	sp, r7
 800a412:	bd80      	pop	{r7, pc}

0800a414 <LSM6DSO16IS_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_Write_Reg(LSM6DSO16IS_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 800a414:	b580      	push	{r7, lr}
 800a416:	b084      	sub	sp, #16
 800a418:	af00      	add	r7, sp, #0
 800a41a:	6078      	str	r0, [r7, #4]
 800a41c:	460b      	mov	r3, r1
 800a41e:	70fb      	strb	r3, [r7, #3]
 800a420:	4613      	mov	r3, r2
 800a422:	70bb      	strb	r3, [r7, #2]
  int32_t ret = LSM6DSO16IS_OK;
 800a424:	2300      	movs	r3, #0
 800a426:	60fb      	str	r3, [r7, #12]

  if (lsm6dso16is_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LSM6DSO16IS_OK)
 800a428:	687b      	ldr	r3, [r7, #4]
 800a42a:	f103 0020 	add.w	r0, r3, #32
 800a42e:	1cba      	adds	r2, r7, #2
 800a430:	78f9      	ldrb	r1, [r7, #3]
 800a432:	2301      	movs	r3, #1
 800a434:	f000 faa0 	bl	800a978 <lsm6dso16is_write_reg>
 800a438:	4603      	mov	r3, r0
 800a43a:	2b00      	cmp	r3, #0
 800a43c:	d002      	beq.n	800a444 <LSM6DSO16IS_Write_Reg+0x30>
  {
    ret = LSM6DSO16IS_ERROR;
 800a43e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a442:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 800a444:	68fb      	ldr	r3, [r7, #12]
}
 800a446:	4618      	mov	r0, r3
 800a448:	3710      	adds	r7, #16
 800a44a:	46bd      	mov	sp, r7
 800a44c:	bd80      	pop	{r7, pc}

0800a44e <LSM6DSO16IS_Set_Mem_Bank>:
  * @param  Val the value of memory bank in reg FUNC_CFG_ACCESS
  *         0 - LSM6DSO16IS_MAIN_MEM_BANK, 2 - LSM6DSO16IS_SENSOR_HUB_MEM_BANK, 3 - LSM6DSO16IS_ISPU_MEM_BANK
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSO16IS_Set_Mem_Bank(LSM6DSO16IS_Object_t *pObj, uint8_t Val)
{
 800a44e:	b580      	push	{r7, lr}
 800a450:	b084      	sub	sp, #16
 800a452:	af00      	add	r7, sp, #0
 800a454:	6078      	str	r0, [r7, #4]
 800a456:	460b      	mov	r3, r1
 800a458:	70fb      	strb	r3, [r7, #3]
  int32_t ret = LSM6DSO16IS_OK;
 800a45a:	2300      	movs	r3, #0
 800a45c:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_mem_bank_t reg;

  reg = (Val == 2U) ? LSM6DSO16IS_SENSOR_HUB_MEM_BANK
        : (Val == 3U) ? LSM6DSO16IS_ISPU_MEM_BANK
 800a45e:	78fb      	ldrb	r3, [r7, #3]
 800a460:	2b02      	cmp	r3, #2
 800a462:	d006      	beq.n	800a472 <LSM6DSO16IS_Set_Mem_Bank+0x24>
 800a464:	78fb      	ldrb	r3, [r7, #3]
 800a466:	2b03      	cmp	r3, #3
 800a468:	d101      	bne.n	800a46e <LSM6DSO16IS_Set_Mem_Bank+0x20>
 800a46a:	2303      	movs	r3, #3
 800a46c:	e002      	b.n	800a474 <LSM6DSO16IS_Set_Mem_Bank+0x26>
 800a46e:	2300      	movs	r3, #0
 800a470:	e000      	b.n	800a474 <LSM6DSO16IS_Set_Mem_Bank+0x26>
 800a472:	2302      	movs	r3, #2
  reg = (Val == 2U) ? LSM6DSO16IS_SENSOR_HUB_MEM_BANK
 800a474:	72fb      	strb	r3, [r7, #11]
        :               LSM6DSO16IS_MAIN_MEM_BANK;

  if (lsm6dso16is_mem_bank_set(&(pObj->Ctx), reg) != LSM6DSO16IS_OK)
 800a476:	687b      	ldr	r3, [r7, #4]
 800a478:	3320      	adds	r3, #32
 800a47a:	7afa      	ldrb	r2, [r7, #11]
 800a47c:	4611      	mov	r1, r2
 800a47e:	4618      	mov	r0, r3
 800a480:	f000 fa92 	bl	800a9a8 <lsm6dso16is_mem_bank_set>
 800a484:	4603      	mov	r3, r0
 800a486:	2b00      	cmp	r3, #0
 800a488:	d002      	beq.n	800a490 <LSM6DSO16IS_Set_Mem_Bank+0x42>
  {
    ret = LSM6DSO16IS_ERROR;
 800a48a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a48e:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 800a490:	68fb      	ldr	r3, [r7, #12]
}
 800a492:	4618      	mov	r0, r3
 800a494:	3710      	adds	r7, #16
 800a496:	46bd      	mov	sp, r7
 800a498:	bd80      	pop	{r7, pc}
	...

0800a49c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled(LSM6DSO16IS_Object_t *pObj, float_t Odr)
{
 800a49c:	b580      	push	{r7, lr}
 800a49e:	b084      	sub	sp, #16
 800a4a0:	af00      	add	r7, sp, #0
 800a4a2:	6078      	str	r0, [r7, #4]
 800a4a4:	ed87 0a00 	vstr	s0, [r7]
  int32_t ret = LSM6DSO16IS_OK;
 800a4a8:	2300      	movs	r3, #0
 800a4aa:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_xl_data_rate_t new_odr;

  new_odr = (Odr <=   12.5f) ? LSM6DSO16IS_XL_ODR_AT_12Hz5_HP
            : (Odr <=   26.0f) ? LSM6DSO16IS_XL_ODR_AT_26H_HP
 800a4ac:	edd7 7a00 	vldr	s15, [r7]
 800a4b0:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 800a4b4:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a4b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a4bc:	d801      	bhi.n	800a4c2 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x26>
 800a4be:	2301      	movs	r3, #1
 800a4c0:	e058      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a4c2:	edd7 7a00 	vldr	s15, [r7]
 800a4c6:	eeb3 7a0a 	vmov.f32	s14, #58	@ 0x41d00000  26.0
 800a4ca:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a4ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a4d2:	d801      	bhi.n	800a4d8 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x3c>
 800a4d4:	2302      	movs	r3, #2
 800a4d6:	e04d      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a4d8:	edd7 7a00 	vldr	s15, [r7]
 800a4dc:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 800a59c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x100>
 800a4e0:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a4e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a4e8:	d801      	bhi.n	800a4ee <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x52>
 800a4ea:	2303      	movs	r3, #3
 800a4ec:	e042      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a4ee:	edd7 7a00 	vldr	s15, [r7]
 800a4f2:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 800a5a0 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x104>
 800a4f6:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a4fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a4fe:	d801      	bhi.n	800a504 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x68>
 800a500:	2304      	movs	r3, #4
 800a502:	e037      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a504:	edd7 7a00 	vldr	s15, [r7]
 800a508:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800a5a4 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x108>
 800a50c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a514:	d801      	bhi.n	800a51a <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x7e>
 800a516:	2305      	movs	r3, #5
 800a518:	e02c      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a51a:	edd7 7a00 	vldr	s15, [r7]
 800a51e:	ed9f 7a22 	vldr	s14, [pc, #136]	@ 800a5a8 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x10c>
 800a522:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a526:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a52a:	d801      	bhi.n	800a530 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x94>
 800a52c:	2306      	movs	r3, #6
 800a52e:	e021      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a530:	edd7 7a00 	vldr	s15, [r7]
 800a534:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800a5ac <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x110>
 800a538:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a53c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a540:	d801      	bhi.n	800a546 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xaa>
 800a542:	2307      	movs	r3, #7
 800a544:	e016      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a546:	edd7 7a00 	vldr	s15, [r7]
 800a54a:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 800a5b0 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x114>
 800a54e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a552:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a556:	d801      	bhi.n	800a55c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xc0>
 800a558:	2308      	movs	r3, #8
 800a55a:	e00b      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a55c:	edd7 7a00 	vldr	s15, [r7]
 800a560:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800a5b4 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0x118>
 800a564:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a568:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a56c:	d801      	bhi.n	800a572 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd6>
 800a56e:	2309      	movs	r3, #9
 800a570:	e000      	b.n	800a574 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xd8>
 800a572:	230a      	movs	r3, #10
  new_odr = (Odr <=   12.5f) ? LSM6DSO16IS_XL_ODR_AT_12Hz5_HP
 800a574:	72fb      	strb	r3, [r7, #11]
            : (Odr <= 1667.0f) ? LSM6DSO16IS_XL_ODR_AT_1667Hz_HP
            : (Odr <= 3333.0f) ? LSM6DSO16IS_XL_ODR_AT_3333Hz_HP
            :                    LSM6DSO16IS_XL_ODR_AT_6667Hz_HP;

  /* Output data rate selection. */
  if (lsm6dso16is_xl_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSO16IS_OK)
 800a576:	687b      	ldr	r3, [r7, #4]
 800a578:	3320      	adds	r3, #32
 800a57a:	7afa      	ldrb	r2, [r7, #11]
 800a57c:	4611      	mov	r1, r2
 800a57e:	4618      	mov	r0, r3
 800a580:	f000 fad0 	bl	800ab24 <lsm6dso16is_xl_data_rate_set>
 800a584:	4603      	mov	r3, r0
 800a586:	2b00      	cmp	r3, #0
 800a588:	d002      	beq.n	800a590 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Enabled+0xf4>
  {
    ret = LSM6DSO16IS_ERROR;
 800a58a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a58e:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 800a590:	68fb      	ldr	r3, [r7, #12]
}
 800a592:	4618      	mov	r0, r3
 800a594:	3710      	adds	r7, #16
 800a596:	46bd      	mov	sp, r7
 800a598:	bd80      	pop	{r7, pc}
 800a59a:	bf00      	nop
 800a59c:	42500000 	.word	0x42500000
 800a5a0:	42d00000 	.word	0x42d00000
 800a5a4:	43500000 	.word	0x43500000
 800a5a8:	43d00000 	.word	0x43d00000
 800a5ac:	44504000 	.word	0x44504000
 800a5b0:	44d06000 	.word	0x44d06000
 800a5b4:	45505000 	.word	0x45505000

0800a5b8 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled(LSM6DSO16IS_Object_t *pObj, float_t Odr)
{
 800a5b8:	b480      	push	{r7}
 800a5ba:	b083      	sub	sp, #12
 800a5bc:	af00      	add	r7, sp, #0
 800a5be:	6078      	str	r0, [r7, #4]
 800a5c0:	ed87 0a00 	vstr	s0, [r7]
  pObj->acc_odr = (Odr <=   12.5f) ? LSM6DSO16IS_XL_ODR_AT_12Hz5_HP
                  : (Odr <=   26.0f) ? LSM6DSO16IS_XL_ODR_AT_26H_HP
 800a5c4:	edd7 7a00 	vldr	s15, [r7]
 800a5c8:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 800a5cc:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a5d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a5d4:	d801      	bhi.n	800a5da <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0x22>
 800a5d6:	2301      	movs	r3, #1
 800a5d8:	e058      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a5da:	edd7 7a00 	vldr	s15, [r7]
 800a5de:	eeb3 7a0a 	vmov.f32	s14, #58	@ 0x41d00000  26.0
 800a5e2:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a5e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a5ea:	d801      	bhi.n	800a5f0 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0x38>
 800a5ec:	2302      	movs	r3, #2
 800a5ee:	e04d      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a5f0:	edd7 7a00 	vldr	s15, [r7]
 800a5f4:	ed9f 7a2a 	vldr	s14, [pc, #168]	@ 800a6a0 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xe8>
 800a5f8:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a5fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a600:	d801      	bhi.n	800a606 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0x4e>
 800a602:	2303      	movs	r3, #3
 800a604:	e042      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a606:	edd7 7a00 	vldr	s15, [r7]
 800a60a:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800a6a4 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xec>
 800a60e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a612:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a616:	d801      	bhi.n	800a61c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0x64>
 800a618:	2304      	movs	r3, #4
 800a61a:	e037      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a61c:	edd7 7a00 	vldr	s15, [r7]
 800a620:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 800a6a8 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xf0>
 800a624:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a628:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a62c:	d801      	bhi.n	800a632 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0x7a>
 800a62e:	2305      	movs	r3, #5
 800a630:	e02c      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a632:	edd7 7a00 	vldr	s15, [r7]
 800a636:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800a6ac <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xf4>
 800a63a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a63e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a642:	d801      	bhi.n	800a648 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0x90>
 800a644:	2306      	movs	r3, #6
 800a646:	e021      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a648:	edd7 7a00 	vldr	s15, [r7]
 800a64c:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800a6b0 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xf8>
 800a650:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a654:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a658:	d801      	bhi.n	800a65e <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xa6>
 800a65a:	2307      	movs	r3, #7
 800a65c:	e016      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a65e:	edd7 7a00 	vldr	s15, [r7]
 800a662:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800a6b4 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xfc>
 800a666:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a66a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a66e:	d801      	bhi.n	800a674 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xbc>
 800a670:	2308      	movs	r3, #8
 800a672:	e00b      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a674:	edd7 7a00 	vldr	s15, [r7]
 800a678:	ed9f 7a0f 	vldr	s14, [pc, #60]	@ 800a6b8 <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0x100>
 800a67c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a680:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a684:	d801      	bhi.n	800a68a <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd2>
 800a686:	2309      	movs	r3, #9
 800a688:	e000      	b.n	800a68c <LSM6DSO16IS_ACC_SetOutputDataRate_When_Disabled+0xd4>
 800a68a:	230a      	movs	r3, #10
  pObj->acc_odr = (Odr <=   12.5f) ? LSM6DSO16IS_XL_ODR_AT_12Hz5_HP
 800a68c:	687a      	ldr	r2, [r7, #4]
 800a68e:	f882 3033 	strb.w	r3, [r2, #51]	@ 0x33
                  : (Odr <=  833.0f) ? LSM6DSO16IS_XL_ODR_AT_833Hz_HP
                  : (Odr <= 1667.0f) ? LSM6DSO16IS_XL_ODR_AT_1667Hz_HP
                  : (Odr <= 3333.0f) ? LSM6DSO16IS_XL_ODR_AT_3333Hz_HP
                  :                    LSM6DSO16IS_XL_ODR_AT_6667Hz_HP;

  return LSM6DSO16IS_OK;
 800a692:	2300      	movs	r3, #0
}
 800a694:	4618      	mov	r0, r3
 800a696:	370c      	adds	r7, #12
 800a698:	46bd      	mov	sp, r7
 800a69a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a69e:	4770      	bx	lr
 800a6a0:	42500000 	.word	0x42500000
 800a6a4:	42d00000 	.word	0x42d00000
 800a6a8:	43500000 	.word	0x43500000
 800a6ac:	43d00000 	.word	0x43d00000
 800a6b0:	44504000 	.word	0x44504000
 800a6b4:	44d06000 	.word	0x44d06000
 800a6b8:	45505000 	.word	0x45505000

0800a6bc <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled(LSM6DSO16IS_Object_t *pObj, float_t Odr)
{
 800a6bc:	b580      	push	{r7, lr}
 800a6be:	b084      	sub	sp, #16
 800a6c0:	af00      	add	r7, sp, #0
 800a6c2:	6078      	str	r0, [r7, #4]
 800a6c4:	ed87 0a00 	vstr	s0, [r7]
  int32_t ret = LSM6DSO16IS_OK;
 800a6c8:	2300      	movs	r3, #0
 800a6ca:	60fb      	str	r3, [r7, #12]
  lsm6dso16is_gy_data_rate_t new_odr;

  new_odr = (Odr <=   12.5f) ? LSM6DSO16IS_GY_ODR_AT_12Hz5_HP
            : (Odr <=   26.0f) ? LSM6DSO16IS_GY_ODR_AT_26H_HP
 800a6cc:	edd7 7a00 	vldr	s15, [r7]
 800a6d0:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 800a6d4:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a6d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a6dc:	d801      	bhi.n	800a6e2 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x26>
 800a6de:	2301      	movs	r3, #1
 800a6e0:	e058      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a6e2:	edd7 7a00 	vldr	s15, [r7]
 800a6e6:	eeb3 7a0a 	vmov.f32	s14, #58	@ 0x41d00000  26.0
 800a6ea:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a6ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a6f2:	d801      	bhi.n	800a6f8 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x3c>
 800a6f4:	2302      	movs	r3, #2
 800a6f6:	e04d      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a6f8:	edd7 7a00 	vldr	s15, [r7]
 800a6fc:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 800a7bc <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x100>
 800a700:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a704:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a708:	d801      	bhi.n	800a70e <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x52>
 800a70a:	2303      	movs	r3, #3
 800a70c:	e042      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a70e:	edd7 7a00 	vldr	s15, [r7]
 800a712:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 800a7c0 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x104>
 800a716:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a71a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a71e:	d801      	bhi.n	800a724 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x68>
 800a720:	2304      	movs	r3, #4
 800a722:	e037      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a724:	edd7 7a00 	vldr	s15, [r7]
 800a728:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800a7c4 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x108>
 800a72c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a730:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a734:	d801      	bhi.n	800a73a <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x7e>
 800a736:	2305      	movs	r3, #5
 800a738:	e02c      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a73a:	edd7 7a00 	vldr	s15, [r7]
 800a73e:	ed9f 7a22 	vldr	s14, [pc, #136]	@ 800a7c8 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x10c>
 800a742:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a746:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a74a:	d801      	bhi.n	800a750 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x94>
 800a74c:	2306      	movs	r3, #6
 800a74e:	e021      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a750:	edd7 7a00 	vldr	s15, [r7]
 800a754:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800a7cc <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x110>
 800a758:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a75c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a760:	d801      	bhi.n	800a766 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xaa>
 800a762:	2307      	movs	r3, #7
 800a764:	e016      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a766:	edd7 7a00 	vldr	s15, [r7]
 800a76a:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 800a7d0 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x114>
 800a76e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a772:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a776:	d801      	bhi.n	800a77c <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xc0>
 800a778:	2308      	movs	r3, #8
 800a77a:	e00b      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a77c:	edd7 7a00 	vldr	s15, [r7]
 800a780:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800a7d4 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0x118>
 800a784:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a788:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a78c:	d801      	bhi.n	800a792 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd6>
 800a78e:	2309      	movs	r3, #9
 800a790:	e000      	b.n	800a794 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xd8>
 800a792:	230a      	movs	r3, #10
  new_odr = (Odr <=   12.5f) ? LSM6DSO16IS_GY_ODR_AT_12Hz5_HP
 800a794:	72fb      	strb	r3, [r7, #11]
            : (Odr <= 1667.0f) ? LSM6DSO16IS_GY_ODR_AT_1667Hz_HP
            : (Odr <= 3333.0f) ? LSM6DSO16IS_GY_ODR_AT_3333Hz_HP
            :                    LSM6DSO16IS_GY_ODR_AT_6667Hz_HP;

  /* Output data rate selection. */
  if (lsm6dso16is_gy_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSO16IS_OK)
 800a796:	687b      	ldr	r3, [r7, #4]
 800a798:	3320      	adds	r3, #32
 800a79a:	7afa      	ldrb	r2, [r7, #11]
 800a79c:	4611      	mov	r1, r2
 800a79e:	4618      	mov	r0, r3
 800a7a0:	f000 fb74 	bl	800ae8c <lsm6dso16is_gy_data_rate_set>
 800a7a4:	4603      	mov	r3, r0
 800a7a6:	2b00      	cmp	r3, #0
 800a7a8:	d002      	beq.n	800a7b0 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Enabled+0xf4>
  {
    ret = LSM6DSO16IS_ERROR;
 800a7aa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800a7ae:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 800a7b0:	68fb      	ldr	r3, [r7, #12]
}
 800a7b2:	4618      	mov	r0, r3
 800a7b4:	3710      	adds	r7, #16
 800a7b6:	46bd      	mov	sp, r7
 800a7b8:	bd80      	pop	{r7, pc}
 800a7ba:	bf00      	nop
 800a7bc:	42500000 	.word	0x42500000
 800a7c0:	42d00000 	.word	0x42d00000
 800a7c4:	43500000 	.word	0x43500000
 800a7c8:	43d00000 	.word	0x43d00000
 800a7cc:	44504000 	.word	0x44504000
 800a7d0:	44d06000 	.word	0x44d06000
 800a7d4:	45505000 	.word	0x45505000

0800a7d8 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled(LSM6DSO16IS_Object_t *pObj, float_t Odr)
{
 800a7d8:	b480      	push	{r7}
 800a7da:	b083      	sub	sp, #12
 800a7dc:	af00      	add	r7, sp, #0
 800a7de:	6078      	str	r0, [r7, #4]
 800a7e0:	ed87 0a00 	vstr	s0, [r7]
  pObj->gyro_odr = (Odr <=   12.5f) ? LSM6DSO16IS_GY_ODR_AT_12Hz5_HP
                   : (Odr <=   26.0f) ? LSM6DSO16IS_GY_ODR_AT_26H_HP
 800a7e4:	edd7 7a00 	vldr	s15, [r7]
 800a7e8:	eeb2 7a09 	vmov.f32	s14, #41	@ 0x41480000  12.5
 800a7ec:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a7f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a7f4:	d801      	bhi.n	800a7fa <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0x22>
 800a7f6:	2301      	movs	r3, #1
 800a7f8:	e058      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a7fa:	edd7 7a00 	vldr	s15, [r7]
 800a7fe:	eeb3 7a0a 	vmov.f32	s14, #58	@ 0x41d00000  26.0
 800a802:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a806:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a80a:	d801      	bhi.n	800a810 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0x38>
 800a80c:	2302      	movs	r3, #2
 800a80e:	e04d      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a810:	edd7 7a00 	vldr	s15, [r7]
 800a814:	ed9f 7a2a 	vldr	s14, [pc, #168]	@ 800a8c0 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800a818:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a81c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a820:	d801      	bhi.n	800a826 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0x4e>
 800a822:	2303      	movs	r3, #3
 800a824:	e042      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a826:	edd7 7a00 	vldr	s15, [r7]
 800a82a:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800a8c4 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xec>
 800a82e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a832:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a836:	d801      	bhi.n	800a83c <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0x64>
 800a838:	2304      	movs	r3, #4
 800a83a:	e037      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a83c:	edd7 7a00 	vldr	s15, [r7]
 800a840:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 800a8c8 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xf0>
 800a844:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a848:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a84c:	d801      	bhi.n	800a852 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0x7a>
 800a84e:	2305      	movs	r3, #5
 800a850:	e02c      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a852:	edd7 7a00 	vldr	s15, [r7]
 800a856:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800a8cc <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xf4>
 800a85a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a85e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a862:	d801      	bhi.n	800a868 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0x90>
 800a864:	2306      	movs	r3, #6
 800a866:	e021      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a868:	edd7 7a00 	vldr	s15, [r7]
 800a86c:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800a8d0 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xf8>
 800a870:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a874:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a878:	d801      	bhi.n	800a87e <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xa6>
 800a87a:	2307      	movs	r3, #7
 800a87c:	e016      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a87e:	edd7 7a00 	vldr	s15, [r7]
 800a882:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800a8d4 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xfc>
 800a886:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a88a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a88e:	d801      	bhi.n	800a894 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xbc>
 800a890:	2308      	movs	r3, #8
 800a892:	e00b      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a894:	edd7 7a00 	vldr	s15, [r7]
 800a898:	ed9f 7a0f 	vldr	s14, [pc, #60]	@ 800a8d8 <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0x100>
 800a89c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800a8a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a8a4:	d801      	bhi.n	800a8aa <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd2>
 800a8a6:	2309      	movs	r3, #9
 800a8a8:	e000      	b.n	800a8ac <LSM6DSO16IS_GYRO_SetOutputDataRate_When_Disabled+0xd4>
 800a8aa:	230a      	movs	r3, #10
  pObj->gyro_odr = (Odr <=   12.5f) ? LSM6DSO16IS_GY_ODR_AT_12Hz5_HP
 800a8ac:	687a      	ldr	r2, [r7, #4]
 800a8ae:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
                   : (Odr <=  833.0f) ? LSM6DSO16IS_GY_ODR_AT_833Hz_HP
                   : (Odr <= 1667.0f) ? LSM6DSO16IS_GY_ODR_AT_1667Hz_HP
                   : (Odr <= 3333.0f) ? LSM6DSO16IS_GY_ODR_AT_3333Hz_HP
                   :                    LSM6DSO16IS_GY_ODR_AT_6667Hz_HP;

  return LSM6DSO16IS_OK;
 800a8b2:	2300      	movs	r3, #0
}
 800a8b4:	4618      	mov	r0, r3
 800a8b6:	370c      	adds	r7, #12
 800a8b8:	46bd      	mov	sp, r7
 800a8ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a8be:	4770      	bx	lr
 800a8c0:	42500000 	.word	0x42500000
 800a8c4:	42d00000 	.word	0x42d00000
 800a8c8:	43500000 	.word	0x43500000
 800a8cc:	43d00000 	.word	0x43d00000
 800a8d0:	44504000 	.word	0x44504000
 800a8d4:	44d06000 	.word	0x44d06000
 800a8d8:	45505000 	.word	0x45505000

0800a8dc <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800a8dc:	b590      	push	{r4, r7, lr}
 800a8de:	b087      	sub	sp, #28
 800a8e0:	af00      	add	r7, sp, #0
 800a8e2:	60f8      	str	r0, [r7, #12]
 800a8e4:	607a      	str	r2, [r7, #4]
 800a8e6:	461a      	mov	r2, r3
 800a8e8:	460b      	mov	r3, r1
 800a8ea:	72fb      	strb	r3, [r7, #11]
 800a8ec:	4613      	mov	r3, r2
 800a8ee:	813b      	strh	r3, [r7, #8]
  LSM6DSO16IS_Object_t *pObj = (LSM6DSO16IS_Object_t *)Handle;
 800a8f0:	68fb      	ldr	r3, [r7, #12]
 800a8f2:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 800a8f4:	697b      	ldr	r3, [r7, #20]
 800a8f6:	695c      	ldr	r4, [r3, #20]
 800a8f8:	697b      	ldr	r3, [r7, #20]
 800a8fa:	7b1b      	ldrb	r3, [r3, #12]
 800a8fc:	4618      	mov	r0, r3
 800a8fe:	7afb      	ldrb	r3, [r7, #11]
 800a900:	b299      	uxth	r1, r3
 800a902:	893b      	ldrh	r3, [r7, #8]
 800a904:	687a      	ldr	r2, [r7, #4]
 800a906:	47a0      	blx	r4
 800a908:	4603      	mov	r3, r0
}
 800a90a:	4618      	mov	r0, r3
 800a90c:	371c      	adds	r7, #28
 800a90e:	46bd      	mov	sp, r7
 800a910:	bd90      	pop	{r4, r7, pc}

0800a912 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800a912:	b590      	push	{r4, r7, lr}
 800a914:	b087      	sub	sp, #28
 800a916:	af00      	add	r7, sp, #0
 800a918:	60f8      	str	r0, [r7, #12]
 800a91a:	607a      	str	r2, [r7, #4]
 800a91c:	461a      	mov	r2, r3
 800a91e:	460b      	mov	r3, r1
 800a920:	72fb      	strb	r3, [r7, #11]
 800a922:	4613      	mov	r3, r2
 800a924:	813b      	strh	r3, [r7, #8]
  LSM6DSO16IS_Object_t *pObj = (LSM6DSO16IS_Object_t *)Handle;
 800a926:	68fb      	ldr	r3, [r7, #12]
 800a928:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800a92a:	697b      	ldr	r3, [r7, #20]
 800a92c:	691c      	ldr	r4, [r3, #16]
 800a92e:	697b      	ldr	r3, [r7, #20]
 800a930:	7b1b      	ldrb	r3, [r3, #12]
 800a932:	4618      	mov	r0, r3
 800a934:	7afb      	ldrb	r3, [r7, #11]
 800a936:	b299      	uxth	r1, r3
 800a938:	893b      	ldrh	r3, [r7, #8]
 800a93a:	687a      	ldr	r2, [r7, #4]
 800a93c:	47a0      	blx	r4
 800a93e:	4603      	mov	r3, r0
}
 800a940:	4618      	mov	r0, r3
 800a942:	371c      	adds	r7, #28
 800a944:	46bd      	mov	sp, r7
 800a946:	bd90      	pop	{r4, r7, pc}

0800a948 <lsm6dso16is_read_reg>:
  *
  */
int32_t __weak lsm6dso16is_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                    uint8_t *data,
                                    uint16_t len)
{
 800a948:	b590      	push	{r4, r7, lr}
 800a94a:	b087      	sub	sp, #28
 800a94c:	af00      	add	r7, sp, #0
 800a94e:	60f8      	str	r0, [r7, #12]
 800a950:	607a      	str	r2, [r7, #4]
 800a952:	461a      	mov	r2, r3
 800a954:	460b      	mov	r3, r1
 800a956:	72fb      	strb	r3, [r7, #11]
 800a958:	4613      	mov	r3, r2
 800a95a:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800a95c:	68fb      	ldr	r3, [r7, #12]
 800a95e:	685c      	ldr	r4, [r3, #4]
 800a960:	68fb      	ldr	r3, [r7, #12]
 800a962:	68d8      	ldr	r0, [r3, #12]
 800a964:	893b      	ldrh	r3, [r7, #8]
 800a966:	7af9      	ldrb	r1, [r7, #11]
 800a968:	687a      	ldr	r2, [r7, #4]
 800a96a:	47a0      	blx	r4
 800a96c:	6178      	str	r0, [r7, #20]

  return ret;
 800a96e:	697b      	ldr	r3, [r7, #20]
}
 800a970:	4618      	mov	r0, r3
 800a972:	371c      	adds	r7, #28
 800a974:	46bd      	mov	sp, r7
 800a976:	bd90      	pop	{r4, r7, pc}

0800a978 <lsm6dso16is_write_reg>:
  *
  */
int32_t __weak lsm6dso16is_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                     uint8_t *data,
                                     uint16_t len)
{
 800a978:	b590      	push	{r4, r7, lr}
 800a97a:	b087      	sub	sp, #28
 800a97c:	af00      	add	r7, sp, #0
 800a97e:	60f8      	str	r0, [r7, #12]
 800a980:	607a      	str	r2, [r7, #4]
 800a982:	461a      	mov	r2, r3
 800a984:	460b      	mov	r3, r1
 800a986:	72fb      	strb	r3, [r7, #11]
 800a988:	4613      	mov	r3, r2
 800a98a:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800a98c:	68fb      	ldr	r3, [r7, #12]
 800a98e:	681c      	ldr	r4, [r3, #0]
 800a990:	68fb      	ldr	r3, [r7, #12]
 800a992:	68d8      	ldr	r0, [r3, #12]
 800a994:	893b      	ldrh	r3, [r7, #8]
 800a996:	7af9      	ldrb	r1, [r7, #11]
 800a998:	687a      	ldr	r2, [r7, #4]
 800a99a:	47a0      	blx	r4
 800a99c:	6178      	str	r0, [r7, #20]

  return ret;
 800a99e:	697b      	ldr	r3, [r7, #20]
}
 800a9a0:	4618      	mov	r0, r3
 800a9a2:	371c      	adds	r7, #28
 800a9a4:	46bd      	mov	sp, r7
 800a9a6:	bd90      	pop	{r4, r7, pc}

0800a9a8 <lsm6dso16is_mem_bank_set>:
  * @param  val      MAIN_MEM_BANK, EMBED_FUNC_MEM_BANK, SENSOR_HUB_MEM_BANK, ISPU_MEM_BANK,
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_mem_bank_set(stmdev_ctx_t *ctx, lsm6dso16is_mem_bank_t val)
{
 800a9a8:	b580      	push	{r7, lr}
 800a9aa:	b084      	sub	sp, #16
 800a9ac:	af00      	add	r7, sp, #0
 800a9ae:	6078      	str	r0, [r7, #4]
 800a9b0:	460b      	mov	r3, r1
 800a9b2:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_func_cfg_access_t func_cfg_access = {0x0};
 800a9b4:	2300      	movs	r3, #0
 800a9b6:	723b      	strb	r3, [r7, #8]
  int32_t ret;

  /* no need to read it first as the only other field is a ispu reset bit */
  func_cfg_access.shub_reg_access = (val == LSM6DSO16IS_SENSOR_HUB_MEM_BANK) ? 0x1U : 0x0U;
 800a9b8:	78fb      	ldrb	r3, [r7, #3]
 800a9ba:	2b02      	cmp	r3, #2
 800a9bc:	d101      	bne.n	800a9c2 <lsm6dso16is_mem_bank_set+0x1a>
 800a9be:	2201      	movs	r2, #1
 800a9c0:	e000      	b.n	800a9c4 <lsm6dso16is_mem_bank_set+0x1c>
 800a9c2:	2200      	movs	r2, #0
 800a9c4:	7a3b      	ldrb	r3, [r7, #8]
 800a9c6:	f362 1386 	bfi	r3, r2, #6, #1
 800a9ca:	723b      	strb	r3, [r7, #8]
  func_cfg_access.ispu_reg_access = (val == LSM6DSO16IS_ISPU_MEM_BANK) ? 0x1U : 0x0U;
 800a9cc:	78fb      	ldrb	r3, [r7, #3]
 800a9ce:	2b03      	cmp	r3, #3
 800a9d0:	d101      	bne.n	800a9d6 <lsm6dso16is_mem_bank_set+0x2e>
 800a9d2:	2201      	movs	r2, #1
 800a9d4:	e000      	b.n	800a9d8 <lsm6dso16is_mem_bank_set+0x30>
 800a9d6:	2200      	movs	r2, #0
 800a9d8:	7a3b      	ldrb	r3, [r7, #8]
 800a9da:	f362 13c7 	bfi	r3, r2, #7, #1
 800a9de:	723b      	strb	r3, [r7, #8]
  ret = lsm6dso16is_write_reg(ctx, LSM6DSO16IS_FUNC_CFG_ACCESS, (uint8_t *)&func_cfg_access, 1);
 800a9e0:	f107 0208 	add.w	r2, r7, #8
 800a9e4:	2301      	movs	r3, #1
 800a9e6:	2101      	movs	r1, #1
 800a9e8:	6878      	ldr	r0, [r7, #4]
 800a9ea:	f7ff ffc5 	bl	800a978 <lsm6dso16is_write_reg>
 800a9ee:	60f8      	str	r0, [r7, #12]

  return ret;
 800a9f0:	68fb      	ldr	r3, [r7, #12]
}
 800a9f2:	4618      	mov	r0, r3
 800a9f4:	3710      	adds	r7, #16
 800a9f6:	46bd      	mov	sp, r7
 800a9f8:	bd80      	pop	{r7, pc}

0800a9fa <lsm6dso16is_device_id_get>:
  * @param  val      Device ID.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_device_id_get(stmdev_ctx_t *ctx, uint8_t *val)
{
 800a9fa:	b580      	push	{r7, lr}
 800a9fc:	b084      	sub	sp, #16
 800a9fe:	af00      	add	r7, sp, #0
 800aa00:	6078      	str	r0, [r7, #4]
 800aa02:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_WHO_AM_I, (uint8_t *)val, 1);
 800aa04:	2301      	movs	r3, #1
 800aa06:	683a      	ldr	r2, [r7, #0]
 800aa08:	210f      	movs	r1, #15
 800aa0a:	6878      	ldr	r0, [r7, #4]
 800aa0c:	f7ff ff9c 	bl	800a948 <lsm6dso16is_read_reg>
 800aa10:	60f8      	str	r0, [r7, #12]

  return ret;
 800aa12:	68fb      	ldr	r3, [r7, #12]
}
 800aa14:	4618      	mov	r0, r3
 800aa16:	3710      	adds	r7, #16
 800aa18:	46bd      	mov	sp, r7
 800aa1a:	bd80      	pop	{r7, pc}

0800aa1c <lsm6dso16is_xl_hm_mode_set>:
  * @param  val      HIGH_PERFOMANCE_MODE_ENABLED, HIGH_PERFOMANCE_MODE_DISABLED,
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_xl_hm_mode_set(stmdev_ctx_t *ctx, lsm6dso16is_hm_mode_t val)
{
 800aa1c:	b580      	push	{r7, lr}
 800aa1e:	b084      	sub	sp, #16
 800aa20:	af00      	add	r7, sp, #0
 800aa22:	6078      	str	r0, [r7, #4]
 800aa24:	460b      	mov	r3, r1
 800aa26:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl6_c_t ctrl6_c;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL6_C, (uint8_t *)&ctrl6_c, 1);
 800aa28:	f107 0208 	add.w	r2, r7, #8
 800aa2c:	2301      	movs	r3, #1
 800aa2e:	2115      	movs	r1, #21
 800aa30:	6878      	ldr	r0, [r7, #4]
 800aa32:	f7ff ff89 	bl	800a948 <lsm6dso16is_read_reg>
 800aa36:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800aa38:	68fb      	ldr	r3, [r7, #12]
 800aa3a:	2b00      	cmp	r3, #0
 800aa3c:	d10f      	bne.n	800aa5e <lsm6dso16is_xl_hm_mode_set+0x42>
  {
    ctrl6_c.xl_hm_mode = ((uint8_t)val & 0x1U);
 800aa3e:	78fb      	ldrb	r3, [r7, #3]
 800aa40:	f003 0301 	and.w	r3, r3, #1
 800aa44:	b2da      	uxtb	r2, r3
 800aa46:	7a3b      	ldrb	r3, [r7, #8]
 800aa48:	f362 1304 	bfi	r3, r2, #4, #1
 800aa4c:	723b      	strb	r3, [r7, #8]
    ret = lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL6_C, (uint8_t *)&ctrl6_c, 1);
 800aa4e:	f107 0208 	add.w	r2, r7, #8
 800aa52:	2301      	movs	r3, #1
 800aa54:	2115      	movs	r1, #21
 800aa56:	6878      	ldr	r0, [r7, #4]
 800aa58:	f7ff ff8e 	bl	800a978 <lsm6dso16is_write_reg>
 800aa5c:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800aa5e:	68fb      	ldr	r3, [r7, #12]
}
 800aa60:	4618      	mov	r0, r3
 800aa62:	3710      	adds	r7, #16
 800aa64:	46bd      	mov	sp, r7
 800aa66:	bd80      	pop	{r7, pc}

0800aa68 <lsm6dso16is_xl_full_scale_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_xl_full_scale_set(stmdev_ctx_t *ctx,
                                      lsm6dso16is_xl_full_scale_t val)
{
 800aa68:	b580      	push	{r7, lr}
 800aa6a:	b084      	sub	sp, #16
 800aa6c:	af00      	add	r7, sp, #0
 800aa6e:	6078      	str	r0, [r7, #4]
 800aa70:	460b      	mov	r3, r1
 800aa72:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL1_XL, (uint8_t *)&ctrl1_xl, 1);
 800aa74:	f107 0208 	add.w	r2, r7, #8
 800aa78:	2301      	movs	r3, #1
 800aa7a:	2110      	movs	r1, #16
 800aa7c:	6878      	ldr	r0, [r7, #4]
 800aa7e:	f7ff ff63 	bl	800a948 <lsm6dso16is_read_reg>
 800aa82:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800aa84:	68fb      	ldr	r3, [r7, #12]
 800aa86:	2b00      	cmp	r3, #0
 800aa88:	d10f      	bne.n	800aaaa <lsm6dso16is_xl_full_scale_set+0x42>
  {
    ctrl1_xl.fs_xl = ((uint8_t)val & 0x3U);
 800aa8a:	78fb      	ldrb	r3, [r7, #3]
 800aa8c:	f003 0303 	and.w	r3, r3, #3
 800aa90:	b2da      	uxtb	r2, r3
 800aa92:	7a3b      	ldrb	r3, [r7, #8]
 800aa94:	f362 0383 	bfi	r3, r2, #2, #2
 800aa98:	723b      	strb	r3, [r7, #8]
    ret = lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL1_XL, (uint8_t *)&ctrl1_xl, 1);
 800aa9a:	f107 0208 	add.w	r2, r7, #8
 800aa9e:	2301      	movs	r3, #1
 800aaa0:	2110      	movs	r1, #16
 800aaa2:	6878      	ldr	r0, [r7, #4]
 800aaa4:	f7ff ff68 	bl	800a978 <lsm6dso16is_write_reg>
 800aaa8:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800aaaa:	68fb      	ldr	r3, [r7, #12]
}
 800aaac:	4618      	mov	r0, r3
 800aaae:	3710      	adds	r7, #16
 800aab0:	46bd      	mov	sp, r7
 800aab2:	bd80      	pop	{r7, pc}

0800aab4 <lsm6dso16is_xl_full_scale_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_xl_full_scale_get(stmdev_ctx_t *ctx,
                                      lsm6dso16is_xl_full_scale_t *val)
{
 800aab4:	b580      	push	{r7, lr}
 800aab6:	b084      	sub	sp, #16
 800aab8:	af00      	add	r7, sp, #0
 800aaba:	6078      	str	r0, [r7, #4]
 800aabc:	6039      	str	r1, [r7, #0]
  lsm6dso16is_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL1_XL, (uint8_t *)&ctrl1_xl, 1);
 800aabe:	f107 0208 	add.w	r2, r7, #8
 800aac2:	2301      	movs	r3, #1
 800aac4:	2110      	movs	r1, #16
 800aac6:	6878      	ldr	r0, [r7, #4]
 800aac8:	f7ff ff3e 	bl	800a948 <lsm6dso16is_read_reg>
 800aacc:	60f8      	str	r0, [r7, #12]

  switch ((ctrl1_xl.fs_xl))
 800aace:	7a3b      	ldrb	r3, [r7, #8]
 800aad0:	f3c3 0381 	ubfx	r3, r3, #2, #2
 800aad4:	b2db      	uxtb	r3, r3
 800aad6:	2b03      	cmp	r3, #3
 800aad8:	d81a      	bhi.n	800ab10 <lsm6dso16is_xl_full_scale_get+0x5c>
 800aada:	a201      	add	r2, pc, #4	@ (adr r2, 800aae0 <lsm6dso16is_xl_full_scale_get+0x2c>)
 800aadc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800aae0:	0800aaf1 	.word	0x0800aaf1
 800aae4:	0800ab09 	.word	0x0800ab09
 800aae8:	0800aaf9 	.word	0x0800aaf9
 800aaec:	0800ab01 	.word	0x0800ab01
  {
    case LSM6DSO16IS_2g:
      *val = LSM6DSO16IS_2g;
 800aaf0:	683b      	ldr	r3, [r7, #0]
 800aaf2:	2200      	movs	r2, #0
 800aaf4:	701a      	strb	r2, [r3, #0]
      break;
 800aaf6:	e00f      	b.n	800ab18 <lsm6dso16is_xl_full_scale_get+0x64>

    case LSM6DSO16IS_4g:
      *val = LSM6DSO16IS_4g;
 800aaf8:	683b      	ldr	r3, [r7, #0]
 800aafa:	2202      	movs	r2, #2
 800aafc:	701a      	strb	r2, [r3, #0]
      break;
 800aafe:	e00b      	b.n	800ab18 <lsm6dso16is_xl_full_scale_get+0x64>

    case LSM6DSO16IS_8g:
      *val = LSM6DSO16IS_8g;
 800ab00:	683b      	ldr	r3, [r7, #0]
 800ab02:	2203      	movs	r2, #3
 800ab04:	701a      	strb	r2, [r3, #0]
      break;
 800ab06:	e007      	b.n	800ab18 <lsm6dso16is_xl_full_scale_get+0x64>

    case LSM6DSO16IS_16g:
      *val = LSM6DSO16IS_16g;
 800ab08:	683b      	ldr	r3, [r7, #0]
 800ab0a:	2201      	movs	r2, #1
 800ab0c:	701a      	strb	r2, [r3, #0]
      break;
 800ab0e:	e003      	b.n	800ab18 <lsm6dso16is_xl_full_scale_get+0x64>

    default:
      *val = LSM6DSO16IS_2g;
 800ab10:	683b      	ldr	r3, [r7, #0]
 800ab12:	2200      	movs	r2, #0
 800ab14:	701a      	strb	r2, [r3, #0]
      break;
 800ab16:	bf00      	nop
  }
  return ret;
 800ab18:	68fb      	ldr	r3, [r7, #12]
}
 800ab1a:	4618      	mov	r0, r3
 800ab1c:	3710      	adds	r7, #16
 800ab1e:	46bd      	mov	sp, r7
 800ab20:	bd80      	pop	{r7, pc}
 800ab22:	bf00      	nop

0800ab24 <lsm6dso16is_xl_data_rate_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_xl_data_rate_set(stmdev_ctx_t *ctx,
                                     lsm6dso16is_xl_data_rate_t val)
{
 800ab24:	b580      	push	{r7, lr}
 800ab26:	b084      	sub	sp, #16
 800ab28:	af00      	add	r7, sp, #0
 800ab2a:	6078      	str	r0, [r7, #4]
 800ab2c:	460b      	mov	r3, r1
 800ab2e:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl1_xl_t ctrl1_xl;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL1_XL, (uint8_t *)&ctrl1_xl, 1);
 800ab30:	f107 0208 	add.w	r2, r7, #8
 800ab34:	2301      	movs	r3, #1
 800ab36:	2110      	movs	r1, #16
 800ab38:	6878      	ldr	r0, [r7, #4]
 800ab3a:	f7ff ff05 	bl	800a948 <lsm6dso16is_read_reg>
 800ab3e:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800ab40:	68fb      	ldr	r3, [r7, #12]
 800ab42:	2b00      	cmp	r3, #0
 800ab44:	d128      	bne.n	800ab98 <lsm6dso16is_xl_data_rate_set+0x74>
  {
    if (((uint8_t)val & 0x10U) == 0x10U)
 800ab46:	78fb      	ldrb	r3, [r7, #3]
 800ab48:	f003 0310 	and.w	r3, r3, #16
 800ab4c:	2b00      	cmp	r3, #0
 800ab4e:	d008      	beq.n	800ab62 <lsm6dso16is_xl_data_rate_set+0x3e>
    {
      ret += lsm6dso16is_xl_hm_mode_set(ctx, LSM6DSO16IS_HIGH_PERFOMANCE_MODE_DISABLED);
 800ab50:	2101      	movs	r1, #1
 800ab52:	6878      	ldr	r0, [r7, #4]
 800ab54:	f7ff ff62 	bl	800aa1c <lsm6dso16is_xl_hm_mode_set>
 800ab58:	4602      	mov	r2, r0
 800ab5a:	68fb      	ldr	r3, [r7, #12]
 800ab5c:	4413      	add	r3, r2
 800ab5e:	60fb      	str	r3, [r7, #12]
 800ab60:	e007      	b.n	800ab72 <lsm6dso16is_xl_data_rate_set+0x4e>
    }
    else
    {
      ret += lsm6dso16is_xl_hm_mode_set(ctx, LSM6DSO16IS_HIGH_PERFOMANCE_MODE_ENABLED);
 800ab62:	2100      	movs	r1, #0
 800ab64:	6878      	ldr	r0, [r7, #4]
 800ab66:	f7ff ff59 	bl	800aa1c <lsm6dso16is_xl_hm_mode_set>
 800ab6a:	4602      	mov	r2, r0
 800ab6c:	68fb      	ldr	r3, [r7, #12]
 800ab6e:	4413      	add	r3, r2
 800ab70:	60fb      	str	r3, [r7, #12]
    }

    ctrl1_xl.odr_xl = ((uint8_t)val & 0xfU);
 800ab72:	78fb      	ldrb	r3, [r7, #3]
 800ab74:	f003 030f 	and.w	r3, r3, #15
 800ab78:	b2da      	uxtb	r2, r3
 800ab7a:	7a3b      	ldrb	r3, [r7, #8]
 800ab7c:	f362 1307 	bfi	r3, r2, #4, #4
 800ab80:	723b      	strb	r3, [r7, #8]
    ret += lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL1_XL, (uint8_t *)&ctrl1_xl, 1);
 800ab82:	f107 0208 	add.w	r2, r7, #8
 800ab86:	2301      	movs	r3, #1
 800ab88:	2110      	movs	r1, #16
 800ab8a:	6878      	ldr	r0, [r7, #4]
 800ab8c:	f7ff fef4 	bl	800a978 <lsm6dso16is_write_reg>
 800ab90:	4602      	mov	r2, r0
 800ab92:	68fb      	ldr	r3, [r7, #12]
 800ab94:	4413      	add	r3, r2
 800ab96:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 800ab98:	68fb      	ldr	r3, [r7, #12]
}
 800ab9a:	4618      	mov	r0, r3
 800ab9c:	3710      	adds	r7, #16
 800ab9e:	46bd      	mov	sp, r7
 800aba0:	bd80      	pop	{r7, pc}
	...

0800aba4 <lsm6dso16is_xl_data_rate_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_xl_data_rate_get(stmdev_ctx_t *ctx,
                                     lsm6dso16is_xl_data_rate_t *val)
{
 800aba4:	b580      	push	{r7, lr}
 800aba6:	b086      	sub	sp, #24
 800aba8:	af00      	add	r7, sp, #0
 800abaa:	6078      	str	r0, [r7, #4]
 800abac:	6039      	str	r1, [r7, #0]
  lsm6dso16is_ctrl1_xl_t ctrl1_xl;
  lsm6dso16is_ctrl6_c_t ctrl6_c;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL1_XL, (uint8_t *)&ctrl1_xl, 1);
 800abae:	f107 0210 	add.w	r2, r7, #16
 800abb2:	2301      	movs	r3, #1
 800abb4:	2110      	movs	r1, #16
 800abb6:	6878      	ldr	r0, [r7, #4]
 800abb8:	f7ff fec6 	bl	800a948 <lsm6dso16is_read_reg>
 800abbc:	6178      	str	r0, [r7, #20]
  ret += lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL6_C, (uint8_t *)&ctrl6_c, 1);
 800abbe:	f107 020c 	add.w	r2, r7, #12
 800abc2:	2301      	movs	r3, #1
 800abc4:	2115      	movs	r1, #21
 800abc6:	6878      	ldr	r0, [r7, #4]
 800abc8:	f7ff febe 	bl	800a948 <lsm6dso16is_read_reg>
 800abcc:	4602      	mov	r2, r0
 800abce:	697b      	ldr	r3, [r7, #20]
 800abd0:	4413      	add	r3, r2
 800abd2:	617b      	str	r3, [r7, #20]

  switch ((ctrl6_c.xl_hm_mode << 4) | (ctrl1_xl.odr_xl))
 800abd4:	7b3b      	ldrb	r3, [r7, #12]
 800abd6:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800abda:	b2db      	uxtb	r3, r3
 800abdc:	011b      	lsls	r3, r3, #4
 800abde:	7c3a      	ldrb	r2, [r7, #16]
 800abe0:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800abe4:	b2d2      	uxtb	r2, r2
 800abe6:	4313      	orrs	r3, r2
 800abe8:	2b1b      	cmp	r3, #27
 800abea:	f200 8093 	bhi.w	800ad14 <lsm6dso16is_xl_data_rate_get+0x170>
 800abee:	a201      	add	r2, pc, #4	@ (adr r2, 800abf4 <lsm6dso16is_xl_data_rate_get+0x50>)
 800abf0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800abf4:	0800ac65 	.word	0x0800ac65
 800abf8:	0800ac6d 	.word	0x0800ac6d
 800abfc:	0800ac75 	.word	0x0800ac75
 800ac00:	0800ac7d 	.word	0x0800ac7d
 800ac04:	0800ac85 	.word	0x0800ac85
 800ac08:	0800ac8d 	.word	0x0800ac8d
 800ac0c:	0800ac95 	.word	0x0800ac95
 800ac10:	0800ac9d 	.word	0x0800ac9d
 800ac14:	0800aca5 	.word	0x0800aca5
 800ac18:	0800acad 	.word	0x0800acad
 800ac1c:	0800acb5 	.word	0x0800acb5
 800ac20:	0800ad15 	.word	0x0800ad15
 800ac24:	0800ad15 	.word	0x0800ad15
 800ac28:	0800ad15 	.word	0x0800ad15
 800ac2c:	0800ad15 	.word	0x0800ad15
 800ac30:	0800ad15 	.word	0x0800ad15
 800ac34:	0800ad15 	.word	0x0800ad15
 800ac38:	0800acbd 	.word	0x0800acbd
 800ac3c:	0800acc5 	.word	0x0800acc5
 800ac40:	0800accd 	.word	0x0800accd
 800ac44:	0800acd5 	.word	0x0800acd5
 800ac48:	0800acdd 	.word	0x0800acdd
 800ac4c:	0800ace5 	.word	0x0800ace5
 800ac50:	0800aced 	.word	0x0800aced
 800ac54:	0800acf5 	.word	0x0800acf5
 800ac58:	0800acfd 	.word	0x0800acfd
 800ac5c:	0800ad05 	.word	0x0800ad05
 800ac60:	0800ad0d 	.word	0x0800ad0d
  {
    case LSM6DSO16IS_XL_ODR_OFF:
      *val = LSM6DSO16IS_XL_ODR_OFF;
 800ac64:	683b      	ldr	r3, [r7, #0]
 800ac66:	2200      	movs	r2, #0
 800ac68:	701a      	strb	r2, [r3, #0]
      break;
 800ac6a:	e057      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_12Hz5_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_12Hz5_HP;
 800ac6c:	683b      	ldr	r3, [r7, #0]
 800ac6e:	2201      	movs	r2, #1
 800ac70:	701a      	strb	r2, [r3, #0]
      break;
 800ac72:	e053      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_26H_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_26H_HP;
 800ac74:	683b      	ldr	r3, [r7, #0]
 800ac76:	2202      	movs	r2, #2
 800ac78:	701a      	strb	r2, [r3, #0]
      break;
 800ac7a:	e04f      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_52Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_52Hz_HP;
 800ac7c:	683b      	ldr	r3, [r7, #0]
 800ac7e:	2203      	movs	r2, #3
 800ac80:	701a      	strb	r2, [r3, #0]
      break;
 800ac82:	e04b      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_104Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_104Hz_HP;
 800ac84:	683b      	ldr	r3, [r7, #0]
 800ac86:	2204      	movs	r2, #4
 800ac88:	701a      	strb	r2, [r3, #0]
      break;
 800ac8a:	e047      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_208Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_208Hz_HP;
 800ac8c:	683b      	ldr	r3, [r7, #0]
 800ac8e:	2205      	movs	r2, #5
 800ac90:	701a      	strb	r2, [r3, #0]
      break;
 800ac92:	e043      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_416Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_416Hz_HP;
 800ac94:	683b      	ldr	r3, [r7, #0]
 800ac96:	2206      	movs	r2, #6
 800ac98:	701a      	strb	r2, [r3, #0]
      break;
 800ac9a:	e03f      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_833Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_833Hz_HP;
 800ac9c:	683b      	ldr	r3, [r7, #0]
 800ac9e:	2207      	movs	r2, #7
 800aca0:	701a      	strb	r2, [r3, #0]
      break;
 800aca2:	e03b      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_1667Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_1667Hz_HP;
 800aca4:	683b      	ldr	r3, [r7, #0]
 800aca6:	2208      	movs	r2, #8
 800aca8:	701a      	strb	r2, [r3, #0]
      break;
 800acaa:	e037      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_3333Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_3333Hz_HP;
 800acac:	683b      	ldr	r3, [r7, #0]
 800acae:	2209      	movs	r2, #9
 800acb0:	701a      	strb	r2, [r3, #0]
      break;
 800acb2:	e033      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_6667Hz_HP:
      *val = LSM6DSO16IS_XL_ODR_AT_6667Hz_HP;
 800acb4:	683b      	ldr	r3, [r7, #0]
 800acb6:	220a      	movs	r2, #10
 800acb8:	701a      	strb	r2, [r3, #0]
      break;
 800acba:	e02f      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_12Hz5_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_12Hz5_LP;
 800acbc:	683b      	ldr	r3, [r7, #0]
 800acbe:	2211      	movs	r2, #17
 800acc0:	701a      	strb	r2, [r3, #0]
      break;
 800acc2:	e02b      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_26H_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_26H_LP;
 800acc4:	683b      	ldr	r3, [r7, #0]
 800acc6:	2212      	movs	r2, #18
 800acc8:	701a      	strb	r2, [r3, #0]
      break;
 800acca:	e027      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_52Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_52Hz_LP;
 800accc:	683b      	ldr	r3, [r7, #0]
 800acce:	2213      	movs	r2, #19
 800acd0:	701a      	strb	r2, [r3, #0]
      break;
 800acd2:	e023      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_104Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_104Hz_LP;
 800acd4:	683b      	ldr	r3, [r7, #0]
 800acd6:	2214      	movs	r2, #20
 800acd8:	701a      	strb	r2, [r3, #0]
      break;
 800acda:	e01f      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_208Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_208Hz_LP;
 800acdc:	683b      	ldr	r3, [r7, #0]
 800acde:	2215      	movs	r2, #21
 800ace0:	701a      	strb	r2, [r3, #0]
      break;
 800ace2:	e01b      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_416Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_416Hz_LP;
 800ace4:	683b      	ldr	r3, [r7, #0]
 800ace6:	2216      	movs	r2, #22
 800ace8:	701a      	strb	r2, [r3, #0]
      break;
 800acea:	e017      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_833Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_833Hz_LP;
 800acec:	683b      	ldr	r3, [r7, #0]
 800acee:	2217      	movs	r2, #23
 800acf0:	701a      	strb	r2, [r3, #0]
      break;
 800acf2:	e013      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_1667Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_1667Hz_LP;
 800acf4:	683b      	ldr	r3, [r7, #0]
 800acf6:	2218      	movs	r2, #24
 800acf8:	701a      	strb	r2, [r3, #0]
      break;
 800acfa:	e00f      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_3333Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_3333Hz_LP;
 800acfc:	683b      	ldr	r3, [r7, #0]
 800acfe:	2219      	movs	r2, #25
 800ad00:	701a      	strb	r2, [r3, #0]
      break;
 800ad02:	e00b      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_6667Hz_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_6667Hz_LP;
 800ad04:	683b      	ldr	r3, [r7, #0]
 800ad06:	221a      	movs	r2, #26
 800ad08:	701a      	strb	r2, [r3, #0]
      break;
 800ad0a:	e007      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    case LSM6DSO16IS_XL_ODR_AT_1Hz6_LP:
      *val = LSM6DSO16IS_XL_ODR_AT_1Hz6_LP;
 800ad0c:	683b      	ldr	r3, [r7, #0]
 800ad0e:	221b      	movs	r2, #27
 800ad10:	701a      	strb	r2, [r3, #0]
      break;
 800ad12:	e003      	b.n	800ad1c <lsm6dso16is_xl_data_rate_get+0x178>

    default:
      *val = LSM6DSO16IS_XL_ODR_OFF;
 800ad14:	683b      	ldr	r3, [r7, #0]
 800ad16:	2200      	movs	r2, #0
 800ad18:	701a      	strb	r2, [r3, #0]
      break;
 800ad1a:	bf00      	nop
  }

  return ret;
 800ad1c:	697b      	ldr	r3, [r7, #20]
}
 800ad1e:	4618      	mov	r0, r3
 800ad20:	3718      	adds	r7, #24
 800ad22:	46bd      	mov	sp, r7
 800ad24:	bd80      	pop	{r7, pc}
 800ad26:	bf00      	nop

0800ad28 <lsm6dso16is_gy_hm_mode_set>:
  * @param  val      HIGH_PERFOMANCE_MODE_ENABLED, HIGH_PERFOMANCE_MODE_DISABLED,
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_gy_hm_mode_set(stmdev_ctx_t *ctx, lsm6dso16is_hm_mode_t val)
{
 800ad28:	b580      	push	{r7, lr}
 800ad2a:	b084      	sub	sp, #16
 800ad2c:	af00      	add	r7, sp, #0
 800ad2e:	6078      	str	r0, [r7, #4]
 800ad30:	460b      	mov	r3, r1
 800ad32:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl7_g_t ctrl7_g;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL7_G, (uint8_t *)&ctrl7_g, 1);
 800ad34:	f107 0208 	add.w	r2, r7, #8
 800ad38:	2301      	movs	r3, #1
 800ad3a:	2116      	movs	r1, #22
 800ad3c:	6878      	ldr	r0, [r7, #4]
 800ad3e:	f7ff fe03 	bl	800a948 <lsm6dso16is_read_reg>
 800ad42:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800ad44:	68fb      	ldr	r3, [r7, #12]
 800ad46:	2b00      	cmp	r3, #0
 800ad48:	d10f      	bne.n	800ad6a <lsm6dso16is_gy_hm_mode_set+0x42>
  {
    ctrl7_g.g_hm_mode = ((uint8_t)val & 0x1U);
 800ad4a:	78fb      	ldrb	r3, [r7, #3]
 800ad4c:	f003 0301 	and.w	r3, r3, #1
 800ad50:	b2da      	uxtb	r2, r3
 800ad52:	7a3b      	ldrb	r3, [r7, #8]
 800ad54:	f362 13c7 	bfi	r3, r2, #7, #1
 800ad58:	723b      	strb	r3, [r7, #8]
    ret = lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL7_G, (uint8_t *)&ctrl7_g, 1);
 800ad5a:	f107 0208 	add.w	r2, r7, #8
 800ad5e:	2301      	movs	r3, #1
 800ad60:	2116      	movs	r1, #22
 800ad62:	6878      	ldr	r0, [r7, #4]
 800ad64:	f7ff fe08 	bl	800a978 <lsm6dso16is_write_reg>
 800ad68:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800ad6a:	68fb      	ldr	r3, [r7, #12]
}
 800ad6c:	4618      	mov	r0, r3
 800ad6e:	3710      	adds	r7, #16
 800ad70:	46bd      	mov	sp, r7
 800ad72:	bd80      	pop	{r7, pc}

0800ad74 <lsm6dso16is_gy_full_scale_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_gy_full_scale_set(stmdev_ctx_t *ctx,
                                      lsm6dso16is_gy_full_scale_t val)
{
 800ad74:	b580      	push	{r7, lr}
 800ad76:	b084      	sub	sp, #16
 800ad78:	af00      	add	r7, sp, #0
 800ad7a:	6078      	str	r0, [r7, #4]
 800ad7c:	460b      	mov	r3, r1
 800ad7e:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL2_G, (uint8_t *)&ctrl2_g, 1);
 800ad80:	f107 0208 	add.w	r2, r7, #8
 800ad84:	2301      	movs	r3, #1
 800ad86:	2111      	movs	r1, #17
 800ad88:	6878      	ldr	r0, [r7, #4]
 800ad8a:	f7ff fddd 	bl	800a948 <lsm6dso16is_read_reg>
 800ad8e:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800ad90:	68fb      	ldr	r3, [r7, #12]
 800ad92:	2b00      	cmp	r3, #0
 800ad94:	d119      	bne.n	800adca <lsm6dso16is_gy_full_scale_set+0x56>
  {
    ctrl2_g.fs_g = ((uint8_t)val & 0x3U);
 800ad96:	78fb      	ldrb	r3, [r7, #3]
 800ad98:	f003 0303 	and.w	r3, r3, #3
 800ad9c:	b2da      	uxtb	r2, r3
 800ad9e:	7a3b      	ldrb	r3, [r7, #8]
 800ada0:	f362 0383 	bfi	r3, r2, #2, #2
 800ada4:	723b      	strb	r3, [r7, #8]
    ctrl2_g.fs_125 = ((uint8_t)val >> 4);
 800ada6:	78fb      	ldrb	r3, [r7, #3]
 800ada8:	091b      	lsrs	r3, r3, #4
 800adaa:	b2db      	uxtb	r3, r3
 800adac:	f003 0301 	and.w	r3, r3, #1
 800adb0:	b2da      	uxtb	r2, r3
 800adb2:	7a3b      	ldrb	r3, [r7, #8]
 800adb4:	f362 0341 	bfi	r3, r2, #1, #1
 800adb8:	723b      	strb	r3, [r7, #8]
    ret = lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL2_G, (uint8_t *)&ctrl2_g, 1);
 800adba:	f107 0208 	add.w	r2, r7, #8
 800adbe:	2301      	movs	r3, #1
 800adc0:	2111      	movs	r1, #17
 800adc2:	6878      	ldr	r0, [r7, #4]
 800adc4:	f7ff fdd8 	bl	800a978 <lsm6dso16is_write_reg>
 800adc8:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800adca:	68fb      	ldr	r3, [r7, #12]
}
 800adcc:	4618      	mov	r0, r3
 800adce:	3710      	adds	r7, #16
 800add0:	46bd      	mov	sp, r7
 800add2:	bd80      	pop	{r7, pc}

0800add4 <lsm6dso16is_gy_full_scale_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_gy_full_scale_get(stmdev_ctx_t *ctx,
                                      lsm6dso16is_gy_full_scale_t *val)
{
 800add4:	b580      	push	{r7, lr}
 800add6:	b084      	sub	sp, #16
 800add8:	af00      	add	r7, sp, #0
 800adda:	6078      	str	r0, [r7, #4]
 800addc:	6039      	str	r1, [r7, #0]
  lsm6dso16is_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL2_G, (uint8_t *)&ctrl2_g, 1);
 800adde:	f107 0208 	add.w	r2, r7, #8
 800ade2:	2301      	movs	r3, #1
 800ade4:	2111      	movs	r1, #17
 800ade6:	6878      	ldr	r0, [r7, #4]
 800ade8:	f7ff fdae 	bl	800a948 <lsm6dso16is_read_reg>
 800adec:	60f8      	str	r0, [r7, #12]

  switch ((ctrl2_g.fs_125 << 4) | (ctrl2_g.fs_g))
 800adee:	7a3b      	ldrb	r3, [r7, #8]
 800adf0:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800adf4:	b2db      	uxtb	r3, r3
 800adf6:	011b      	lsls	r3, r3, #4
 800adf8:	7a3a      	ldrb	r2, [r7, #8]
 800adfa:	f3c2 0281 	ubfx	r2, r2, #2, #2
 800adfe:	b2d2      	uxtb	r2, r2
 800ae00:	4313      	orrs	r3, r2
 800ae02:	2b10      	cmp	r3, #16
 800ae04:	d838      	bhi.n	800ae78 <lsm6dso16is_gy_full_scale_get+0xa4>
 800ae06:	a201      	add	r2, pc, #4	@ (adr r2, 800ae0c <lsm6dso16is_gy_full_scale_get+0x38>)
 800ae08:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ae0c:	0800ae59 	.word	0x0800ae59
 800ae10:	0800ae61 	.word	0x0800ae61
 800ae14:	0800ae69 	.word	0x0800ae69
 800ae18:	0800ae71 	.word	0x0800ae71
 800ae1c:	0800ae79 	.word	0x0800ae79
 800ae20:	0800ae79 	.word	0x0800ae79
 800ae24:	0800ae79 	.word	0x0800ae79
 800ae28:	0800ae79 	.word	0x0800ae79
 800ae2c:	0800ae79 	.word	0x0800ae79
 800ae30:	0800ae79 	.word	0x0800ae79
 800ae34:	0800ae79 	.word	0x0800ae79
 800ae38:	0800ae79 	.word	0x0800ae79
 800ae3c:	0800ae79 	.word	0x0800ae79
 800ae40:	0800ae79 	.word	0x0800ae79
 800ae44:	0800ae79 	.word	0x0800ae79
 800ae48:	0800ae79 	.word	0x0800ae79
 800ae4c:	0800ae51 	.word	0x0800ae51
  {
    case LSM6DSO16IS_125dps:
      *val = LSM6DSO16IS_125dps;
 800ae50:	683b      	ldr	r3, [r7, #0]
 800ae52:	2210      	movs	r2, #16
 800ae54:	701a      	strb	r2, [r3, #0]
      break;
 800ae56:	e013      	b.n	800ae80 <lsm6dso16is_gy_full_scale_get+0xac>

    case LSM6DSO16IS_250dps:
      *val = LSM6DSO16IS_250dps;
 800ae58:	683b      	ldr	r3, [r7, #0]
 800ae5a:	2200      	movs	r2, #0
 800ae5c:	701a      	strb	r2, [r3, #0]
      break;
 800ae5e:	e00f      	b.n	800ae80 <lsm6dso16is_gy_full_scale_get+0xac>

    case LSM6DSO16IS_500dps:
      *val = LSM6DSO16IS_500dps;
 800ae60:	683b      	ldr	r3, [r7, #0]
 800ae62:	2201      	movs	r2, #1
 800ae64:	701a      	strb	r2, [r3, #0]
      break;
 800ae66:	e00b      	b.n	800ae80 <lsm6dso16is_gy_full_scale_get+0xac>

    case LSM6DSO16IS_1000dps:
      *val = LSM6DSO16IS_1000dps;
 800ae68:	683b      	ldr	r3, [r7, #0]
 800ae6a:	2202      	movs	r2, #2
 800ae6c:	701a      	strb	r2, [r3, #0]
      break;
 800ae6e:	e007      	b.n	800ae80 <lsm6dso16is_gy_full_scale_get+0xac>

    case LSM6DSO16IS_2000dps:
      *val = LSM6DSO16IS_2000dps;
 800ae70:	683b      	ldr	r3, [r7, #0]
 800ae72:	2203      	movs	r2, #3
 800ae74:	701a      	strb	r2, [r3, #0]
      break;
 800ae76:	e003      	b.n	800ae80 <lsm6dso16is_gy_full_scale_get+0xac>

    default:
      *val = LSM6DSO16IS_125dps;
 800ae78:	683b      	ldr	r3, [r7, #0]
 800ae7a:	2210      	movs	r2, #16
 800ae7c:	701a      	strb	r2, [r3, #0]
      break;
 800ae7e:	bf00      	nop
  }
  return ret;
 800ae80:	68fb      	ldr	r3, [r7, #12]
}
 800ae82:	4618      	mov	r0, r3
 800ae84:	3710      	adds	r7, #16
 800ae86:	46bd      	mov	sp, r7
 800ae88:	bd80      	pop	{r7, pc}
 800ae8a:	bf00      	nop

0800ae8c <lsm6dso16is_gy_data_rate_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_gy_data_rate_set(stmdev_ctx_t *ctx,
                                     lsm6dso16is_gy_data_rate_t val)
{
 800ae8c:	b580      	push	{r7, lr}
 800ae8e:	b084      	sub	sp, #16
 800ae90:	af00      	add	r7, sp, #0
 800ae92:	6078      	str	r0, [r7, #4]
 800ae94:	460b      	mov	r3, r1
 800ae96:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl2_g_t ctrl2_g;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL2_G, (uint8_t *)&ctrl2_g, 1);
 800ae98:	f107 0208 	add.w	r2, r7, #8
 800ae9c:	2301      	movs	r3, #1
 800ae9e:	2111      	movs	r1, #17
 800aea0:	6878      	ldr	r0, [r7, #4]
 800aea2:	f7ff fd51 	bl	800a948 <lsm6dso16is_read_reg>
 800aea6:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800aea8:	68fb      	ldr	r3, [r7, #12]
 800aeaa:	2b00      	cmp	r3, #0
 800aeac:	d128      	bne.n	800af00 <lsm6dso16is_gy_data_rate_set+0x74>
  {
    if (((uint8_t)val & 0x10U) == 0x10U)
 800aeae:	78fb      	ldrb	r3, [r7, #3]
 800aeb0:	f003 0310 	and.w	r3, r3, #16
 800aeb4:	2b00      	cmp	r3, #0
 800aeb6:	d008      	beq.n	800aeca <lsm6dso16is_gy_data_rate_set+0x3e>
    {
      ret += lsm6dso16is_gy_hm_mode_set(ctx, LSM6DSO16IS_HIGH_PERFOMANCE_MODE_DISABLED);
 800aeb8:	2101      	movs	r1, #1
 800aeba:	6878      	ldr	r0, [r7, #4]
 800aebc:	f7ff ff34 	bl	800ad28 <lsm6dso16is_gy_hm_mode_set>
 800aec0:	4602      	mov	r2, r0
 800aec2:	68fb      	ldr	r3, [r7, #12]
 800aec4:	4413      	add	r3, r2
 800aec6:	60fb      	str	r3, [r7, #12]
 800aec8:	e007      	b.n	800aeda <lsm6dso16is_gy_data_rate_set+0x4e>
    }
    else
    {
      ret += lsm6dso16is_gy_hm_mode_set(ctx, LSM6DSO16IS_HIGH_PERFOMANCE_MODE_ENABLED);
 800aeca:	2100      	movs	r1, #0
 800aecc:	6878      	ldr	r0, [r7, #4]
 800aece:	f7ff ff2b 	bl	800ad28 <lsm6dso16is_gy_hm_mode_set>
 800aed2:	4602      	mov	r2, r0
 800aed4:	68fb      	ldr	r3, [r7, #12]
 800aed6:	4413      	add	r3, r2
 800aed8:	60fb      	str	r3, [r7, #12]
    }

    ctrl2_g.odr_g = ((uint8_t)val & 0xfU);
 800aeda:	78fb      	ldrb	r3, [r7, #3]
 800aedc:	f003 030f 	and.w	r3, r3, #15
 800aee0:	b2da      	uxtb	r2, r3
 800aee2:	7a3b      	ldrb	r3, [r7, #8]
 800aee4:	f362 1307 	bfi	r3, r2, #4, #4
 800aee8:	723b      	strb	r3, [r7, #8]
    ret += lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL2_G, (uint8_t *)&ctrl2_g, 1);
 800aeea:	f107 0208 	add.w	r2, r7, #8
 800aeee:	2301      	movs	r3, #1
 800aef0:	2111      	movs	r1, #17
 800aef2:	6878      	ldr	r0, [r7, #4]
 800aef4:	f7ff fd40 	bl	800a978 <lsm6dso16is_write_reg>
 800aef8:	4602      	mov	r2, r0
 800aefa:	68fb      	ldr	r3, [r7, #12]
 800aefc:	4413      	add	r3, r2
 800aefe:	60fb      	str	r3, [r7, #12]
  }

  return ret;
 800af00:	68fb      	ldr	r3, [r7, #12]
}
 800af02:	4618      	mov	r0, r3
 800af04:	3710      	adds	r7, #16
 800af06:	46bd      	mov	sp, r7
 800af08:	bd80      	pop	{r7, pc}
	...

0800af0c <lsm6dso16is_gy_data_rate_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_gy_data_rate_get(stmdev_ctx_t *ctx,
                                     lsm6dso16is_gy_data_rate_t *val)
{
 800af0c:	b580      	push	{r7, lr}
 800af0e:	b086      	sub	sp, #24
 800af10:	af00      	add	r7, sp, #0
 800af12:	6078      	str	r0, [r7, #4]
 800af14:	6039      	str	r1, [r7, #0]
  lsm6dso16is_ctrl2_g_t ctrl2_g;
  lsm6dso16is_ctrl7_g_t ctrl7_g;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL2_G, (uint8_t *)&ctrl2_g, 1);
 800af16:	f107 0210 	add.w	r2, r7, #16
 800af1a:	2301      	movs	r3, #1
 800af1c:	2111      	movs	r1, #17
 800af1e:	6878      	ldr	r0, [r7, #4]
 800af20:	f7ff fd12 	bl	800a948 <lsm6dso16is_read_reg>
 800af24:	6178      	str	r0, [r7, #20]
  ret += lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL7_G, (uint8_t *)&ctrl7_g, 1);
 800af26:	f107 020c 	add.w	r2, r7, #12
 800af2a:	2301      	movs	r3, #1
 800af2c:	2116      	movs	r1, #22
 800af2e:	6878      	ldr	r0, [r7, #4]
 800af30:	f7ff fd0a 	bl	800a948 <lsm6dso16is_read_reg>
 800af34:	4602      	mov	r2, r0
 800af36:	697b      	ldr	r3, [r7, #20]
 800af38:	4413      	add	r3, r2
 800af3a:	617b      	str	r3, [r7, #20]

  switch ((ctrl7_g.g_hm_mode << 4) | (ctrl2_g.odr_g))
 800af3c:	7b3b      	ldrb	r3, [r7, #12]
 800af3e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800af42:	b2db      	uxtb	r3, r3
 800af44:	011b      	lsls	r3, r3, #4
 800af46:	7c3a      	ldrb	r2, [r7, #16]
 800af48:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800af4c:	b2d2      	uxtb	r2, r2
 800af4e:	4313      	orrs	r3, r2
 800af50:	2b1a      	cmp	r3, #26
 800af52:	f200 808d 	bhi.w	800b070 <lsm6dso16is_gy_data_rate_get+0x164>
 800af56:	a201      	add	r2, pc, #4	@ (adr r2, 800af5c <lsm6dso16is_gy_data_rate_get+0x50>)
 800af58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800af5c:	0800afc9 	.word	0x0800afc9
 800af60:	0800afd1 	.word	0x0800afd1
 800af64:	0800afd9 	.word	0x0800afd9
 800af68:	0800afe1 	.word	0x0800afe1
 800af6c:	0800afe9 	.word	0x0800afe9
 800af70:	0800aff1 	.word	0x0800aff1
 800af74:	0800aff9 	.word	0x0800aff9
 800af78:	0800b001 	.word	0x0800b001
 800af7c:	0800b009 	.word	0x0800b009
 800af80:	0800b011 	.word	0x0800b011
 800af84:	0800b019 	.word	0x0800b019
 800af88:	0800b071 	.word	0x0800b071
 800af8c:	0800b071 	.word	0x0800b071
 800af90:	0800b071 	.word	0x0800b071
 800af94:	0800b071 	.word	0x0800b071
 800af98:	0800b071 	.word	0x0800b071
 800af9c:	0800b071 	.word	0x0800b071
 800afa0:	0800b021 	.word	0x0800b021
 800afa4:	0800b029 	.word	0x0800b029
 800afa8:	0800b031 	.word	0x0800b031
 800afac:	0800b039 	.word	0x0800b039
 800afb0:	0800b041 	.word	0x0800b041
 800afb4:	0800b049 	.word	0x0800b049
 800afb8:	0800b051 	.word	0x0800b051
 800afbc:	0800b059 	.word	0x0800b059
 800afc0:	0800b061 	.word	0x0800b061
 800afc4:	0800b069 	.word	0x0800b069
  {
    case LSM6DSO16IS_GY_ODR_OFF:
      *val = LSM6DSO16IS_GY_ODR_OFF;
 800afc8:	683b      	ldr	r3, [r7, #0]
 800afca:	2200      	movs	r2, #0
 800afcc:	701a      	strb	r2, [r3, #0]
      break;
 800afce:	e053      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_12Hz5_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_12Hz5_HP;
 800afd0:	683b      	ldr	r3, [r7, #0]
 800afd2:	2201      	movs	r2, #1
 800afd4:	701a      	strb	r2, [r3, #0]
      break;
 800afd6:	e04f      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_26H_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_26H_HP;
 800afd8:	683b      	ldr	r3, [r7, #0]
 800afda:	2202      	movs	r2, #2
 800afdc:	701a      	strb	r2, [r3, #0]
      break;
 800afde:	e04b      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_52Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_52Hz_HP;
 800afe0:	683b      	ldr	r3, [r7, #0]
 800afe2:	2203      	movs	r2, #3
 800afe4:	701a      	strb	r2, [r3, #0]
      break;
 800afe6:	e047      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_104Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_104Hz_HP;
 800afe8:	683b      	ldr	r3, [r7, #0]
 800afea:	2204      	movs	r2, #4
 800afec:	701a      	strb	r2, [r3, #0]
      break;
 800afee:	e043      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_208Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_208Hz_HP;
 800aff0:	683b      	ldr	r3, [r7, #0]
 800aff2:	2205      	movs	r2, #5
 800aff4:	701a      	strb	r2, [r3, #0]
      break;
 800aff6:	e03f      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_416Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_416Hz_HP;
 800aff8:	683b      	ldr	r3, [r7, #0]
 800affa:	2206      	movs	r2, #6
 800affc:	701a      	strb	r2, [r3, #0]
      break;
 800affe:	e03b      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_833Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_833Hz_HP;
 800b000:	683b      	ldr	r3, [r7, #0]
 800b002:	2207      	movs	r2, #7
 800b004:	701a      	strb	r2, [r3, #0]
      break;
 800b006:	e037      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_1667Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_1667Hz_HP;
 800b008:	683b      	ldr	r3, [r7, #0]
 800b00a:	2208      	movs	r2, #8
 800b00c:	701a      	strb	r2, [r3, #0]
      break;
 800b00e:	e033      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_3333Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_3333Hz_HP;
 800b010:	683b      	ldr	r3, [r7, #0]
 800b012:	2209      	movs	r2, #9
 800b014:	701a      	strb	r2, [r3, #0]
      break;
 800b016:	e02f      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_6667Hz_HP:
      *val = LSM6DSO16IS_GY_ODR_AT_6667Hz_HP;
 800b018:	683b      	ldr	r3, [r7, #0]
 800b01a:	220a      	movs	r2, #10
 800b01c:	701a      	strb	r2, [r3, #0]
      break;
 800b01e:	e02b      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_12Hz5_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_12Hz5_LP;
 800b020:	683b      	ldr	r3, [r7, #0]
 800b022:	2211      	movs	r2, #17
 800b024:	701a      	strb	r2, [r3, #0]
      break;
 800b026:	e027      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_26H_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_26H_LP;
 800b028:	683b      	ldr	r3, [r7, #0]
 800b02a:	2212      	movs	r2, #18
 800b02c:	701a      	strb	r2, [r3, #0]
      break;
 800b02e:	e023      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_52Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_52Hz_LP;
 800b030:	683b      	ldr	r3, [r7, #0]
 800b032:	2213      	movs	r2, #19
 800b034:	701a      	strb	r2, [r3, #0]
      break;
 800b036:	e01f      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_104Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_104Hz_LP;
 800b038:	683b      	ldr	r3, [r7, #0]
 800b03a:	2214      	movs	r2, #20
 800b03c:	701a      	strb	r2, [r3, #0]
      break;
 800b03e:	e01b      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_208Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_208Hz_LP;
 800b040:	683b      	ldr	r3, [r7, #0]
 800b042:	2215      	movs	r2, #21
 800b044:	701a      	strb	r2, [r3, #0]
      break;
 800b046:	e017      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_416Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_416Hz_LP;
 800b048:	683b      	ldr	r3, [r7, #0]
 800b04a:	2216      	movs	r2, #22
 800b04c:	701a      	strb	r2, [r3, #0]
      break;
 800b04e:	e013      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_833Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_833Hz_LP;
 800b050:	683b      	ldr	r3, [r7, #0]
 800b052:	2217      	movs	r2, #23
 800b054:	701a      	strb	r2, [r3, #0]
      break;
 800b056:	e00f      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_1667Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_1667Hz_LP;
 800b058:	683b      	ldr	r3, [r7, #0]
 800b05a:	2218      	movs	r2, #24
 800b05c:	701a      	strb	r2, [r3, #0]
      break;
 800b05e:	e00b      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_3333Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_3333Hz_LP;
 800b060:	683b      	ldr	r3, [r7, #0]
 800b062:	2219      	movs	r2, #25
 800b064:	701a      	strb	r2, [r3, #0]
      break;
 800b066:	e007      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    case LSM6DSO16IS_GY_ODR_AT_6667Hz_LP:
      *val = LSM6DSO16IS_GY_ODR_AT_6667Hz_LP;
 800b068:	683b      	ldr	r3, [r7, #0]
 800b06a:	221a      	movs	r2, #26
 800b06c:	701a      	strb	r2, [r3, #0]
      break;
 800b06e:	e003      	b.n	800b078 <lsm6dso16is_gy_data_rate_get+0x16c>

    default:
      *val = LSM6DSO16IS_GY_ODR_OFF;
 800b070:	683b      	ldr	r3, [r7, #0]
 800b072:	2200      	movs	r2, #0
 800b074:	701a      	strb	r2, [r3, #0]
      break;
 800b076:	bf00      	nop
  }

  return ret;
 800b078:	697b      	ldr	r3, [r7, #20]
}
 800b07a:	4618      	mov	r0, r3
 800b07c:	3718      	adds	r7, #24
 800b07e:	46bd      	mov	sp, r7
 800b080:	bd80      	pop	{r7, pc}
 800b082:	bf00      	nop

0800b084 <lsm6dso16is_auto_increment_set>:
  * @param  val      Register address automatically incremented during a multiple byte access with a serial interface (enable by default).
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_auto_increment_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800b084:	b580      	push	{r7, lr}
 800b086:	b084      	sub	sp, #16
 800b088:	af00      	add	r7, sp, #0
 800b08a:	6078      	str	r0, [r7, #4]
 800b08c:	460b      	mov	r3, r1
 800b08e:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL3_C, (uint8_t *)&ctrl3_c, 1);
 800b090:	f107 0208 	add.w	r2, r7, #8
 800b094:	2301      	movs	r3, #1
 800b096:	2112      	movs	r1, #18
 800b098:	6878      	ldr	r0, [r7, #4]
 800b09a:	f7ff fc55 	bl	800a948 <lsm6dso16is_read_reg>
 800b09e:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800b0a0:	68fb      	ldr	r3, [r7, #12]
 800b0a2:	2b00      	cmp	r3, #0
 800b0a4:	d10f      	bne.n	800b0c6 <lsm6dso16is_auto_increment_set+0x42>
  {
    ctrl3_c.if_inc = val;
 800b0a6:	78fb      	ldrb	r3, [r7, #3]
 800b0a8:	f003 0301 	and.w	r3, r3, #1
 800b0ac:	b2da      	uxtb	r2, r3
 800b0ae:	7a3b      	ldrb	r3, [r7, #8]
 800b0b0:	f362 0382 	bfi	r3, r2, #2, #1
 800b0b4:	723b      	strb	r3, [r7, #8]
    ret = lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL3_C, (uint8_t *)&ctrl3_c, 1);
 800b0b6:	f107 0208 	add.w	r2, r7, #8
 800b0ba:	2301      	movs	r3, #1
 800b0bc:	2112      	movs	r1, #18
 800b0be:	6878      	ldr	r0, [r7, #4]
 800b0c0:	f7ff fc5a 	bl	800a978 <lsm6dso16is_write_reg>
 800b0c4:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800b0c6:	68fb      	ldr	r3, [r7, #12]
}
 800b0c8:	4618      	mov	r0, r3
 800b0ca:	3710      	adds	r7, #16
 800b0cc:	46bd      	mov	sp, r7
 800b0ce:	bd80      	pop	{r7, pc}

0800b0d0 <lsm6dso16is_block_data_update_set>:
  * @param  val      Block Data Update (BDU): output registers are not updated until LSB and MSB have been read).
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800b0d0:	b580      	push	{r7, lr}
 800b0d2:	b084      	sub	sp, #16
 800b0d4:	af00      	add	r7, sp, #0
 800b0d6:	6078      	str	r0, [r7, #4]
 800b0d8:	460b      	mov	r3, r1
 800b0da:	70fb      	strb	r3, [r7, #3]
  lsm6dso16is_ctrl3_c_t ctrl3_c;
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_CTRL3_C, (uint8_t *)&ctrl3_c, 1);
 800b0dc:	f107 0208 	add.w	r2, r7, #8
 800b0e0:	2301      	movs	r3, #1
 800b0e2:	2112      	movs	r1, #18
 800b0e4:	6878      	ldr	r0, [r7, #4]
 800b0e6:	f7ff fc2f 	bl	800a948 <lsm6dso16is_read_reg>
 800b0ea:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800b0ec:	68fb      	ldr	r3, [r7, #12]
 800b0ee:	2b00      	cmp	r3, #0
 800b0f0:	d10f      	bne.n	800b112 <lsm6dso16is_block_data_update_set+0x42>
  {
    ctrl3_c.bdu = val;
 800b0f2:	78fb      	ldrb	r3, [r7, #3]
 800b0f4:	f003 0301 	and.w	r3, r3, #1
 800b0f8:	b2da      	uxtb	r2, r3
 800b0fa:	7a3b      	ldrb	r3, [r7, #8]
 800b0fc:	f362 1386 	bfi	r3, r2, #6, #1
 800b100:	723b      	strb	r3, [r7, #8]
    ret = lsm6dso16is_write_reg(ctx, LSM6DSO16IS_CTRL3_C, (uint8_t *)&ctrl3_c, 1);
 800b102:	f107 0208 	add.w	r2, r7, #8
 800b106:	2301      	movs	r3, #1
 800b108:	2112      	movs	r1, #18
 800b10a:	6878      	ldr	r0, [r7, #4]
 800b10c:	f7ff fc34 	bl	800a978 <lsm6dso16is_write_reg>
 800b110:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800b112:	68fb      	ldr	r3, [r7, #12]
}
 800b114:	4618      	mov	r0, r3
 800b116:	3710      	adds	r7, #16
 800b118:	46bd      	mov	sp, r7
 800b11a:	bd80      	pop	{r7, pc}

0800b11c <lsm6dso16is_angular_rate_raw_get>:
  * @param  val      Angular rate sensor.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_angular_rate_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800b11c:	b580      	push	{r7, lr}
 800b11e:	b086      	sub	sp, #24
 800b120:	af00      	add	r7, sp, #0
 800b122:	6078      	str	r0, [r7, #4]
 800b124:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_OUTX_L_G, buff, 6);
 800b126:	f107 020c 	add.w	r2, r7, #12
 800b12a:	2306      	movs	r3, #6
 800b12c:	2122      	movs	r1, #34	@ 0x22
 800b12e:	6878      	ldr	r0, [r7, #4]
 800b130:	f7ff fc0a 	bl	800a948 <lsm6dso16is_read_reg>
 800b134:	6178      	str	r0, [r7, #20]
  val[0] = (int16_t)buff[1];
 800b136:	7b7b      	ldrb	r3, [r7, #13]
 800b138:	b21a      	sxth	r2, r3
 800b13a:	683b      	ldr	r3, [r7, #0]
 800b13c:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 800b13e:	683b      	ldr	r3, [r7, #0]
 800b140:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b144:	b29b      	uxth	r3, r3
 800b146:	021b      	lsls	r3, r3, #8
 800b148:	b29b      	uxth	r3, r3
 800b14a:	7b3a      	ldrb	r2, [r7, #12]
 800b14c:	4413      	add	r3, r2
 800b14e:	b29b      	uxth	r3, r3
 800b150:	b21a      	sxth	r2, r3
 800b152:	683b      	ldr	r3, [r7, #0]
 800b154:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800b156:	7bfa      	ldrb	r2, [r7, #15]
 800b158:	683b      	ldr	r3, [r7, #0]
 800b15a:	3302      	adds	r3, #2
 800b15c:	b212      	sxth	r2, r2
 800b15e:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 800b160:	683b      	ldr	r3, [r7, #0]
 800b162:	3302      	adds	r3, #2
 800b164:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b168:	b29b      	uxth	r3, r3
 800b16a:	021b      	lsls	r3, r3, #8
 800b16c:	b29b      	uxth	r3, r3
 800b16e:	7bba      	ldrb	r2, [r7, #14]
 800b170:	4413      	add	r3, r2
 800b172:	b29a      	uxth	r2, r3
 800b174:	683b      	ldr	r3, [r7, #0]
 800b176:	3302      	adds	r3, #2
 800b178:	b212      	sxth	r2, r2
 800b17a:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 800b17c:	7c7a      	ldrb	r2, [r7, #17]
 800b17e:	683b      	ldr	r3, [r7, #0]
 800b180:	3304      	adds	r3, #4
 800b182:	b212      	sxth	r2, r2
 800b184:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 800b186:	683b      	ldr	r3, [r7, #0]
 800b188:	3304      	adds	r3, #4
 800b18a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b18e:	b29b      	uxth	r3, r3
 800b190:	021b      	lsls	r3, r3, #8
 800b192:	b29b      	uxth	r3, r3
 800b194:	7c3a      	ldrb	r2, [r7, #16]
 800b196:	4413      	add	r3, r2
 800b198:	b29a      	uxth	r2, r3
 800b19a:	683b      	ldr	r3, [r7, #0]
 800b19c:	3304      	adds	r3, #4
 800b19e:	b212      	sxth	r2, r2
 800b1a0:	801a      	strh	r2, [r3, #0]

  return ret;
 800b1a2:	697b      	ldr	r3, [r7, #20]
}
 800b1a4:	4618      	mov	r0, r3
 800b1a6:	3718      	adds	r7, #24
 800b1a8:	46bd      	mov	sp, r7
 800b1aa:	bd80      	pop	{r7, pc}

0800b1ac <lsm6dso16is_acceleration_raw_get>:
  * @param  val      Linear acceleration sensor.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dso16is_acceleration_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800b1ac:	b580      	push	{r7, lr}
 800b1ae:	b086      	sub	sp, #24
 800b1b0:	af00      	add	r7, sp, #0
 800b1b2:	6078      	str	r0, [r7, #4]
 800b1b4:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lsm6dso16is_read_reg(ctx, LSM6DSO16IS_OUTX_L_A, buff, 6);
 800b1b6:	f107 020c 	add.w	r2, r7, #12
 800b1ba:	2306      	movs	r3, #6
 800b1bc:	2128      	movs	r1, #40	@ 0x28
 800b1be:	6878      	ldr	r0, [r7, #4]
 800b1c0:	f7ff fbc2 	bl	800a948 <lsm6dso16is_read_reg>
 800b1c4:	6178      	str	r0, [r7, #20]
  val[0] = (int16_t)buff[1];
 800b1c6:	7b7b      	ldrb	r3, [r7, #13]
 800b1c8:	b21a      	sxth	r2, r3
 800b1ca:	683b      	ldr	r3, [r7, #0]
 800b1cc:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 800b1ce:	683b      	ldr	r3, [r7, #0]
 800b1d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b1d4:	b29b      	uxth	r3, r3
 800b1d6:	021b      	lsls	r3, r3, #8
 800b1d8:	b29b      	uxth	r3, r3
 800b1da:	7b3a      	ldrb	r2, [r7, #12]
 800b1dc:	4413      	add	r3, r2
 800b1de:	b29b      	uxth	r3, r3
 800b1e0:	b21a      	sxth	r2, r3
 800b1e2:	683b      	ldr	r3, [r7, #0]
 800b1e4:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800b1e6:	7bfa      	ldrb	r2, [r7, #15]
 800b1e8:	683b      	ldr	r3, [r7, #0]
 800b1ea:	3302      	adds	r3, #2
 800b1ec:	b212      	sxth	r2, r2
 800b1ee:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 800b1f0:	683b      	ldr	r3, [r7, #0]
 800b1f2:	3302      	adds	r3, #2
 800b1f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b1f8:	b29b      	uxth	r3, r3
 800b1fa:	021b      	lsls	r3, r3, #8
 800b1fc:	b29b      	uxth	r3, r3
 800b1fe:	7bba      	ldrb	r2, [r7, #14]
 800b200:	4413      	add	r3, r2
 800b202:	b29a      	uxth	r2, r3
 800b204:	683b      	ldr	r3, [r7, #0]
 800b206:	3302      	adds	r3, #2
 800b208:	b212      	sxth	r2, r2
 800b20a:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 800b20c:	7c7a      	ldrb	r2, [r7, #17]
 800b20e:	683b      	ldr	r3, [r7, #0]
 800b210:	3304      	adds	r3, #4
 800b212:	b212      	sxth	r2, r2
 800b214:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 800b216:	683b      	ldr	r3, [r7, #0]
 800b218:	3304      	adds	r3, #4
 800b21a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b21e:	b29b      	uxth	r3, r3
 800b220:	021b      	lsls	r3, r3, #8
 800b222:	b29b      	uxth	r3, r3
 800b224:	7c3a      	ldrb	r2, [r7, #16]
 800b226:	4413      	add	r3, r2
 800b228:	b29a      	uxth	r2, r3
 800b22a:	683b      	ldr	r3, [r7, #0]
 800b22c:	3304      	adds	r3, #4
 800b22e:	b212      	sxth	r2, r2
 800b230:	801a      	strh	r2, [r3, #0]

  return ret;
 800b232:	697b      	ldr	r3, [r7, #20]
}
 800b234:	4618      	mov	r0, r3
 800b236:	3718      	adds	r7, #24
 800b238:	46bd      	mov	sp, r7
 800b23a:	bd80      	pop	{r7, pc}

0800b23c <LSM6DSV16X_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_RegisterBusIO(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_IO_t *pIO)
{
 800b23c:	b580      	push	{r7, lr}
 800b23e:	b084      	sub	sp, #16
 800b240:	af00      	add	r7, sp, #0
 800b242:	6078      	str	r0, [r7, #4]
 800b244:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800b246:	2300      	movs	r3, #0
 800b248:	60fb      	str	r3, [r7, #12]

  if (pObj == NULL)
 800b24a:	687b      	ldr	r3, [r7, #4]
 800b24c:	2b00      	cmp	r3, #0
 800b24e:	d103      	bne.n	800b258 <LSM6DSV16X_RegisterBusIO+0x1c>
  {
    ret = LSM6DSV16X_ERROR;
 800b250:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b254:	60fb      	str	r3, [r7, #12]
 800b256:	e05d      	b.n	800b314 <LSM6DSV16X_RegisterBusIO+0xd8>
  }
  else
  {
    pObj->IO.Init       = pIO->Init;
 800b258:	683b      	ldr	r3, [r7, #0]
 800b25a:	681a      	ldr	r2, [r3, #0]
 800b25c:	687b      	ldr	r3, [r7, #4]
 800b25e:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit     = pIO->DeInit;
 800b260:	683b      	ldr	r3, [r7, #0]
 800b262:	685a      	ldr	r2, [r3, #4]
 800b264:	687b      	ldr	r3, [r7, #4]
 800b266:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType    = pIO->BusType;
 800b268:	683b      	ldr	r3, [r7, #0]
 800b26a:	689a      	ldr	r2, [r3, #8]
 800b26c:	687b      	ldr	r3, [r7, #4]
 800b26e:	609a      	str	r2, [r3, #8]
    pObj->IO.Address    = pIO->Address;
 800b270:	683b      	ldr	r3, [r7, #0]
 800b272:	7b1a      	ldrb	r2, [r3, #12]
 800b274:	687b      	ldr	r3, [r7, #4]
 800b276:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg   = pIO->WriteReg;
 800b278:	683b      	ldr	r3, [r7, #0]
 800b27a:	691a      	ldr	r2, [r3, #16]
 800b27c:	687b      	ldr	r3, [r7, #4]
 800b27e:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg    = pIO->ReadReg;
 800b280:	683b      	ldr	r3, [r7, #0]
 800b282:	695a      	ldr	r2, [r3, #20]
 800b284:	687b      	ldr	r3, [r7, #4]
 800b286:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick    = pIO->GetTick;
 800b288:	683b      	ldr	r3, [r7, #0]
 800b28a:	699a      	ldr	r2, [r3, #24]
 800b28c:	687b      	ldr	r3, [r7, #4]
 800b28e:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 800b290:	687b      	ldr	r3, [r7, #4]
 800b292:	4a23      	ldr	r2, [pc, #140]	@ (800b320 <LSM6DSV16X_RegisterBusIO+0xe4>)
 800b294:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800b296:	687b      	ldr	r3, [r7, #4]
 800b298:	4a22      	ldr	r2, [pc, #136]	@ (800b324 <LSM6DSV16X_RegisterBusIO+0xe8>)
 800b29a:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 800b29c:	683b      	ldr	r3, [r7, #0]
 800b29e:	69da      	ldr	r2, [r3, #28]
 800b2a0:	687b      	ldr	r3, [r7, #4]
 800b2a2:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 800b2a4:	687b      	ldr	r3, [r7, #4]
 800b2a6:	687a      	ldr	r2, [r7, #4]
 800b2a8:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init == NULL)
 800b2aa:	687b      	ldr	r3, [r7, #4]
 800b2ac:	681b      	ldr	r3, [r3, #0]
 800b2ae:	2b00      	cmp	r3, #0
 800b2b0:	d103      	bne.n	800b2ba <LSM6DSV16X_RegisterBusIO+0x7e>
    {
      ret = LSM6DSV16X_ERROR;
 800b2b2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b2b6:	60fb      	str	r3, [r7, #12]
 800b2b8:	e02c      	b.n	800b314 <LSM6DSV16X_RegisterBusIO+0xd8>
    }
    else if (pObj->IO.Init() != LSM6DSV16X_OK)
 800b2ba:	687b      	ldr	r3, [r7, #4]
 800b2bc:	681b      	ldr	r3, [r3, #0]
 800b2be:	4798      	blx	r3
 800b2c0:	4603      	mov	r3, r0
 800b2c2:	2b00      	cmp	r3, #0
 800b2c4:	d003      	beq.n	800b2ce <LSM6DSV16X_RegisterBusIO+0x92>
    {
      ret = LSM6DSV16X_ERROR;
 800b2c6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b2ca:	60fb      	str	r3, [r7, #12]
 800b2cc:	e022      	b.n	800b314 <LSM6DSV16X_RegisterBusIO+0xd8>
    }
    else
    {
      if (pObj->IO.BusType == LSM6DSV16X_SPI_3WIRES_BUS) /* SPI 3-Wires */
 800b2ce:	687b      	ldr	r3, [r7, #4]
 800b2d0:	689b      	ldr	r3, [r3, #8]
 800b2d2:	2b02      	cmp	r3, #2
 800b2d4:	d11e      	bne.n	800b314 <LSM6DSV16X_RegisterBusIO+0xd8>
      {
        /* Enable the SPI 3-Wires support only the first time */
        if (pObj->is_initialized == 0U)
 800b2d6:	687b      	ldr	r3, [r7, #4]
 800b2d8:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800b2dc:	2b00      	cmp	r3, #0
 800b2de:	d119      	bne.n	800b314 <LSM6DSV16X_RegisterBusIO+0xd8>
        {
          /* Enable SPI 3-Wires on the component */
          uint8_t data = 0x04;
 800b2e0:	2304      	movs	r3, #4
 800b2e2:	72fb      	strb	r3, [r7, #11]

          if (LSM6DSV16X_Write_Reg(pObj, LSM6DSV16X_CTRL3, data) != LSM6DSV16X_OK)
 800b2e4:	7afb      	ldrb	r3, [r7, #11]
 800b2e6:	461a      	mov	r2, r3
 800b2e8:	2112      	movs	r1, #18
 800b2ea:	6878      	ldr	r0, [r7, #4]
 800b2ec:	f000 fd95 	bl	800be1a <LSM6DSV16X_Write_Reg>
 800b2f0:	4603      	mov	r3, r0
 800b2f2:	2b00      	cmp	r3, #0
 800b2f4:	d002      	beq.n	800b2fc <LSM6DSV16X_RegisterBusIO+0xc0>
          {
            ret = LSM6DSV16X_ERROR;
 800b2f6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b2fa:	60fb      	str	r3, [r7, #12]
          }

          if (LSM6DSV16X_Write_Reg(pObj, LSM6DSV16X_IF_CFG, data) != LSM6DSV16X_OK)
 800b2fc:	7afb      	ldrb	r3, [r7, #11]
 800b2fe:	461a      	mov	r2, r3
 800b300:	2103      	movs	r1, #3
 800b302:	6878      	ldr	r0, [r7, #4]
 800b304:	f000 fd89 	bl	800be1a <LSM6DSV16X_Write_Reg>
 800b308:	4603      	mov	r3, r0
 800b30a:	2b00      	cmp	r3, #0
 800b30c:	d002      	beq.n	800b314 <LSM6DSV16X_RegisterBusIO+0xd8>
          {
            ret = LSM6DSV16X_ERROR;
 800b30e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b312:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

  return ret;
 800b314:	68fb      	ldr	r3, [r7, #12]
}
 800b316:	4618      	mov	r0, r3
 800b318:	3710      	adds	r7, #16
 800b31a:	46bd      	mov	sp, r7
 800b31c:	bd80      	pop	{r7, pc}
 800b31e:	bf00      	nop
 800b320:	0800c30d 	.word	0x0800c30d
 800b324:	0800c343 	.word	0x0800c343

0800b328 <LSM6DSV16X_Init>:
  * @brief  Initialize the LSM6DSV16X sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_Init(LSM6DSV16X_Object_t *pObj)
{
 800b328:	b580      	push	{r7, lr}
 800b32a:	b084      	sub	sp, #16
 800b32c:	af00      	add	r7, sp, #0
 800b32e:	6078      	str	r0, [r7, #4]
  /* Enable register address automatically incremented during a multiple byte
  access with a serial interface */
  if (lsm6dsv16x_auto_increment_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSV16X_OK)
 800b330:	687b      	ldr	r3, [r7, #4]
 800b332:	3320      	adds	r3, #32
 800b334:	2101      	movs	r1, #1
 800b336:	4618      	mov	r0, r3
 800b338:	f001 fb20 	bl	800c97c <lsm6dsv16x_auto_increment_set>
 800b33c:	4603      	mov	r3, r0
 800b33e:	2b00      	cmp	r3, #0
 800b340:	d002      	beq.n	800b348 <LSM6DSV16X_Init+0x20>
  {
    return LSM6DSV16X_ERROR;
 800b342:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b346:	e064      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  /* Enable BDU */
  if (lsm6dsv16x_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != LSM6DSV16X_OK)
 800b348:	687b      	ldr	r3, [r7, #4]
 800b34a:	3320      	adds	r3, #32
 800b34c:	2101      	movs	r1, #1
 800b34e:	4618      	mov	r0, r3
 800b350:	f001 fb3a 	bl	800c9c8 <lsm6dsv16x_block_data_update_set>
 800b354:	4603      	mov	r3, r0
 800b356:	2b00      	cmp	r3, #0
 800b358:	d002      	beq.n	800b360 <LSM6DSV16X_Init+0x38>
  {
    return LSM6DSV16X_ERROR;
 800b35a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b35e:	e058      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  /* WAKE_UP mode selection */
  if (lsm6dsv16x_fifo_mode_set(&(pObj->Ctx), LSM6DSV16X_BYPASS_MODE) != LSM6DSV16X_OK)
 800b360:	687b      	ldr	r3, [r7, #4]
 800b362:	3320      	adds	r3, #32
 800b364:	2100      	movs	r1, #0
 800b366:	4618      	mov	r0, r3
 800b368:	f001 fcd0 	bl	800cd0c <lsm6dsv16x_fifo_mode_set>
 800b36c:	4603      	mov	r3, r0
 800b36e:	2b00      	cmp	r3, #0
 800b370:	d002      	beq.n	800b378 <LSM6DSV16X_Init+0x50>
  {
    return LSM6DSV16X_ERROR;
 800b372:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b376:	e04c      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  /* Select default output data rate */
  pObj->acc_odr = LSM6DSV16X_ODR_AT_120Hz;
 800b378:	687b      	ldr	r3, [r7, #4]
 800b37a:	2206      	movs	r2, #6
 800b37c:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33

  /* Output data rate selection - power down */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800b380:	687b      	ldr	r3, [r7, #4]
 800b382:	3320      	adds	r3, #32
 800b384:	2100      	movs	r1, #0
 800b386:	4618      	mov	r0, r3
 800b388:	f001 f837 	bl	800c3fa <lsm6dsv16x_xl_data_rate_set>
 800b38c:	4603      	mov	r3, r0
 800b38e:	2b00      	cmp	r3, #0
 800b390:	d002      	beq.n	800b398 <LSM6DSV16X_Init+0x70>
  {
    return LSM6DSV16X_ERROR;
 800b392:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b396:	e03c      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  /* Full scale selection */
  if (lsm6dsv16x_xl_full_scale_set(&(pObj->Ctx), LSM6DSV16X_2g) != LSM6DSV16X_OK)
 800b398:	687b      	ldr	r3, [r7, #4]
 800b39a:	3320      	adds	r3, #32
 800b39c:	2100      	movs	r1, #0
 800b39e:	4618      	mov	r0, r3
 800b3a0:	f001 fbb6 	bl	800cb10 <lsm6dsv16x_xl_full_scale_set>
 800b3a4:	4603      	mov	r3, r0
 800b3a6:	2b00      	cmp	r3, #0
 800b3a8:	d002      	beq.n	800b3b0 <LSM6DSV16X_Init+0x88>
  {
    return LSM6DSV16X_ERROR;
 800b3aa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b3ae:	e030      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  /* Select default output data rate */
  pObj->gyro_odr = LSM6DSV16X_ODR_AT_120Hz;
 800b3b0:	687b      	ldr	r3, [r7, #4]
 800b3b2:	2206      	movs	r2, #6
 800b3b4:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  /* Output data rate selection - power down */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800b3b8:	687b      	ldr	r3, [r7, #4]
 800b3ba:	3320      	adds	r3, #32
 800b3bc:	2100      	movs	r1, #0
 800b3be:	4618      	mov	r0, r3
 800b3c0:	f001 f97c 	bl	800c6bc <lsm6dsv16x_gy_data_rate_set>
 800b3c4:	4603      	mov	r3, r0
 800b3c6:	2b00      	cmp	r3, #0
 800b3c8:	d002      	beq.n	800b3d0 <LSM6DSV16X_Init+0xa8>
  {
    return LSM6DSV16X_ERROR;
 800b3ca:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b3ce:	e020      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  /* Full scale selection */
  if (lsm6dsv16x_gy_full_scale_set(&(pObj->Ctx), LSM6DSV16X_2000dps) != LSM6DSV16X_OK)
 800b3d0:	687b      	ldr	r3, [r7, #4]
 800b3d2:	3320      	adds	r3, #32
 800b3d4:	2104      	movs	r1, #4
 800b3d6:	4618      	mov	r0, r3
 800b3d8:	f001 fb1c 	bl	800ca14 <lsm6dsv16x_gy_full_scale_set>
 800b3dc:	4603      	mov	r3, r0
 800b3de:	2b00      	cmp	r3, #0
 800b3e0:	d002      	beq.n	800b3e8 <LSM6DSV16X_Init+0xc0>
  {
    return LSM6DSV16X_ERROR;
 800b3e2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b3e6:	e014      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  /* Enable Qvar functionality */
  lsm6dsv16x_ah_qvar_mode_t mode;
  mode.ah_qvar_en = 1;
 800b3e8:	7b3b      	ldrb	r3, [r7, #12]
 800b3ea:	f043 0301 	orr.w	r3, r3, #1
 800b3ee:	733b      	strb	r3, [r7, #12]

  if (lsm6dsv16x_ah_qvar_mode_set(&(pObj->Ctx), mode) != LSM6DSV16X_OK)
 800b3f0:	687b      	ldr	r3, [r7, #4]
 800b3f2:	3320      	adds	r3, #32
 800b3f4:	7b39      	ldrb	r1, [r7, #12]
 800b3f6:	4618      	mov	r0, r3
 800b3f8:	f001 fcae 	bl	800cd58 <lsm6dsv16x_ah_qvar_mode_set>
 800b3fc:	4603      	mov	r3, r0
 800b3fe:	2b00      	cmp	r3, #0
 800b400:	d002      	beq.n	800b408 <LSM6DSV16X_Init+0xe0>
  {
    return LSM6DSV16X_ERROR;
 800b402:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b406:	e004      	b.n	800b412 <LSM6DSV16X_Init+0xea>
  }

  pObj->is_initialized = 1;
 800b408:	687b      	ldr	r3, [r7, #4]
 800b40a:	2201      	movs	r2, #1
 800b40c:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LSM6DSV16X_OK;
 800b410:	2300      	movs	r3, #0
}
 800b412:	4618      	mov	r0, r3
 800b414:	3710      	adds	r7, #16
 800b416:	46bd      	mov	sp, r7
 800b418:	bd80      	pop	{r7, pc}

0800b41a <LSM6DSV16X_DeInit>:
  * @brief  Deinitialize the LSM6DSV16X sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_DeInit(LSM6DSV16X_Object_t *pObj)
{
 800b41a:	b580      	push	{r7, lr}
 800b41c:	b084      	sub	sp, #16
 800b41e:	af00      	add	r7, sp, #0
 800b420:	6078      	str	r0, [r7, #4]
  /* Disable the component */
  if (LSM6DSV16X_ACC_Disable(pObj) != LSM6DSV16X_OK)
 800b422:	6878      	ldr	r0, [r7, #4]
 800b424:	f000 f898 	bl	800b558 <LSM6DSV16X_ACC_Disable>
 800b428:	4603      	mov	r3, r0
 800b42a:	2b00      	cmp	r3, #0
 800b42c:	d002      	beq.n	800b434 <LSM6DSV16X_DeInit+0x1a>
  {
    return LSM6DSV16X_ERROR;
 800b42e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b432:	e025      	b.n	800b480 <LSM6DSV16X_DeInit+0x66>
  }

  if (LSM6DSV16X_GYRO_Disable(pObj) != LSM6DSV16X_OK)
 800b434:	6878      	ldr	r0, [r7, #4]
 800b436:	f000 fab2 	bl	800b99e <LSM6DSV16X_GYRO_Disable>
 800b43a:	4603      	mov	r3, r0
 800b43c:	2b00      	cmp	r3, #0
 800b43e:	d002      	beq.n	800b446 <LSM6DSV16X_DeInit+0x2c>
  {
    return LSM6DSV16X_ERROR;
 800b440:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b444:	e01c      	b.n	800b480 <LSM6DSV16X_DeInit+0x66>
  }

  /* Reset output data rate */
  pObj->acc_odr = LSM6DSV16X_ODR_OFF;
 800b446:	687b      	ldr	r3, [r7, #4]
 800b448:	2200      	movs	r2, #0
 800b44a:	f883 2033 	strb.w	r2, [r3, #51]	@ 0x33
  pObj->gyro_odr = LSM6DSV16X_ODR_OFF;
 800b44e:	687b      	ldr	r3, [r7, #4]
 800b450:	2200      	movs	r2, #0
 800b452:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  /* Disable Qvar functionality */
  lsm6dsv16x_ah_qvar_mode_t mode;
  mode.ah_qvar_en = 0;
 800b456:	7b3b      	ldrb	r3, [r7, #12]
 800b458:	f36f 0300 	bfc	r3, #0, #1
 800b45c:	733b      	strb	r3, [r7, #12]

  if (lsm6dsv16x_ah_qvar_mode_set(&(pObj->Ctx), mode) != LSM6DSV16X_OK)
 800b45e:	687b      	ldr	r3, [r7, #4]
 800b460:	3320      	adds	r3, #32
 800b462:	7b39      	ldrb	r1, [r7, #12]
 800b464:	4618      	mov	r0, r3
 800b466:	f001 fc77 	bl	800cd58 <lsm6dsv16x_ah_qvar_mode_set>
 800b46a:	4603      	mov	r3, r0
 800b46c:	2b00      	cmp	r3, #0
 800b46e:	d002      	beq.n	800b476 <LSM6DSV16X_DeInit+0x5c>
  {
    return LSM6DSV16X_ERROR;
 800b470:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b474:	e004      	b.n	800b480 <LSM6DSV16X_DeInit+0x66>
  }

  pObj->is_initialized = 0;
 800b476:	687b      	ldr	r3, [r7, #4]
 800b478:	2200      	movs	r2, #0
 800b47a:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return LSM6DSV16X_OK;
 800b47e:	2300      	movs	r3, #0
}
 800b480:	4618      	mov	r0, r3
 800b482:	3710      	adds	r7, #16
 800b484:	46bd      	mov	sp, r7
 800b486:	bd80      	pop	{r7, pc}

0800b488 <LSM6DSV16X_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ReadID(LSM6DSV16X_Object_t *pObj, uint8_t *Id)
{
 800b488:	b580      	push	{r7, lr}
 800b48a:	b082      	sub	sp, #8
 800b48c:	af00      	add	r7, sp, #0
 800b48e:	6078      	str	r0, [r7, #4]
 800b490:	6039      	str	r1, [r7, #0]
  if (lsm6dsv16x_device_id_get(&(pObj->Ctx), Id) != LSM6DSV16X_OK)
 800b492:	687b      	ldr	r3, [r7, #4]
 800b494:	3320      	adds	r3, #32
 800b496:	6839      	ldr	r1, [r7, #0]
 800b498:	4618      	mov	r0, r3
 800b49a:	f000 ff9d 	bl	800c3d8 <lsm6dsv16x_device_id_get>
 800b49e:	4603      	mov	r3, r0
 800b4a0:	2b00      	cmp	r3, #0
 800b4a2:	d002      	beq.n	800b4aa <LSM6DSV16X_ReadID+0x22>
  {
    return LSM6DSV16X_ERROR;
 800b4a4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b4a8:	e000      	b.n	800b4ac <LSM6DSV16X_ReadID+0x24>
  }

  return LSM6DSV16X_OK;
 800b4aa:	2300      	movs	r3, #0
}
 800b4ac:	4618      	mov	r0, r3
 800b4ae:	3708      	adds	r7, #8
 800b4b0:	46bd      	mov	sp, r7
 800b4b2:	bd80      	pop	{r7, pc}

0800b4b4 <LSM6DSV16X_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to LSM6DSV16X sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GetCapabilities(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_Capabilities_t *Capabilities)
{
 800b4b4:	b480      	push	{r7}
 800b4b6:	b083      	sub	sp, #12
 800b4b8:	af00      	add	r7, sp, #0
 800b4ba:	6078      	str	r0, [r7, #4]
 800b4bc:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Acc          = 1;
 800b4be:	683b      	ldr	r3, [r7, #0]
 800b4c0:	2201      	movs	r2, #1
 800b4c2:	701a      	strb	r2, [r3, #0]
  Capabilities->Gyro         = 1;
 800b4c4:	683b      	ldr	r3, [r7, #0]
 800b4c6:	2201      	movs	r2, #1
 800b4c8:	705a      	strb	r2, [r3, #1]
  Capabilities->Magneto      = 0;
 800b4ca:	683b      	ldr	r3, [r7, #0]
 800b4cc:	2200      	movs	r2, #0
 800b4ce:	709a      	strb	r2, [r3, #2]
  Capabilities->LowPower     = 1;
 800b4d0:	683b      	ldr	r3, [r7, #0]
 800b4d2:	2201      	movs	r2, #1
 800b4d4:	70da      	strb	r2, [r3, #3]
  Capabilities->GyroMaxFS    = 4000;
 800b4d6:	683b      	ldr	r3, [r7, #0]
 800b4d8:	f44f 627a 	mov.w	r2, #4000	@ 0xfa0
 800b4dc:	605a      	str	r2, [r3, #4]
  Capabilities->AccMaxFS     = 16;
 800b4de:	683b      	ldr	r3, [r7, #0]
 800b4e0:	2210      	movs	r2, #16
 800b4e2:	609a      	str	r2, [r3, #8]
  Capabilities->MagMaxFS     = 0;
 800b4e4:	683b      	ldr	r3, [r7, #0]
 800b4e6:	2200      	movs	r2, #0
 800b4e8:	60da      	str	r2, [r3, #12]
  Capabilities->GyroMaxOdr   = 7680.0f;
 800b4ea:	683b      	ldr	r3, [r7, #0]
 800b4ec:	4a07      	ldr	r2, [pc, #28]	@ (800b50c <LSM6DSV16X_GetCapabilities+0x58>)
 800b4ee:	611a      	str	r2, [r3, #16]
  Capabilities->AccMaxOdr    = 7680.0f;
 800b4f0:	683b      	ldr	r3, [r7, #0]
 800b4f2:	4a06      	ldr	r2, [pc, #24]	@ (800b50c <LSM6DSV16X_GetCapabilities+0x58>)
 800b4f4:	615a      	str	r2, [r3, #20]
  Capabilities->MagMaxOdr    = 0.0f;
 800b4f6:	683b      	ldr	r3, [r7, #0]
 800b4f8:	f04f 0200 	mov.w	r2, #0
 800b4fc:	619a      	str	r2, [r3, #24]
  return LSM6DSV16X_OK;
 800b4fe:	2300      	movs	r3, #0
}
 800b500:	4618      	mov	r0, r3
 800b502:	370c      	adds	r7, #12
 800b504:	46bd      	mov	sp, r7
 800b506:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b50a:	4770      	bx	lr
 800b50c:	45f00000 	.word	0x45f00000

0800b510 <LSM6DSV16X_ACC_Enable>:
  * @brief  Enable the LSM6DSV16X accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_Enable(LSM6DSV16X_Object_t *pObj)
{
 800b510:	b580      	push	{r7, lr}
 800b512:	b082      	sub	sp, #8
 800b514:	af00      	add	r7, sp, #0
 800b516:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->acc_is_enabled == 1U)
 800b518:	687b      	ldr	r3, [r7, #4]
 800b51a:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800b51e:	2b01      	cmp	r3, #1
 800b520:	d101      	bne.n	800b526 <LSM6DSV16X_ACC_Enable+0x16>
  {
    return LSM6DSV16X_OK;
 800b522:	2300      	movs	r3, #0
 800b524:	e014      	b.n	800b550 <LSM6DSV16X_ACC_Enable+0x40>
  }

  /* Output data rate selection */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), pObj->acc_odr) != LSM6DSV16X_OK)
 800b526:	687b      	ldr	r3, [r7, #4]
 800b528:	f103 0220 	add.w	r2, r3, #32
 800b52c:	687b      	ldr	r3, [r7, #4]
 800b52e:	f893 3033 	ldrb.w	r3, [r3, #51]	@ 0x33
 800b532:	4619      	mov	r1, r3
 800b534:	4610      	mov	r0, r2
 800b536:	f000 ff60 	bl	800c3fa <lsm6dsv16x_xl_data_rate_set>
 800b53a:	4603      	mov	r3, r0
 800b53c:	2b00      	cmp	r3, #0
 800b53e:	d002      	beq.n	800b546 <LSM6DSV16X_ACC_Enable+0x36>
  {
    return LSM6DSV16X_ERROR;
 800b540:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b544:	e004      	b.n	800b550 <LSM6DSV16X_ACC_Enable+0x40>
  }

  pObj->acc_is_enabled = 1;
 800b546:	687b      	ldr	r3, [r7, #4]
 800b548:	2201      	movs	r2, #1
 800b54a:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LSM6DSV16X_OK;
 800b54e:	2300      	movs	r3, #0
}
 800b550:	4618      	mov	r0, r3
 800b552:	3708      	adds	r7, #8
 800b554:	46bd      	mov	sp, r7
 800b556:	bd80      	pop	{r7, pc}

0800b558 <LSM6DSV16X_ACC_Disable>:
  * @brief  Disable the LSM6DSV16X accelerometer sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_Disable(LSM6DSV16X_Object_t *pObj)
{
 800b558:	b580      	push	{r7, lr}
 800b55a:	b082      	sub	sp, #8
 800b55c:	af00      	add	r7, sp, #0
 800b55e:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->acc_is_enabled == 0U)
 800b560:	687b      	ldr	r3, [r7, #4]
 800b562:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800b566:	2b00      	cmp	r3, #0
 800b568:	d101      	bne.n	800b56e <LSM6DSV16X_ACC_Disable+0x16>
  {
    return LSM6DSV16X_OK;
 800b56a:	2300      	movs	r3, #0
 800b56c:	e01f      	b.n	800b5ae <LSM6DSV16X_ACC_Disable+0x56>
  }

  /* Get current output data rate */
  if (lsm6dsv16x_xl_data_rate_get(&(pObj->Ctx), &pObj->acc_odr) != LSM6DSV16X_OK)
 800b56e:	687b      	ldr	r3, [r7, #4]
 800b570:	f103 0220 	add.w	r2, r3, #32
 800b574:	687b      	ldr	r3, [r7, #4]
 800b576:	3333      	adds	r3, #51	@ 0x33
 800b578:	4619      	mov	r1, r3
 800b57a:	4610      	mov	r0, r2
 800b57c:	f000 ff8e 	bl	800c49c <lsm6dsv16x_xl_data_rate_get>
 800b580:	4603      	mov	r3, r0
 800b582:	2b00      	cmp	r3, #0
 800b584:	d002      	beq.n	800b58c <LSM6DSV16X_ACC_Disable+0x34>
  {
    return LSM6DSV16X_ERROR;
 800b586:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b58a:	e010      	b.n	800b5ae <LSM6DSV16X_ACC_Disable+0x56>
  }

  /* Output data rate selection - power down */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800b58c:	687b      	ldr	r3, [r7, #4]
 800b58e:	3320      	adds	r3, #32
 800b590:	2100      	movs	r1, #0
 800b592:	4618      	mov	r0, r3
 800b594:	f000 ff31 	bl	800c3fa <lsm6dsv16x_xl_data_rate_set>
 800b598:	4603      	mov	r3, r0
 800b59a:	2b00      	cmp	r3, #0
 800b59c:	d002      	beq.n	800b5a4 <LSM6DSV16X_ACC_Disable+0x4c>
  {
    return LSM6DSV16X_ERROR;
 800b59e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b5a2:	e004      	b.n	800b5ae <LSM6DSV16X_ACC_Disable+0x56>
  }

  pObj->acc_is_enabled = 0;
 800b5a4:	687b      	ldr	r3, [r7, #4]
 800b5a6:	2200      	movs	r2, #0
 800b5a8:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return LSM6DSV16X_OK;
 800b5ac:	2300      	movs	r3, #0
}
 800b5ae:	4618      	mov	r0, r3
 800b5b0:	3708      	adds	r7, #8
 800b5b2:	46bd      	mov	sp, r7
 800b5b4:	bd80      	pop	{r7, pc}
	...

0800b5b8 <LSM6DSV16X_ACC_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetSensitivity(LSM6DSV16X_Object_t *pObj, float *Sensitivity)
{
 800b5b8:	b580      	push	{r7, lr}
 800b5ba:	b084      	sub	sp, #16
 800b5bc:	af00      	add	r7, sp, #0
 800b5be:	6078      	str	r0, [r7, #4]
 800b5c0:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800b5c2:	2300      	movs	r3, #0
 800b5c4:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_xl_full_scale_t full_scale;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_xl_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSV16X_OK)
 800b5c6:	687b      	ldr	r3, [r7, #4]
 800b5c8:	3320      	adds	r3, #32
 800b5ca:	f107 020b 	add.w	r2, r7, #11
 800b5ce:	4611      	mov	r1, r2
 800b5d0:	4618      	mov	r0, r3
 800b5d2:	f001 fac3 	bl	800cb5c <lsm6dsv16x_xl_full_scale_get>
 800b5d6:	4603      	mov	r3, r0
 800b5d8:	2b00      	cmp	r3, #0
 800b5da:	d002      	beq.n	800b5e2 <LSM6DSV16X_ACC_GetSensitivity+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800b5dc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b5e0:	e023      	b.n	800b62a <LSM6DSV16X_ACC_GetSensitivity+0x72>
  }

  /* Store the Sensitivity based on actual full scale */
  switch (full_scale)
 800b5e2:	7afb      	ldrb	r3, [r7, #11]
 800b5e4:	2b03      	cmp	r3, #3
 800b5e6:	d81b      	bhi.n	800b620 <LSM6DSV16X_ACC_GetSensitivity+0x68>
 800b5e8:	a201      	add	r2, pc, #4	@ (adr r2, 800b5f0 <LSM6DSV16X_ACC_GetSensitivity+0x38>)
 800b5ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b5ee:	bf00      	nop
 800b5f0:	0800b601 	.word	0x0800b601
 800b5f4:	0800b609 	.word	0x0800b609
 800b5f8:	0800b611 	.word	0x0800b611
 800b5fc:	0800b619 	.word	0x0800b619
  {
    case LSM6DSV16X_2g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_2G;
 800b600:	683b      	ldr	r3, [r7, #0]
 800b602:	4a0c      	ldr	r2, [pc, #48]	@ (800b634 <LSM6DSV16X_ACC_GetSensitivity+0x7c>)
 800b604:	601a      	str	r2, [r3, #0]
      break;
 800b606:	e00f      	b.n	800b628 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    case LSM6DSV16X_4g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_4G;
 800b608:	683b      	ldr	r3, [r7, #0]
 800b60a:	4a0b      	ldr	r2, [pc, #44]	@ (800b638 <LSM6DSV16X_ACC_GetSensitivity+0x80>)
 800b60c:	601a      	str	r2, [r3, #0]
      break;
 800b60e:	e00b      	b.n	800b628 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    case LSM6DSV16X_8g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_8G;
 800b610:	683b      	ldr	r3, [r7, #0]
 800b612:	4a0a      	ldr	r2, [pc, #40]	@ (800b63c <LSM6DSV16X_ACC_GetSensitivity+0x84>)
 800b614:	601a      	str	r2, [r3, #0]
      break;
 800b616:	e007      	b.n	800b628 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    case LSM6DSV16X_16g:
      *Sensitivity = LSM6DSV16X_ACC_SENSITIVITY_FS_16G;
 800b618:	683b      	ldr	r3, [r7, #0]
 800b61a:	4a09      	ldr	r2, [pc, #36]	@ (800b640 <LSM6DSV16X_ACC_GetSensitivity+0x88>)
 800b61c:	601a      	str	r2, [r3, #0]
      break;
 800b61e:	e003      	b.n	800b628 <LSM6DSV16X_ACC_GetSensitivity+0x70>

    default:
      ret = LSM6DSV16X_ERROR;
 800b620:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b624:	60fb      	str	r3, [r7, #12]
      break;
 800b626:	bf00      	nop
  }

  return ret;
 800b628:	68fb      	ldr	r3, [r7, #12]
}
 800b62a:	4618      	mov	r0, r3
 800b62c:	3710      	adds	r7, #16
 800b62e:	46bd      	mov	sp, r7
 800b630:	bd80      	pop	{r7, pc}
 800b632:	bf00      	nop
 800b634:	3d79db23 	.word	0x3d79db23
 800b638:	3df9db23 	.word	0x3df9db23
 800b63c:	3e79db23 	.word	0x3e79db23
 800b640:	3ef9db23 	.word	0x3ef9db23

0800b644 <LSM6DSV16X_ACC_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetOutputDataRate(LSM6DSV16X_Object_t *pObj, float *Odr)
{
 800b644:	b580      	push	{r7, lr}
 800b646:	b084      	sub	sp, #16
 800b648:	af00      	add	r7, sp, #0
 800b64a:	6078      	str	r0, [r7, #4]
 800b64c:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800b64e:	2300      	movs	r3, #0
 800b650:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_data_rate_t odr_low_level;

  /* Get current output data rate */
  if (lsm6dsv16x_xl_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSV16X_OK)
 800b652:	687b      	ldr	r3, [r7, #4]
 800b654:	3320      	adds	r3, #32
 800b656:	f107 020b 	add.w	r2, r7, #11
 800b65a:	4611      	mov	r1, r2
 800b65c:	4618      	mov	r0, r3
 800b65e:	f000 ff1d 	bl	800c49c <lsm6dsv16x_xl_data_rate_get>
 800b662:	4603      	mov	r3, r0
 800b664:	2b00      	cmp	r3, #0
 800b666:	d002      	beq.n	800b66e <LSM6DSV16X_ACC_GetOutputDataRate+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800b668:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b66c:	e05a      	b.n	800b724 <LSM6DSV16X_ACC_GetOutputDataRate+0xe0>
  }

  switch (odr_low_level)
 800b66e:	7afb      	ldrb	r3, [r7, #11]
 800b670:	2b0c      	cmp	r3, #12
 800b672:	d852      	bhi.n	800b71a <LSM6DSV16X_ACC_GetOutputDataRate+0xd6>
 800b674:	a201      	add	r2, pc, #4	@ (adr r2, 800b67c <LSM6DSV16X_ACC_GetOutputDataRate+0x38>)
 800b676:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b67a:	bf00      	nop
 800b67c:	0800b6b1 	.word	0x0800b6b1
 800b680:	0800b6bb 	.word	0x0800b6bb
 800b684:	0800b6c3 	.word	0x0800b6c3
 800b688:	0800b6cb 	.word	0x0800b6cb
 800b68c:	0800b6d3 	.word	0x0800b6d3
 800b690:	0800b6db 	.word	0x0800b6db
 800b694:	0800b6e3 	.word	0x0800b6e3
 800b698:	0800b6eb 	.word	0x0800b6eb
 800b69c:	0800b6f3 	.word	0x0800b6f3
 800b6a0:	0800b6fb 	.word	0x0800b6fb
 800b6a4:	0800b703 	.word	0x0800b703
 800b6a8:	0800b70b 	.word	0x0800b70b
 800b6ac:	0800b713 	.word	0x0800b713
  {
    case LSM6DSV16X_ODR_OFF:
      *Odr = 0.0f;
 800b6b0:	683b      	ldr	r3, [r7, #0]
 800b6b2:	f04f 0200 	mov.w	r2, #0
 800b6b6:	601a      	str	r2, [r3, #0]
      break;
 800b6b8:	e033      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_1Hz875:
      *Odr = 1.875f;
 800b6ba:	683b      	ldr	r3, [r7, #0]
 800b6bc:	4a1b      	ldr	r2, [pc, #108]	@ (800b72c <LSM6DSV16X_ACC_GetOutputDataRate+0xe8>)
 800b6be:	601a      	str	r2, [r3, #0]
      break;
 800b6c0:	e02f      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *Odr = 7.5f;
 800b6c2:	683b      	ldr	r3, [r7, #0]
 800b6c4:	4a1a      	ldr	r2, [pc, #104]	@ (800b730 <LSM6DSV16X_ACC_GetOutputDataRate+0xec>)
 800b6c6:	601a      	str	r2, [r3, #0]
      break;
 800b6c8:	e02b      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_15Hz:
      *Odr = 15.0f;
 800b6ca:	683b      	ldr	r3, [r7, #0]
 800b6cc:	4a19      	ldr	r2, [pc, #100]	@ (800b734 <LSM6DSV16X_ACC_GetOutputDataRate+0xf0>)
 800b6ce:	601a      	str	r2, [r3, #0]
      break;
 800b6d0:	e027      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_30Hz:
      *Odr = 30.0f;
 800b6d2:	683b      	ldr	r3, [r7, #0]
 800b6d4:	4a18      	ldr	r2, [pc, #96]	@ (800b738 <LSM6DSV16X_ACC_GetOutputDataRate+0xf4>)
 800b6d6:	601a      	str	r2, [r3, #0]
      break;
 800b6d8:	e023      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_60Hz:
      *Odr = 60.0f;
 800b6da:	683b      	ldr	r3, [r7, #0]
 800b6dc:	4a17      	ldr	r2, [pc, #92]	@ (800b73c <LSM6DSV16X_ACC_GetOutputDataRate+0xf8>)
 800b6de:	601a      	str	r2, [r3, #0]
      break;
 800b6e0:	e01f      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_120Hz:
      *Odr = 120.0f;
 800b6e2:	683b      	ldr	r3, [r7, #0]
 800b6e4:	4a16      	ldr	r2, [pc, #88]	@ (800b740 <LSM6DSV16X_ACC_GetOutputDataRate+0xfc>)
 800b6e6:	601a      	str	r2, [r3, #0]
      break;
 800b6e8:	e01b      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_240Hz:
      *Odr = 240.0f;
 800b6ea:	683b      	ldr	r3, [r7, #0]
 800b6ec:	4a15      	ldr	r2, [pc, #84]	@ (800b744 <LSM6DSV16X_ACC_GetOutputDataRate+0x100>)
 800b6ee:	601a      	str	r2, [r3, #0]
      break;
 800b6f0:	e017      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_480Hz:
      *Odr = 480.0f;
 800b6f2:	683b      	ldr	r3, [r7, #0]
 800b6f4:	4a14      	ldr	r2, [pc, #80]	@ (800b748 <LSM6DSV16X_ACC_GetOutputDataRate+0x104>)
 800b6f6:	601a      	str	r2, [r3, #0]
      break;
 800b6f8:	e013      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_960Hz:
      *Odr = 960.0f;
 800b6fa:	683b      	ldr	r3, [r7, #0]
 800b6fc:	4a13      	ldr	r2, [pc, #76]	@ (800b74c <LSM6DSV16X_ACC_GetOutputDataRate+0x108>)
 800b6fe:	601a      	str	r2, [r3, #0]
      break;
 800b700:	e00f      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_1920Hz:
      *Odr = 1920.0f;
 800b702:	683b      	ldr	r3, [r7, #0]
 800b704:	4a12      	ldr	r2, [pc, #72]	@ (800b750 <LSM6DSV16X_ACC_GetOutputDataRate+0x10c>)
 800b706:	601a      	str	r2, [r3, #0]
      break;
 800b708:	e00b      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_3840Hz:
      *Odr = 3840.0f;
 800b70a:	683b      	ldr	r3, [r7, #0]
 800b70c:	4a11      	ldr	r2, [pc, #68]	@ (800b754 <LSM6DSV16X_ACC_GetOutputDataRate+0x110>)
 800b70e:	601a      	str	r2, [r3, #0]
      break;
 800b710:	e007      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    case LSM6DSV16X_ODR_AT_7680Hz:
      *Odr = 7680.0f;
 800b712:	683b      	ldr	r3, [r7, #0]
 800b714:	4a10      	ldr	r2, [pc, #64]	@ (800b758 <LSM6DSV16X_ACC_GetOutputDataRate+0x114>)
 800b716:	601a      	str	r2, [r3, #0]
      break;
 800b718:	e003      	b.n	800b722 <LSM6DSV16X_ACC_GetOutputDataRate+0xde>

    default:
      ret = LSM6DSV16X_ERROR;
 800b71a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b71e:	60fb      	str	r3, [r7, #12]
      break;
 800b720:	bf00      	nop
  }

  return ret;
 800b722:	68fb      	ldr	r3, [r7, #12]
}
 800b724:	4618      	mov	r0, r3
 800b726:	3710      	adds	r7, #16
 800b728:	46bd      	mov	sp, r7
 800b72a:	bd80      	pop	{r7, pc}
 800b72c:	3ff00000 	.word	0x3ff00000
 800b730:	40f00000 	.word	0x40f00000
 800b734:	41700000 	.word	0x41700000
 800b738:	41f00000 	.word	0x41f00000
 800b73c:	42700000 	.word	0x42700000
 800b740:	42f00000 	.word	0x42f00000
 800b744:	43700000 	.word	0x43700000
 800b748:	43f00000 	.word	0x43f00000
 800b74c:	44700000 	.word	0x44700000
 800b750:	44f00000 	.word	0x44f00000
 800b754:	45700000 	.word	0x45700000
 800b758:	45f00000 	.word	0x45f00000

0800b75c <LSM6DSV16X_ACC_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_SetOutputDataRate(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800b75c:	b580      	push	{r7, lr}
 800b75e:	b082      	sub	sp, #8
 800b760:	af00      	add	r7, sp, #0
 800b762:	6078      	str	r0, [r7, #4]
 800b764:	ed87 0a00 	vstr	s0, [r7]
  if (pObj->acc_is_enabled == 1U)
 800b768:	687b      	ldr	r3, [r7, #4]
 800b76a:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800b76e:	2b01      	cmp	r3, #1
 800b770:	d106      	bne.n	800b780 <LSM6DSV16X_ACC_SetOutputDataRate+0x24>
  {
    return LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled(pObj, Odr);
 800b772:	ed97 0a00 	vldr	s0, [r7]
 800b776:	6878      	ldr	r0, [r7, #4]
 800b778:	f000 fb6a 	bl	800be50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled>
 800b77c:	4603      	mov	r3, r0
 800b77e:	e005      	b.n	800b78c <LSM6DSV16X_ACC_SetOutputDataRate+0x30>
  }
  else
  {
    return LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled(pObj, Odr);
 800b780:	ed97 0a00 	vldr	s0, [r7]
 800b784:	6878      	ldr	r0, [r7, #4]
 800b786:	f000 fc05 	bl	800bf94 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled>
 800b78a:	4603      	mov	r3, r0
  }
}
 800b78c:	4618      	mov	r0, r3
 800b78e:	3708      	adds	r7, #8
 800b790:	46bd      	mov	sp, r7
 800b792:	bd80      	pop	{r7, pc}

0800b794 <LSM6DSV16X_ACC_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetFullScale(LSM6DSV16X_Object_t *pObj, int32_t *FullScale)
{
 800b794:	b580      	push	{r7, lr}
 800b796:	b084      	sub	sp, #16
 800b798:	af00      	add	r7, sp, #0
 800b79a:	6078      	str	r0, [r7, #4]
 800b79c:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800b79e:	2300      	movs	r3, #0
 800b7a0:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_xl_full_scale_t fs_low_level;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_xl_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSV16X_OK)
 800b7a2:	687b      	ldr	r3, [r7, #4]
 800b7a4:	3320      	adds	r3, #32
 800b7a6:	f107 020b 	add.w	r2, r7, #11
 800b7aa:	4611      	mov	r1, r2
 800b7ac:	4618      	mov	r0, r3
 800b7ae:	f001 f9d5 	bl	800cb5c <lsm6dsv16x_xl_full_scale_get>
 800b7b2:	4603      	mov	r3, r0
 800b7b4:	2b00      	cmp	r3, #0
 800b7b6:	d002      	beq.n	800b7be <LSM6DSV16X_ACC_GetFullScale+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800b7b8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b7bc:	e023      	b.n	800b806 <LSM6DSV16X_ACC_GetFullScale+0x72>
  }

  switch (fs_low_level)
 800b7be:	7afb      	ldrb	r3, [r7, #11]
 800b7c0:	2b03      	cmp	r3, #3
 800b7c2:	d81b      	bhi.n	800b7fc <LSM6DSV16X_ACC_GetFullScale+0x68>
 800b7c4:	a201      	add	r2, pc, #4	@ (adr r2, 800b7cc <LSM6DSV16X_ACC_GetFullScale+0x38>)
 800b7c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b7ca:	bf00      	nop
 800b7cc:	0800b7dd 	.word	0x0800b7dd
 800b7d0:	0800b7e5 	.word	0x0800b7e5
 800b7d4:	0800b7ed 	.word	0x0800b7ed
 800b7d8:	0800b7f5 	.word	0x0800b7f5
  {
    case LSM6DSV16X_2g:
      *FullScale =  2;
 800b7dc:	683b      	ldr	r3, [r7, #0]
 800b7de:	2202      	movs	r2, #2
 800b7e0:	601a      	str	r2, [r3, #0]
      break;
 800b7e2:	e00f      	b.n	800b804 <LSM6DSV16X_ACC_GetFullScale+0x70>

    case LSM6DSV16X_4g:
      *FullScale =  4;
 800b7e4:	683b      	ldr	r3, [r7, #0]
 800b7e6:	2204      	movs	r2, #4
 800b7e8:	601a      	str	r2, [r3, #0]
      break;
 800b7ea:	e00b      	b.n	800b804 <LSM6DSV16X_ACC_GetFullScale+0x70>

    case LSM6DSV16X_8g:
      *FullScale =  8;
 800b7ec:	683b      	ldr	r3, [r7, #0]
 800b7ee:	2208      	movs	r2, #8
 800b7f0:	601a      	str	r2, [r3, #0]
      break;
 800b7f2:	e007      	b.n	800b804 <LSM6DSV16X_ACC_GetFullScale+0x70>

    case LSM6DSV16X_16g:
      *FullScale = 16;
 800b7f4:	683b      	ldr	r3, [r7, #0]
 800b7f6:	2210      	movs	r2, #16
 800b7f8:	601a      	str	r2, [r3, #0]
      break;
 800b7fa:	e003      	b.n	800b804 <LSM6DSV16X_ACC_GetFullScale+0x70>

    default:
      ret = LSM6DSV16X_ERROR;
 800b7fc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b800:	60fb      	str	r3, [r7, #12]
      break;
 800b802:	bf00      	nop
  }

  return ret;
 800b804:	68fb      	ldr	r3, [r7, #12]
}
 800b806:	4618      	mov	r0, r3
 800b808:	3710      	adds	r7, #16
 800b80a:	46bd      	mov	sp, r7
 800b80c:	bd80      	pop	{r7, pc}
 800b80e:	bf00      	nop

0800b810 <LSM6DSV16X_ACC_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_SetFullScale(LSM6DSV16X_Object_t *pObj, int32_t FullScale)
{
 800b810:	b580      	push	{r7, lr}
 800b812:	b084      	sub	sp, #16
 800b814:	af00      	add	r7, sp, #0
 800b816:	6078      	str	r0, [r7, #4]
 800b818:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_xl_full_scale_t new_fs;

  /* Seems like MISRA C-2012 rule 14.3a violation but only from single file statical analysis point of view because
     the parameter passed to the function is not known at the moment of analysis */
  new_fs = (FullScale <= 2) ? LSM6DSV16X_2g
           : (FullScale <= 4) ? LSM6DSV16X_4g
 800b81a:	683b      	ldr	r3, [r7, #0]
 800b81c:	2b02      	cmp	r3, #2
 800b81e:	dd0b      	ble.n	800b838 <LSM6DSV16X_ACC_SetFullScale+0x28>
 800b820:	683b      	ldr	r3, [r7, #0]
 800b822:	2b04      	cmp	r3, #4
 800b824:	dd06      	ble.n	800b834 <LSM6DSV16X_ACC_SetFullScale+0x24>
 800b826:	683b      	ldr	r3, [r7, #0]
 800b828:	2b08      	cmp	r3, #8
 800b82a:	dc01      	bgt.n	800b830 <LSM6DSV16X_ACC_SetFullScale+0x20>
 800b82c:	2302      	movs	r3, #2
 800b82e:	e004      	b.n	800b83a <LSM6DSV16X_ACC_SetFullScale+0x2a>
 800b830:	2303      	movs	r3, #3
 800b832:	e002      	b.n	800b83a <LSM6DSV16X_ACC_SetFullScale+0x2a>
 800b834:	2301      	movs	r3, #1
 800b836:	e000      	b.n	800b83a <LSM6DSV16X_ACC_SetFullScale+0x2a>
 800b838:	2300      	movs	r3, #0
  new_fs = (FullScale <= 2) ? LSM6DSV16X_2g
 800b83a:	73fb      	strb	r3, [r7, #15]
           : (FullScale <= 8) ? LSM6DSV16X_8g
           :                    LSM6DSV16X_16g;

  if (lsm6dsv16x_xl_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSV16X_OK)
 800b83c:	687b      	ldr	r3, [r7, #4]
 800b83e:	3320      	adds	r3, #32
 800b840:	7bfa      	ldrb	r2, [r7, #15]
 800b842:	4611      	mov	r1, r2
 800b844:	4618      	mov	r0, r3
 800b846:	f001 f963 	bl	800cb10 <lsm6dsv16x_xl_full_scale_set>
 800b84a:	4603      	mov	r3, r0
 800b84c:	2b00      	cmp	r3, #0
 800b84e:	d002      	beq.n	800b856 <LSM6DSV16X_ACC_SetFullScale+0x46>
  {
    return LSM6DSV16X_ERROR;
 800b850:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b854:	e000      	b.n	800b858 <LSM6DSV16X_ACC_SetFullScale+0x48>
  }

  return LSM6DSV16X_OK;
 800b856:	2300      	movs	r3, #0
}
 800b858:	4618      	mov	r0, r3
 800b85a:	3710      	adds	r7, #16
 800b85c:	46bd      	mov	sp, r7
 800b85e:	bd80      	pop	{r7, pc}

0800b860 <LSM6DSV16X_ACC_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetAxesRaw(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_AxesRaw_t *Value)
{
 800b860:	b580      	push	{r7, lr}
 800b862:	b084      	sub	sp, #16
 800b864:	af00      	add	r7, sp, #0
 800b866:	6078      	str	r0, [r7, #4]
 800b868:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;

  /* Read raw data values */
  if (lsm6dsv16x_acceleration_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800b86a:	687b      	ldr	r3, [r7, #4]
 800b86c:	3320      	adds	r3, #32
 800b86e:	f107 0208 	add.w	r2, r7, #8
 800b872:	4611      	mov	r1, r2
 800b874:	4618      	mov	r0, r3
 800b876:	f001 f9fc 	bl	800cc72 <lsm6dsv16x_acceleration_raw_get>
 800b87a:	4603      	mov	r3, r0
 800b87c:	2b00      	cmp	r3, #0
 800b87e:	d002      	beq.n	800b886 <LSM6DSV16X_ACC_GetAxesRaw+0x26>
  {
    return LSM6DSV16X_ERROR;
 800b880:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b884:	e00c      	b.n	800b8a0 <LSM6DSV16X_ACC_GetAxesRaw+0x40>
  }

  /* Format the data */
  Value->x = data_raw.i16bit[0];
 800b886:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 800b88a:	683b      	ldr	r3, [r7, #0]
 800b88c:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw.i16bit[1];
 800b88e:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 800b892:	683b      	ldr	r3, [r7, #0]
 800b894:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw.i16bit[2];
 800b896:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 800b89a:	683b      	ldr	r3, [r7, #0]
 800b89c:	809a      	strh	r2, [r3, #4]

  return LSM6DSV16X_OK;
 800b89e:	2300      	movs	r3, #0
}
 800b8a0:	4618      	mov	r0, r3
 800b8a2:	3710      	adds	r7, #16
 800b8a4:	46bd      	mov	sp, r7
 800b8a6:	bd80      	pop	{r7, pc}

0800b8a8 <LSM6DSV16X_ACC_GetAxes>:
  * @param  pObj the device pObj
  * @param  Acceleration pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_ACC_GetAxes(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_Axes_t *Acceleration)
{
 800b8a8:	b580      	push	{r7, lr}
 800b8aa:	b086      	sub	sp, #24
 800b8ac:	af00      	add	r7, sp, #0
 800b8ae:	6078      	str	r0, [r7, #4]
 800b8b0:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;
  float sensitivity = 0.0f;
 800b8b2:	f04f 0300 	mov.w	r3, #0
 800b8b6:	60fb      	str	r3, [r7, #12]

  /* Read raw data values */
  if (lsm6dsv16x_acceleration_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800b8b8:	687b      	ldr	r3, [r7, #4]
 800b8ba:	3320      	adds	r3, #32
 800b8bc:	f107 0210 	add.w	r2, r7, #16
 800b8c0:	4611      	mov	r1, r2
 800b8c2:	4618      	mov	r0, r3
 800b8c4:	f001 f9d5 	bl	800cc72 <lsm6dsv16x_acceleration_raw_get>
 800b8c8:	4603      	mov	r3, r0
 800b8ca:	2b00      	cmp	r3, #0
 800b8cc:	d002      	beq.n	800b8d4 <LSM6DSV16X_ACC_GetAxes+0x2c>
  {
    return LSM6DSV16X_ERROR;
 800b8ce:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b8d2:	e03c      	b.n	800b94e <LSM6DSV16X_ACC_GetAxes+0xa6>
  }

  /* Get LSM6DSV16X actual sensitivity */
  if (LSM6DSV16X_ACC_GetSensitivity(pObj, &sensitivity) != LSM6DSV16X_OK)
 800b8d4:	f107 030c 	add.w	r3, r7, #12
 800b8d8:	4619      	mov	r1, r3
 800b8da:	6878      	ldr	r0, [r7, #4]
 800b8dc:	f7ff fe6c 	bl	800b5b8 <LSM6DSV16X_ACC_GetSensitivity>
 800b8e0:	4603      	mov	r3, r0
 800b8e2:	2b00      	cmp	r3, #0
 800b8e4:	d002      	beq.n	800b8ec <LSM6DSV16X_ACC_GetAxes+0x44>
  {
    return LSM6DSV16X_ERROR;
 800b8e6:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b8ea:	e030      	b.n	800b94e <LSM6DSV16X_ACC_GetAxes+0xa6>
  }

  /* Calculate the data */
  Acceleration->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800b8ec:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800b8f0:	ee07 3a90 	vmov	s15, r3
 800b8f4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800b8f8:	edd7 7a03 	vldr	s15, [r7, #12]
 800b8fc:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b900:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800b904:	ee17 2a90 	vmov	r2, s15
 800b908:	683b      	ldr	r3, [r7, #0]
 800b90a:	601a      	str	r2, [r3, #0]
  Acceleration->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800b90c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800b910:	ee07 3a90 	vmov	s15, r3
 800b914:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800b918:	edd7 7a03 	vldr	s15, [r7, #12]
 800b91c:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b920:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800b924:	ee17 2a90 	vmov	r2, s15
 800b928:	683b      	ldr	r3, [r7, #0]
 800b92a:	605a      	str	r2, [r3, #4]
  Acceleration->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800b92c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800b930:	ee07 3a90 	vmov	s15, r3
 800b934:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800b938:	edd7 7a03 	vldr	s15, [r7, #12]
 800b93c:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b940:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800b944:	ee17 2a90 	vmov	r2, s15
 800b948:	683b      	ldr	r3, [r7, #0]
 800b94a:	609a      	str	r2, [r3, #8]

  return LSM6DSV16X_OK;
 800b94c:	2300      	movs	r3, #0
}
 800b94e:	4618      	mov	r0, r3
 800b950:	3718      	adds	r7, #24
 800b952:	46bd      	mov	sp, r7
 800b954:	bd80      	pop	{r7, pc}

0800b956 <LSM6DSV16X_GYRO_Enable>:
  * @brief  Enable the LSM6DSV16X gyroscope sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_Enable(LSM6DSV16X_Object_t *pObj)
{
 800b956:	b580      	push	{r7, lr}
 800b958:	b082      	sub	sp, #8
 800b95a:	af00      	add	r7, sp, #0
 800b95c:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->gyro_is_enabled == 1U)
 800b95e:	687b      	ldr	r3, [r7, #4]
 800b960:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800b964:	2b01      	cmp	r3, #1
 800b966:	d101      	bne.n	800b96c <LSM6DSV16X_GYRO_Enable+0x16>
  {
    return LSM6DSV16X_OK;
 800b968:	2300      	movs	r3, #0
 800b96a:	e014      	b.n	800b996 <LSM6DSV16X_GYRO_Enable+0x40>
  }

  /* Output data rate selection */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), pObj->gyro_odr) != LSM6DSV16X_OK)
 800b96c:	687b      	ldr	r3, [r7, #4]
 800b96e:	f103 0220 	add.w	r2, r3, #32
 800b972:	687b      	ldr	r3, [r7, #4]
 800b974:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800b978:	4619      	mov	r1, r3
 800b97a:	4610      	mov	r0, r2
 800b97c:	f000 fe9e 	bl	800c6bc <lsm6dsv16x_gy_data_rate_set>
 800b980:	4603      	mov	r3, r0
 800b982:	2b00      	cmp	r3, #0
 800b984:	d002      	beq.n	800b98c <LSM6DSV16X_GYRO_Enable+0x36>
  {
    return LSM6DSV16X_ERROR;
 800b986:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b98a:	e004      	b.n	800b996 <LSM6DSV16X_GYRO_Enable+0x40>
  }

  pObj->gyro_is_enabled = 1;
 800b98c:	687b      	ldr	r3, [r7, #4]
 800b98e:	2201      	movs	r2, #1
 800b990:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LSM6DSV16X_OK;
 800b994:	2300      	movs	r3, #0
}
 800b996:	4618      	mov	r0, r3
 800b998:	3708      	adds	r7, #8
 800b99a:	46bd      	mov	sp, r7
 800b99c:	bd80      	pop	{r7, pc}

0800b99e <LSM6DSV16X_GYRO_Disable>:
  * @brief  Disable the LSM6DSV16X gyroscope sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_Disable(LSM6DSV16X_Object_t *pObj)
{
 800b99e:	b580      	push	{r7, lr}
 800b9a0:	b082      	sub	sp, #8
 800b9a2:	af00      	add	r7, sp, #0
 800b9a4:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->gyro_is_enabled == 0U)
 800b9a6:	687b      	ldr	r3, [r7, #4]
 800b9a8:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800b9ac:	2b00      	cmp	r3, #0
 800b9ae:	d101      	bne.n	800b9b4 <LSM6DSV16X_GYRO_Disable+0x16>
  {
    return LSM6DSV16X_OK;
 800b9b0:	2300      	movs	r3, #0
 800b9b2:	e01f      	b.n	800b9f4 <LSM6DSV16X_GYRO_Disable+0x56>
  }

  /* Get current output data rate */
  if (lsm6dsv16x_gy_data_rate_get(&(pObj->Ctx), &pObj->gyro_odr) != LSM6DSV16X_OK)
 800b9b4:	687b      	ldr	r3, [r7, #4]
 800b9b6:	f103 0220 	add.w	r2, r3, #32
 800b9ba:	687b      	ldr	r3, [r7, #4]
 800b9bc:	3334      	adds	r3, #52	@ 0x34
 800b9be:	4619      	mov	r1, r3
 800b9c0:	4610      	mov	r0, r2
 800b9c2:	f000 fecb 	bl	800c75c <lsm6dsv16x_gy_data_rate_get>
 800b9c6:	4603      	mov	r3, r0
 800b9c8:	2b00      	cmp	r3, #0
 800b9ca:	d002      	beq.n	800b9d2 <LSM6DSV16X_GYRO_Disable+0x34>
  {
    return LSM6DSV16X_ERROR;
 800b9cc:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b9d0:	e010      	b.n	800b9f4 <LSM6DSV16X_GYRO_Disable+0x56>
  }

  /* Output data rate selection - power down */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), LSM6DSV16X_ODR_OFF) != LSM6DSV16X_OK)
 800b9d2:	687b      	ldr	r3, [r7, #4]
 800b9d4:	3320      	adds	r3, #32
 800b9d6:	2100      	movs	r1, #0
 800b9d8:	4618      	mov	r0, r3
 800b9da:	f000 fe6f 	bl	800c6bc <lsm6dsv16x_gy_data_rate_set>
 800b9de:	4603      	mov	r3, r0
 800b9e0:	2b00      	cmp	r3, #0
 800b9e2:	d002      	beq.n	800b9ea <LSM6DSV16X_GYRO_Disable+0x4c>
  {
    return LSM6DSV16X_ERROR;
 800b9e4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800b9e8:	e004      	b.n	800b9f4 <LSM6DSV16X_GYRO_Disable+0x56>
  }

  pObj->gyro_is_enabled = 0;
 800b9ea:	687b      	ldr	r3, [r7, #4]
 800b9ec:	2200      	movs	r2, #0
 800b9ee:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return LSM6DSV16X_OK;
 800b9f2:	2300      	movs	r3, #0
}
 800b9f4:	4618      	mov	r0, r3
 800b9f6:	3708      	adds	r7, #8
 800b9f8:	46bd      	mov	sp, r7
 800b9fa:	bd80      	pop	{r7, pc}

0800b9fc <LSM6DSV16X_GYRO_GetSensitivity>:
  * @param  pObj the device pObj
  * @param  Sensitivity pointer
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetSensitivity(LSM6DSV16X_Object_t *pObj, float *Sensitivity)
{
 800b9fc:	b580      	push	{r7, lr}
 800b9fe:	b084      	sub	sp, #16
 800ba00:	af00      	add	r7, sp, #0
 800ba02:	6078      	str	r0, [r7, #4]
 800ba04:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800ba06:	2300      	movs	r3, #0
 800ba08:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_gy_full_scale_t full_scale;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_gy_full_scale_get(&(pObj->Ctx), &full_scale) != LSM6DSV16X_OK)
 800ba0a:	687b      	ldr	r3, [r7, #4]
 800ba0c:	3320      	adds	r3, #32
 800ba0e:	f107 020b 	add.w	r2, r7, #11
 800ba12:	4611      	mov	r1, r2
 800ba14:	4618      	mov	r0, r3
 800ba16:	f001 f823 	bl	800ca60 <lsm6dsv16x_gy_full_scale_get>
 800ba1a:	4603      	mov	r3, r0
 800ba1c:	2b00      	cmp	r3, #0
 800ba1e:	d002      	beq.n	800ba26 <LSM6DSV16X_GYRO_GetSensitivity+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800ba20:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800ba24:	e03d      	b.n	800baa2 <LSM6DSV16X_GYRO_GetSensitivity+0xa6>
  }

  /* Store the sensitivity based on actual full scale */
  switch (full_scale)
 800ba26:	7afb      	ldrb	r3, [r7, #11]
 800ba28:	2b0c      	cmp	r3, #12
 800ba2a:	d835      	bhi.n	800ba98 <LSM6DSV16X_GYRO_GetSensitivity+0x9c>
 800ba2c:	a201      	add	r2, pc, #4	@ (adr r2, 800ba34 <LSM6DSV16X_GYRO_GetSensitivity+0x38>)
 800ba2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ba32:	bf00      	nop
 800ba34:	0800ba69 	.word	0x0800ba69
 800ba38:	0800ba71 	.word	0x0800ba71
 800ba3c:	0800ba79 	.word	0x0800ba79
 800ba40:	0800ba81 	.word	0x0800ba81
 800ba44:	0800ba89 	.word	0x0800ba89
 800ba48:	0800ba99 	.word	0x0800ba99
 800ba4c:	0800ba99 	.word	0x0800ba99
 800ba50:	0800ba99 	.word	0x0800ba99
 800ba54:	0800ba99 	.word	0x0800ba99
 800ba58:	0800ba99 	.word	0x0800ba99
 800ba5c:	0800ba99 	.word	0x0800ba99
 800ba60:	0800ba99 	.word	0x0800ba99
 800ba64:	0800ba91 	.word	0x0800ba91
  {
    case LSM6DSV16X_125dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_125DPS;
 800ba68:	683b      	ldr	r3, [r7, #0]
 800ba6a:	4a10      	ldr	r2, [pc, #64]	@ (800baac <LSM6DSV16X_GYRO_GetSensitivity+0xb0>)
 800ba6c:	601a      	str	r2, [r3, #0]
      break;
 800ba6e:	e017      	b.n	800baa0 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_250dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_250DPS;
 800ba70:	683b      	ldr	r3, [r7, #0]
 800ba72:	4a0f      	ldr	r2, [pc, #60]	@ (800bab0 <LSM6DSV16X_GYRO_GetSensitivity+0xb4>)
 800ba74:	601a      	str	r2, [r3, #0]
      break;
 800ba76:	e013      	b.n	800baa0 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_500dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_500DPS;
 800ba78:	683b      	ldr	r3, [r7, #0]
 800ba7a:	4a0e      	ldr	r2, [pc, #56]	@ (800bab4 <LSM6DSV16X_GYRO_GetSensitivity+0xb8>)
 800ba7c:	601a      	str	r2, [r3, #0]
      break;
 800ba7e:	e00f      	b.n	800baa0 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_1000dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_1000DPS;
 800ba80:	683b      	ldr	r3, [r7, #0]
 800ba82:	4a0d      	ldr	r2, [pc, #52]	@ (800bab8 <LSM6DSV16X_GYRO_GetSensitivity+0xbc>)
 800ba84:	601a      	str	r2, [r3, #0]
      break;
 800ba86:	e00b      	b.n	800baa0 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_2000dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_2000DPS;
 800ba88:	683b      	ldr	r3, [r7, #0]
 800ba8a:	4a0c      	ldr	r2, [pc, #48]	@ (800babc <LSM6DSV16X_GYRO_GetSensitivity+0xc0>)
 800ba8c:	601a      	str	r2, [r3, #0]
      break;
 800ba8e:	e007      	b.n	800baa0 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    case LSM6DSV16X_4000dps:
      *Sensitivity = LSM6DSV16X_GYRO_SENSITIVITY_FS_4000DPS;
 800ba90:	683b      	ldr	r3, [r7, #0]
 800ba92:	4a0b      	ldr	r2, [pc, #44]	@ (800bac0 <LSM6DSV16X_GYRO_GetSensitivity+0xc4>)
 800ba94:	601a      	str	r2, [r3, #0]
      break;
 800ba96:	e003      	b.n	800baa0 <LSM6DSV16X_GYRO_GetSensitivity+0xa4>

    default:
      ret = LSM6DSV16X_ERROR;
 800ba98:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800ba9c:	60fb      	str	r3, [r7, #12]
      break;
 800ba9e:	bf00      	nop
  }

  return ret;
 800baa0:	68fb      	ldr	r3, [r7, #12]
}
 800baa2:	4618      	mov	r0, r3
 800baa4:	3710      	adds	r7, #16
 800baa6:	46bd      	mov	sp, r7
 800baa8:	bd80      	pop	{r7, pc}
 800baaa:	bf00      	nop
 800baac:	408c0000 	.word	0x408c0000
 800bab0:	410c0000 	.word	0x410c0000
 800bab4:	418c0000 	.word	0x418c0000
 800bab8:	420c0000 	.word	0x420c0000
 800babc:	428c0000 	.word	0x428c0000
 800bac0:	430c0000 	.word	0x430c0000

0800bac4 <LSM6DSV16X_GYRO_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetOutputDataRate(LSM6DSV16X_Object_t *pObj, float *Odr)
{
 800bac4:	b580      	push	{r7, lr}
 800bac6:	b084      	sub	sp, #16
 800bac8:	af00      	add	r7, sp, #0
 800baca:	6078      	str	r0, [r7, #4]
 800bacc:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800bace:	2300      	movs	r3, #0
 800bad0:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_data_rate_t odr_low_level;

  /* Get current output data rate */
  if (lsm6dsv16x_gy_data_rate_get(&(pObj->Ctx), &odr_low_level) != LSM6DSV16X_OK)
 800bad2:	687b      	ldr	r3, [r7, #4]
 800bad4:	3320      	adds	r3, #32
 800bad6:	f107 020b 	add.w	r2, r7, #11
 800bada:	4611      	mov	r1, r2
 800badc:	4618      	mov	r0, r3
 800bade:	f000 fe3d 	bl	800c75c <lsm6dsv16x_gy_data_rate_get>
 800bae2:	4603      	mov	r3, r0
 800bae4:	2b00      	cmp	r3, #0
 800bae6:	d002      	beq.n	800baee <LSM6DSV16X_GYRO_GetOutputDataRate+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800bae8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800baec:	e056      	b.n	800bb9c <LSM6DSV16X_GYRO_GetOutputDataRate+0xd8>
  }

  switch (odr_low_level)
 800baee:	7afb      	ldrb	r3, [r7, #11]
 800baf0:	2b0c      	cmp	r3, #12
 800baf2:	d84e      	bhi.n	800bb92 <LSM6DSV16X_GYRO_GetOutputDataRate+0xce>
 800baf4:	a201      	add	r2, pc, #4	@ (adr r2, 800bafc <LSM6DSV16X_GYRO_GetOutputDataRate+0x38>)
 800baf6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bafa:	bf00      	nop
 800bafc:	0800bb31 	.word	0x0800bb31
 800bb00:	0800bb93 	.word	0x0800bb93
 800bb04:	0800bb3b 	.word	0x0800bb3b
 800bb08:	0800bb43 	.word	0x0800bb43
 800bb0c:	0800bb4b 	.word	0x0800bb4b
 800bb10:	0800bb53 	.word	0x0800bb53
 800bb14:	0800bb5b 	.word	0x0800bb5b
 800bb18:	0800bb63 	.word	0x0800bb63
 800bb1c:	0800bb6b 	.word	0x0800bb6b
 800bb20:	0800bb73 	.word	0x0800bb73
 800bb24:	0800bb7b 	.word	0x0800bb7b
 800bb28:	0800bb83 	.word	0x0800bb83
 800bb2c:	0800bb8b 	.word	0x0800bb8b
  {
    case LSM6DSV16X_ODR_OFF:
      *Odr = 0.0f;
 800bb30:	683b      	ldr	r3, [r7, #0]
 800bb32:	f04f 0200 	mov.w	r2, #0
 800bb36:	601a      	str	r2, [r3, #0]
      break;
 800bb38:	e02f      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *Odr = 7.5f;
 800bb3a:	683b      	ldr	r3, [r7, #0]
 800bb3c:	4a19      	ldr	r2, [pc, #100]	@ (800bba4 <LSM6DSV16X_GYRO_GetOutputDataRate+0xe0>)
 800bb3e:	601a      	str	r2, [r3, #0]
      break;
 800bb40:	e02b      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_15Hz:
      *Odr = 15.0f;
 800bb42:	683b      	ldr	r3, [r7, #0]
 800bb44:	4a18      	ldr	r2, [pc, #96]	@ (800bba8 <LSM6DSV16X_GYRO_GetOutputDataRate+0xe4>)
 800bb46:	601a      	str	r2, [r3, #0]
      break;
 800bb48:	e027      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_30Hz:
      *Odr = 30.0f;
 800bb4a:	683b      	ldr	r3, [r7, #0]
 800bb4c:	4a17      	ldr	r2, [pc, #92]	@ (800bbac <LSM6DSV16X_GYRO_GetOutputDataRate+0xe8>)
 800bb4e:	601a      	str	r2, [r3, #0]
      break;
 800bb50:	e023      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_60Hz:
      *Odr = 60.0f;
 800bb52:	683b      	ldr	r3, [r7, #0]
 800bb54:	4a16      	ldr	r2, [pc, #88]	@ (800bbb0 <LSM6DSV16X_GYRO_GetOutputDataRate+0xec>)
 800bb56:	601a      	str	r2, [r3, #0]
      break;
 800bb58:	e01f      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_120Hz:
      *Odr = 120.0f;
 800bb5a:	683b      	ldr	r3, [r7, #0]
 800bb5c:	4a15      	ldr	r2, [pc, #84]	@ (800bbb4 <LSM6DSV16X_GYRO_GetOutputDataRate+0xf0>)
 800bb5e:	601a      	str	r2, [r3, #0]
      break;
 800bb60:	e01b      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_240Hz:
      *Odr = 240.0f;
 800bb62:	683b      	ldr	r3, [r7, #0]
 800bb64:	4a14      	ldr	r2, [pc, #80]	@ (800bbb8 <LSM6DSV16X_GYRO_GetOutputDataRate+0xf4>)
 800bb66:	601a      	str	r2, [r3, #0]
      break;
 800bb68:	e017      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_480Hz:
      *Odr = 480.0f;
 800bb6a:	683b      	ldr	r3, [r7, #0]
 800bb6c:	4a13      	ldr	r2, [pc, #76]	@ (800bbbc <LSM6DSV16X_GYRO_GetOutputDataRate+0xf8>)
 800bb6e:	601a      	str	r2, [r3, #0]
      break;
 800bb70:	e013      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_960Hz:
      *Odr = 960.0f;
 800bb72:	683b      	ldr	r3, [r7, #0]
 800bb74:	4a12      	ldr	r2, [pc, #72]	@ (800bbc0 <LSM6DSV16X_GYRO_GetOutputDataRate+0xfc>)
 800bb76:	601a      	str	r2, [r3, #0]
      break;
 800bb78:	e00f      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_1920Hz:
      *Odr = 1920.0f;
 800bb7a:	683b      	ldr	r3, [r7, #0]
 800bb7c:	4a11      	ldr	r2, [pc, #68]	@ (800bbc4 <LSM6DSV16X_GYRO_GetOutputDataRate+0x100>)
 800bb7e:	601a      	str	r2, [r3, #0]
      break;
 800bb80:	e00b      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_3840Hz:
      *Odr = 3840.0f;
 800bb82:	683b      	ldr	r3, [r7, #0]
 800bb84:	4a10      	ldr	r2, [pc, #64]	@ (800bbc8 <LSM6DSV16X_GYRO_GetOutputDataRate+0x104>)
 800bb86:	601a      	str	r2, [r3, #0]
      break;
 800bb88:	e007      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    case LSM6DSV16X_ODR_AT_7680Hz:
      *Odr = 7680.0f;
 800bb8a:	683b      	ldr	r3, [r7, #0]
 800bb8c:	4a0f      	ldr	r2, [pc, #60]	@ (800bbcc <LSM6DSV16X_GYRO_GetOutputDataRate+0x108>)
 800bb8e:	601a      	str	r2, [r3, #0]
      break;
 800bb90:	e003      	b.n	800bb9a <LSM6DSV16X_GYRO_GetOutputDataRate+0xd6>

    default:
      ret = LSM6DSV16X_ERROR;
 800bb92:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bb96:	60fb      	str	r3, [r7, #12]
      break;
 800bb98:	bf00      	nop
  }

  return ret;
 800bb9a:	68fb      	ldr	r3, [r7, #12]
}
 800bb9c:	4618      	mov	r0, r3
 800bb9e:	3710      	adds	r7, #16
 800bba0:	46bd      	mov	sp, r7
 800bba2:	bd80      	pop	{r7, pc}
 800bba4:	40f00000 	.word	0x40f00000
 800bba8:	41700000 	.word	0x41700000
 800bbac:	41f00000 	.word	0x41f00000
 800bbb0:	42700000 	.word	0x42700000
 800bbb4:	42f00000 	.word	0x42f00000
 800bbb8:	43700000 	.word	0x43700000
 800bbbc:	43f00000 	.word	0x43f00000
 800bbc0:	44700000 	.word	0x44700000
 800bbc4:	44f00000 	.word	0x44f00000
 800bbc8:	45700000 	.word	0x45700000
 800bbcc:	45f00000 	.word	0x45f00000

0800bbd0 <LSM6DSV16X_GYRO_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_SetOutputDataRate(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800bbd0:	b580      	push	{r7, lr}
 800bbd2:	b082      	sub	sp, #8
 800bbd4:	af00      	add	r7, sp, #0
 800bbd6:	6078      	str	r0, [r7, #4]
 800bbd8:	ed87 0a00 	vstr	s0, [r7]
  if (pObj->gyro_is_enabled == 1U)
 800bbdc:	687b      	ldr	r3, [r7, #4]
 800bbde:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800bbe2:	2b01      	cmp	r3, #1
 800bbe4:	d106      	bne.n	800bbf4 <LSM6DSV16X_GYRO_SetOutputDataRate+0x24>
  {
    return LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled(pObj, Odr);
 800bbe6:	ed97 0a00 	vldr	s0, [r7]
 800bbea:	6878      	ldr	r0, [r7, #4]
 800bbec:	f000 fa6a 	bl	800c0c4 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled>
 800bbf0:	4603      	mov	r3, r0
 800bbf2:	e005      	b.n	800bc00 <LSM6DSV16X_GYRO_SetOutputDataRate+0x30>
  }
  else
  {
    return LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled(pObj, Odr);
 800bbf4:	ed97 0a00 	vldr	s0, [r7]
 800bbf8:	6878      	ldr	r0, [r7, #4]
 800bbfa:	f000 faf9 	bl	800c1f0 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled>
 800bbfe:	4603      	mov	r3, r0
  }
}
 800bc00:	4618      	mov	r0, r3
 800bc02:	3708      	adds	r7, #8
 800bc04:	46bd      	mov	sp, r7
 800bc06:	bd80      	pop	{r7, pc}

0800bc08 <LSM6DSV16X_GYRO_GetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale pointer where the full scale is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetFullScale(LSM6DSV16X_Object_t *pObj, int32_t  *FullScale)
{
 800bc08:	b580      	push	{r7, lr}
 800bc0a:	b084      	sub	sp, #16
 800bc0c:	af00      	add	r7, sp, #0
 800bc0e:	6078      	str	r0, [r7, #4]
 800bc10:	6039      	str	r1, [r7, #0]
  int32_t ret = LSM6DSV16X_OK;
 800bc12:	2300      	movs	r3, #0
 800bc14:	60fb      	str	r3, [r7, #12]
  lsm6dsv16x_gy_full_scale_t fs_low_level;

  /* Read actual full scale selection from sensor */
  if (lsm6dsv16x_gy_full_scale_get(&(pObj->Ctx), &fs_low_level) != LSM6DSV16X_OK)
 800bc16:	687b      	ldr	r3, [r7, #4]
 800bc18:	3320      	adds	r3, #32
 800bc1a:	f107 020b 	add.w	r2, r7, #11
 800bc1e:	4611      	mov	r1, r2
 800bc20:	4618      	mov	r0, r3
 800bc22:	f000 ff1d 	bl	800ca60 <lsm6dsv16x_gy_full_scale_get>
 800bc26:	4603      	mov	r3, r0
 800bc28:	2b00      	cmp	r3, #0
 800bc2a:	d002      	beq.n	800bc32 <LSM6DSV16X_GYRO_GetFullScale+0x2a>
  {
    return LSM6DSV16X_ERROR;
 800bc2c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bc30:	e041      	b.n	800bcb6 <LSM6DSV16X_GYRO_GetFullScale+0xae>
  }

  switch (fs_low_level)
 800bc32:	7afb      	ldrb	r3, [r7, #11]
 800bc34:	2b0c      	cmp	r3, #12
 800bc36:	d839      	bhi.n	800bcac <LSM6DSV16X_GYRO_GetFullScale+0xa4>
 800bc38:	a201      	add	r2, pc, #4	@ (adr r2, 800bc40 <LSM6DSV16X_GYRO_GetFullScale+0x38>)
 800bc3a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bc3e:	bf00      	nop
 800bc40:	0800bc75 	.word	0x0800bc75
 800bc44:	0800bc7d 	.word	0x0800bc7d
 800bc48:	0800bc85 	.word	0x0800bc85
 800bc4c:	0800bc8f 	.word	0x0800bc8f
 800bc50:	0800bc99 	.word	0x0800bc99
 800bc54:	0800bcad 	.word	0x0800bcad
 800bc58:	0800bcad 	.word	0x0800bcad
 800bc5c:	0800bcad 	.word	0x0800bcad
 800bc60:	0800bcad 	.word	0x0800bcad
 800bc64:	0800bcad 	.word	0x0800bcad
 800bc68:	0800bcad 	.word	0x0800bcad
 800bc6c:	0800bcad 	.word	0x0800bcad
 800bc70:	0800bca3 	.word	0x0800bca3
  {
    case LSM6DSV16X_125dps:
      *FullScale =  125;
 800bc74:	683b      	ldr	r3, [r7, #0]
 800bc76:	227d      	movs	r2, #125	@ 0x7d
 800bc78:	601a      	str	r2, [r3, #0]
      break;
 800bc7a:	e01b      	b.n	800bcb4 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_250dps:
      *FullScale =  250;
 800bc7c:	683b      	ldr	r3, [r7, #0]
 800bc7e:	22fa      	movs	r2, #250	@ 0xfa
 800bc80:	601a      	str	r2, [r3, #0]
      break;
 800bc82:	e017      	b.n	800bcb4 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_500dps:
      *FullScale =  500;
 800bc84:	683b      	ldr	r3, [r7, #0]
 800bc86:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
 800bc8a:	601a      	str	r2, [r3, #0]
      break;
 800bc8c:	e012      	b.n	800bcb4 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_1000dps:
      *FullScale = 1000;
 800bc8e:	683b      	ldr	r3, [r7, #0]
 800bc90:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 800bc94:	601a      	str	r2, [r3, #0]
      break;
 800bc96:	e00d      	b.n	800bcb4 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_2000dps:
      *FullScale = 2000;
 800bc98:	683b      	ldr	r3, [r7, #0]
 800bc9a:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 800bc9e:	601a      	str	r2, [r3, #0]
      break;
 800bca0:	e008      	b.n	800bcb4 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    case LSM6DSV16X_4000dps:
      *FullScale = 4000;
 800bca2:	683b      	ldr	r3, [r7, #0]
 800bca4:	f44f 627a 	mov.w	r2, #4000	@ 0xfa0
 800bca8:	601a      	str	r2, [r3, #0]
      break;
 800bcaa:	e003      	b.n	800bcb4 <LSM6DSV16X_GYRO_GetFullScale+0xac>

    default:
      ret = LSM6DSV16X_ERROR;
 800bcac:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bcb0:	60fb      	str	r3, [r7, #12]
      break;
 800bcb2:	bf00      	nop
  }

  return ret;
 800bcb4:	68fb      	ldr	r3, [r7, #12]
}
 800bcb6:	4618      	mov	r0, r3
 800bcb8:	3710      	adds	r7, #16
 800bcba:	46bd      	mov	sp, r7
 800bcbc:	bd80      	pop	{r7, pc}
 800bcbe:	bf00      	nop

0800bcc0 <LSM6DSV16X_GYRO_SetFullScale>:
  * @param  pObj the device pObj
  * @param  FullScale the functional full scale to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_SetFullScale(LSM6DSV16X_Object_t *pObj, int32_t FullScale)
{
 800bcc0:	b580      	push	{r7, lr}
 800bcc2:	b084      	sub	sp, #16
 800bcc4:	af00      	add	r7, sp, #0
 800bcc6:	6078      	str	r0, [r7, #4]
 800bcc8:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_gy_full_scale_t new_fs;

  new_fs = (FullScale <= 125)  ? LSM6DSV16X_125dps
           : (FullScale <= 250)  ? LSM6DSV16X_250dps
 800bcca:	683b      	ldr	r3, [r7, #0]
 800bccc:	2b7d      	cmp	r3, #125	@ 0x7d
 800bcce:	dd18      	ble.n	800bd02 <LSM6DSV16X_GYRO_SetFullScale+0x42>
 800bcd0:	683b      	ldr	r3, [r7, #0]
 800bcd2:	2bfa      	cmp	r3, #250	@ 0xfa
 800bcd4:	dd13      	ble.n	800bcfe <LSM6DSV16X_GYRO_SetFullScale+0x3e>
 800bcd6:	683b      	ldr	r3, [r7, #0]
 800bcd8:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
 800bcdc:	dd0d      	ble.n	800bcfa <LSM6DSV16X_GYRO_SetFullScale+0x3a>
 800bcde:	683b      	ldr	r3, [r7, #0]
 800bce0:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800bce4:	dd07      	ble.n	800bcf6 <LSM6DSV16X_GYRO_SetFullScale+0x36>
 800bce6:	683b      	ldr	r3, [r7, #0]
 800bce8:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 800bcec:	dc01      	bgt.n	800bcf2 <LSM6DSV16X_GYRO_SetFullScale+0x32>
 800bcee:	2304      	movs	r3, #4
 800bcf0:	e008      	b.n	800bd04 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800bcf2:	230c      	movs	r3, #12
 800bcf4:	e006      	b.n	800bd04 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800bcf6:	2303      	movs	r3, #3
 800bcf8:	e004      	b.n	800bd04 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800bcfa:	2302      	movs	r3, #2
 800bcfc:	e002      	b.n	800bd04 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800bcfe:	2301      	movs	r3, #1
 800bd00:	e000      	b.n	800bd04 <LSM6DSV16X_GYRO_SetFullScale+0x44>
 800bd02:	2300      	movs	r3, #0
  new_fs = (FullScale <= 125)  ? LSM6DSV16X_125dps
 800bd04:	73fb      	strb	r3, [r7, #15]
           : (FullScale <= 500)  ? LSM6DSV16X_500dps
           : (FullScale <= 1000) ? LSM6DSV16X_1000dps
           : (FullScale <= 2000) ? LSM6DSV16X_2000dps
           :                       LSM6DSV16X_4000dps;

  if (lsm6dsv16x_gy_full_scale_set(&(pObj->Ctx), new_fs) != LSM6DSV16X_OK)
 800bd06:	687b      	ldr	r3, [r7, #4]
 800bd08:	3320      	adds	r3, #32
 800bd0a:	7bfa      	ldrb	r2, [r7, #15]
 800bd0c:	4611      	mov	r1, r2
 800bd0e:	4618      	mov	r0, r3
 800bd10:	f000 fe80 	bl	800ca14 <lsm6dsv16x_gy_full_scale_set>
 800bd14:	4603      	mov	r3, r0
 800bd16:	2b00      	cmp	r3, #0
 800bd18:	d002      	beq.n	800bd20 <LSM6DSV16X_GYRO_SetFullScale+0x60>
  {
    return LSM6DSV16X_ERROR;
 800bd1a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bd1e:	e000      	b.n	800bd22 <LSM6DSV16X_GYRO_SetFullScale+0x62>
  }

  return LSM6DSV16X_OK;
 800bd20:	2300      	movs	r3, #0
}
 800bd22:	4618      	mov	r0, r3
 800bd24:	3710      	adds	r7, #16
 800bd26:	46bd      	mov	sp, r7
 800bd28:	bd80      	pop	{r7, pc}

0800bd2a <LSM6DSV16X_GYRO_GetAxesRaw>:
  * @param  pObj the device pObj
  * @param  Value pointer where the raw values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetAxesRaw(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_AxesRaw_t *Value)
{
 800bd2a:	b580      	push	{r7, lr}
 800bd2c:	b084      	sub	sp, #16
 800bd2e:	af00      	add	r7, sp, #0
 800bd30:	6078      	str	r0, [r7, #4]
 800bd32:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;

  /* Read raw data values */
  if (lsm6dsv16x_angular_rate_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800bd34:	687b      	ldr	r3, [r7, #4]
 800bd36:	3320      	adds	r3, #32
 800bd38:	f107 0208 	add.w	r2, r7, #8
 800bd3c:	4611      	mov	r1, r2
 800bd3e:	4618      	mov	r0, r3
 800bd40:	f000 ff4a 	bl	800cbd8 <lsm6dsv16x_angular_rate_raw_get>
 800bd44:	4603      	mov	r3, r0
 800bd46:	2b00      	cmp	r3, #0
 800bd48:	d002      	beq.n	800bd50 <LSM6DSV16X_GYRO_GetAxesRaw+0x26>
  {
    return LSM6DSV16X_ERROR;
 800bd4a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bd4e:	e00c      	b.n	800bd6a <LSM6DSV16X_GYRO_GetAxesRaw+0x40>
  }

  /* Format the data */
  Value->x = data_raw.i16bit[0];
 800bd50:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 800bd54:	683b      	ldr	r3, [r7, #0]
 800bd56:	801a      	strh	r2, [r3, #0]
  Value->y = data_raw.i16bit[1];
 800bd58:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 800bd5c:	683b      	ldr	r3, [r7, #0]
 800bd5e:	805a      	strh	r2, [r3, #2]
  Value->z = data_raw.i16bit[2];
 800bd60:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 800bd64:	683b      	ldr	r3, [r7, #0]
 800bd66:	809a      	strh	r2, [r3, #4]

  return LSM6DSV16X_OK;
 800bd68:	2300      	movs	r3, #0
}
 800bd6a:	4618      	mov	r0, r3
 800bd6c:	3710      	adds	r7, #16
 800bd6e:	46bd      	mov	sp, r7
 800bd70:	bd80      	pop	{r7, pc}

0800bd72 <LSM6DSV16X_GYRO_GetAxes>:
  * @param  pObj the device pObj
  * @param  AngularRate pointer where the values of the axes are written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_GYRO_GetAxes(LSM6DSV16X_Object_t *pObj, LSM6DSV16X_Axes_t *AngularRate)
{
 800bd72:	b580      	push	{r7, lr}
 800bd74:	b086      	sub	sp, #24
 800bd76:	af00      	add	r7, sp, #0
 800bd78:	6078      	str	r0, [r7, #4]
 800bd7a:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_axis3bit16_t data_raw;
  float sensitivity;

  /* Read raw data values */
  if (lsm6dsv16x_angular_rate_raw_get(&(pObj->Ctx), data_raw.i16bit) != LSM6DSV16X_OK)
 800bd7c:	687b      	ldr	r3, [r7, #4]
 800bd7e:	3320      	adds	r3, #32
 800bd80:	f107 0210 	add.w	r2, r7, #16
 800bd84:	4611      	mov	r1, r2
 800bd86:	4618      	mov	r0, r3
 800bd88:	f000 ff26 	bl	800cbd8 <lsm6dsv16x_angular_rate_raw_get>
 800bd8c:	4603      	mov	r3, r0
 800bd8e:	2b00      	cmp	r3, #0
 800bd90:	d002      	beq.n	800bd98 <LSM6DSV16X_GYRO_GetAxes+0x26>
  {
    return LSM6DSV16X_ERROR;
 800bd92:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bd96:	e03c      	b.n	800be12 <LSM6DSV16X_GYRO_GetAxes+0xa0>
  }

  /* Get LSM6DSV16X actual sensitivity */
  if (LSM6DSV16X_GYRO_GetSensitivity(pObj, &sensitivity) != LSM6DSV16X_OK)
 800bd98:	f107 030c 	add.w	r3, r7, #12
 800bd9c:	4619      	mov	r1, r3
 800bd9e:	6878      	ldr	r0, [r7, #4]
 800bda0:	f7ff fe2c 	bl	800b9fc <LSM6DSV16X_GYRO_GetSensitivity>
 800bda4:	4603      	mov	r3, r0
 800bda6:	2b00      	cmp	r3, #0
 800bda8:	d002      	beq.n	800bdb0 <LSM6DSV16X_GYRO_GetAxes+0x3e>
  {
    return LSM6DSV16X_ERROR;
 800bdaa:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bdae:	e030      	b.n	800be12 <LSM6DSV16X_GYRO_GetAxes+0xa0>
  }

  /* Calculate the data */
  AngularRate->x = (int32_t)((float)((float)data_raw.i16bit[0] * sensitivity));
 800bdb0:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800bdb4:	ee07 3a90 	vmov	s15, r3
 800bdb8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800bdbc:	edd7 7a03 	vldr	s15, [r7, #12]
 800bdc0:	ee67 7a27 	vmul.f32	s15, s14, s15
 800bdc4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bdc8:	ee17 2a90 	vmov	r2, s15
 800bdcc:	683b      	ldr	r3, [r7, #0]
 800bdce:	601a      	str	r2, [r3, #0]
  AngularRate->y = (int32_t)((float)((float)data_raw.i16bit[1] * sensitivity));
 800bdd0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800bdd4:	ee07 3a90 	vmov	s15, r3
 800bdd8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800bddc:	edd7 7a03 	vldr	s15, [r7, #12]
 800bde0:	ee67 7a27 	vmul.f32	s15, s14, s15
 800bde4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800bde8:	ee17 2a90 	vmov	r2, s15
 800bdec:	683b      	ldr	r3, [r7, #0]
 800bdee:	605a      	str	r2, [r3, #4]
  AngularRate->z = (int32_t)((float)((float)data_raw.i16bit[2] * sensitivity));
 800bdf0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800bdf4:	ee07 3a90 	vmov	s15, r3
 800bdf8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 800bdfc:	edd7 7a03 	vldr	s15, [r7, #12]
 800be00:	ee67 7a27 	vmul.f32	s15, s14, s15
 800be04:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800be08:	ee17 2a90 	vmov	r2, s15
 800be0c:	683b      	ldr	r3, [r7, #0]
 800be0e:	609a      	str	r2, [r3, #8]

  return LSM6DSV16X_OK;
 800be10:	2300      	movs	r3, #0
}
 800be12:	4618      	mov	r0, r3
 800be14:	3718      	adds	r7, #24
 800be16:	46bd      	mov	sp, r7
 800be18:	bd80      	pop	{r7, pc}

0800be1a <LSM6DSV16X_Write_Reg>:
  * @param  Reg address to be written
  * @param  Data value to be written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t LSM6DSV16X_Write_Reg(LSM6DSV16X_Object_t *pObj, uint8_t Reg, uint8_t Data)
{
 800be1a:	b580      	push	{r7, lr}
 800be1c:	b082      	sub	sp, #8
 800be1e:	af00      	add	r7, sp, #0
 800be20:	6078      	str	r0, [r7, #4]
 800be22:	460b      	mov	r3, r1
 800be24:	70fb      	strb	r3, [r7, #3]
 800be26:	4613      	mov	r3, r2
 800be28:	70bb      	strb	r3, [r7, #2]
  if (lsm6dsv16x_write_reg(&(pObj->Ctx), Reg, &Data, 1) != LSM6DSV16X_OK)
 800be2a:	687b      	ldr	r3, [r7, #4]
 800be2c:	f103 0020 	add.w	r0, r3, #32
 800be30:	1cba      	adds	r2, r7, #2
 800be32:	78f9      	ldrb	r1, [r7, #3]
 800be34:	2301      	movs	r3, #1
 800be36:	f000 fab7 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800be3a:	4603      	mov	r3, r0
 800be3c:	2b00      	cmp	r3, #0
 800be3e:	d002      	beq.n	800be46 <LSM6DSV16X_Write_Reg+0x2c>
  {
    return LSM6DSV16X_ERROR;
 800be40:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800be44:	e000      	b.n	800be48 <LSM6DSV16X_Write_Reg+0x2e>
  }

  return LSM6DSV16X_OK;
 800be46:	2300      	movs	r3, #0
}
 800be48:	4618      	mov	r0, r3
 800be4a:	3708      	adds	r7, #8
 800be4c:	46bd      	mov	sp, r7
 800be4e:	bd80      	pop	{r7, pc}

0800be50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800be50:	b580      	push	{r7, lr}
 800be52:	b084      	sub	sp, #16
 800be54:	af00      	add	r7, sp, #0
 800be56:	6078      	str	r0, [r7, #4]
 800be58:	ed87 0a00 	vstr	s0, [r7]
  lsm6dsv16x_data_rate_t new_odr;

  new_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
            : (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800be5c:	edd7 7a00 	vldr	s15, [r7]
 800be60:	eeb7 7a0e 	vmov.f32	s14, #126	@ 0x3ff00000  1.875
 800be64:	eef4 7ac7 	vcmpe.f32	s15, s14
 800be68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800be6c:	d801      	bhi.n	800be72 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x22>
 800be6e:	2301      	movs	r3, #1
 800be70:	e06e      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800be72:	edd7 7a00 	vldr	s15, [r7]
 800be76:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800be7a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800be7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800be82:	d801      	bhi.n	800be88 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x38>
 800be84:	2302      	movs	r3, #2
 800be86:	e063      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800be88:	edd7 7a00 	vldr	s15, [r7]
 800be8c:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800be90:	eef4 7ac7 	vcmpe.f32	s15, s14
 800be94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800be98:	d801      	bhi.n	800be9e <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x4e>
 800be9a:	2303      	movs	r3, #3
 800be9c:	e058      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800be9e:	edd7 7a00 	vldr	s15, [r7]
 800bea2:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800bea6:	eef4 7ac7 	vcmpe.f32	s15, s14
 800beaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800beae:	d801      	bhi.n	800beb4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x64>
 800beb0:	2304      	movs	r3, #4
 800beb2:	e04d      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800beb4:	edd7 7a00 	vldr	s15, [r7]
 800beb8:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 800bf78 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x128>
 800bebc:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bec0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bec4:	d801      	bhi.n	800beca <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x7a>
 800bec6:	2305      	movs	r3, #5
 800bec8:	e042      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800beca:	edd7 7a00 	vldr	s15, [r7]
 800bece:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 800bf7c <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x12c>
 800bed2:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bed6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800beda:	d801      	bhi.n	800bee0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x90>
 800bedc:	2306      	movs	r3, #6
 800bede:	e037      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800bee0:	edd7 7a00 	vldr	s15, [r7]
 800bee4:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800bf80 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x130>
 800bee8:	eef4 7ac7 	vcmpe.f32	s15, s14
 800beec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bef0:	d801      	bhi.n	800bef6 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xa6>
 800bef2:	2307      	movs	r3, #7
 800bef4:	e02c      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800bef6:	edd7 7a00 	vldr	s15, [r7]
 800befa:	ed9f 7a22 	vldr	s14, [pc, #136]	@ 800bf84 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x134>
 800befe:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bf02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf06:	d801      	bhi.n	800bf0c <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xbc>
 800bf08:	2308      	movs	r3, #8
 800bf0a:	e021      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800bf0c:	edd7 7a00 	vldr	s15, [r7]
 800bf10:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800bf88 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x138>
 800bf14:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bf18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf1c:	d801      	bhi.n	800bf22 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xd2>
 800bf1e:	2309      	movs	r3, #9
 800bf20:	e016      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800bf22:	edd7 7a00 	vldr	s15, [r7]
 800bf26:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 800bf8c <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x13c>
 800bf2a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bf2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf32:	d801      	bhi.n	800bf38 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xe8>
 800bf34:	230a      	movs	r3, #10
 800bf36:	e00b      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800bf38:	edd7 7a00 	vldr	s15, [r7]
 800bf3c:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800bf90 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x140>
 800bf40:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bf44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf48:	d801      	bhi.n	800bf4e <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0xfe>
 800bf4a:	230b      	movs	r3, #11
 800bf4c:	e000      	b.n	800bf50 <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x100>
 800bf4e:	230c      	movs	r3, #12
  new_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
 800bf50:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
            : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
            :                    LSM6DSV16X_ODR_AT_7680Hz;

  /* Output data rate selection */
  if (lsm6dsv16x_xl_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSV16X_OK)
 800bf52:	687b      	ldr	r3, [r7, #4]
 800bf54:	3320      	adds	r3, #32
 800bf56:	7bfa      	ldrb	r2, [r7, #15]
 800bf58:	4611      	mov	r1, r2
 800bf5a:	4618      	mov	r0, r3
 800bf5c:	f000 fa4d 	bl	800c3fa <lsm6dsv16x_xl_data_rate_set>
 800bf60:	4603      	mov	r3, r0
 800bf62:	2b00      	cmp	r3, #0
 800bf64:	d002      	beq.n	800bf6c <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x11c>
  {
    return LSM6DSV16X_ERROR;
 800bf66:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800bf6a:	e000      	b.n	800bf6e <LSM6DSV16X_ACC_SetOutputDataRate_When_Enabled+0x11e>
  }

  return LSM6DSV16X_OK;
 800bf6c:	2300      	movs	r3, #0
}
 800bf6e:	4618      	mov	r0, r3
 800bf70:	3710      	adds	r7, #16
 800bf72:	46bd      	mov	sp, r7
 800bf74:	bd80      	pop	{r7, pc}
 800bf76:	bf00      	nop
 800bf78:	42700000 	.word	0x42700000
 800bf7c:	42f00000 	.word	0x42f00000
 800bf80:	43700000 	.word	0x43700000
 800bf84:	43f00000 	.word	0x43f00000
 800bf88:	44700000 	.word	0x44700000
 800bf8c:	44f00000 	.word	0x44f00000
 800bf90:	45700000 	.word	0x45700000

0800bf94 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800bf94:	b480      	push	{r7}
 800bf96:	b083      	sub	sp, #12
 800bf98:	af00      	add	r7, sp, #0
 800bf9a:	6078      	str	r0, [r7, #4]
 800bf9c:	ed87 0a00 	vstr	s0, [r7]
  pObj->acc_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
                  : (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800bfa0:	edd7 7a00 	vldr	s15, [r7]
 800bfa4:	eeb7 7a0e 	vmov.f32	s14, #126	@ 0x3ff00000  1.875
 800bfa8:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bfac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bfb0:	d801      	bhi.n	800bfb6 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x22>
 800bfb2:	2301      	movs	r3, #1
 800bfb4:	e06e      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800bfb6:	edd7 7a00 	vldr	s15, [r7]
 800bfba:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800bfbe:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bfc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bfc6:	d801      	bhi.n	800bfcc <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x38>
 800bfc8:	2302      	movs	r3, #2
 800bfca:	e063      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800bfcc:	edd7 7a00 	vldr	s15, [r7]
 800bfd0:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800bfd4:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bfd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bfdc:	d801      	bhi.n	800bfe2 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x4e>
 800bfde:	2303      	movs	r3, #3
 800bfe0:	e058      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800bfe2:	edd7 7a00 	vldr	s15, [r7]
 800bfe6:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800bfea:	eef4 7ac7 	vcmpe.f32	s15, s14
 800bfee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bff2:	d801      	bhi.n	800bff8 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x64>
 800bff4:	2304      	movs	r3, #4
 800bff6:	e04d      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800bff8:	edd7 7a00 	vldr	s15, [r7]
 800bffc:	ed9f 7a2a 	vldr	s14, [pc, #168]	@ 800c0a8 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x114>
 800c000:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c004:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c008:	d801      	bhi.n	800c00e <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x7a>
 800c00a:	2305      	movs	r3, #5
 800c00c:	e042      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800c00e:	edd7 7a00 	vldr	s15, [r7]
 800c012:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800c0ac <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x118>
 800c016:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c01a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c01e:	d801      	bhi.n	800c024 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x90>
 800c020:	2306      	movs	r3, #6
 800c022:	e037      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800c024:	edd7 7a00 	vldr	s15, [r7]
 800c028:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 800c0b0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x11c>
 800c02c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c030:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c034:	d801      	bhi.n	800c03a <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xa6>
 800c036:	2307      	movs	r3, #7
 800c038:	e02c      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800c03a:	edd7 7a00 	vldr	s15, [r7]
 800c03e:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800c0b4 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x120>
 800c042:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c04a:	d801      	bhi.n	800c050 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xbc>
 800c04c:	2308      	movs	r3, #8
 800c04e:	e021      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800c050:	edd7 7a00 	vldr	s15, [r7]
 800c054:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800c0b8 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x124>
 800c058:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c05c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c060:	d801      	bhi.n	800c066 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xd2>
 800c062:	2309      	movs	r3, #9
 800c064:	e016      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800c066:	edd7 7a00 	vldr	s15, [r7]
 800c06a:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800c0bc <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x128>
 800c06e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c072:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c076:	d801      	bhi.n	800c07c <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xe8>
 800c078:	230a      	movs	r3, #10
 800c07a:	e00b      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800c07c:	edd7 7a00 	vldr	s15, [r7]
 800c080:	ed9f 7a0f 	vldr	s14, [pc, #60]	@ 800c0c0 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x12c>
 800c084:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c088:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c08c:	d801      	bhi.n	800c092 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0xfe>
 800c08e:	230b      	movs	r3, #11
 800c090:	e000      	b.n	800c094 <LSM6DSV16X_ACC_SetOutputDataRate_When_Disabled+0x100>
 800c092:	230c      	movs	r3, #12
  pObj->acc_odr = (Odr <=  1.875f) ? LSM6DSV16X_ODR_AT_1Hz875
 800c094:	687a      	ldr	r2, [r7, #4]
 800c096:	f882 3033 	strb.w	r3, [r2, #51]	@ 0x33
                  : (Odr <=  960.0f) ? LSM6DSV16X_ODR_AT_960Hz
                  : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
                  : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
                  :                    LSM6DSV16X_ODR_AT_7680Hz;

  return LSM6DSV16X_OK;
 800c09a:	2300      	movs	r3, #0
}
 800c09c:	4618      	mov	r0, r3
 800c09e:	370c      	adds	r7, #12
 800c0a0:	46bd      	mov	sp, r7
 800c0a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0a6:	4770      	bx	lr
 800c0a8:	42700000 	.word	0x42700000
 800c0ac:	42f00000 	.word	0x42f00000
 800c0b0:	43700000 	.word	0x43700000
 800c0b4:	43f00000 	.word	0x43f00000
 800c0b8:	44700000 	.word	0x44700000
 800c0bc:	44f00000 	.word	0x44f00000
 800c0c0:	45700000 	.word	0x45700000

0800c0c4 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800c0c4:	b580      	push	{r7, lr}
 800c0c6:	b084      	sub	sp, #16
 800c0c8:	af00      	add	r7, sp, #0
 800c0ca:	6078      	str	r0, [r7, #4]
 800c0cc:	ed87 0a00 	vstr	s0, [r7]
  lsm6dsv16x_data_rate_t new_odr;

  new_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
            : (Odr <=   15.0f) ? LSM6DSV16X_ODR_AT_15Hz
 800c0d0:	edd7 7a00 	vldr	s15, [r7]
 800c0d4:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800c0d8:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c0dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c0e0:	d801      	bhi.n	800c0e6 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x22>
 800c0e2:	2302      	movs	r3, #2
 800c0e4:	e063      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c0e6:	edd7 7a00 	vldr	s15, [r7]
 800c0ea:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800c0ee:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c0f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c0f6:	d801      	bhi.n	800c0fc <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x38>
 800c0f8:	2303      	movs	r3, #3
 800c0fa:	e058      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c0fc:	edd7 7a00 	vldr	s15, [r7]
 800c100:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800c104:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c108:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c10c:	d801      	bhi.n	800c112 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x4e>
 800c10e:	2304      	movs	r3, #4
 800c110:	e04d      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c112:	edd7 7a00 	vldr	s15, [r7]
 800c116:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 800c1d4 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x110>
 800c11a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c11e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c122:	d801      	bhi.n	800c128 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x64>
 800c124:	2305      	movs	r3, #5
 800c126:	e042      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c128:	edd7 7a00 	vldr	s15, [r7]
 800c12c:	ed9f 7a2a 	vldr	s14, [pc, #168]	@ 800c1d8 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x114>
 800c130:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c134:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c138:	d801      	bhi.n	800c13e <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x7a>
 800c13a:	2306      	movs	r3, #6
 800c13c:	e037      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c13e:	edd7 7a00 	vldr	s15, [r7]
 800c142:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800c1dc <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x118>
 800c146:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c14a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c14e:	d801      	bhi.n	800c154 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x90>
 800c150:	2307      	movs	r3, #7
 800c152:	e02c      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c154:	edd7 7a00 	vldr	s15, [r7]
 800c158:	ed9f 7a21 	vldr	s14, [pc, #132]	@ 800c1e0 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x11c>
 800c15c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c160:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c164:	d801      	bhi.n	800c16a <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xa6>
 800c166:	2308      	movs	r3, #8
 800c168:	e021      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c16a:	edd7 7a00 	vldr	s15, [r7]
 800c16e:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800c1e4 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x120>
 800c172:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c176:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c17a:	d801      	bhi.n	800c180 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xbc>
 800c17c:	2309      	movs	r3, #9
 800c17e:	e016      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c180:	edd7 7a00 	vldr	s15, [r7]
 800c184:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 800c1e8 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x124>
 800c188:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c18c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c190:	d801      	bhi.n	800c196 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xd2>
 800c192:	230a      	movs	r3, #10
 800c194:	e00b      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c196:	edd7 7a00 	vldr	s15, [r7]
 800c19a:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800c1ec <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x128>
 800c19e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c1a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c1a6:	d801      	bhi.n	800c1ac <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xe8>
 800c1a8:	230b      	movs	r3, #11
 800c1aa:	e000      	b.n	800c1ae <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0xea>
 800c1ac:	230c      	movs	r3, #12
  new_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800c1ae:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
            : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
            :                    LSM6DSV16X_ODR_AT_7680Hz;

  /* Output data rate selection */
  if (lsm6dsv16x_gy_data_rate_set(&(pObj->Ctx), new_odr) != LSM6DSV16X_OK)
 800c1b0:	687b      	ldr	r3, [r7, #4]
 800c1b2:	3320      	adds	r3, #32
 800c1b4:	7bfa      	ldrb	r2, [r7, #15]
 800c1b6:	4611      	mov	r1, r2
 800c1b8:	4618      	mov	r0, r3
 800c1ba:	f000 fa7f 	bl	800c6bc <lsm6dsv16x_gy_data_rate_set>
 800c1be:	4603      	mov	r3, r0
 800c1c0:	2b00      	cmp	r3, #0
 800c1c2:	d002      	beq.n	800c1ca <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x106>
  {
    return LSM6DSV16X_ERROR;
 800c1c4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800c1c8:	e000      	b.n	800c1cc <LSM6DSV16X_GYRO_SetOutputDataRate_When_Enabled+0x108>
  }

  return LSM6DSV16X_OK;
 800c1ca:	2300      	movs	r3, #0
}
 800c1cc:	4618      	mov	r0, r3
 800c1ce:	3710      	adds	r7, #16
 800c1d0:	46bd      	mov	sp, r7
 800c1d2:	bd80      	pop	{r7, pc}
 800c1d4:	42700000 	.word	0x42700000
 800c1d8:	42f00000 	.word	0x42f00000
 800c1dc:	43700000 	.word	0x43700000
 800c1e0:	43f00000 	.word	0x43f00000
 800c1e4:	44700000 	.word	0x44700000
 800c1e8:	44f00000 	.word	0x44f00000
 800c1ec:	45700000 	.word	0x45700000

0800c1f0 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled>:
  * @param  pObj the device pObj
  * @param  Odr the functional output data rate to be set
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled(LSM6DSV16X_Object_t *pObj, float Odr)
{
 800c1f0:	b480      	push	{r7}
 800c1f2:	b083      	sub	sp, #12
 800c1f4:	af00      	add	r7, sp, #0
 800c1f6:	6078      	str	r0, [r7, #4]
 800c1f8:	ed87 0a00 	vstr	s0, [r7]
  pObj->gyro_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
                   : (Odr <=   15.0f) ? LSM6DSV16X_ODR_AT_15Hz
 800c1fc:	edd7 7a00 	vldr	s15, [r7]
 800c200:	eeb1 7a0e 	vmov.f32	s14, #30	@ 0x40f00000  7.5
 800c204:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c208:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c20c:	d801      	bhi.n	800c212 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x22>
 800c20e:	2302      	movs	r3, #2
 800c210:	e063      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c212:	edd7 7a00 	vldr	s15, [r7]
 800c216:	eeb2 7a0e 	vmov.f32	s14, #46	@ 0x41700000  15.0
 800c21a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c21e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c222:	d801      	bhi.n	800c228 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x38>
 800c224:	2303      	movs	r3, #3
 800c226:	e058      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c228:	edd7 7a00 	vldr	s15, [r7]
 800c22c:	eeb3 7a0e 	vmov.f32	s14, #62	@ 0x41f00000  30.0
 800c230:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c234:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c238:	d801      	bhi.n	800c23e <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x4e>
 800c23a:	2304      	movs	r3, #4
 800c23c:	e04d      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c23e:	edd7 7a00 	vldr	s15, [r7]
 800c242:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 800c2f0 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x100>
 800c246:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c24a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c24e:	d801      	bhi.n	800c254 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x64>
 800c250:	2305      	movs	r3, #5
 800c252:	e042      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c254:	edd7 7a00 	vldr	s15, [r7]
 800c258:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 800c2f4 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x104>
 800c25c:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c260:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c264:	d801      	bhi.n	800c26a <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x7a>
 800c266:	2306      	movs	r3, #6
 800c268:	e037      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c26a:	edd7 7a00 	vldr	s15, [r7]
 800c26e:	ed9f 7a22 	vldr	s14, [pc, #136]	@ 800c2f8 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x108>
 800c272:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c276:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c27a:	d801      	bhi.n	800c280 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x90>
 800c27c:	2307      	movs	r3, #7
 800c27e:	e02c      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c280:	edd7 7a00 	vldr	s15, [r7]
 800c284:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 800c2fc <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x10c>
 800c288:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c28c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c290:	d801      	bhi.n	800c296 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xa6>
 800c292:	2308      	movs	r3, #8
 800c294:	e021      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c296:	edd7 7a00 	vldr	s15, [r7]
 800c29a:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 800c300 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x110>
 800c29e:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c2a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c2a6:	d801      	bhi.n	800c2ac <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xbc>
 800c2a8:	2309      	movs	r3, #9
 800c2aa:	e016      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c2ac:	edd7 7a00 	vldr	s15, [r7]
 800c2b0:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800c304 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x114>
 800c2b4:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c2b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c2bc:	d801      	bhi.n	800c2c2 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xd2>
 800c2be:	230a      	movs	r3, #10
 800c2c0:	e00b      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c2c2:	edd7 7a00 	vldr	s15, [r7]
 800c2c6:	ed9f 7a10 	vldr	s14, [pc, #64]	@ 800c308 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0x118>
 800c2ca:	eef4 7ac7 	vcmpe.f32	s15, s14
 800c2ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800c2d2:	d801      	bhi.n	800c2d8 <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xe8>
 800c2d4:	230b      	movs	r3, #11
 800c2d6:	e000      	b.n	800c2da <LSM6DSV16X_GYRO_SetOutputDataRate_When_Disabled+0xea>
 800c2d8:	230c      	movs	r3, #12
  pObj->gyro_odr = (Odr <=    7.5f) ? LSM6DSV16X_ODR_AT_7Hz5
 800c2da:	687a      	ldr	r2, [r7, #4]
 800c2dc:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
                   : (Odr <=  960.0f) ? LSM6DSV16X_ODR_AT_960Hz
                   : (Odr <= 1920.0f) ? LSM6DSV16X_ODR_AT_1920Hz
                   : (Odr <= 3840.0f) ? LSM6DSV16X_ODR_AT_3840Hz
                   :                    LSM6DSV16X_ODR_AT_7680Hz;

  return LSM6DSV16X_OK;
 800c2e0:	2300      	movs	r3, #0
}
 800c2e2:	4618      	mov	r0, r3
 800c2e4:	370c      	adds	r7, #12
 800c2e6:	46bd      	mov	sp, r7
 800c2e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2ec:	4770      	bx	lr
 800c2ee:	bf00      	nop
 800c2f0:	42700000 	.word	0x42700000
 800c2f4:	42f00000 	.word	0x42f00000
 800c2f8:	43700000 	.word	0x43700000
 800c2fc:	43f00000 	.word	0x43f00000
 800c300:	44700000 	.word	0x44700000
 800c304:	44f00000 	.word	0x44f00000
 800c308:	45700000 	.word	0x45700000

0800c30c <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800c30c:	b590      	push	{r4, r7, lr}
 800c30e:	b087      	sub	sp, #28
 800c310:	af00      	add	r7, sp, #0
 800c312:	60f8      	str	r0, [r7, #12]
 800c314:	607a      	str	r2, [r7, #4]
 800c316:	461a      	mov	r2, r3
 800c318:	460b      	mov	r3, r1
 800c31a:	72fb      	strb	r3, [r7, #11]
 800c31c:	4613      	mov	r3, r2
 800c31e:	813b      	strh	r3, [r7, #8]
  LSM6DSV16X_Object_t *pObj = (LSM6DSV16X_Object_t *)Handle;
 800c320:	68fb      	ldr	r3, [r7, #12]
 800c322:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
 800c324:	697b      	ldr	r3, [r7, #20]
 800c326:	695c      	ldr	r4, [r3, #20]
 800c328:	697b      	ldr	r3, [r7, #20]
 800c32a:	7b1b      	ldrb	r3, [r3, #12]
 800c32c:	4618      	mov	r0, r3
 800c32e:	7afb      	ldrb	r3, [r7, #11]
 800c330:	b299      	uxth	r1, r3
 800c332:	893b      	ldrh	r3, [r7, #8]
 800c334:	687a      	ldr	r2, [r7, #4]
 800c336:	47a0      	blx	r4
 800c338:	4603      	mov	r3, r0
}
 800c33a:	4618      	mov	r0, r3
 800c33c:	371c      	adds	r7, #28
 800c33e:	46bd      	mov	sp, r7
 800c340:	bd90      	pop	{r4, r7, pc}

0800c342 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800c342:	b590      	push	{r4, r7, lr}
 800c344:	b087      	sub	sp, #28
 800c346:	af00      	add	r7, sp, #0
 800c348:	60f8      	str	r0, [r7, #12]
 800c34a:	607a      	str	r2, [r7, #4]
 800c34c:	461a      	mov	r2, r3
 800c34e:	460b      	mov	r3, r1
 800c350:	72fb      	strb	r3, [r7, #11]
 800c352:	4613      	mov	r3, r2
 800c354:	813b      	strh	r3, [r7, #8]
  LSM6DSV16X_Object_t *pObj = (LSM6DSV16X_Object_t *)Handle;
 800c356:	68fb      	ldr	r3, [r7, #12]
 800c358:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
 800c35a:	697b      	ldr	r3, [r7, #20]
 800c35c:	691c      	ldr	r4, [r3, #16]
 800c35e:	697b      	ldr	r3, [r7, #20]
 800c360:	7b1b      	ldrb	r3, [r3, #12]
 800c362:	4618      	mov	r0, r3
 800c364:	7afb      	ldrb	r3, [r7, #11]
 800c366:	b299      	uxth	r1, r3
 800c368:	893b      	ldrh	r3, [r7, #8]
 800c36a:	687a      	ldr	r2, [r7, #4]
 800c36c:	47a0      	blx	r4
 800c36e:	4603      	mov	r3, r0
}
 800c370:	4618      	mov	r0, r3
 800c372:	371c      	adds	r7, #28
 800c374:	46bd      	mov	sp, r7
 800c376:	bd90      	pop	{r4, r7, pc}

0800c378 <lsm6dsv16x_read_reg>:
  *
  */
int32_t __weak lsm6dsv16x_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                   uint8_t *data,
                                   uint16_t len)
{
 800c378:	b590      	push	{r4, r7, lr}
 800c37a:	b087      	sub	sp, #28
 800c37c:	af00      	add	r7, sp, #0
 800c37e:	60f8      	str	r0, [r7, #12]
 800c380:	607a      	str	r2, [r7, #4]
 800c382:	461a      	mov	r2, r3
 800c384:	460b      	mov	r3, r1
 800c386:	72fb      	strb	r3, [r7, #11]
 800c388:	4613      	mov	r3, r2
 800c38a:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800c38c:	68fb      	ldr	r3, [r7, #12]
 800c38e:	685c      	ldr	r4, [r3, #4]
 800c390:	68fb      	ldr	r3, [r7, #12]
 800c392:	68d8      	ldr	r0, [r3, #12]
 800c394:	893b      	ldrh	r3, [r7, #8]
 800c396:	7af9      	ldrb	r1, [r7, #11]
 800c398:	687a      	ldr	r2, [r7, #4]
 800c39a:	47a0      	blx	r4
 800c39c:	6178      	str	r0, [r7, #20]

  return ret;
 800c39e:	697b      	ldr	r3, [r7, #20]
}
 800c3a0:	4618      	mov	r0, r3
 800c3a2:	371c      	adds	r7, #28
 800c3a4:	46bd      	mov	sp, r7
 800c3a6:	bd90      	pop	{r4, r7, pc}

0800c3a8 <lsm6dsv16x_write_reg>:
  *
  */
int32_t __weak lsm6dsv16x_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                    uint8_t *data,
                                    uint16_t len)
{
 800c3a8:	b590      	push	{r4, r7, lr}
 800c3aa:	b087      	sub	sp, #28
 800c3ac:	af00      	add	r7, sp, #0
 800c3ae:	60f8      	str	r0, [r7, #12]
 800c3b0:	607a      	str	r2, [r7, #4]
 800c3b2:	461a      	mov	r2, r3
 800c3b4:	460b      	mov	r3, r1
 800c3b6:	72fb      	strb	r3, [r7, #11]
 800c3b8:	4613      	mov	r3, r2
 800c3ba:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800c3bc:	68fb      	ldr	r3, [r7, #12]
 800c3be:	681c      	ldr	r4, [r3, #0]
 800c3c0:	68fb      	ldr	r3, [r7, #12]
 800c3c2:	68d8      	ldr	r0, [r3, #12]
 800c3c4:	893b      	ldrh	r3, [r7, #8]
 800c3c6:	7af9      	ldrb	r1, [r7, #11]
 800c3c8:	687a      	ldr	r2, [r7, #4]
 800c3ca:	47a0      	blx	r4
 800c3cc:	6178      	str	r0, [r7, #20]

  return ret;
 800c3ce:	697b      	ldr	r3, [r7, #20]
}
 800c3d0:	4618      	mov	r0, r3
 800c3d2:	371c      	adds	r7, #28
 800c3d4:	46bd      	mov	sp, r7
 800c3d6:	bd90      	pop	{r4, r7, pc}

0800c3d8 <lsm6dsv16x_device_id_get>:
  * @param  val      Device ID.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_device_id_get(stmdev_ctx_t *ctx, uint8_t *val)
{
 800c3d8:	b580      	push	{r7, lr}
 800c3da:	b084      	sub	sp, #16
 800c3dc:	af00      	add	r7, sp, #0
 800c3de:	6078      	str	r0, [r7, #4]
 800c3e0:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_WHO_AM_I, val, 1);
 800c3e2:	2301      	movs	r3, #1
 800c3e4:	683a      	ldr	r2, [r7, #0]
 800c3e6:	210f      	movs	r1, #15
 800c3e8:	6878      	ldr	r0, [r7, #4]
 800c3ea:	f7ff ffc5 	bl	800c378 <lsm6dsv16x_read_reg>
 800c3ee:	60f8      	str	r0, [r7, #12]

  return ret;
 800c3f0:	68fb      	ldr	r3, [r7, #12]
}
 800c3f2:	4618      	mov	r0, r3
 800c3f4:	3710      	adds	r7, #16
 800c3f6:	46bd      	mov	sp, r7
 800c3f8:	bd80      	pop	{r7, pc}

0800c3fa <lsm6dsv16x_xl_data_rate_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_data_rate_set(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t val)
{
 800c3fa:	b580      	push	{r7, lr}
 800c3fc:	b086      	sub	sp, #24
 800c3fe:	af00      	add	r7, sp, #0
 800c400:	6078      	str	r0, [r7, #4]
 800c402:	460b      	mov	r3, r1
 800c404:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl1_t ctrl1;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL1, (uint8_t *)&ctrl1, 1);
 800c406:	f107 0210 	add.w	r2, r7, #16
 800c40a:	2301      	movs	r3, #1
 800c40c:	2110      	movs	r1, #16
 800c40e:	6878      	ldr	r0, [r7, #4]
 800c410:	f7ff ffb2 	bl	800c378 <lsm6dsv16x_read_reg>
 800c414:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800c416:	697b      	ldr	r3, [r7, #20]
 800c418:	2b00      	cmp	r3, #0
 800c41a:	d001      	beq.n	800c420 <lsm6dsv16x_xl_data_rate_set+0x26>
 800c41c:	697b      	ldr	r3, [r7, #20]
 800c41e:	e039      	b.n	800c494 <lsm6dsv16x_xl_data_rate_set+0x9a>

  ctrl1.odr_xl = (uint8_t)val & 0x0Fu;
 800c420:	78fb      	ldrb	r3, [r7, #3]
 800c422:	f003 030f 	and.w	r3, r3, #15
 800c426:	b2da      	uxtb	r2, r3
 800c428:	7c3b      	ldrb	r3, [r7, #16]
 800c42a:	f362 0303 	bfi	r3, r2, #0, #4
 800c42e:	743b      	strb	r3, [r7, #16]
  ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL1, (uint8_t *)&ctrl1, 1);
 800c430:	f107 0210 	add.w	r2, r7, #16
 800c434:	2301      	movs	r3, #1
 800c436:	2110      	movs	r1, #16
 800c438:	6878      	ldr	r0, [r7, #4]
 800c43a:	f7ff ffb5 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800c43e:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800c440:	697b      	ldr	r3, [r7, #20]
 800c442:	2b00      	cmp	r3, #0
 800c444:	d001      	beq.n	800c44a <lsm6dsv16x_xl_data_rate_set+0x50>
 800c446:	697b      	ldr	r3, [r7, #20]
 800c448:	e024      	b.n	800c494 <lsm6dsv16x_xl_data_rate_set+0x9a>

  sel = ((uint8_t)val >> 4) & 0xFU;
 800c44a:	78fb      	ldrb	r3, [r7, #3]
 800c44c:	091b      	lsrs	r3, r3, #4
 800c44e:	74fb      	strb	r3, [r7, #19]
  if (sel != 0U)
 800c450:	7cfb      	ldrb	r3, [r7, #19]
 800c452:	2b00      	cmp	r3, #0
 800c454:	d01d      	beq.n	800c492 <lsm6dsv16x_xl_data_rate_set+0x98>
  {
    ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800c456:	f107 020c 	add.w	r2, r7, #12
 800c45a:	2301      	movs	r3, #1
 800c45c:	2162      	movs	r1, #98	@ 0x62
 800c45e:	6878      	ldr	r0, [r7, #4]
 800c460:	f7ff ff8a 	bl	800c378 <lsm6dsv16x_read_reg>
 800c464:	4602      	mov	r2, r0
 800c466:	697b      	ldr	r3, [r7, #20]
 800c468:	4413      	add	r3, r2
 800c46a:	617b      	str	r3, [r7, #20]
    haodr.haodr_sel = sel;
 800c46c:	7cfb      	ldrb	r3, [r7, #19]
 800c46e:	f003 0303 	and.w	r3, r3, #3
 800c472:	b2da      	uxtb	r2, r3
 800c474:	7b3b      	ldrb	r3, [r7, #12]
 800c476:	f362 0301 	bfi	r3, r2, #0, #2
 800c47a:	733b      	strb	r3, [r7, #12]
    ret += lsm6dsv16x_write_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800c47c:	f107 020c 	add.w	r2, r7, #12
 800c480:	2301      	movs	r3, #1
 800c482:	2162      	movs	r1, #98	@ 0x62
 800c484:	6878      	ldr	r0, [r7, #4]
 800c486:	f7ff ff8f 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800c48a:	4602      	mov	r2, r0
 800c48c:	697b      	ldr	r3, [r7, #20]
 800c48e:	4413      	add	r3, r2
 800c490:	617b      	str	r3, [r7, #20]
  }

  return ret;
 800c492:	697b      	ldr	r3, [r7, #20]
}
 800c494:	4618      	mov	r0, r3
 800c496:	3718      	adds	r7, #24
 800c498:	46bd      	mov	sp, r7
 800c49a:	bd80      	pop	{r7, pc}

0800c49c <lsm6dsv16x_xl_data_rate_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_data_rate_get(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t *val)
{
 800c49c:	b580      	push	{r7, lr}
 800c49e:	b086      	sub	sp, #24
 800c4a0:	af00      	add	r7, sp, #0
 800c4a2:	6078      	str	r0, [r7, #4]
 800c4a4:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl1_t ctrl1;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL1, (uint8_t *)&ctrl1, 1);
 800c4a6:	f107 0210 	add.w	r2, r7, #16
 800c4aa:	2301      	movs	r3, #1
 800c4ac:	2110      	movs	r1, #16
 800c4ae:	6878      	ldr	r0, [r7, #4]
 800c4b0:	f7ff ff62 	bl	800c378 <lsm6dsv16x_read_reg>
 800c4b4:	6178      	str	r0, [r7, #20]
  ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800c4b6:	f107 020c 	add.w	r2, r7, #12
 800c4ba:	2301      	movs	r3, #1
 800c4bc:	2162      	movs	r1, #98	@ 0x62
 800c4be:	6878      	ldr	r0, [r7, #4]
 800c4c0:	f7ff ff5a 	bl	800c378 <lsm6dsv16x_read_reg>
 800c4c4:	4602      	mov	r2, r0
 800c4c6:	697b      	ldr	r3, [r7, #20]
 800c4c8:	4413      	add	r3, r2
 800c4ca:	617b      	str	r3, [r7, #20]
  if (ret != 0) { return ret; }
 800c4cc:	697b      	ldr	r3, [r7, #20]
 800c4ce:	2b00      	cmp	r3, #0
 800c4d0:	d001      	beq.n	800c4d6 <lsm6dsv16x_xl_data_rate_get+0x3a>
 800c4d2:	697b      	ldr	r3, [r7, #20]
 800c4d4:	e0ed      	b.n	800c6b2 <lsm6dsv16x_xl_data_rate_get+0x216>

  sel = haodr.haodr_sel;
 800c4d6:	7b3b      	ldrb	r3, [r7, #12]
 800c4d8:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800c4dc:	b2db      	uxtb	r3, r3
 800c4de:	74fb      	strb	r3, [r7, #19]

  switch (ctrl1.odr_xl)
 800c4e0:	7c3b      	ldrb	r3, [r7, #16]
 800c4e2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800c4e6:	b2db      	uxtb	r3, r3
 800c4e8:	2b0c      	cmp	r3, #12
 800c4ea:	f200 80dd 	bhi.w	800c6a8 <lsm6dsv16x_xl_data_rate_get+0x20c>
 800c4ee:	a201      	add	r2, pc, #4	@ (adr r2, 800c4f4 <lsm6dsv16x_xl_data_rate_get+0x58>)
 800c4f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c4f4:	0800c529 	.word	0x0800c529
 800c4f8:	0800c531 	.word	0x0800c531
 800c4fc:	0800c539 	.word	0x0800c539
 800c500:	0800c541 	.word	0x0800c541
 800c504:	0800c565 	.word	0x0800c565
 800c508:	0800c589 	.word	0x0800c589
 800c50c:	0800c5ad 	.word	0x0800c5ad
 800c510:	0800c5d1 	.word	0x0800c5d1
 800c514:	0800c5f5 	.word	0x0800c5f5
 800c518:	0800c619 	.word	0x0800c619
 800c51c:	0800c63d 	.word	0x0800c63d
 800c520:	0800c661 	.word	0x0800c661
 800c524:	0800c685 	.word	0x0800c685
  {
    case LSM6DSV16X_ODR_OFF:
      *val = LSM6DSV16X_ODR_OFF;
 800c528:	683b      	ldr	r3, [r7, #0]
 800c52a:	2200      	movs	r2, #0
 800c52c:	701a      	strb	r2, [r3, #0]
      break;
 800c52e:	e0bf      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1Hz875:
      *val = LSM6DSV16X_ODR_AT_1Hz875;
 800c530:	683b      	ldr	r3, [r7, #0]
 800c532:	2201      	movs	r2, #1
 800c534:	701a      	strb	r2, [r3, #0]
      break;
 800c536:	e0bb      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *val = LSM6DSV16X_ODR_AT_7Hz5;
 800c538:	683b      	ldr	r3, [r7, #0]
 800c53a:	2202      	movs	r2, #2
 800c53c:	701a      	strb	r2, [r3, #0]
      break;
 800c53e:	e0b7      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_15Hz:
      switch (sel) {
 800c540:	7cfb      	ldrb	r3, [r7, #19]
 800c542:	2b01      	cmp	r3, #1
 800c544:	d005      	beq.n	800c552 <lsm6dsv16x_xl_data_rate_get+0xb6>
 800c546:	2b02      	cmp	r3, #2
 800c548:	d007      	beq.n	800c55a <lsm6dsv16x_xl_data_rate_get+0xbe>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_15Hz;
 800c54a:	683b      	ldr	r3, [r7, #0]
 800c54c:	2203      	movs	r2, #3
 800c54e:	701a      	strb	r2, [r3, #0]
        break;
 800c550:	e007      	b.n	800c562 <lsm6dsv16x_xl_data_rate_get+0xc6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_15Hz625;
 800c552:	683b      	ldr	r3, [r7, #0]
 800c554:	2213      	movs	r2, #19
 800c556:	701a      	strb	r2, [r3, #0]
        break;
 800c558:	e003      	b.n	800c562 <lsm6dsv16x_xl_data_rate_get+0xc6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_12Hz5;
 800c55a:	683b      	ldr	r3, [r7, #0]
 800c55c:	2223      	movs	r2, #35	@ 0x23
 800c55e:	701a      	strb	r2, [r3, #0]
        break;
 800c560:	bf00      	nop
      }
      break;
 800c562:	e0a5      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_30Hz:
      switch (sel) {
 800c564:	7cfb      	ldrb	r3, [r7, #19]
 800c566:	2b01      	cmp	r3, #1
 800c568:	d005      	beq.n	800c576 <lsm6dsv16x_xl_data_rate_get+0xda>
 800c56a:	2b02      	cmp	r3, #2
 800c56c:	d007      	beq.n	800c57e <lsm6dsv16x_xl_data_rate_get+0xe2>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_30Hz;
 800c56e:	683b      	ldr	r3, [r7, #0]
 800c570:	2204      	movs	r2, #4
 800c572:	701a      	strb	r2, [r3, #0]
        break;
 800c574:	e007      	b.n	800c586 <lsm6dsv16x_xl_data_rate_get+0xea>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_31Hz25;
 800c576:	683b      	ldr	r3, [r7, #0]
 800c578:	2214      	movs	r2, #20
 800c57a:	701a      	strb	r2, [r3, #0]
        break;
 800c57c:	e003      	b.n	800c586 <lsm6dsv16x_xl_data_rate_get+0xea>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_25Hz;
 800c57e:	683b      	ldr	r3, [r7, #0]
 800c580:	2224      	movs	r2, #36	@ 0x24
 800c582:	701a      	strb	r2, [r3, #0]
        break;
 800c584:	bf00      	nop
      }
      break;
 800c586:	e093      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_60Hz:
      switch (sel) {
 800c588:	7cfb      	ldrb	r3, [r7, #19]
 800c58a:	2b01      	cmp	r3, #1
 800c58c:	d005      	beq.n	800c59a <lsm6dsv16x_xl_data_rate_get+0xfe>
 800c58e:	2b02      	cmp	r3, #2
 800c590:	d007      	beq.n	800c5a2 <lsm6dsv16x_xl_data_rate_get+0x106>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_60Hz;
 800c592:	683b      	ldr	r3, [r7, #0]
 800c594:	2205      	movs	r2, #5
 800c596:	701a      	strb	r2, [r3, #0]
        break;
 800c598:	e007      	b.n	800c5aa <lsm6dsv16x_xl_data_rate_get+0x10e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_62Hz5;
 800c59a:	683b      	ldr	r3, [r7, #0]
 800c59c:	2215      	movs	r2, #21
 800c59e:	701a      	strb	r2, [r3, #0]
        break;
 800c5a0:	e003      	b.n	800c5aa <lsm6dsv16x_xl_data_rate_get+0x10e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_50Hz;
 800c5a2:	683b      	ldr	r3, [r7, #0]
 800c5a4:	2225      	movs	r2, #37	@ 0x25
 800c5a6:	701a      	strb	r2, [r3, #0]
        break;
 800c5a8:	bf00      	nop
      }
      break;
 800c5aa:	e081      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_120Hz:
      switch (sel) {
 800c5ac:	7cfb      	ldrb	r3, [r7, #19]
 800c5ae:	2b01      	cmp	r3, #1
 800c5b0:	d005      	beq.n	800c5be <lsm6dsv16x_xl_data_rate_get+0x122>
 800c5b2:	2b02      	cmp	r3, #2
 800c5b4:	d007      	beq.n	800c5c6 <lsm6dsv16x_xl_data_rate_get+0x12a>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_120Hz;
 800c5b6:	683b      	ldr	r3, [r7, #0]
 800c5b8:	2206      	movs	r2, #6
 800c5ba:	701a      	strb	r2, [r3, #0]
        break;
 800c5bc:	e007      	b.n	800c5ce <lsm6dsv16x_xl_data_rate_get+0x132>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_125Hz;
 800c5be:	683b      	ldr	r3, [r7, #0]
 800c5c0:	2216      	movs	r2, #22
 800c5c2:	701a      	strb	r2, [r3, #0]
        break;
 800c5c4:	e003      	b.n	800c5ce <lsm6dsv16x_xl_data_rate_get+0x132>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_100Hz;
 800c5c6:	683b      	ldr	r3, [r7, #0]
 800c5c8:	2226      	movs	r2, #38	@ 0x26
 800c5ca:	701a      	strb	r2, [r3, #0]
        break;
 800c5cc:	bf00      	nop
      }
      break;
 800c5ce:	e06f      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_240Hz:
      switch (sel) {
 800c5d0:	7cfb      	ldrb	r3, [r7, #19]
 800c5d2:	2b01      	cmp	r3, #1
 800c5d4:	d005      	beq.n	800c5e2 <lsm6dsv16x_xl_data_rate_get+0x146>
 800c5d6:	2b02      	cmp	r3, #2
 800c5d8:	d007      	beq.n	800c5ea <lsm6dsv16x_xl_data_rate_get+0x14e>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_240Hz;
 800c5da:	683b      	ldr	r3, [r7, #0]
 800c5dc:	2207      	movs	r2, #7
 800c5de:	701a      	strb	r2, [r3, #0]
        break;
 800c5e0:	e007      	b.n	800c5f2 <lsm6dsv16x_xl_data_rate_get+0x156>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_250Hz;
 800c5e2:	683b      	ldr	r3, [r7, #0]
 800c5e4:	2217      	movs	r2, #23
 800c5e6:	701a      	strb	r2, [r3, #0]
        break;
 800c5e8:	e003      	b.n	800c5f2 <lsm6dsv16x_xl_data_rate_get+0x156>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_200Hz;
 800c5ea:	683b      	ldr	r3, [r7, #0]
 800c5ec:	2227      	movs	r2, #39	@ 0x27
 800c5ee:	701a      	strb	r2, [r3, #0]
        break;
 800c5f0:	bf00      	nop
      }
      break;
 800c5f2:	e05d      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_480Hz:
      switch (sel) {
 800c5f4:	7cfb      	ldrb	r3, [r7, #19]
 800c5f6:	2b01      	cmp	r3, #1
 800c5f8:	d005      	beq.n	800c606 <lsm6dsv16x_xl_data_rate_get+0x16a>
 800c5fa:	2b02      	cmp	r3, #2
 800c5fc:	d007      	beq.n	800c60e <lsm6dsv16x_xl_data_rate_get+0x172>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_480Hz;
 800c5fe:	683b      	ldr	r3, [r7, #0]
 800c600:	2208      	movs	r2, #8
 800c602:	701a      	strb	r2, [r3, #0]
        break;
 800c604:	e007      	b.n	800c616 <lsm6dsv16x_xl_data_rate_get+0x17a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_500Hz;
 800c606:	683b      	ldr	r3, [r7, #0]
 800c608:	2218      	movs	r2, #24
 800c60a:	701a      	strb	r2, [r3, #0]
        break;
 800c60c:	e003      	b.n	800c616 <lsm6dsv16x_xl_data_rate_get+0x17a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_400Hz;
 800c60e:	683b      	ldr	r3, [r7, #0]
 800c610:	2228      	movs	r2, #40	@ 0x28
 800c612:	701a      	strb	r2, [r3, #0]
        break;
 800c614:	bf00      	nop
      }
      break;
 800c616:	e04b      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_960Hz:
      switch (sel) {
 800c618:	7cfb      	ldrb	r3, [r7, #19]
 800c61a:	2b01      	cmp	r3, #1
 800c61c:	d005      	beq.n	800c62a <lsm6dsv16x_xl_data_rate_get+0x18e>
 800c61e:	2b02      	cmp	r3, #2
 800c620:	d007      	beq.n	800c632 <lsm6dsv16x_xl_data_rate_get+0x196>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_960Hz;
 800c622:	683b      	ldr	r3, [r7, #0]
 800c624:	2209      	movs	r2, #9
 800c626:	701a      	strb	r2, [r3, #0]
        break;
 800c628:	e007      	b.n	800c63a <lsm6dsv16x_xl_data_rate_get+0x19e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_1000Hz;
 800c62a:	683b      	ldr	r3, [r7, #0]
 800c62c:	2219      	movs	r2, #25
 800c62e:	701a      	strb	r2, [r3, #0]
        break;
 800c630:	e003      	b.n	800c63a <lsm6dsv16x_xl_data_rate_get+0x19e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_800Hz;
 800c632:	683b      	ldr	r3, [r7, #0]
 800c634:	2229      	movs	r2, #41	@ 0x29
 800c636:	701a      	strb	r2, [r3, #0]
        break;
 800c638:	bf00      	nop
      }
      break;
 800c63a:	e039      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1920Hz:
      switch (sel) {
 800c63c:	7cfb      	ldrb	r3, [r7, #19]
 800c63e:	2b01      	cmp	r3, #1
 800c640:	d005      	beq.n	800c64e <lsm6dsv16x_xl_data_rate_get+0x1b2>
 800c642:	2b02      	cmp	r3, #2
 800c644:	d007      	beq.n	800c656 <lsm6dsv16x_xl_data_rate_get+0x1ba>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_1920Hz;
 800c646:	683b      	ldr	r3, [r7, #0]
 800c648:	220a      	movs	r2, #10
 800c64a:	701a      	strb	r2, [r3, #0]
        break;
 800c64c:	e007      	b.n	800c65e <lsm6dsv16x_xl_data_rate_get+0x1c2>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_2000Hz;
 800c64e:	683b      	ldr	r3, [r7, #0]
 800c650:	221a      	movs	r2, #26
 800c652:	701a      	strb	r2, [r3, #0]
        break;
 800c654:	e003      	b.n	800c65e <lsm6dsv16x_xl_data_rate_get+0x1c2>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_1600Hz;
 800c656:	683b      	ldr	r3, [r7, #0]
 800c658:	222a      	movs	r2, #42	@ 0x2a
 800c65a:	701a      	strb	r2, [r3, #0]
        break;
 800c65c:	bf00      	nop
      }
      break;
 800c65e:	e027      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_3840Hz:
      switch (sel) {
 800c660:	7cfb      	ldrb	r3, [r7, #19]
 800c662:	2b01      	cmp	r3, #1
 800c664:	d005      	beq.n	800c672 <lsm6dsv16x_xl_data_rate_get+0x1d6>
 800c666:	2b02      	cmp	r3, #2
 800c668:	d007      	beq.n	800c67a <lsm6dsv16x_xl_data_rate_get+0x1de>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_3840Hz;
 800c66a:	683b      	ldr	r3, [r7, #0]
 800c66c:	220b      	movs	r2, #11
 800c66e:	701a      	strb	r2, [r3, #0]
        break;
 800c670:	e007      	b.n	800c682 <lsm6dsv16x_xl_data_rate_get+0x1e6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_4000Hz;
 800c672:	683b      	ldr	r3, [r7, #0]
 800c674:	221b      	movs	r2, #27
 800c676:	701a      	strb	r2, [r3, #0]
        break;
 800c678:	e003      	b.n	800c682 <lsm6dsv16x_xl_data_rate_get+0x1e6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_3200Hz;
 800c67a:	683b      	ldr	r3, [r7, #0]
 800c67c:	222b      	movs	r2, #43	@ 0x2b
 800c67e:	701a      	strb	r2, [r3, #0]
        break;
 800c680:	bf00      	nop
      }
      break;
 800c682:	e015      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7680Hz:
      switch (sel) {
 800c684:	7cfb      	ldrb	r3, [r7, #19]
 800c686:	2b01      	cmp	r3, #1
 800c688:	d005      	beq.n	800c696 <lsm6dsv16x_xl_data_rate_get+0x1fa>
 800c68a:	2b02      	cmp	r3, #2
 800c68c:	d007      	beq.n	800c69e <lsm6dsv16x_xl_data_rate_get+0x202>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_7680Hz;
 800c68e:	683b      	ldr	r3, [r7, #0]
 800c690:	220c      	movs	r2, #12
 800c692:	701a      	strb	r2, [r3, #0]
        break;
 800c694:	e007      	b.n	800c6a6 <lsm6dsv16x_xl_data_rate_get+0x20a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_8000Hz;
 800c696:	683b      	ldr	r3, [r7, #0]
 800c698:	221c      	movs	r2, #28
 800c69a:	701a      	strb	r2, [r3, #0]
        break;
 800c69c:	e003      	b.n	800c6a6 <lsm6dsv16x_xl_data_rate_get+0x20a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_6400Hz;
 800c69e:	683b      	ldr	r3, [r7, #0]
 800c6a0:	222c      	movs	r2, #44	@ 0x2c
 800c6a2:	701a      	strb	r2, [r3, #0]
        break;
 800c6a4:	bf00      	nop
      }
      break;
 800c6a6:	e003      	b.n	800c6b0 <lsm6dsv16x_xl_data_rate_get+0x214>

    default:
      *val = LSM6DSV16X_ODR_OFF;
 800c6a8:	683b      	ldr	r3, [r7, #0]
 800c6aa:	2200      	movs	r2, #0
 800c6ac:	701a      	strb	r2, [r3, #0]
      break;
 800c6ae:	bf00      	nop
  }

  return ret;
 800c6b0:	697b      	ldr	r3, [r7, #20]
}
 800c6b2:	4618      	mov	r0, r3
 800c6b4:	3718      	adds	r7, #24
 800c6b6:	46bd      	mov	sp, r7
 800c6b8:	bd80      	pop	{r7, pc}
 800c6ba:	bf00      	nop

0800c6bc <lsm6dsv16x_gy_data_rate_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_data_rate_set(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t val)
{
 800c6bc:	b580      	push	{r7, lr}
 800c6be:	b086      	sub	sp, #24
 800c6c0:	af00      	add	r7, sp, #0
 800c6c2:	6078      	str	r0, [r7, #4]
 800c6c4:	460b      	mov	r3, r1
 800c6c6:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl2_t ctrl2;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL2, (uint8_t *)&ctrl2, 1);
 800c6c8:	f107 0210 	add.w	r2, r7, #16
 800c6cc:	2301      	movs	r3, #1
 800c6ce:	2111      	movs	r1, #17
 800c6d0:	6878      	ldr	r0, [r7, #4]
 800c6d2:	f7ff fe51 	bl	800c378 <lsm6dsv16x_read_reg>
 800c6d6:	6178      	str	r0, [r7, #20]
  ctrl2.odr_g = (uint8_t)val & 0x0Fu;
 800c6d8:	78fb      	ldrb	r3, [r7, #3]
 800c6da:	f003 030f 	and.w	r3, r3, #15
 800c6de:	b2da      	uxtb	r2, r3
 800c6e0:	7c3b      	ldrb	r3, [r7, #16]
 800c6e2:	f362 0303 	bfi	r3, r2, #0, #4
 800c6e6:	743b      	strb	r3, [r7, #16]
  ret += lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL2, (uint8_t *)&ctrl2, 1);
 800c6e8:	f107 0210 	add.w	r2, r7, #16
 800c6ec:	2301      	movs	r3, #1
 800c6ee:	2111      	movs	r1, #17
 800c6f0:	6878      	ldr	r0, [r7, #4]
 800c6f2:	f7ff fe59 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800c6f6:	4602      	mov	r2, r0
 800c6f8:	697b      	ldr	r3, [r7, #20]
 800c6fa:	4413      	add	r3, r2
 800c6fc:	617b      	str	r3, [r7, #20]
  if (ret != 0) { return ret; }
 800c6fe:	697b      	ldr	r3, [r7, #20]
 800c700:	2b00      	cmp	r3, #0
 800c702:	d001      	beq.n	800c708 <lsm6dsv16x_gy_data_rate_set+0x4c>
 800c704:	697b      	ldr	r3, [r7, #20]
 800c706:	e024      	b.n	800c752 <lsm6dsv16x_gy_data_rate_set+0x96>

  sel = ((uint8_t)val >> 4) & 0xFU;
 800c708:	78fb      	ldrb	r3, [r7, #3]
 800c70a:	091b      	lsrs	r3, r3, #4
 800c70c:	74fb      	strb	r3, [r7, #19]
  if (sel != 0U)
 800c70e:	7cfb      	ldrb	r3, [r7, #19]
 800c710:	2b00      	cmp	r3, #0
 800c712:	d01d      	beq.n	800c750 <lsm6dsv16x_gy_data_rate_set+0x94>
  {
    ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800c714:	f107 020c 	add.w	r2, r7, #12
 800c718:	2301      	movs	r3, #1
 800c71a:	2162      	movs	r1, #98	@ 0x62
 800c71c:	6878      	ldr	r0, [r7, #4]
 800c71e:	f7ff fe2b 	bl	800c378 <lsm6dsv16x_read_reg>
 800c722:	4602      	mov	r2, r0
 800c724:	697b      	ldr	r3, [r7, #20]
 800c726:	4413      	add	r3, r2
 800c728:	617b      	str	r3, [r7, #20]
    haodr.haodr_sel = sel;
 800c72a:	7cfb      	ldrb	r3, [r7, #19]
 800c72c:	f003 0303 	and.w	r3, r3, #3
 800c730:	b2da      	uxtb	r2, r3
 800c732:	7b3b      	ldrb	r3, [r7, #12]
 800c734:	f362 0301 	bfi	r3, r2, #0, #2
 800c738:	733b      	strb	r3, [r7, #12]
    ret += lsm6dsv16x_write_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800c73a:	f107 020c 	add.w	r2, r7, #12
 800c73e:	2301      	movs	r3, #1
 800c740:	2162      	movs	r1, #98	@ 0x62
 800c742:	6878      	ldr	r0, [r7, #4]
 800c744:	f7ff fe30 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800c748:	4602      	mov	r2, r0
 800c74a:	697b      	ldr	r3, [r7, #20]
 800c74c:	4413      	add	r3, r2
 800c74e:	617b      	str	r3, [r7, #20]
  }

  return ret;
 800c750:	697b      	ldr	r3, [r7, #20]
}
 800c752:	4618      	mov	r0, r3
 800c754:	3718      	adds	r7, #24
 800c756:	46bd      	mov	sp, r7
 800c758:	bd80      	pop	{r7, pc}
	...

0800c75c <lsm6dsv16x_gy_data_rate_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_data_rate_get(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_data_rate_t *val)
{
 800c75c:	b580      	push	{r7, lr}
 800c75e:	b086      	sub	sp, #24
 800c760:	af00      	add	r7, sp, #0
 800c762:	6078      	str	r0, [r7, #4]
 800c764:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl2_t ctrl2;
  lsm6dsv16x_haodr_cfg_t haodr;
  uint8_t sel;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL2, (uint8_t *)&ctrl2, 1);
 800c766:	f107 0210 	add.w	r2, r7, #16
 800c76a:	2301      	movs	r3, #1
 800c76c:	2111      	movs	r1, #17
 800c76e:	6878      	ldr	r0, [r7, #4]
 800c770:	f7ff fe02 	bl	800c378 <lsm6dsv16x_read_reg>
 800c774:	6178      	str	r0, [r7, #20]
  ret += lsm6dsv16x_read_reg(ctx, LSM6DSV16X_HAODR_CFG, (uint8_t *)&haodr, 1);
 800c776:	f107 020c 	add.w	r2, r7, #12
 800c77a:	2301      	movs	r3, #1
 800c77c:	2162      	movs	r1, #98	@ 0x62
 800c77e:	6878      	ldr	r0, [r7, #4]
 800c780:	f7ff fdfa 	bl	800c378 <lsm6dsv16x_read_reg>
 800c784:	4602      	mov	r2, r0
 800c786:	697b      	ldr	r3, [r7, #20]
 800c788:	4413      	add	r3, r2
 800c78a:	617b      	str	r3, [r7, #20]
  if (ret != 0) { return ret; }
 800c78c:	697b      	ldr	r3, [r7, #20]
 800c78e:	2b00      	cmp	r3, #0
 800c790:	d001      	beq.n	800c796 <lsm6dsv16x_gy_data_rate_get+0x3a>
 800c792:	697b      	ldr	r3, [r7, #20]
 800c794:	e0ed      	b.n	800c972 <lsm6dsv16x_gy_data_rate_get+0x216>

  sel = haodr.haodr_sel;
 800c796:	7b3b      	ldrb	r3, [r7, #12]
 800c798:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800c79c:	b2db      	uxtb	r3, r3
 800c79e:	74fb      	strb	r3, [r7, #19]

  switch (ctrl2.odr_g)
 800c7a0:	7c3b      	ldrb	r3, [r7, #16]
 800c7a2:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800c7a6:	b2db      	uxtb	r3, r3
 800c7a8:	2b0c      	cmp	r3, #12
 800c7aa:	f200 80dd 	bhi.w	800c968 <lsm6dsv16x_gy_data_rate_get+0x20c>
 800c7ae:	a201      	add	r2, pc, #4	@ (adr r2, 800c7b4 <lsm6dsv16x_gy_data_rate_get+0x58>)
 800c7b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c7b4:	0800c7e9 	.word	0x0800c7e9
 800c7b8:	0800c7f1 	.word	0x0800c7f1
 800c7bc:	0800c7f9 	.word	0x0800c7f9
 800c7c0:	0800c801 	.word	0x0800c801
 800c7c4:	0800c825 	.word	0x0800c825
 800c7c8:	0800c849 	.word	0x0800c849
 800c7cc:	0800c86d 	.word	0x0800c86d
 800c7d0:	0800c891 	.word	0x0800c891
 800c7d4:	0800c8b5 	.word	0x0800c8b5
 800c7d8:	0800c8d9 	.word	0x0800c8d9
 800c7dc:	0800c8fd 	.word	0x0800c8fd
 800c7e0:	0800c921 	.word	0x0800c921
 800c7e4:	0800c945 	.word	0x0800c945
  {
    case LSM6DSV16X_ODR_OFF:
      *val = LSM6DSV16X_ODR_OFF;
 800c7e8:	683b      	ldr	r3, [r7, #0]
 800c7ea:	2200      	movs	r2, #0
 800c7ec:	701a      	strb	r2, [r3, #0]
      break;
 800c7ee:	e0bf      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1Hz875:
      *val = LSM6DSV16X_ODR_AT_1Hz875;
 800c7f0:	683b      	ldr	r3, [r7, #0]
 800c7f2:	2201      	movs	r2, #1
 800c7f4:	701a      	strb	r2, [r3, #0]
      break;
 800c7f6:	e0bb      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7Hz5:
      *val = LSM6DSV16X_ODR_AT_7Hz5;
 800c7f8:	683b      	ldr	r3, [r7, #0]
 800c7fa:	2202      	movs	r2, #2
 800c7fc:	701a      	strb	r2, [r3, #0]
      break;
 800c7fe:	e0b7      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_15Hz:
      switch (sel) {
 800c800:	7cfb      	ldrb	r3, [r7, #19]
 800c802:	2b01      	cmp	r3, #1
 800c804:	d005      	beq.n	800c812 <lsm6dsv16x_gy_data_rate_get+0xb6>
 800c806:	2b02      	cmp	r3, #2
 800c808:	d007      	beq.n	800c81a <lsm6dsv16x_gy_data_rate_get+0xbe>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_15Hz;
 800c80a:	683b      	ldr	r3, [r7, #0]
 800c80c:	2203      	movs	r2, #3
 800c80e:	701a      	strb	r2, [r3, #0]
        break;
 800c810:	e007      	b.n	800c822 <lsm6dsv16x_gy_data_rate_get+0xc6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_15Hz625;
 800c812:	683b      	ldr	r3, [r7, #0]
 800c814:	2213      	movs	r2, #19
 800c816:	701a      	strb	r2, [r3, #0]
        break;
 800c818:	e003      	b.n	800c822 <lsm6dsv16x_gy_data_rate_get+0xc6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_12Hz5;
 800c81a:	683b      	ldr	r3, [r7, #0]
 800c81c:	2223      	movs	r2, #35	@ 0x23
 800c81e:	701a      	strb	r2, [r3, #0]
        break;
 800c820:	bf00      	nop
      }
      break;
 800c822:	e0a5      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_30Hz:
      switch (sel) {
 800c824:	7cfb      	ldrb	r3, [r7, #19]
 800c826:	2b01      	cmp	r3, #1
 800c828:	d005      	beq.n	800c836 <lsm6dsv16x_gy_data_rate_get+0xda>
 800c82a:	2b02      	cmp	r3, #2
 800c82c:	d007      	beq.n	800c83e <lsm6dsv16x_gy_data_rate_get+0xe2>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_30Hz;
 800c82e:	683b      	ldr	r3, [r7, #0]
 800c830:	2204      	movs	r2, #4
 800c832:	701a      	strb	r2, [r3, #0]
        break;
 800c834:	e007      	b.n	800c846 <lsm6dsv16x_gy_data_rate_get+0xea>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_31Hz25;
 800c836:	683b      	ldr	r3, [r7, #0]
 800c838:	2214      	movs	r2, #20
 800c83a:	701a      	strb	r2, [r3, #0]
        break;
 800c83c:	e003      	b.n	800c846 <lsm6dsv16x_gy_data_rate_get+0xea>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_25Hz;
 800c83e:	683b      	ldr	r3, [r7, #0]
 800c840:	2224      	movs	r2, #36	@ 0x24
 800c842:	701a      	strb	r2, [r3, #0]
        break;
 800c844:	bf00      	nop
      }
      break;
 800c846:	e093      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_60Hz:
      switch (sel) {
 800c848:	7cfb      	ldrb	r3, [r7, #19]
 800c84a:	2b01      	cmp	r3, #1
 800c84c:	d005      	beq.n	800c85a <lsm6dsv16x_gy_data_rate_get+0xfe>
 800c84e:	2b02      	cmp	r3, #2
 800c850:	d007      	beq.n	800c862 <lsm6dsv16x_gy_data_rate_get+0x106>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_60Hz;
 800c852:	683b      	ldr	r3, [r7, #0]
 800c854:	2205      	movs	r2, #5
 800c856:	701a      	strb	r2, [r3, #0]
        break;
 800c858:	e007      	b.n	800c86a <lsm6dsv16x_gy_data_rate_get+0x10e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_62Hz5;
 800c85a:	683b      	ldr	r3, [r7, #0]
 800c85c:	2215      	movs	r2, #21
 800c85e:	701a      	strb	r2, [r3, #0]
        break;
 800c860:	e003      	b.n	800c86a <lsm6dsv16x_gy_data_rate_get+0x10e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_50Hz;
 800c862:	683b      	ldr	r3, [r7, #0]
 800c864:	2225      	movs	r2, #37	@ 0x25
 800c866:	701a      	strb	r2, [r3, #0]
        break;
 800c868:	bf00      	nop
      }
      break;
 800c86a:	e081      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_120Hz:
      switch (sel) {
 800c86c:	7cfb      	ldrb	r3, [r7, #19]
 800c86e:	2b01      	cmp	r3, #1
 800c870:	d005      	beq.n	800c87e <lsm6dsv16x_gy_data_rate_get+0x122>
 800c872:	2b02      	cmp	r3, #2
 800c874:	d007      	beq.n	800c886 <lsm6dsv16x_gy_data_rate_get+0x12a>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_120Hz;
 800c876:	683b      	ldr	r3, [r7, #0]
 800c878:	2206      	movs	r2, #6
 800c87a:	701a      	strb	r2, [r3, #0]
        break;
 800c87c:	e007      	b.n	800c88e <lsm6dsv16x_gy_data_rate_get+0x132>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_125Hz;
 800c87e:	683b      	ldr	r3, [r7, #0]
 800c880:	2216      	movs	r2, #22
 800c882:	701a      	strb	r2, [r3, #0]
        break;
 800c884:	e003      	b.n	800c88e <lsm6dsv16x_gy_data_rate_get+0x132>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_100Hz;
 800c886:	683b      	ldr	r3, [r7, #0]
 800c888:	2226      	movs	r2, #38	@ 0x26
 800c88a:	701a      	strb	r2, [r3, #0]
        break;
 800c88c:	bf00      	nop
      }
      break;
 800c88e:	e06f      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_240Hz:
      switch (sel) {
 800c890:	7cfb      	ldrb	r3, [r7, #19]
 800c892:	2b01      	cmp	r3, #1
 800c894:	d005      	beq.n	800c8a2 <lsm6dsv16x_gy_data_rate_get+0x146>
 800c896:	2b02      	cmp	r3, #2
 800c898:	d007      	beq.n	800c8aa <lsm6dsv16x_gy_data_rate_get+0x14e>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_240Hz;
 800c89a:	683b      	ldr	r3, [r7, #0]
 800c89c:	2207      	movs	r2, #7
 800c89e:	701a      	strb	r2, [r3, #0]
        break;
 800c8a0:	e007      	b.n	800c8b2 <lsm6dsv16x_gy_data_rate_get+0x156>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_250Hz;
 800c8a2:	683b      	ldr	r3, [r7, #0]
 800c8a4:	2217      	movs	r2, #23
 800c8a6:	701a      	strb	r2, [r3, #0]
        break;
 800c8a8:	e003      	b.n	800c8b2 <lsm6dsv16x_gy_data_rate_get+0x156>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_200Hz;
 800c8aa:	683b      	ldr	r3, [r7, #0]
 800c8ac:	2227      	movs	r2, #39	@ 0x27
 800c8ae:	701a      	strb	r2, [r3, #0]
        break;
 800c8b0:	bf00      	nop
      }
      break;
 800c8b2:	e05d      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_480Hz:
      switch (sel) {
 800c8b4:	7cfb      	ldrb	r3, [r7, #19]
 800c8b6:	2b01      	cmp	r3, #1
 800c8b8:	d005      	beq.n	800c8c6 <lsm6dsv16x_gy_data_rate_get+0x16a>
 800c8ba:	2b02      	cmp	r3, #2
 800c8bc:	d007      	beq.n	800c8ce <lsm6dsv16x_gy_data_rate_get+0x172>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_480Hz;
 800c8be:	683b      	ldr	r3, [r7, #0]
 800c8c0:	2208      	movs	r2, #8
 800c8c2:	701a      	strb	r2, [r3, #0]
        break;
 800c8c4:	e007      	b.n	800c8d6 <lsm6dsv16x_gy_data_rate_get+0x17a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_500Hz;
 800c8c6:	683b      	ldr	r3, [r7, #0]
 800c8c8:	2218      	movs	r2, #24
 800c8ca:	701a      	strb	r2, [r3, #0]
        break;
 800c8cc:	e003      	b.n	800c8d6 <lsm6dsv16x_gy_data_rate_get+0x17a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_400Hz;
 800c8ce:	683b      	ldr	r3, [r7, #0]
 800c8d0:	2228      	movs	r2, #40	@ 0x28
 800c8d2:	701a      	strb	r2, [r3, #0]
        break;
 800c8d4:	bf00      	nop
      }
      break;
 800c8d6:	e04b      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_960Hz:
      switch (sel) {
 800c8d8:	7cfb      	ldrb	r3, [r7, #19]
 800c8da:	2b01      	cmp	r3, #1
 800c8dc:	d005      	beq.n	800c8ea <lsm6dsv16x_gy_data_rate_get+0x18e>
 800c8de:	2b02      	cmp	r3, #2
 800c8e0:	d007      	beq.n	800c8f2 <lsm6dsv16x_gy_data_rate_get+0x196>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_960Hz;
 800c8e2:	683b      	ldr	r3, [r7, #0]
 800c8e4:	2209      	movs	r2, #9
 800c8e6:	701a      	strb	r2, [r3, #0]
        break;
 800c8e8:	e007      	b.n	800c8fa <lsm6dsv16x_gy_data_rate_get+0x19e>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_1000Hz;
 800c8ea:	683b      	ldr	r3, [r7, #0]
 800c8ec:	2219      	movs	r2, #25
 800c8ee:	701a      	strb	r2, [r3, #0]
        break;
 800c8f0:	e003      	b.n	800c8fa <lsm6dsv16x_gy_data_rate_get+0x19e>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_800Hz;
 800c8f2:	683b      	ldr	r3, [r7, #0]
 800c8f4:	2229      	movs	r2, #41	@ 0x29
 800c8f6:	701a      	strb	r2, [r3, #0]
        break;
 800c8f8:	bf00      	nop
      }
      break;
 800c8fa:	e039      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_1920Hz:
      switch (sel) {
 800c8fc:	7cfb      	ldrb	r3, [r7, #19]
 800c8fe:	2b01      	cmp	r3, #1
 800c900:	d005      	beq.n	800c90e <lsm6dsv16x_gy_data_rate_get+0x1b2>
 800c902:	2b02      	cmp	r3, #2
 800c904:	d007      	beq.n	800c916 <lsm6dsv16x_gy_data_rate_get+0x1ba>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_1920Hz;
 800c906:	683b      	ldr	r3, [r7, #0]
 800c908:	220a      	movs	r2, #10
 800c90a:	701a      	strb	r2, [r3, #0]
        break;
 800c90c:	e007      	b.n	800c91e <lsm6dsv16x_gy_data_rate_get+0x1c2>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_2000Hz;
 800c90e:	683b      	ldr	r3, [r7, #0]
 800c910:	221a      	movs	r2, #26
 800c912:	701a      	strb	r2, [r3, #0]
        break;
 800c914:	e003      	b.n	800c91e <lsm6dsv16x_gy_data_rate_get+0x1c2>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_1600Hz;
 800c916:	683b      	ldr	r3, [r7, #0]
 800c918:	222a      	movs	r2, #42	@ 0x2a
 800c91a:	701a      	strb	r2, [r3, #0]
        break;
 800c91c:	bf00      	nop
      }
      break;
 800c91e:	e027      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_3840Hz:
      switch (sel) {
 800c920:	7cfb      	ldrb	r3, [r7, #19]
 800c922:	2b01      	cmp	r3, #1
 800c924:	d005      	beq.n	800c932 <lsm6dsv16x_gy_data_rate_get+0x1d6>
 800c926:	2b02      	cmp	r3, #2
 800c928:	d007      	beq.n	800c93a <lsm6dsv16x_gy_data_rate_get+0x1de>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_3840Hz;
 800c92a:	683b      	ldr	r3, [r7, #0]
 800c92c:	220b      	movs	r2, #11
 800c92e:	701a      	strb	r2, [r3, #0]
        break;
 800c930:	e007      	b.n	800c942 <lsm6dsv16x_gy_data_rate_get+0x1e6>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_4000Hz;
 800c932:	683b      	ldr	r3, [r7, #0]
 800c934:	221b      	movs	r2, #27
 800c936:	701a      	strb	r2, [r3, #0]
        break;
 800c938:	e003      	b.n	800c942 <lsm6dsv16x_gy_data_rate_get+0x1e6>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_3200Hz;
 800c93a:	683b      	ldr	r3, [r7, #0]
 800c93c:	222b      	movs	r2, #43	@ 0x2b
 800c93e:	701a      	strb	r2, [r3, #0]
        break;
 800c940:	bf00      	nop
      }
      break;
 800c942:	e015      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    case LSM6DSV16X_ODR_AT_7680Hz:
      switch (sel) {
 800c944:	7cfb      	ldrb	r3, [r7, #19]
 800c946:	2b01      	cmp	r3, #1
 800c948:	d005      	beq.n	800c956 <lsm6dsv16x_gy_data_rate_get+0x1fa>
 800c94a:	2b02      	cmp	r3, #2
 800c94c:	d007      	beq.n	800c95e <lsm6dsv16x_gy_data_rate_get+0x202>
      default:
      case 0:
        *val = LSM6DSV16X_ODR_AT_7680Hz;
 800c94e:	683b      	ldr	r3, [r7, #0]
 800c950:	220c      	movs	r2, #12
 800c952:	701a      	strb	r2, [r3, #0]
        break;
 800c954:	e007      	b.n	800c966 <lsm6dsv16x_gy_data_rate_get+0x20a>
      case 1:
        *val = LSM6DSV16X_ODR_HA01_AT_8000Hz;
 800c956:	683b      	ldr	r3, [r7, #0]
 800c958:	221c      	movs	r2, #28
 800c95a:	701a      	strb	r2, [r3, #0]
        break;
 800c95c:	e003      	b.n	800c966 <lsm6dsv16x_gy_data_rate_get+0x20a>
      case 2:
        *val = LSM6DSV16X_ODR_HA02_AT_6400Hz;
 800c95e:	683b      	ldr	r3, [r7, #0]
 800c960:	222c      	movs	r2, #44	@ 0x2c
 800c962:	701a      	strb	r2, [r3, #0]
        break;
 800c964:	bf00      	nop
      }
      break;
 800c966:	e003      	b.n	800c970 <lsm6dsv16x_gy_data_rate_get+0x214>

    default:
      *val = LSM6DSV16X_ODR_OFF;
 800c968:	683b      	ldr	r3, [r7, #0]
 800c96a:	2200      	movs	r2, #0
 800c96c:	701a      	strb	r2, [r3, #0]
      break;
 800c96e:	bf00      	nop
  }

  return ret;
 800c970:	697b      	ldr	r3, [r7, #20]
}
 800c972:	4618      	mov	r0, r3
 800c974:	3718      	adds	r7, #24
 800c976:	46bd      	mov	sp, r7
 800c978:	bd80      	pop	{r7, pc}
 800c97a:	bf00      	nop

0800c97c <lsm6dsv16x_auto_increment_set>:
  * @param  val      Register address automatically incremented during a multiple byte access with a serial interface (enable by default).
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_auto_increment_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800c97c:	b580      	push	{r7, lr}
 800c97e:	b084      	sub	sp, #16
 800c980:	af00      	add	r7, sp, #0
 800c982:	6078      	str	r0, [r7, #4]
 800c984:	460b      	mov	r3, r1
 800c986:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl3_t ctrl3;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800c988:	f107 0208 	add.w	r2, r7, #8
 800c98c:	2301      	movs	r3, #1
 800c98e:	2112      	movs	r1, #18
 800c990:	6878      	ldr	r0, [r7, #4]
 800c992:	f7ff fcf1 	bl	800c378 <lsm6dsv16x_read_reg>
 800c996:	60f8      	str	r0, [r7, #12]
  if (ret == 0)
 800c998:	68fb      	ldr	r3, [r7, #12]
 800c99a:	2b00      	cmp	r3, #0
 800c99c:	d10f      	bne.n	800c9be <lsm6dsv16x_auto_increment_set+0x42>
  {
    ctrl3.if_inc = val;
 800c99e:	78fb      	ldrb	r3, [r7, #3]
 800c9a0:	f003 0301 	and.w	r3, r3, #1
 800c9a4:	b2da      	uxtb	r2, r3
 800c9a6:	7a3b      	ldrb	r3, [r7, #8]
 800c9a8:	f362 0382 	bfi	r3, r2, #2, #1
 800c9ac:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800c9ae:	f107 0208 	add.w	r2, r7, #8
 800c9b2:	2301      	movs	r3, #1
 800c9b4:	2112      	movs	r1, #18
 800c9b6:	6878      	ldr	r0, [r7, #4]
 800c9b8:	f7ff fcf6 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800c9bc:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800c9be:	68fb      	ldr	r3, [r7, #12]
}
 800c9c0:	4618      	mov	r0, r3
 800c9c2:	3710      	adds	r7, #16
 800c9c4:	46bd      	mov	sp, r7
 800c9c6:	bd80      	pop	{r7, pc}

0800c9c8 <lsm6dsv16x_block_data_update_set>:
  * @param  val      Block Data Update (BDU): output registers are not updated until LSB and MSB have been read).
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800c9c8:	b580      	push	{r7, lr}
 800c9ca:	b084      	sub	sp, #16
 800c9cc:	af00      	add	r7, sp, #0
 800c9ce:	6078      	str	r0, [r7, #4]
 800c9d0:	460b      	mov	r3, r1
 800c9d2:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl3_t ctrl3;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800c9d4:	f107 0208 	add.w	r2, r7, #8
 800c9d8:	2301      	movs	r3, #1
 800c9da:	2112      	movs	r1, #18
 800c9dc:	6878      	ldr	r0, [r7, #4]
 800c9de:	f7ff fccb 	bl	800c378 <lsm6dsv16x_read_reg>
 800c9e2:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800c9e4:	68fb      	ldr	r3, [r7, #12]
 800c9e6:	2b00      	cmp	r3, #0
 800c9e8:	d10f      	bne.n	800ca0a <lsm6dsv16x_block_data_update_set+0x42>
  {
    ctrl3.bdu = val;
 800c9ea:	78fb      	ldrb	r3, [r7, #3]
 800c9ec:	f003 0301 	and.w	r3, r3, #1
 800c9f0:	b2da      	uxtb	r2, r3
 800c9f2:	7a3b      	ldrb	r3, [r7, #8]
 800c9f4:	f362 1386 	bfi	r3, r2, #6, #1
 800c9f8:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL3, (uint8_t *)&ctrl3, 1);
 800c9fa:	f107 0208 	add.w	r2, r7, #8
 800c9fe:	2301      	movs	r3, #1
 800ca00:	2112      	movs	r1, #18
 800ca02:	6878      	ldr	r0, [r7, #4]
 800ca04:	f7ff fcd0 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800ca08:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800ca0a:	68fb      	ldr	r3, [r7, #12]
}
 800ca0c:	4618      	mov	r0, r3
 800ca0e:	3710      	adds	r7, #16
 800ca10:	46bd      	mov	sp, r7
 800ca12:	bd80      	pop	{r7, pc}

0800ca14 <lsm6dsv16x_gy_full_scale_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_full_scale_set(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_gy_full_scale_t val)
{
 800ca14:	b580      	push	{r7, lr}
 800ca16:	b084      	sub	sp, #16
 800ca18:	af00      	add	r7, sp, #0
 800ca1a:	6078      	str	r0, [r7, #4]
 800ca1c:	460b      	mov	r3, r1
 800ca1e:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl6_t ctrl6;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL6, (uint8_t *)&ctrl6, 1);
 800ca20:	f107 0208 	add.w	r2, r7, #8
 800ca24:	2301      	movs	r3, #1
 800ca26:	2115      	movs	r1, #21
 800ca28:	6878      	ldr	r0, [r7, #4]
 800ca2a:	f7ff fca5 	bl	800c378 <lsm6dsv16x_read_reg>
 800ca2e:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800ca30:	68fb      	ldr	r3, [r7, #12]
 800ca32:	2b00      	cmp	r3, #0
 800ca34:	d10f      	bne.n	800ca56 <lsm6dsv16x_gy_full_scale_set+0x42>
  {
    ctrl6.fs_g = (uint8_t)val & 0xfu;
 800ca36:	78fb      	ldrb	r3, [r7, #3]
 800ca38:	f003 030f 	and.w	r3, r3, #15
 800ca3c:	b2da      	uxtb	r2, r3
 800ca3e:	7a3b      	ldrb	r3, [r7, #8]
 800ca40:	f362 0303 	bfi	r3, r2, #0, #4
 800ca44:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL6, (uint8_t *)&ctrl6, 1);
 800ca46:	f107 0208 	add.w	r2, r7, #8
 800ca4a:	2301      	movs	r3, #1
 800ca4c:	2115      	movs	r1, #21
 800ca4e:	6878      	ldr	r0, [r7, #4]
 800ca50:	f7ff fcaa 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800ca54:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800ca56:	68fb      	ldr	r3, [r7, #12]
}
 800ca58:	4618      	mov	r0, r3
 800ca5a:	3710      	adds	r7, #16
 800ca5c:	46bd      	mov	sp, r7
 800ca5e:	bd80      	pop	{r7, pc}

0800ca60 <lsm6dsv16x_gy_full_scale_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_gy_full_scale_get(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_gy_full_scale_t *val)
{
 800ca60:	b580      	push	{r7, lr}
 800ca62:	b084      	sub	sp, #16
 800ca64:	af00      	add	r7, sp, #0
 800ca66:	6078      	str	r0, [r7, #4]
 800ca68:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl6_t ctrl6;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL6, (uint8_t *)&ctrl6, 1);
 800ca6a:	f107 0208 	add.w	r2, r7, #8
 800ca6e:	2301      	movs	r3, #1
 800ca70:	2115      	movs	r1, #21
 800ca72:	6878      	ldr	r0, [r7, #4]
 800ca74:	f7ff fc80 	bl	800c378 <lsm6dsv16x_read_reg>
 800ca78:	60f8      	str	r0, [r7, #12]
  if (ret != 0) { return ret; }
 800ca7a:	68fb      	ldr	r3, [r7, #12]
 800ca7c:	2b00      	cmp	r3, #0
 800ca7e:	d001      	beq.n	800ca84 <lsm6dsv16x_gy_full_scale_get+0x24>
 800ca80:	68fb      	ldr	r3, [r7, #12]
 800ca82:	e040      	b.n	800cb06 <lsm6dsv16x_gy_full_scale_get+0xa6>

  switch (ctrl6.fs_g)
 800ca84:	7a3b      	ldrb	r3, [r7, #8]
 800ca86:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800ca8a:	b2db      	uxtb	r3, r3
 800ca8c:	2b0c      	cmp	r3, #12
 800ca8e:	d835      	bhi.n	800cafc <lsm6dsv16x_gy_full_scale_get+0x9c>
 800ca90:	a201      	add	r2, pc, #4	@ (adr r2, 800ca98 <lsm6dsv16x_gy_full_scale_get+0x38>)
 800ca92:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ca96:	bf00      	nop
 800ca98:	0800cacd 	.word	0x0800cacd
 800ca9c:	0800cad5 	.word	0x0800cad5
 800caa0:	0800cadd 	.word	0x0800cadd
 800caa4:	0800cae5 	.word	0x0800cae5
 800caa8:	0800caed 	.word	0x0800caed
 800caac:	0800cafd 	.word	0x0800cafd
 800cab0:	0800cafd 	.word	0x0800cafd
 800cab4:	0800cafd 	.word	0x0800cafd
 800cab8:	0800cafd 	.word	0x0800cafd
 800cabc:	0800cafd 	.word	0x0800cafd
 800cac0:	0800cafd 	.word	0x0800cafd
 800cac4:	0800cafd 	.word	0x0800cafd
 800cac8:	0800caf5 	.word	0x0800caf5
  {
    case LSM6DSV16X_125dps:
      *val = LSM6DSV16X_125dps;
 800cacc:	683b      	ldr	r3, [r7, #0]
 800cace:	2200      	movs	r2, #0
 800cad0:	701a      	strb	r2, [r3, #0]
      break;
 800cad2:	e017      	b.n	800cb04 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_250dps:
      *val = LSM6DSV16X_250dps;
 800cad4:	683b      	ldr	r3, [r7, #0]
 800cad6:	2201      	movs	r2, #1
 800cad8:	701a      	strb	r2, [r3, #0]
      break;
 800cada:	e013      	b.n	800cb04 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_500dps:
      *val = LSM6DSV16X_500dps;
 800cadc:	683b      	ldr	r3, [r7, #0]
 800cade:	2202      	movs	r2, #2
 800cae0:	701a      	strb	r2, [r3, #0]
      break;
 800cae2:	e00f      	b.n	800cb04 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_1000dps:
      *val = LSM6DSV16X_1000dps;
 800cae4:	683b      	ldr	r3, [r7, #0]
 800cae6:	2203      	movs	r2, #3
 800cae8:	701a      	strb	r2, [r3, #0]
      break;
 800caea:	e00b      	b.n	800cb04 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_2000dps:
      *val = LSM6DSV16X_2000dps;
 800caec:	683b      	ldr	r3, [r7, #0]
 800caee:	2204      	movs	r2, #4
 800caf0:	701a      	strb	r2, [r3, #0]
      break;
 800caf2:	e007      	b.n	800cb04 <lsm6dsv16x_gy_full_scale_get+0xa4>

    case LSM6DSV16X_4000dps:
      *val = LSM6DSV16X_4000dps;
 800caf4:	683b      	ldr	r3, [r7, #0]
 800caf6:	220c      	movs	r2, #12
 800caf8:	701a      	strb	r2, [r3, #0]
      break;
 800cafa:	e003      	b.n	800cb04 <lsm6dsv16x_gy_full_scale_get+0xa4>

    default:
      *val = LSM6DSV16X_125dps;
 800cafc:	683b      	ldr	r3, [r7, #0]
 800cafe:	2200      	movs	r2, #0
 800cb00:	701a      	strb	r2, [r3, #0]
      break;
 800cb02:	bf00      	nop
  }

  return ret;
 800cb04:	68fb      	ldr	r3, [r7, #12]
}
 800cb06:	4618      	mov	r0, r3
 800cb08:	3710      	adds	r7, #16
 800cb0a:	46bd      	mov	sp, r7
 800cb0c:	bd80      	pop	{r7, pc}
 800cb0e:	bf00      	nop

0800cb10 <lsm6dsv16x_xl_full_scale_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_full_scale_set(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_xl_full_scale_t val)
{
 800cb10:	b580      	push	{r7, lr}
 800cb12:	b084      	sub	sp, #16
 800cb14:	af00      	add	r7, sp, #0
 800cb16:	6078      	str	r0, [r7, #4]
 800cb18:	460b      	mov	r3, r1
 800cb1a:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_ctrl8_t ctrl8;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL8, (uint8_t *)&ctrl8, 1);
 800cb1c:	f107 0208 	add.w	r2, r7, #8
 800cb20:	2301      	movs	r3, #1
 800cb22:	2117      	movs	r1, #23
 800cb24:	6878      	ldr	r0, [r7, #4]
 800cb26:	f7ff fc27 	bl	800c378 <lsm6dsv16x_read_reg>
 800cb2a:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800cb2c:	68fb      	ldr	r3, [r7, #12]
 800cb2e:	2b00      	cmp	r3, #0
 800cb30:	d10f      	bne.n	800cb52 <lsm6dsv16x_xl_full_scale_set+0x42>
  {
    ctrl8.fs_xl = (uint8_t)val & 0x3U;
 800cb32:	78fb      	ldrb	r3, [r7, #3]
 800cb34:	f003 0303 	and.w	r3, r3, #3
 800cb38:	b2da      	uxtb	r2, r3
 800cb3a:	7a3b      	ldrb	r3, [r7, #8]
 800cb3c:	f362 0301 	bfi	r3, r2, #0, #2
 800cb40:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL8, (uint8_t *)&ctrl8, 1);
 800cb42:	f107 0208 	add.w	r2, r7, #8
 800cb46:	2301      	movs	r3, #1
 800cb48:	2117      	movs	r1, #23
 800cb4a:	6878      	ldr	r0, [r7, #4]
 800cb4c:	f7ff fc2c 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800cb50:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800cb52:	68fb      	ldr	r3, [r7, #12]
}
 800cb54:	4618      	mov	r0, r3
 800cb56:	3710      	adds	r7, #16
 800cb58:	46bd      	mov	sp, r7
 800cb5a:	bd80      	pop	{r7, pc}

0800cb5c <lsm6dsv16x_xl_full_scale_get>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_xl_full_scale_get(stmdev_ctx_t *ctx,
                                     lsm6dsv16x_xl_full_scale_t *val)
{
 800cb5c:	b580      	push	{r7, lr}
 800cb5e:	b084      	sub	sp, #16
 800cb60:	af00      	add	r7, sp, #0
 800cb62:	6078      	str	r0, [r7, #4]
 800cb64:	6039      	str	r1, [r7, #0]
  lsm6dsv16x_ctrl8_t ctrl8;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL8, (uint8_t *)&ctrl8, 1);
 800cb66:	f107 0208 	add.w	r2, r7, #8
 800cb6a:	2301      	movs	r3, #1
 800cb6c:	2117      	movs	r1, #23
 800cb6e:	6878      	ldr	r0, [r7, #4]
 800cb70:	f7ff fc02 	bl	800c378 <lsm6dsv16x_read_reg>
 800cb74:	60f8      	str	r0, [r7, #12]
  if (ret != 0) { return ret; }
 800cb76:	68fb      	ldr	r3, [r7, #12]
 800cb78:	2b00      	cmp	r3, #0
 800cb7a:	d001      	beq.n	800cb80 <lsm6dsv16x_xl_full_scale_get+0x24>
 800cb7c:	68fb      	ldr	r3, [r7, #12]
 800cb7e:	e026      	b.n	800cbce <lsm6dsv16x_xl_full_scale_get+0x72>

  switch (ctrl8.fs_xl)
 800cb80:	7a3b      	ldrb	r3, [r7, #8]
 800cb82:	f3c3 0301 	ubfx	r3, r3, #0, #2
 800cb86:	b2db      	uxtb	r3, r3
 800cb88:	2b03      	cmp	r3, #3
 800cb8a:	d81b      	bhi.n	800cbc4 <lsm6dsv16x_xl_full_scale_get+0x68>
 800cb8c:	a201      	add	r2, pc, #4	@ (adr r2, 800cb94 <lsm6dsv16x_xl_full_scale_get+0x38>)
 800cb8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800cb92:	bf00      	nop
 800cb94:	0800cba5 	.word	0x0800cba5
 800cb98:	0800cbad 	.word	0x0800cbad
 800cb9c:	0800cbb5 	.word	0x0800cbb5
 800cba0:	0800cbbd 	.word	0x0800cbbd
  {
    case LSM6DSV16X_2g:
      *val = LSM6DSV16X_2g;
 800cba4:	683b      	ldr	r3, [r7, #0]
 800cba6:	2200      	movs	r2, #0
 800cba8:	701a      	strb	r2, [r3, #0]
      break;
 800cbaa:	e00f      	b.n	800cbcc <lsm6dsv16x_xl_full_scale_get+0x70>

    case LSM6DSV16X_4g:
      *val = LSM6DSV16X_4g;
 800cbac:	683b      	ldr	r3, [r7, #0]
 800cbae:	2201      	movs	r2, #1
 800cbb0:	701a      	strb	r2, [r3, #0]
      break;
 800cbb2:	e00b      	b.n	800cbcc <lsm6dsv16x_xl_full_scale_get+0x70>

    case LSM6DSV16X_8g:
      *val = LSM6DSV16X_8g;
 800cbb4:	683b      	ldr	r3, [r7, #0]
 800cbb6:	2202      	movs	r2, #2
 800cbb8:	701a      	strb	r2, [r3, #0]
      break;
 800cbba:	e007      	b.n	800cbcc <lsm6dsv16x_xl_full_scale_get+0x70>

    case LSM6DSV16X_16g:
      *val = LSM6DSV16X_16g;
 800cbbc:	683b      	ldr	r3, [r7, #0]
 800cbbe:	2203      	movs	r2, #3
 800cbc0:	701a      	strb	r2, [r3, #0]
      break;
 800cbc2:	e003      	b.n	800cbcc <lsm6dsv16x_xl_full_scale_get+0x70>

    default:
      *val = LSM6DSV16X_2g;
 800cbc4:	683b      	ldr	r3, [r7, #0]
 800cbc6:	2200      	movs	r2, #0
 800cbc8:	701a      	strb	r2, [r3, #0]
      break;
 800cbca:	bf00      	nop
  }

  return ret;
 800cbcc:	68fb      	ldr	r3, [r7, #12]
}
 800cbce:	4618      	mov	r0, r3
 800cbd0:	3710      	adds	r7, #16
 800cbd2:	46bd      	mov	sp, r7
 800cbd4:	bd80      	pop	{r7, pc}
 800cbd6:	bf00      	nop

0800cbd8 <lsm6dsv16x_angular_rate_raw_get>:
  * @param  val      Angular rate sensor.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_angular_rate_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800cbd8:	b580      	push	{r7, lr}
 800cbda:	b086      	sub	sp, #24
 800cbdc:	af00      	add	r7, sp, #0
 800cbde:	6078      	str	r0, [r7, #4]
 800cbe0:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_OUTX_L_G, &buff[0], 6);
 800cbe2:	f107 020c 	add.w	r2, r7, #12
 800cbe6:	2306      	movs	r3, #6
 800cbe8:	2122      	movs	r1, #34	@ 0x22
 800cbea:	6878      	ldr	r0, [r7, #4]
 800cbec:	f7ff fbc4 	bl	800c378 <lsm6dsv16x_read_reg>
 800cbf0:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800cbf2:	697b      	ldr	r3, [r7, #20]
 800cbf4:	2b00      	cmp	r3, #0
 800cbf6:	d001      	beq.n	800cbfc <lsm6dsv16x_angular_rate_raw_get+0x24>
 800cbf8:	697b      	ldr	r3, [r7, #20]
 800cbfa:	e036      	b.n	800cc6a <lsm6dsv16x_angular_rate_raw_get+0x92>

  val[0] = (int16_t)buff[1];
 800cbfc:	7b7b      	ldrb	r3, [r7, #13]
 800cbfe:	b21a      	sxth	r2, r3
 800cc00:	683b      	ldr	r3, [r7, #0]
 800cc02:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 800cc04:	683b      	ldr	r3, [r7, #0]
 800cc06:	f9b3 3000 	ldrsh.w	r3, [r3]
 800cc0a:	b29b      	uxth	r3, r3
 800cc0c:	021b      	lsls	r3, r3, #8
 800cc0e:	b29b      	uxth	r3, r3
 800cc10:	7b3a      	ldrb	r2, [r7, #12]
 800cc12:	4413      	add	r3, r2
 800cc14:	b29b      	uxth	r3, r3
 800cc16:	b21a      	sxth	r2, r3
 800cc18:	683b      	ldr	r3, [r7, #0]
 800cc1a:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800cc1c:	7bfa      	ldrb	r2, [r7, #15]
 800cc1e:	683b      	ldr	r3, [r7, #0]
 800cc20:	3302      	adds	r3, #2
 800cc22:	b212      	sxth	r2, r2
 800cc24:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 800cc26:	683b      	ldr	r3, [r7, #0]
 800cc28:	3302      	adds	r3, #2
 800cc2a:	f9b3 3000 	ldrsh.w	r3, [r3]
 800cc2e:	b29b      	uxth	r3, r3
 800cc30:	021b      	lsls	r3, r3, #8
 800cc32:	b29b      	uxth	r3, r3
 800cc34:	7bba      	ldrb	r2, [r7, #14]
 800cc36:	4413      	add	r3, r2
 800cc38:	b29a      	uxth	r2, r3
 800cc3a:	683b      	ldr	r3, [r7, #0]
 800cc3c:	3302      	adds	r3, #2
 800cc3e:	b212      	sxth	r2, r2
 800cc40:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 800cc42:	7c7a      	ldrb	r2, [r7, #17]
 800cc44:	683b      	ldr	r3, [r7, #0]
 800cc46:	3304      	adds	r3, #4
 800cc48:	b212      	sxth	r2, r2
 800cc4a:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 800cc4c:	683b      	ldr	r3, [r7, #0]
 800cc4e:	3304      	adds	r3, #4
 800cc50:	f9b3 3000 	ldrsh.w	r3, [r3]
 800cc54:	b29b      	uxth	r3, r3
 800cc56:	021b      	lsls	r3, r3, #8
 800cc58:	b29b      	uxth	r3, r3
 800cc5a:	7c3a      	ldrb	r2, [r7, #16]
 800cc5c:	4413      	add	r3, r2
 800cc5e:	b29a      	uxth	r2, r3
 800cc60:	683b      	ldr	r3, [r7, #0]
 800cc62:	3304      	adds	r3, #4
 800cc64:	b212      	sxth	r2, r2
 800cc66:	801a      	strh	r2, [r3, #0]

  return ret;
 800cc68:	697b      	ldr	r3, [r7, #20]
}
 800cc6a:	4618      	mov	r0, r3
 800cc6c:	3718      	adds	r7, #24
 800cc6e:	46bd      	mov	sp, r7
 800cc70:	bd80      	pop	{r7, pc}

0800cc72 <lsm6dsv16x_acceleration_raw_get>:
  * @param  val      Linear acceleration sensor.
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_acceleration_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800cc72:	b580      	push	{r7, lr}
 800cc74:	b086      	sub	sp, #24
 800cc76:	af00      	add	r7, sp, #0
 800cc78:	6078      	str	r0, [r7, #4]
 800cc7a:	6039      	str	r1, [r7, #0]
  uint8_t buff[6];
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_OUTX_L_A, &buff[0], 6);
 800cc7c:	f107 020c 	add.w	r2, r7, #12
 800cc80:	2306      	movs	r3, #6
 800cc82:	2128      	movs	r1, #40	@ 0x28
 800cc84:	6878      	ldr	r0, [r7, #4]
 800cc86:	f7ff fb77 	bl	800c378 <lsm6dsv16x_read_reg>
 800cc8a:	6178      	str	r0, [r7, #20]
  if (ret != 0) { return ret; }
 800cc8c:	697b      	ldr	r3, [r7, #20]
 800cc8e:	2b00      	cmp	r3, #0
 800cc90:	d001      	beq.n	800cc96 <lsm6dsv16x_acceleration_raw_get+0x24>
 800cc92:	697b      	ldr	r3, [r7, #20]
 800cc94:	e036      	b.n	800cd04 <lsm6dsv16x_acceleration_raw_get+0x92>

  val[0] = (int16_t)buff[1];
 800cc96:	7b7b      	ldrb	r3, [r7, #13]
 800cc98:	b21a      	sxth	r2, r3
 800cc9a:	683b      	ldr	r3, [r7, #0]
 800cc9c:	801a      	strh	r2, [r3, #0]
  val[0] = (val[0] * 256) + (int16_t)buff[0];
 800cc9e:	683b      	ldr	r3, [r7, #0]
 800cca0:	f9b3 3000 	ldrsh.w	r3, [r3]
 800cca4:	b29b      	uxth	r3, r3
 800cca6:	021b      	lsls	r3, r3, #8
 800cca8:	b29b      	uxth	r3, r3
 800ccaa:	7b3a      	ldrb	r2, [r7, #12]
 800ccac:	4413      	add	r3, r2
 800ccae:	b29b      	uxth	r3, r3
 800ccb0:	b21a      	sxth	r2, r3
 800ccb2:	683b      	ldr	r3, [r7, #0]
 800ccb4:	801a      	strh	r2, [r3, #0]
  val[1] = (int16_t)buff[3];
 800ccb6:	7bfa      	ldrb	r2, [r7, #15]
 800ccb8:	683b      	ldr	r3, [r7, #0]
 800ccba:	3302      	adds	r3, #2
 800ccbc:	b212      	sxth	r2, r2
 800ccbe:	801a      	strh	r2, [r3, #0]
  val[1] = (val[1] * 256) + (int16_t)buff[2];
 800ccc0:	683b      	ldr	r3, [r7, #0]
 800ccc2:	3302      	adds	r3, #2
 800ccc4:	f9b3 3000 	ldrsh.w	r3, [r3]
 800ccc8:	b29b      	uxth	r3, r3
 800ccca:	021b      	lsls	r3, r3, #8
 800cccc:	b29b      	uxth	r3, r3
 800ccce:	7bba      	ldrb	r2, [r7, #14]
 800ccd0:	4413      	add	r3, r2
 800ccd2:	b29a      	uxth	r2, r3
 800ccd4:	683b      	ldr	r3, [r7, #0]
 800ccd6:	3302      	adds	r3, #2
 800ccd8:	b212      	sxth	r2, r2
 800ccda:	801a      	strh	r2, [r3, #0]
  val[2] = (int16_t)buff[5];
 800ccdc:	7c7a      	ldrb	r2, [r7, #17]
 800ccde:	683b      	ldr	r3, [r7, #0]
 800cce0:	3304      	adds	r3, #4
 800cce2:	b212      	sxth	r2, r2
 800cce4:	801a      	strh	r2, [r3, #0]
  val[2] = (val[2] * 256) + (int16_t)buff[4];
 800cce6:	683b      	ldr	r3, [r7, #0]
 800cce8:	3304      	adds	r3, #4
 800ccea:	f9b3 3000 	ldrsh.w	r3, [r3]
 800ccee:	b29b      	uxth	r3, r3
 800ccf0:	021b      	lsls	r3, r3, #8
 800ccf2:	b29b      	uxth	r3, r3
 800ccf4:	7c3a      	ldrb	r2, [r7, #16]
 800ccf6:	4413      	add	r3, r2
 800ccf8:	b29a      	uxth	r2, r3
 800ccfa:	683b      	ldr	r3, [r7, #0]
 800ccfc:	3304      	adds	r3, #4
 800ccfe:	b212      	sxth	r2, r2
 800cd00:	801a      	strh	r2, [r3, #0]

  return ret;
 800cd02:	697b      	ldr	r3, [r7, #20]
}
 800cd04:	4618      	mov	r0, r3
 800cd06:	3718      	adds	r7, #24
 800cd08:	46bd      	mov	sp, r7
 800cd0a:	bd80      	pop	{r7, pc}

0800cd0c <lsm6dsv16x_fifo_mode_set>:
  * @param  val      BYPASS_MODE, FIFO_MODE, STREAM_WTM_TO_FULL_MODE, STREAM_TO_FIFO_MODE, BYPASS_TO_STREAM_MODE, STREAM_MODE, BYPASS_TO_FIFO_MODE,
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_fifo_mode_set(stmdev_ctx_t *ctx, lsm6dsv16x_fifo_mode_t val)
{
 800cd0c:	b580      	push	{r7, lr}
 800cd0e:	b084      	sub	sp, #16
 800cd10:	af00      	add	r7, sp, #0
 800cd12:	6078      	str	r0, [r7, #4]
 800cd14:	460b      	mov	r3, r1
 800cd16:	70fb      	strb	r3, [r7, #3]
  lsm6dsv16x_fifo_ctrl4_t fifo_ctrl4;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_FIFO_CTRL4, (uint8_t *)&fifo_ctrl4, 1);
 800cd18:	f107 0208 	add.w	r2, r7, #8
 800cd1c:	2301      	movs	r3, #1
 800cd1e:	210a      	movs	r1, #10
 800cd20:	6878      	ldr	r0, [r7, #4]
 800cd22:	f7ff fb29 	bl	800c378 <lsm6dsv16x_read_reg>
 800cd26:	60f8      	str	r0, [r7, #12]
  if (ret == 0)
 800cd28:	68fb      	ldr	r3, [r7, #12]
 800cd2a:	2b00      	cmp	r3, #0
 800cd2c:	d10f      	bne.n	800cd4e <lsm6dsv16x_fifo_mode_set+0x42>
  {
    fifo_ctrl4.fifo_mode = (uint8_t)val & 0x07U;
 800cd2e:	78fb      	ldrb	r3, [r7, #3]
 800cd30:	f003 0307 	and.w	r3, r3, #7
 800cd34:	b2da      	uxtb	r2, r3
 800cd36:	7a3b      	ldrb	r3, [r7, #8]
 800cd38:	f362 0302 	bfi	r3, r2, #0, #3
 800cd3c:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_FIFO_CTRL4, (uint8_t *)&fifo_ctrl4, 1);
 800cd3e:	f107 0208 	add.w	r2, r7, #8
 800cd42:	2301      	movs	r3, #1
 800cd44:	210a      	movs	r1, #10
 800cd46:	6878      	ldr	r0, [r7, #4]
 800cd48:	f7ff fb2e 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800cd4c:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800cd4e:	68fb      	ldr	r3, [r7, #12]
}
 800cd50:	4618      	mov	r0, r3
 800cd52:	3710      	adds	r7, #16
 800cd54:	46bd      	mov	sp, r7
 800cd56:	bd80      	pop	{r7, pc}

0800cd58 <lsm6dsv16x_ah_qvar_mode_set>:
  * @retval          interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t lsm6dsv16x_ah_qvar_mode_set(stmdev_ctx_t *ctx,
                                    lsm6dsv16x_ah_qvar_mode_t val)
{
 800cd58:	b580      	push	{r7, lr}
 800cd5a:	b084      	sub	sp, #16
 800cd5c:	af00      	add	r7, sp, #0
 800cd5e:	6078      	str	r0, [r7, #4]
 800cd60:	7039      	strb	r1, [r7, #0]
  lsm6dsv16x_ctrl7_t ctrl7;
  int32_t ret;

  ret = lsm6dsv16x_read_reg(ctx, LSM6DSV16X_CTRL7, (uint8_t *)&ctrl7, 1);
 800cd62:	f107 0208 	add.w	r2, r7, #8
 800cd66:	2301      	movs	r3, #1
 800cd68:	2116      	movs	r1, #22
 800cd6a:	6878      	ldr	r0, [r7, #4]
 800cd6c:	f7ff fb04 	bl	800c378 <lsm6dsv16x_read_reg>
 800cd70:	60f8      	str	r0, [r7, #12]
  if (ret == 0)
 800cd72:	68fb      	ldr	r3, [r7, #12]
 800cd74:	2b00      	cmp	r3, #0
 800cd76:	d10f      	bne.n	800cd98 <lsm6dsv16x_ah_qvar_mode_set+0x40>
  {
    ctrl7.ah_qvar_en = val.ah_qvar_en;
 800cd78:	783b      	ldrb	r3, [r7, #0]
 800cd7a:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800cd7e:	b2da      	uxtb	r2, r3
 800cd80:	7a3b      	ldrb	r3, [r7, #8]
 800cd82:	f362 13c7 	bfi	r3, r2, #7, #1
 800cd86:	723b      	strb	r3, [r7, #8]
    ret = lsm6dsv16x_write_reg(ctx, LSM6DSV16X_CTRL7, (uint8_t *)&ctrl7, 1);
 800cd88:	f107 0208 	add.w	r2, r7, #8
 800cd8c:	2301      	movs	r3, #1
 800cd8e:	2116      	movs	r1, #22
 800cd90:	6878      	ldr	r0, [r7, #4]
 800cd92:	f7ff fb09 	bl	800c3a8 <lsm6dsv16x_write_reg>
 800cd96:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800cd98:	68fb      	ldr	r3, [r7, #12]
}
 800cd9a:	4618      	mov	r0, r3
 800cd9c:	3710      	adds	r7, #16
 800cd9e:	46bd      	mov	sp, r7
 800cda0:	bd80      	pop	{r7, pc}
	...

0800cda4 <SHT40AD1B_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_RegisterBusIO(SHT40AD1B_Object_t *pObj, SHT40AD1B_IO_t *pIO)
{
 800cda4:	b580      	push	{r7, lr}
 800cda6:	b084      	sub	sp, #16
 800cda8:	af00      	add	r7, sp, #0
 800cdaa:	6078      	str	r0, [r7, #4]
 800cdac:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
 800cdae:	687b      	ldr	r3, [r7, #4]
 800cdb0:	2b00      	cmp	r3, #0
 800cdb2:	d103      	bne.n	800cdbc <SHT40AD1B_RegisterBusIO+0x18>
  {
    ret = SHT40AD1B_ERROR;
 800cdb4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800cdb8:	60fb      	str	r3, [r7, #12]
 800cdba:	e034      	b.n	800ce26 <SHT40AD1B_RegisterBusIO+0x82>
  }
  else
  {
    pObj->IO.Init    = pIO->Init;
 800cdbc:	683b      	ldr	r3, [r7, #0]
 800cdbe:	681a      	ldr	r2, [r3, #0]
 800cdc0:	687b      	ldr	r3, [r7, #4]
 800cdc2:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit  = pIO->DeInit;
 800cdc4:	683b      	ldr	r3, [r7, #0]
 800cdc6:	685a      	ldr	r2, [r3, #4]
 800cdc8:	687b      	ldr	r3, [r7, #4]
 800cdca:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType = pIO->BusType;
 800cdcc:	683b      	ldr	r3, [r7, #0]
 800cdce:	689a      	ldr	r2, [r3, #8]
 800cdd0:	687b      	ldr	r3, [r7, #4]
 800cdd2:	609a      	str	r2, [r3, #8]
    pObj->IO.Address = pIO->Address;
 800cdd4:	683b      	ldr	r3, [r7, #0]
 800cdd6:	7b1a      	ldrb	r2, [r3, #12]
 800cdd8:	687b      	ldr	r3, [r7, #4]
 800cdda:	731a      	strb	r2, [r3, #12]
    pObj->IO.Write   = pIO->Write;
 800cddc:	683b      	ldr	r3, [r7, #0]
 800cdde:	691a      	ldr	r2, [r3, #16]
 800cde0:	687b      	ldr	r3, [r7, #4]
 800cde2:	611a      	str	r2, [r3, #16]
    pObj->IO.Read    = pIO->Read;
 800cde4:	683b      	ldr	r3, [r7, #0]
 800cde6:	695a      	ldr	r2, [r3, #20]
 800cde8:	687b      	ldr	r3, [r7, #4]
 800cdea:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick = pIO->GetTick;
 800cdec:	683b      	ldr	r3, [r7, #0]
 800cdee:	699a      	ldr	r2, [r3, #24]
 800cdf0:	687b      	ldr	r3, [r7, #4]
 800cdf2:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 800cdf4:	687b      	ldr	r3, [r7, #4]
 800cdf6:	4a0e      	ldr	r2, [pc, #56]	@ (800ce30 <SHT40AD1B_RegisterBusIO+0x8c>)
 800cdf8:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800cdfa:	687b      	ldr	r3, [r7, #4]
 800cdfc:	4a0d      	ldr	r2, [pc, #52]	@ (800ce34 <SHT40AD1B_RegisterBusIO+0x90>)
 800cdfe:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 800ce00:	683b      	ldr	r3, [r7, #0]
 800ce02:	69da      	ldr	r2, [r3, #28]
 800ce04:	687b      	ldr	r3, [r7, #4]
 800ce06:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle    = pObj;
 800ce08:	687b      	ldr	r3, [r7, #4]
 800ce0a:	687a      	ldr	r2, [r7, #4]
 800ce0c:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init != NULL)
 800ce0e:	687b      	ldr	r3, [r7, #4]
 800ce10:	681b      	ldr	r3, [r3, #0]
 800ce12:	2b00      	cmp	r3, #0
 800ce14:	d004      	beq.n	800ce20 <SHT40AD1B_RegisterBusIO+0x7c>
    {
      ret = pObj->IO.Init();
 800ce16:	687b      	ldr	r3, [r7, #4]
 800ce18:	681b      	ldr	r3, [r3, #0]
 800ce1a:	4798      	blx	r3
 800ce1c:	60f8      	str	r0, [r7, #12]
 800ce1e:	e002      	b.n	800ce26 <SHT40AD1B_RegisterBusIO+0x82>
    }
    else
    {
      ret = SHT40AD1B_ERROR;
 800ce20:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800ce24:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 800ce26:	68fb      	ldr	r3, [r7, #12]
}
 800ce28:	4618      	mov	r0, r3
 800ce2a:	3710      	adds	r7, #16
 800ce2c:	46bd      	mov	sp, r7
 800ce2e:	bd80      	pop	{r7, pc}
 800ce30:	0800d0b5 	.word	0x0800d0b5
 800ce34:	0800d0f5 	.word	0x0800d0f5

0800ce38 <SHT40AD1B_Init>:
  * @brief  Initialize the SHT40AD1B sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_Init(SHT40AD1B_Object_t *pObj)
{
 800ce38:	b480      	push	{r7}
 800ce3a:	b083      	sub	sp, #12
 800ce3c:	af00      	add	r7, sp, #0
 800ce3e:	6078      	str	r0, [r7, #4]
  /* This device doesn't support ODR, works more like one-shot measurement */
  pObj->hum_odr  = 0.0f;
 800ce40:	687b      	ldr	r3, [r7, #4]
 800ce42:	f04f 0200 	mov.w	r2, #0
 800ce46:	635a      	str	r2, [r3, #52]	@ 0x34
  pObj->temp_odr = 0.0f;
 800ce48:	687b      	ldr	r3, [r7, #4]
 800ce4a:	f04f 0200 	mov.w	r2, #0
 800ce4e:	639a      	str	r2, [r3, #56]	@ 0x38

  pObj->is_initialized = 1;
 800ce50:	687b      	ldr	r3, [r7, #4]
 800ce52:	2201      	movs	r2, #1
 800ce54:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return SHT40AD1B_OK;
 800ce58:	2300      	movs	r3, #0
}
 800ce5a:	4618      	mov	r0, r3
 800ce5c:	370c      	adds	r7, #12
 800ce5e:	46bd      	mov	sp, r7
 800ce60:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce64:	4770      	bx	lr

0800ce66 <SHT40AD1B_DeInit>:
  * @brief  Deinitialize the SHT40AD1B sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_DeInit(SHT40AD1B_Object_t *pObj)
{
 800ce66:	b480      	push	{r7}
 800ce68:	b083      	sub	sp, #12
 800ce6a:	af00      	add	r7, sp, #0
 800ce6c:	6078      	str	r0, [r7, #4]
  pObj->is_initialized = 0;
 800ce6e:	687b      	ldr	r3, [r7, #4]
 800ce70:	2200      	movs	r2, #0
 800ce72:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return SHT40AD1B_OK;
 800ce76:	2300      	movs	r3, #0
}
 800ce78:	4618      	mov	r0, r3
 800ce7a:	370c      	adds	r7, #12
 800ce7c:	46bd      	mov	sp, r7
 800ce7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce82:	4770      	bx	lr

0800ce84 <SHT40AD1B_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_ReadID(SHT40AD1B_Object_t *pObj, uint8_t *Id)
{
 800ce84:	b580      	push	{r7, lr}
 800ce86:	b082      	sub	sp, #8
 800ce88:	af00      	add	r7, sp, #0
 800ce8a:	6078      	str	r0, [r7, #4]
 800ce8c:	6039      	str	r1, [r7, #0]
  return sht40ad1b_device_id_get(&(pObj->Ctx), Id);
 800ce8e:	687b      	ldr	r3, [r7, #4]
 800ce90:	3320      	adds	r3, #32
 800ce92:	6839      	ldr	r1, [r7, #0]
 800ce94:	4618      	mov	r0, r3
 800ce96:	f000 fa23 	bl	800d2e0 <sht40ad1b_device_id_get>
 800ce9a:	4603      	mov	r3, r0
}
 800ce9c:	4618      	mov	r0, r3
 800ce9e:	3708      	adds	r7, #8
 800cea0:	46bd      	mov	sp, r7
 800cea2:	bd80      	pop	{r7, pc}

0800cea4 <SHT40AD1B_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to SHT40AD1B sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_GetCapabilities(SHT40AD1B_Object_t *pObj, SHT40AD1B_Capabilities_t *Capabilities)
{
 800cea4:	b480      	push	{r7}
 800cea6:	b083      	sub	sp, #12
 800cea8:	af00      	add	r7, sp, #0
 800ceaa:	6078      	str	r0, [r7, #4]
 800ceac:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Humidity    = 1;
 800ceae:	683b      	ldr	r3, [r7, #0]
 800ceb0:	2201      	movs	r2, #1
 800ceb2:	709a      	strb	r2, [r3, #2]
  Capabilities->Pressure    = 0;
 800ceb4:	683b      	ldr	r3, [r7, #0]
 800ceb6:	2200      	movs	r2, #0
 800ceb8:	705a      	strb	r2, [r3, #1]
  Capabilities->Temperature = 1;
 800ceba:	683b      	ldr	r3, [r7, #0]
 800cebc:	2201      	movs	r2, #1
 800cebe:	701a      	strb	r2, [r3, #0]
  Capabilities->Gas         = 0;
 800cec0:	683b      	ldr	r3, [r7, #0]
 800cec2:	2200      	movs	r2, #0
 800cec4:	70da      	strb	r2, [r3, #3]
  Capabilities->LowPower    = 0;
 800cec6:	683b      	ldr	r3, [r7, #0]
 800cec8:	2200      	movs	r2, #0
 800ceca:	711a      	strb	r2, [r3, #4]
  Capabilities->HumMaxOdr   = 0.0f;
 800cecc:	683b      	ldr	r3, [r7, #0]
 800cece:	f04f 0200 	mov.w	r2, #0
 800ced2:	609a      	str	r2, [r3, #8]
  Capabilities->TempMaxOdr  = 0.0f;
 800ced4:	683b      	ldr	r3, [r7, #0]
 800ced6:	f04f 0200 	mov.w	r2, #0
 800ceda:	60da      	str	r2, [r3, #12]
  Capabilities->PressMaxOdr = 0.0f;
 800cedc:	683b      	ldr	r3, [r7, #0]
 800cede:	f04f 0200 	mov.w	r2, #0
 800cee2:	611a      	str	r2, [r3, #16]
  Capabilities->GasMaxOdr   = 0.0f;
 800cee4:	683b      	ldr	r3, [r7, #0]
 800cee6:	f04f 0200 	mov.w	r2, #0
 800ceea:	615a      	str	r2, [r3, #20]
  return SHT40AD1B_OK;
 800ceec:	2300      	movs	r3, #0
}
 800ceee:	4618      	mov	r0, r3
 800cef0:	370c      	adds	r7, #12
 800cef2:	46bd      	mov	sp, r7
 800cef4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cef8:	4770      	bx	lr

0800cefa <SHT40AD1B_HUM_Enable>:
  * @brief  Enable the SHT40AD1B humidity sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_HUM_Enable(SHT40AD1B_Object_t *pObj)
{
 800cefa:	b480      	push	{r7}
 800cefc:	b083      	sub	sp, #12
 800cefe:	af00      	add	r7, sp, #0
 800cf00:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->hum_is_enabled == 1U)
 800cf02:	687b      	ldr	r3, [r7, #4]
 800cf04:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800cf08:	2b01      	cmp	r3, #1
 800cf0a:	d101      	bne.n	800cf10 <SHT40AD1B_HUM_Enable+0x16>
  {
    return SHT40AD1B_OK;
 800cf0c:	2300      	movs	r3, #0
 800cf0e:	e004      	b.n	800cf1a <SHT40AD1B_HUM_Enable+0x20>
  }

  pObj->hum_is_enabled = 1;
 800cf10:	687b      	ldr	r3, [r7, #4]
 800cf12:	2201      	movs	r2, #1
 800cf14:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return SHT40AD1B_OK;
 800cf18:	2300      	movs	r3, #0
}
 800cf1a:	4618      	mov	r0, r3
 800cf1c:	370c      	adds	r7, #12
 800cf1e:	46bd      	mov	sp, r7
 800cf20:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf24:	4770      	bx	lr

0800cf26 <SHT40AD1B_HUM_Disable>:
  * @brief  Disable the SHT40AD1B humidity sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_HUM_Disable(SHT40AD1B_Object_t *pObj)
{
 800cf26:	b480      	push	{r7}
 800cf28:	b083      	sub	sp, #12
 800cf2a:	af00      	add	r7, sp, #0
 800cf2c:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->hum_is_enabled == 0U)
 800cf2e:	687b      	ldr	r3, [r7, #4]
 800cf30:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800cf34:	2b00      	cmp	r3, #0
 800cf36:	d101      	bne.n	800cf3c <SHT40AD1B_HUM_Disable+0x16>
  {
    return SHT40AD1B_OK;
 800cf38:	2300      	movs	r3, #0
 800cf3a:	e004      	b.n	800cf46 <SHT40AD1B_HUM_Disable+0x20>
  }

  pObj->hum_is_enabled = 0;
 800cf3c:	687b      	ldr	r3, [r7, #4]
 800cf3e:	2200      	movs	r2, #0
 800cf40:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return SHT40AD1B_OK;
 800cf44:	2300      	movs	r3, #0
}
 800cf46:	4618      	mov	r0, r3
 800cf48:	370c      	adds	r7, #12
 800cf4a:	46bd      	mov	sp, r7
 800cf4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf50:	4770      	bx	lr

0800cf52 <SHT40AD1B_HUM_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_HUM_GetOutputDataRate(SHT40AD1B_Object_t *pObj, float_t *Odr)
{
 800cf52:	b480      	push	{r7}
 800cf54:	b083      	sub	sp, #12
 800cf56:	af00      	add	r7, sp, #0
 800cf58:	6078      	str	r0, [r7, #4]
 800cf5a:	6039      	str	r1, [r7, #0]
  *Odr = pObj->hum_odr;
 800cf5c:	687b      	ldr	r3, [r7, #4]
 800cf5e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800cf60:	683b      	ldr	r3, [r7, #0]
 800cf62:	601a      	str	r2, [r3, #0]

  return SHT40AD1B_OK;
 800cf64:	2300      	movs	r3, #0
}
 800cf66:	4618      	mov	r0, r3
 800cf68:	370c      	adds	r7, #12
 800cf6a:	46bd      	mov	sp, r7
 800cf6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf70:	4770      	bx	lr

0800cf72 <SHT40AD1B_HUM_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_HUM_SetOutputDataRate(SHT40AD1B_Object_t *pObj, float_t Odr)
{
 800cf72:	b480      	push	{r7}
 800cf74:	b083      	sub	sp, #12
 800cf76:	af00      	add	r7, sp, #0
 800cf78:	6078      	str	r0, [r7, #4]
 800cf7a:	ed87 0a00 	vstr	s0, [r7]
  /* This device doesn't support ODR, works more like one-shot measurement */
  return SHT40AD1B_OK;
 800cf7e:	2300      	movs	r3, #0
}
 800cf80:	4618      	mov	r0, r3
 800cf82:	370c      	adds	r7, #12
 800cf84:	46bd      	mov	sp, r7
 800cf86:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf8a:	4770      	bx	lr

0800cf8c <SHT40AD1B_HUM_GetHumidity>:
  * @param  pObj the device pObj
  * @param  Value pointer where the humidity value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_HUM_GetHumidity(SHT40AD1B_Object_t *pObj, float_t *Value)
{
 800cf8c:	b580      	push	{r7, lr}
 800cf8e:	b082      	sub	sp, #8
 800cf90:	af00      	add	r7, sp, #0
 800cf92:	6078      	str	r0, [r7, #4]
 800cf94:	6039      	str	r1, [r7, #0]
  if (GetData(pObj) != SHT40AD1B_OK)
 800cf96:	6878      	ldr	r0, [r7, #4]
 800cf98:	f000 f86f 	bl	800d07a <GetData>
 800cf9c:	4603      	mov	r3, r0
 800cf9e:	2b00      	cmp	r3, #0
 800cfa0:	d002      	beq.n	800cfa8 <SHT40AD1B_HUM_GetHumidity+0x1c>
  {
    return SHT40AD1B_ERROR;
 800cfa2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800cfa6:	e004      	b.n	800cfb2 <SHT40AD1B_HUM_GetHumidity+0x26>
  }

  *Value = pObj->hum_value;
 800cfa8:	687b      	ldr	r3, [r7, #4]
 800cfaa:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800cfac:	683b      	ldr	r3, [r7, #0]
 800cfae:	601a      	str	r2, [r3, #0]

  return SHT40AD1B_OK;
 800cfb0:	2300      	movs	r3, #0
}
 800cfb2:	4618      	mov	r0, r3
 800cfb4:	3708      	adds	r7, #8
 800cfb6:	46bd      	mov	sp, r7
 800cfb8:	bd80      	pop	{r7, pc}

0800cfba <SHT40AD1B_TEMP_Enable>:
  * @brief  Enable the SHT40AD1B temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_TEMP_Enable(SHT40AD1B_Object_t *pObj)
{
 800cfba:	b480      	push	{r7}
 800cfbc:	b083      	sub	sp, #12
 800cfbe:	af00      	add	r7, sp, #0
 800cfc0:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->temp_is_enabled == 1U)
 800cfc2:	687b      	ldr	r3, [r7, #4]
 800cfc4:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800cfc8:	2b01      	cmp	r3, #1
 800cfca:	d101      	bne.n	800cfd0 <SHT40AD1B_TEMP_Enable+0x16>
  {
    return SHT40AD1B_OK;
 800cfcc:	2300      	movs	r3, #0
 800cfce:	e004      	b.n	800cfda <SHT40AD1B_TEMP_Enable+0x20>
  }

  pObj->temp_is_enabled = 1;
 800cfd0:	687b      	ldr	r3, [r7, #4]
 800cfd2:	2201      	movs	r2, #1
 800cfd4:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return SHT40AD1B_OK;
 800cfd8:	2300      	movs	r3, #0
}
 800cfda:	4618      	mov	r0, r3
 800cfdc:	370c      	adds	r7, #12
 800cfde:	46bd      	mov	sp, r7
 800cfe0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfe4:	4770      	bx	lr

0800cfe6 <SHT40AD1B_TEMP_Disable>:
  * @brief  Disable the SHT40AD1B temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_TEMP_Disable(SHT40AD1B_Object_t *pObj)
{
 800cfe6:	b480      	push	{r7}
 800cfe8:	b083      	sub	sp, #12
 800cfea:	af00      	add	r7, sp, #0
 800cfec:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->temp_is_enabled == 0U)
 800cfee:	687b      	ldr	r3, [r7, #4]
 800cff0:	f893 3032 	ldrb.w	r3, [r3, #50]	@ 0x32
 800cff4:	2b00      	cmp	r3, #0
 800cff6:	d101      	bne.n	800cffc <SHT40AD1B_TEMP_Disable+0x16>
  {
    return SHT40AD1B_OK;
 800cff8:	2300      	movs	r3, #0
 800cffa:	e004      	b.n	800d006 <SHT40AD1B_TEMP_Disable+0x20>
  }

  pObj->temp_is_enabled = 0;
 800cffc:	687b      	ldr	r3, [r7, #4]
 800cffe:	2200      	movs	r2, #0
 800d000:	f883 2032 	strb.w	r2, [r3, #50]	@ 0x32

  return SHT40AD1B_OK;
 800d004:	2300      	movs	r3, #0
}
 800d006:	4618      	mov	r0, r3
 800d008:	370c      	adds	r7, #12
 800d00a:	46bd      	mov	sp, r7
 800d00c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d010:	4770      	bx	lr

0800d012 <SHT40AD1B_TEMP_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_TEMP_GetOutputDataRate(SHT40AD1B_Object_t *pObj, float_t *Odr)
{
 800d012:	b480      	push	{r7}
 800d014:	b083      	sub	sp, #12
 800d016:	af00      	add	r7, sp, #0
 800d018:	6078      	str	r0, [r7, #4]
 800d01a:	6039      	str	r1, [r7, #0]
  *Odr = pObj->temp_odr;
 800d01c:	687b      	ldr	r3, [r7, #4]
 800d01e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800d020:	683b      	ldr	r3, [r7, #0]
 800d022:	601a      	str	r2, [r3, #0]

  return SHT40AD1B_OK;
 800d024:	2300      	movs	r3, #0
}
 800d026:	4618      	mov	r0, r3
 800d028:	370c      	adds	r7, #12
 800d02a:	46bd      	mov	sp, r7
 800d02c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d030:	4770      	bx	lr

0800d032 <SHT40AD1B_TEMP_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_TEMP_SetOutputDataRate(SHT40AD1B_Object_t *pObj, float_t Odr)
{
 800d032:	b480      	push	{r7}
 800d034:	b083      	sub	sp, #12
 800d036:	af00      	add	r7, sp, #0
 800d038:	6078      	str	r0, [r7, #4]
 800d03a:	ed87 0a00 	vstr	s0, [r7]
  /* This device doesn't support ODR, works more like one-shot measurement */
  return SHT40AD1B_OK;
 800d03e:	2300      	movs	r3, #0
}
 800d040:	4618      	mov	r0, r3
 800d042:	370c      	adds	r7, #12
 800d044:	46bd      	mov	sp, r7
 800d046:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d04a:	4770      	bx	lr

0800d04c <SHT40AD1B_TEMP_GetTemperature>:
  * @param  pObj the device pObj
  * @param  Value pointer where the temperature value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t SHT40AD1B_TEMP_GetTemperature(SHT40AD1B_Object_t *pObj, float_t *Value)
{
 800d04c:	b580      	push	{r7, lr}
 800d04e:	b082      	sub	sp, #8
 800d050:	af00      	add	r7, sp, #0
 800d052:	6078      	str	r0, [r7, #4]
 800d054:	6039      	str	r1, [r7, #0]
  if (GetData(pObj) != SHT40AD1B_OK)
 800d056:	6878      	ldr	r0, [r7, #4]
 800d058:	f000 f80f 	bl	800d07a <GetData>
 800d05c:	4603      	mov	r3, r0
 800d05e:	2b00      	cmp	r3, #0
 800d060:	d002      	beq.n	800d068 <SHT40AD1B_TEMP_GetTemperature+0x1c>
  {
    return SHT40AD1B_ERROR;
 800d062:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d066:	e004      	b.n	800d072 <SHT40AD1B_TEMP_GetTemperature+0x26>
  }

  *Value = pObj->temp_value;
 800d068:	687b      	ldr	r3, [r7, #4]
 800d06a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800d06c:	683b      	ldr	r3, [r7, #0]
 800d06e:	601a      	str	r2, [r3, #0]

  return SHT40AD1B_OK;
 800d070:	2300      	movs	r3, #0
}
 800d072:	4618      	mov	r0, r3
 800d074:	3708      	adds	r7, #8
 800d076:	46bd      	mov	sp, r7
 800d078:	bd80      	pop	{r7, pc}

0800d07a <GetData>:
  * @param  pObj the device pObj
  * @param  Status the new data status
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t GetData(SHT40AD1B_Object_t *pObj)
{
 800d07a:	b580      	push	{r7, lr}
 800d07c:	b084      	sub	sp, #16
 800d07e:	af00      	add	r7, sp, #0
 800d080:	6078      	str	r0, [r7, #4]
  float_t data[2];  /* humidity, temperature */

  if (sht40ad1b_data_get(&(pObj->Ctx), data) != 0)
 800d082:	687b      	ldr	r3, [r7, #4]
 800d084:	3320      	adds	r3, #32
 800d086:	f107 0208 	add.w	r2, r7, #8
 800d08a:	4611      	mov	r1, r2
 800d08c:	4618      	mov	r0, r3
 800d08e:	f000 f881 	bl	800d194 <sht40ad1b_data_get>
 800d092:	4603      	mov	r3, r0
 800d094:	2b00      	cmp	r3, #0
 800d096:	d002      	beq.n	800d09e <GetData+0x24>
  {
    return SHT40AD1B_ERROR;
 800d098:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d09c:	e006      	b.n	800d0ac <GetData+0x32>
  }

  pObj->hum_value = data[0];
 800d09e:	68ba      	ldr	r2, [r7, #8]
 800d0a0:	687b      	ldr	r3, [r7, #4]
 800d0a2:	63da      	str	r2, [r3, #60]	@ 0x3c
  pObj->temp_value = data[1];
 800d0a4:	68fa      	ldr	r2, [r7, #12]
 800d0a6:	687b      	ldr	r3, [r7, #4]
 800d0a8:	641a      	str	r2, [r3, #64]	@ 0x40

  return SHT40AD1B_OK;
 800d0aa:	2300      	movs	r3, #0
}
 800d0ac:	4618      	mov	r0, r3
 800d0ae:	3710      	adds	r7, #16
 800d0b0:	46bd      	mov	sp, r7
 800d0b2:	bd80      	pop	{r7, pc}

0800d0b4 <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800d0b4:	b580      	push	{r7, lr}
 800d0b6:	b086      	sub	sp, #24
 800d0b8:	af00      	add	r7, sp, #0
 800d0ba:	60f8      	str	r0, [r7, #12]
 800d0bc:	607a      	str	r2, [r7, #4]
 800d0be:	461a      	mov	r2, r3
 800d0c0:	460b      	mov	r3, r1
 800d0c2:	72fb      	strb	r3, [r7, #11]
 800d0c4:	4613      	mov	r3, r2
 800d0c6:	813b      	strh	r3, [r7, #8]
  SHT40AD1B_Object_t *pObj = (SHT40AD1B_Object_t *)Handle;
 800d0c8:	68fb      	ldr	r3, [r7, #12]
 800d0ca:	617b      	str	r3, [r7, #20]
  (void)Reg;

  if (pObj->IO.BusType == (uint32_t)SHT40AD1B_I2C_BUS) /* I2C */
 800d0cc:	697b      	ldr	r3, [r7, #20]
 800d0ce:	689b      	ldr	r3, [r3, #8]
 800d0d0:	2b00      	cmp	r3, #0
 800d0d2:	d109      	bne.n	800d0e8 <ReadRegWrap+0x34>
  {
    return pObj->IO.Read(pObj->IO.Address, pData, Length);
 800d0d4:	697b      	ldr	r3, [r7, #20]
 800d0d6:	695b      	ldr	r3, [r3, #20]
 800d0d8:	697a      	ldr	r2, [r7, #20]
 800d0da:	7b12      	ldrb	r2, [r2, #12]
 800d0dc:	4610      	mov	r0, r2
 800d0de:	893a      	ldrh	r2, [r7, #8]
 800d0e0:	6879      	ldr	r1, [r7, #4]
 800d0e2:	4798      	blx	r3
 800d0e4:	4603      	mov	r3, r0
 800d0e6:	e001      	b.n	800d0ec <ReadRegWrap+0x38>
  }
  else
  {
    return SHT40AD1B_ERROR;
 800d0e8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  }
}
 800d0ec:	4618      	mov	r0, r3
 800d0ee:	3718      	adds	r7, #24
 800d0f0:	46bd      	mov	sp, r7
 800d0f2:	bd80      	pop	{r7, pc}

0800d0f4 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800d0f4:	b580      	push	{r7, lr}
 800d0f6:	b086      	sub	sp, #24
 800d0f8:	af00      	add	r7, sp, #0
 800d0fa:	60f8      	str	r0, [r7, #12]
 800d0fc:	607a      	str	r2, [r7, #4]
 800d0fe:	461a      	mov	r2, r3
 800d100:	460b      	mov	r3, r1
 800d102:	72fb      	strb	r3, [r7, #11]
 800d104:	4613      	mov	r3, r2
 800d106:	813b      	strh	r3, [r7, #8]
  SHT40AD1B_Object_t *pObj = (SHT40AD1B_Object_t *)Handle;
 800d108:	68fb      	ldr	r3, [r7, #12]
 800d10a:	617b      	str	r3, [r7, #20]
  (void)Reg;

  if (pObj->IO.BusType == (uint32_t)SHT40AD1B_I2C_BUS) /* I2C */
 800d10c:	697b      	ldr	r3, [r7, #20]
 800d10e:	689b      	ldr	r3, [r3, #8]
 800d110:	2b00      	cmp	r3, #0
 800d112:	d109      	bne.n	800d128 <WriteRegWrap+0x34>
  {
    return pObj->IO.Write(pObj->IO.Address, pData, Length);
 800d114:	697b      	ldr	r3, [r7, #20]
 800d116:	691b      	ldr	r3, [r3, #16]
 800d118:	697a      	ldr	r2, [r7, #20]
 800d11a:	7b12      	ldrb	r2, [r2, #12]
 800d11c:	4610      	mov	r0, r2
 800d11e:	893a      	ldrh	r2, [r7, #8]
 800d120:	6879      	ldr	r1, [r7, #4]
 800d122:	4798      	blx	r3
 800d124:	4603      	mov	r3, r0
 800d126:	e001      	b.n	800d12c <WriteRegWrap+0x38>
  }
  else
  {
    return SHT40AD1B_ERROR;
 800d128:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  }
}
 800d12c:	4618      	mov	r0, r3
 800d12e:	3718      	adds	r7, #24
 800d130:	46bd      	mov	sp, r7
 800d132:	bd80      	pop	{r7, pc}

0800d134 <sht40ad1b_read_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t __weak sht40ad1b_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                  uint8_t *data, uint16_t len)
{
 800d134:	b590      	push	{r4, r7, lr}
 800d136:	b087      	sub	sp, #28
 800d138:	af00      	add	r7, sp, #0
 800d13a:	60f8      	str	r0, [r7, #12]
 800d13c:	607a      	str	r2, [r7, #4]
 800d13e:	461a      	mov	r2, r3
 800d140:	460b      	mov	r3, r1
 800d142:	72fb      	strb	r3, [r7, #11]
 800d144:	4613      	mov	r3, r2
 800d146:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d148:	68fb      	ldr	r3, [r7, #12]
 800d14a:	685c      	ldr	r4, [r3, #4]
 800d14c:	68fb      	ldr	r3, [r7, #12]
 800d14e:	68d8      	ldr	r0, [r3, #12]
 800d150:	893b      	ldrh	r3, [r7, #8]
 800d152:	7af9      	ldrb	r1, [r7, #11]
 800d154:	687a      	ldr	r2, [r7, #4]
 800d156:	47a0      	blx	r4
 800d158:	6178      	str	r0, [r7, #20]

  return ret;
 800d15a:	697b      	ldr	r3, [r7, #20]
}
 800d15c:	4618      	mov	r0, r3
 800d15e:	371c      	adds	r7, #28
 800d160:	46bd      	mov	sp, r7
 800d162:	bd90      	pop	{r4, r7, pc}

0800d164 <sht40ad1b_write_reg>:
  * @retval       interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t __weak sht40ad1b_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                   uint8_t *data, uint16_t len)
{
 800d164:	b590      	push	{r4, r7, lr}
 800d166:	b087      	sub	sp, #28
 800d168:	af00      	add	r7, sp, #0
 800d16a:	60f8      	str	r0, [r7, #12]
 800d16c:	607a      	str	r2, [r7, #4]
 800d16e:	461a      	mov	r2, r3
 800d170:	460b      	mov	r3, r1
 800d172:	72fb      	strb	r3, [r7, #11]
 800d174:	4613      	mov	r3, r2
 800d176:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d178:	68fb      	ldr	r3, [r7, #12]
 800d17a:	681c      	ldr	r4, [r3, #0]
 800d17c:	68fb      	ldr	r3, [r7, #12]
 800d17e:	68d8      	ldr	r0, [r3, #12]
 800d180:	893b      	ldrh	r3, [r7, #8]
 800d182:	7af9      	ldrb	r1, [r7, #11]
 800d184:	687a      	ldr	r2, [r7, #4]
 800d186:	47a0      	blx	r4
 800d188:	6178      	str	r0, [r7, #20]

  return ret;
 800d18a:	697b      	ldr	r3, [r7, #20]
}
 800d18c:	4618      	mov	r0, r3
 800d18e:	371c      	adds	r7, #28
 800d190:	46bd      	mov	sp, r7
 800d192:	bd90      	pop	{r4, r7, pc}

0800d194 <sht40ad1b_data_get>:
  * @param  buffer  buffer to store humidity and temperature values pair
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t sht40ad1b_data_get(stmdev_ctx_t *ctx, float_t *buffer)
{
 800d194:	b580      	push	{r7, lr}
 800d196:	b088      	sub	sp, #32
 800d198:	af00      	add	r7, sp, #0
 800d19a:	6078      	str	r0, [r7, #4]
 800d19c:	6039      	str	r1, [r7, #0]
  uint8_t command = 0xFD;
 800d19e:	23fd      	movs	r3, #253	@ 0xfd
 800d1a0:	73fb      	strb	r3, [r7, #15]
  uint8_t data[6] = {0};
 800d1a2:	2300      	movs	r3, #0
 800d1a4:	60bb      	str	r3, [r7, #8]
 800d1a6:	2300      	movs	r3, #0
 800d1a8:	81bb      	strh	r3, [r7, #12]

  if (sht40ad1b_write_reg(ctx, 0, &command, 1) != 0)
 800d1aa:	f107 020f 	add.w	r2, r7, #15
 800d1ae:	2301      	movs	r3, #1
 800d1b0:	2100      	movs	r1, #0
 800d1b2:	6878      	ldr	r0, [r7, #4]
 800d1b4:	f7ff ffd6 	bl	800d164 <sht40ad1b_write_reg>
 800d1b8:	4603      	mov	r3, r0
 800d1ba:	2b00      	cmp	r3, #0
 800d1bc:	d001      	beq.n	800d1c2 <sht40ad1b_data_get+0x2e>
  {
    return 1;
 800d1be:	2301      	movs	r3, #1
 800d1c0:	e07d      	b.n	800d2be <sht40ad1b_data_get+0x12a>
  }

  /* Wait 10 ms */
  ctx->mdelay(10);
 800d1c2:	687b      	ldr	r3, [r7, #4]
 800d1c4:	689b      	ldr	r3, [r3, #8]
 800d1c6:	200a      	movs	r0, #10
 800d1c8:	4798      	blx	r3

  if (sht40ad1b_read_reg(ctx, 0, data, 6) != 0)
 800d1ca:	f107 0208 	add.w	r2, r7, #8
 800d1ce:	2306      	movs	r3, #6
 800d1d0:	2100      	movs	r1, #0
 800d1d2:	6878      	ldr	r0, [r7, #4]
 800d1d4:	f7ff ffae 	bl	800d134 <sht40ad1b_read_reg>
 800d1d8:	4603      	mov	r3, r0
 800d1da:	2b00      	cmp	r3, #0
 800d1dc:	d001      	beq.n	800d1e2 <sht40ad1b_data_get+0x4e>
  {
    return 1;
 800d1de:	2301      	movs	r3, #1
 800d1e0:	e06d      	b.n	800d2be <sht40ad1b_data_get+0x12a>
  }

  uint16_t temp_value_raw = (data[0] * 0x100U) + data[1];
 800d1e2:	7a3b      	ldrb	r3, [r7, #8]
 800d1e4:	021b      	lsls	r3, r3, #8
 800d1e6:	b29b      	uxth	r3, r3
 800d1e8:	7a7a      	ldrb	r2, [r7, #9]
 800d1ea:	4413      	add	r3, r2
 800d1ec:	83fb      	strh	r3, [r7, #30]
  uint8_t temp_value_crc  = data[2];
 800d1ee:	7abb      	ldrb	r3, [r7, #10]
 800d1f0:	777b      	strb	r3, [r7, #29]
  uint16_t hum_value_raw  = (data[3] * 0x100U) + data[4];
 800d1f2:	7afb      	ldrb	r3, [r7, #11]
 800d1f4:	021b      	lsls	r3, r3, #8
 800d1f6:	b29b      	uxth	r3, r3
 800d1f8:	7b3a      	ldrb	r2, [r7, #12]
 800d1fa:	4413      	add	r3, r2
 800d1fc:	837b      	strh	r3, [r7, #26]
  uint8_t hum_value_crc   = data[5];
 800d1fe:	7b7b      	ldrb	r3, [r7, #13]
 800d200:	767b      	strb	r3, [r7, #25]

  /* Check CRC for temperature value */
  if (crc_check(&data[0], 2, temp_value_crc) != 0U)
 800d202:	7f7a      	ldrb	r2, [r7, #29]
 800d204:	f107 0308 	add.w	r3, r7, #8
 800d208:	2102      	movs	r1, #2
 800d20a:	4618      	mov	r0, r3
 800d20c:	f000 f8b3 	bl	800d376 <crc_check>
 800d210:	4603      	mov	r3, r0
 800d212:	2b00      	cmp	r3, #0
 800d214:	d001      	beq.n	800d21a <sht40ad1b_data_get+0x86>
  {
    return 1;
 800d216:	2301      	movs	r3, #1
 800d218:	e051      	b.n	800d2be <sht40ad1b_data_get+0x12a>
  }

  /* Check CRC for humidity value */
  if (crc_check(&data[3], 2, hum_value_crc) != 0U)
 800d21a:	7e7a      	ldrb	r2, [r7, #25]
 800d21c:	f107 0308 	add.w	r3, r7, #8
 800d220:	3303      	adds	r3, #3
 800d222:	2102      	movs	r1, #2
 800d224:	4618      	mov	r0, r3
 800d226:	f000 f8a6 	bl	800d376 <crc_check>
 800d22a:	4603      	mov	r3, r0
 800d22c:	2b00      	cmp	r3, #0
 800d22e:	d001      	beq.n	800d234 <sht40ad1b_data_get+0xa0>
  {
    return 1;
 800d230:	2301      	movs	r3, #1
 800d232:	e044      	b.n	800d2be <sht40ad1b_data_get+0x12a>
  }

  float_t temp_value = -45.0f + (175.0f * (float_t)temp_value_raw / (float_t)0xFFFF);
 800d234:	8bfb      	ldrh	r3, [r7, #30]
 800d236:	ee07 3a90 	vmov	s15, r3
 800d23a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800d23e:	ed9f 7a22 	vldr	s14, [pc, #136]	@ 800d2c8 <sht40ad1b_data_get+0x134>
 800d242:	ee27 7a87 	vmul.f32	s14, s15, s14
 800d246:	eddf 6a21 	vldr	s13, [pc, #132]	@ 800d2cc <sht40ad1b_data_get+0x138>
 800d24a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800d24e:	ed9f 7a20 	vldr	s14, [pc, #128]	@ 800d2d0 <sht40ad1b_data_get+0x13c>
 800d252:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800d256:	edc7 7a05 	vstr	s15, [r7, #20]
  float_t hum_value  =  -6.0f + (125.0f * (float_t)hum_value_raw  / (float_t)0xFFFF);
 800d25a:	8b7b      	ldrh	r3, [r7, #26]
 800d25c:	ee07 3a90 	vmov	s15, r3
 800d260:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800d264:	ed9f 7a1b 	vldr	s14, [pc, #108]	@ 800d2d4 <sht40ad1b_data_get+0x140>
 800d268:	ee27 7a87 	vmul.f32	s14, s15, s14
 800d26c:	eddf 6a17 	vldr	s13, [pc, #92]	@ 800d2cc <sht40ad1b_data_get+0x138>
 800d270:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800d274:	eeb1 7a08 	vmov.f32	s14, #24	@ 0x40c00000  6.0
 800d278:	ee77 7ac7 	vsub.f32	s15, s15, s14
 800d27c:	edc7 7a04 	vstr	s15, [r7, #16]

  hum_value = (hum_value > 100.0f) ? 100.0f
              : (hum_value <   0.0f) ?   0.0f
 800d280:	edd7 7a04 	vldr	s15, [r7, #16]
 800d284:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 800d2d8 <sht40ad1b_data_get+0x144>
 800d288:	eef4 7ac7 	vcmpe.f32	s15, s14
 800d28c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d290:	dd01      	ble.n	800d296 <sht40ad1b_data_get+0x102>
 800d292:	4b12      	ldr	r3, [pc, #72]	@ (800d2dc <sht40ad1b_data_get+0x148>)
 800d294:	e00a      	b.n	800d2ac <sht40ad1b_data_get+0x118>
              :                        hum_value;
 800d296:	edd7 7a04 	vldr	s15, [r7, #16]
 800d29a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 800d29e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d2a2:	d502      	bpl.n	800d2aa <sht40ad1b_data_get+0x116>
 800d2a4:	f04f 0300 	mov.w	r3, #0
 800d2a8:	e000      	b.n	800d2ac <sht40ad1b_data_get+0x118>
 800d2aa:	693b      	ldr	r3, [r7, #16]
  hum_value = (hum_value > 100.0f) ? 100.0f
 800d2ac:	613b      	str	r3, [r7, #16]

  buffer[0] = hum_value;
 800d2ae:	683b      	ldr	r3, [r7, #0]
 800d2b0:	693a      	ldr	r2, [r7, #16]
 800d2b2:	601a      	str	r2, [r3, #0]
  buffer[1] = temp_value;
 800d2b4:	683b      	ldr	r3, [r7, #0]
 800d2b6:	3304      	adds	r3, #4
 800d2b8:	697a      	ldr	r2, [r7, #20]
 800d2ba:	601a      	str	r2, [r3, #0]
  return 0;
 800d2bc:	2300      	movs	r3, #0
}
 800d2be:	4618      	mov	r0, r3
 800d2c0:	3720      	adds	r7, #32
 800d2c2:	46bd      	mov	sp, r7
 800d2c4:	bd80      	pop	{r7, pc}
 800d2c6:	bf00      	nop
 800d2c8:	432f0000 	.word	0x432f0000
 800d2cc:	477fff00 	.word	0x477fff00
 800d2d0:	42340000 	.word	0x42340000
 800d2d4:	42fa0000 	.word	0x42fa0000
 800d2d8:	42c80000 	.word	0x42c80000
 800d2dc:	42c80000 	.word	0x42c80000

0800d2e0 <sht40ad1b_device_id_get>:
  * @param  buff    buffer that stores data read
  * @retval         interface status (MANDATORY: return 0 -> no Error)
  *
  */
int32_t sht40ad1b_device_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
 800d2e0:	b480      	push	{r7}
 800d2e2:	b083      	sub	sp, #12
 800d2e4:	af00      	add	r7, sp, #0
 800d2e6:	6078      	str	r0, [r7, #4]
 800d2e8:	6039      	str	r1, [r7, #0]
  (void)ctx;
  *buff = SHT40AD1B_ID;
 800d2ea:	683b      	ldr	r3, [r7, #0]
 800d2ec:	2200      	movs	r2, #0
 800d2ee:	701a      	strb	r2, [r3, #0]
  return 0;
 800d2f0:	2300      	movs	r3, #0
}
 800d2f2:	4618      	mov	r0, r3
 800d2f4:	370c      	adds	r7, #12
 800d2f6:	46bd      	mov	sp, r7
 800d2f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2fc:	4770      	bx	lr

0800d2fe <crc_calculate>:
  * @param  count  number of data bytes
  * @retval        CRC check sum of data stream
  *
  */
static uint8_t crc_calculate(const uint8_t *data, uint16_t count)
{
 800d2fe:	b480      	push	{r7}
 800d300:	b085      	sub	sp, #20
 800d302:	af00      	add	r7, sp, #0
 800d304:	6078      	str	r0, [r7, #4]
 800d306:	460b      	mov	r3, r1
 800d308:	807b      	strh	r3, [r7, #2]
  const uint8_t crc8_polynomial = 0x31;
 800d30a:	2331      	movs	r3, #49	@ 0x31
 800d30c:	72bb      	strb	r3, [r7, #10]
  uint8_t crc = 0xFF;
 800d30e:	23ff      	movs	r3, #255	@ 0xff
 800d310:	73fb      	strb	r3, [r7, #15]

  /* Calculate 8-bit checksum for given polynomial */
  for (uint16_t index = 0; index < count; index++)
 800d312:	2300      	movs	r3, #0
 800d314:	81bb      	strh	r3, [r7, #12]
 800d316:	e023      	b.n	800d360 <crc_calculate+0x62>
  {
    crc ^= data[index];
 800d318:	89bb      	ldrh	r3, [r7, #12]
 800d31a:	687a      	ldr	r2, [r7, #4]
 800d31c:	4413      	add	r3, r2
 800d31e:	781a      	ldrb	r2, [r3, #0]
 800d320:	7bfb      	ldrb	r3, [r7, #15]
 800d322:	4053      	eors	r3, r2
 800d324:	73fb      	strb	r3, [r7, #15]
    for (uint8_t crc_bit = 8U; crc_bit > 0U; crc_bit--)
 800d326:	2308      	movs	r3, #8
 800d328:	72fb      	strb	r3, [r7, #11]
 800d32a:	e013      	b.n	800d354 <crc_calculate+0x56>
    {
      crc = ((crc & 0x80U) != 0U) ? ((crc << 1) ^ crc8_polynomial) : (crc << 1);
 800d32c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800d330:	2b00      	cmp	r3, #0
 800d332:	da08      	bge.n	800d346 <crc_calculate+0x48>
 800d334:	7bfb      	ldrb	r3, [r7, #15]
 800d336:	005b      	lsls	r3, r3, #1
 800d338:	b25a      	sxtb	r2, r3
 800d33a:	f997 300a 	ldrsb.w	r3, [r7, #10]
 800d33e:	4053      	eors	r3, r2
 800d340:	b25b      	sxtb	r3, r3
 800d342:	b2db      	uxtb	r3, r3
 800d344:	e002      	b.n	800d34c <crc_calculate+0x4e>
 800d346:	7bfb      	ldrb	r3, [r7, #15]
 800d348:	005b      	lsls	r3, r3, #1
 800d34a:	b2db      	uxtb	r3, r3
 800d34c:	73fb      	strb	r3, [r7, #15]
    for (uint8_t crc_bit = 8U; crc_bit > 0U; crc_bit--)
 800d34e:	7afb      	ldrb	r3, [r7, #11]
 800d350:	3b01      	subs	r3, #1
 800d352:	72fb      	strb	r3, [r7, #11]
 800d354:	7afb      	ldrb	r3, [r7, #11]
 800d356:	2b00      	cmp	r3, #0
 800d358:	d1e8      	bne.n	800d32c <crc_calculate+0x2e>
  for (uint16_t index = 0; index < count; index++)
 800d35a:	89bb      	ldrh	r3, [r7, #12]
 800d35c:	3301      	adds	r3, #1
 800d35e:	81bb      	strh	r3, [r7, #12]
 800d360:	89ba      	ldrh	r2, [r7, #12]
 800d362:	887b      	ldrh	r3, [r7, #2]
 800d364:	429a      	cmp	r2, r3
 800d366:	d3d7      	bcc.n	800d318 <crc_calculate+0x1a>
    }
  }

  return crc;
 800d368:	7bfb      	ldrb	r3, [r7, #15]
}
 800d36a:	4618      	mov	r0, r3
 800d36c:	3714      	adds	r7, #20
 800d36e:	46bd      	mov	sp, r7
 800d370:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d374:	4770      	bx	lr

0800d376 <crc_check>:
  * @param  crc    CRC check sum of data stream
  * @retval        0 if CRC is OK else 1
  *
  */
static uint8_t crc_check(const uint8_t *data, uint16_t count, uint8_t crc)
{
 800d376:	b580      	push	{r7, lr}
 800d378:	b082      	sub	sp, #8
 800d37a:	af00      	add	r7, sp, #0
 800d37c:	6078      	str	r0, [r7, #4]
 800d37e:	460b      	mov	r3, r1
 800d380:	807b      	strh	r3, [r7, #2]
 800d382:	4613      	mov	r3, r2
 800d384:	707b      	strb	r3, [r7, #1]
  return (crc_calculate(data, count) == crc) ? 0U : 1U;
 800d386:	887b      	ldrh	r3, [r7, #2]
 800d388:	4619      	mov	r1, r3
 800d38a:	6878      	ldr	r0, [r7, #4]
 800d38c:	f7ff ffb7 	bl	800d2fe <crc_calculate>
 800d390:	4603      	mov	r3, r0
 800d392:	461a      	mov	r2, r3
 800d394:	787b      	ldrb	r3, [r7, #1]
 800d396:	4293      	cmp	r3, r2
 800d398:	bf14      	ite	ne
 800d39a:	2301      	movne	r3, #1
 800d39c:	2300      	moveq	r3, #0
 800d39e:	b2db      	uxtb	r3, r3
}
 800d3a0:	4618      	mov	r0, r3
 800d3a2:	3708      	adds	r7, #8
 800d3a4:	46bd      	mov	sp, r7
 800d3a6:	bd80      	pop	{r7, pc}

0800d3a8 <STTS22H_RegisterBusIO>:
  * @brief  Register Component Bus IO operations
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_RegisterBusIO(STTS22H_Object_t *pObj, STTS22H_IO_t *pIO)
{
 800d3a8:	b580      	push	{r7, lr}
 800d3aa:	b084      	sub	sp, #16
 800d3ac:	af00      	add	r7, sp, #0
 800d3ae:	6078      	str	r0, [r7, #4]
 800d3b0:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
 800d3b2:	687b      	ldr	r3, [r7, #4]
 800d3b4:	2b00      	cmp	r3, #0
 800d3b6:	d103      	bne.n	800d3c0 <STTS22H_RegisterBusIO+0x18>
  {
    ret = STTS22H_ERROR;
 800d3b8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d3bc:	60fb      	str	r3, [r7, #12]
 800d3be:	e034      	b.n	800d42a <STTS22H_RegisterBusIO+0x82>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
 800d3c0:	683b      	ldr	r3, [r7, #0]
 800d3c2:	681a      	ldr	r2, [r3, #0]
 800d3c4:	687b      	ldr	r3, [r7, #4]
 800d3c6:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
 800d3c8:	683b      	ldr	r3, [r7, #0]
 800d3ca:	685a      	ldr	r2, [r3, #4]
 800d3cc:	687b      	ldr	r3, [r7, #4]
 800d3ce:	605a      	str	r2, [r3, #4]
    pObj->IO.BusType   = pIO->BusType;
 800d3d0:	683b      	ldr	r3, [r7, #0]
 800d3d2:	689a      	ldr	r2, [r3, #8]
 800d3d4:	687b      	ldr	r3, [r7, #4]
 800d3d6:	609a      	str	r2, [r3, #8]
    pObj->IO.Address   = pIO->Address;
 800d3d8:	683b      	ldr	r3, [r7, #0]
 800d3da:	7b1a      	ldrb	r2, [r3, #12]
 800d3dc:	687b      	ldr	r3, [r7, #4]
 800d3de:	731a      	strb	r2, [r3, #12]
    pObj->IO.WriteReg  = pIO->WriteReg;
 800d3e0:	683b      	ldr	r3, [r7, #0]
 800d3e2:	691a      	ldr	r2, [r3, #16]
 800d3e4:	687b      	ldr	r3, [r7, #4]
 800d3e6:	611a      	str	r2, [r3, #16]
    pObj->IO.ReadReg   = pIO->ReadReg;
 800d3e8:	683b      	ldr	r3, [r7, #0]
 800d3ea:	695a      	ldr	r2, [r3, #20]
 800d3ec:	687b      	ldr	r3, [r7, #4]
 800d3ee:	615a      	str	r2, [r3, #20]
    pObj->IO.GetTick   = pIO->GetTick;
 800d3f0:	683b      	ldr	r3, [r7, #0]
 800d3f2:	699a      	ldr	r2, [r3, #24]
 800d3f4:	687b      	ldr	r3, [r7, #4]
 800d3f6:	619a      	str	r2, [r3, #24]

    pObj->Ctx.read_reg  = ReadRegWrap;
 800d3f8:	687b      	ldr	r3, [r7, #4]
 800d3fa:	4a0e      	ldr	r2, [pc, #56]	@ (800d434 <STTS22H_RegisterBusIO+0x8c>)
 800d3fc:	625a      	str	r2, [r3, #36]	@ 0x24
    pObj->Ctx.write_reg = WriteRegWrap;
 800d3fe:	687b      	ldr	r3, [r7, #4]
 800d400:	4a0d      	ldr	r2, [pc, #52]	@ (800d438 <STTS22H_RegisterBusIO+0x90>)
 800d402:	621a      	str	r2, [r3, #32]
    pObj->Ctx.mdelay    = pIO->Delay;
 800d404:	683b      	ldr	r3, [r7, #0]
 800d406:	69da      	ldr	r2, [r3, #28]
 800d408:	687b      	ldr	r3, [r7, #4]
 800d40a:	629a      	str	r2, [r3, #40]	@ 0x28
    pObj->Ctx.handle   = pObj;
 800d40c:	687b      	ldr	r3, [r7, #4]
 800d40e:	687a      	ldr	r2, [r7, #4]
 800d410:	62da      	str	r2, [r3, #44]	@ 0x2c

    if (pObj->IO.Init != NULL)
 800d412:	687b      	ldr	r3, [r7, #4]
 800d414:	681b      	ldr	r3, [r3, #0]
 800d416:	2b00      	cmp	r3, #0
 800d418:	d004      	beq.n	800d424 <STTS22H_RegisterBusIO+0x7c>
    {
      ret = pObj->IO.Init();
 800d41a:	687b      	ldr	r3, [r7, #4]
 800d41c:	681b      	ldr	r3, [r3, #0]
 800d41e:	4798      	blx	r3
 800d420:	60f8      	str	r0, [r7, #12]
 800d422:	e002      	b.n	800d42a <STTS22H_RegisterBusIO+0x82>
    }
    else
    {
      ret = STTS22H_ERROR;
 800d424:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d428:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 800d42a:	68fb      	ldr	r3, [r7, #12]
}
 800d42c:	4618      	mov	r0, r3
 800d42e:	3710      	adds	r7, #16
 800d430:	46bd      	mov	sp, r7
 800d432:	bd80      	pop	{r7, pc}
 800d434:	0800d845 	.word	0x0800d845
 800d438:	0800d8b3 	.word	0x0800d8b3

0800d43c <STTS22H_Init>:
  * @brief  Initialize the STTS22H sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_Init(STTS22H_Object_t *pObj)
{
 800d43c:	b580      	push	{r7, lr}
 800d43e:	b082      	sub	sp, #8
 800d440:	af00      	add	r7, sp, #0
 800d442:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 0U)
 800d444:	687b      	ldr	r3, [r7, #4]
 800d446:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800d44a:	2b00      	cmp	r3, #0
 800d44c:	d127      	bne.n	800d49e <STTS22H_Init+0x62>
  {
    /* Set default ODR */
    pObj->temp_odr = 1.0f;
 800d44e:	687b      	ldr	r3, [r7, #4]
 800d450:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 800d454:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Enable BDU */
    if (stts22h_block_data_update_set(&(pObj->Ctx), PROPERTY_ENABLE) != STTS22H_OK)
 800d456:	687b      	ldr	r3, [r7, #4]
 800d458:	3320      	adds	r3, #32
 800d45a:	2101      	movs	r1, #1
 800d45c:	4618      	mov	r0, r3
 800d45e:	f000 fc25 	bl	800dcac <stts22h_block_data_update_set>
 800d462:	4603      	mov	r3, r0
 800d464:	2b00      	cmp	r3, #0
 800d466:	d002      	beq.n	800d46e <STTS22H_Init+0x32>
    {
      return STTS22H_ERROR;
 800d468:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d46c:	e01c      	b.n	800d4a8 <STTS22H_Init+0x6c>
    }

    /* Enable Automatic Address Increment */
    if (stts22h_auto_increment_set(&(pObj->Ctx), PROPERTY_ENABLE) != STTS22H_OK)
 800d46e:	687b      	ldr	r3, [r7, #4]
 800d470:	3320      	adds	r3, #32
 800d472:	2101      	movs	r1, #1
 800d474:	4618      	mov	r0, r3
 800d476:	f000 fc72 	bl	800dd5e <stts22h_auto_increment_set>
 800d47a:	4603      	mov	r3, r0
 800d47c:	2b00      	cmp	r3, #0
 800d47e:	d002      	beq.n	800d486 <STTS22H_Init+0x4a>
    {
      return STTS22H_ERROR;
 800d480:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d484:	e010      	b.n	800d4a8 <STTS22H_Init+0x6c>
    }

    /* Put the component in standby mode. */
    if (stts22h_temp_data_rate_set(&(pObj->Ctx), STTS22H_POWER_DOWN) != STTS22H_OK)
 800d486:	687b      	ldr	r3, [r7, #4]
 800d488:	3320      	adds	r3, #32
 800d48a:	2100      	movs	r1, #0
 800d48c:	4618      	mov	r0, r3
 800d48e:	f000 fa91 	bl	800d9b4 <stts22h_temp_data_rate_set>
 800d492:	4603      	mov	r3, r0
 800d494:	2b00      	cmp	r3, #0
 800d496:	d002      	beq.n	800d49e <STTS22H_Init+0x62>
    {
      return STTS22H_ERROR;
 800d498:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d49c:	e004      	b.n	800d4a8 <STTS22H_Init+0x6c>
    }
  }

  pObj->is_initialized = 1;
 800d49e:	687b      	ldr	r3, [r7, #4]
 800d4a0:	2201      	movs	r2, #1
 800d4a2:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return STTS22H_OK;
 800d4a6:	2300      	movs	r3, #0
}
 800d4a8:	4618      	mov	r0, r3
 800d4aa:	3708      	adds	r7, #8
 800d4ac:	46bd      	mov	sp, r7
 800d4ae:	bd80      	pop	{r7, pc}

0800d4b0 <STTS22H_DeInit>:
  * @brief  Deinitialize the STTS22H sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_DeInit(STTS22H_Object_t *pObj)
{
 800d4b0:	b580      	push	{r7, lr}
 800d4b2:	b082      	sub	sp, #8
 800d4b4:	af00      	add	r7, sp, #0
 800d4b6:	6078      	str	r0, [r7, #4]
  if (pObj->is_initialized == 1U)
 800d4b8:	687b      	ldr	r3, [r7, #4]
 800d4ba:	f893 3030 	ldrb.w	r3, [r3, #48]	@ 0x30
 800d4be:	2b01      	cmp	r3, #1
 800d4c0:	d108      	bne.n	800d4d4 <STTS22H_DeInit+0x24>
  {
    /* Put the component in standby mode */
    if (STTS22H_TEMP_Disable(pObj) != STTS22H_OK)
 800d4c2:	6878      	ldr	r0, [r7, #4]
 800d4c4:	f000 f878 	bl	800d5b8 <STTS22H_TEMP_Disable>
 800d4c8:	4603      	mov	r3, r0
 800d4ca:	2b00      	cmp	r3, #0
 800d4cc:	d002      	beq.n	800d4d4 <STTS22H_DeInit+0x24>
    {
      return STTS22H_ERROR;
 800d4ce:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d4d2:	e004      	b.n	800d4de <STTS22H_DeInit+0x2e>
    }
  }

  pObj->is_initialized = 0;
 800d4d4:	687b      	ldr	r3, [r7, #4]
 800d4d6:	2200      	movs	r2, #0
 800d4d8:	f883 2030 	strb.w	r2, [r3, #48]	@ 0x30

  return STTS22H_OK;
 800d4dc:	2300      	movs	r3, #0
}
 800d4de:	4618      	mov	r0, r3
 800d4e0:	3708      	adds	r7, #8
 800d4e2:	46bd      	mov	sp, r7
 800d4e4:	bd80      	pop	{r7, pc}

0800d4e6 <STTS22H_ReadID>:
  * @param  pObj the device pObj
  * @param  Id the WHO_AM_I value
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_ReadID(STTS22H_Object_t *pObj, uint8_t *Id)
{
 800d4e6:	b580      	push	{r7, lr}
 800d4e8:	b084      	sub	sp, #16
 800d4ea:	af00      	add	r7, sp, #0
 800d4ec:	6078      	str	r0, [r7, #4]
 800d4ee:	6039      	str	r1, [r7, #0]
  uint8_t buf;

  if (stts22h_dev_id_get(&(pObj->Ctx), &buf) != STTS22H_OK)
 800d4f0:	687b      	ldr	r3, [r7, #4]
 800d4f2:	3320      	adds	r3, #32
 800d4f4:	f107 020f 	add.w	r2, r7, #15
 800d4f8:	4611      	mov	r1, r2
 800d4fa:	4618      	mov	r0, r3
 800d4fc:	f000 fc1e 	bl	800dd3c <stts22h_dev_id_get>
 800d500:	4603      	mov	r3, r0
 800d502:	2b00      	cmp	r3, #0
 800d504:	d002      	beq.n	800d50c <STTS22H_ReadID+0x26>
  {
    return STTS22H_ERROR;
 800d506:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d50a:	e003      	b.n	800d514 <STTS22H_ReadID+0x2e>
  }

  *Id = buf;
 800d50c:	7bfa      	ldrb	r2, [r7, #15]
 800d50e:	683b      	ldr	r3, [r7, #0]
 800d510:	701a      	strb	r2, [r3, #0]

  return STTS22H_OK;
 800d512:	2300      	movs	r3, #0
}
 800d514:	4618      	mov	r0, r3
 800d516:	3710      	adds	r7, #16
 800d518:	46bd      	mov	sp, r7
 800d51a:	bd80      	pop	{r7, pc}

0800d51c <STTS22H_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to STTS22H sensor capabilities
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_GetCapabilities(STTS22H_Object_t *pObj, STTS22H_Capabilities_t *Capabilities)
{
 800d51c:	b480      	push	{r7}
 800d51e:	b083      	sub	sp, #12
 800d520:	af00      	add	r7, sp, #0
 800d522:	6078      	str	r0, [r7, #4]
 800d524:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  Capabilities->Humidity    = 0;
 800d526:	683b      	ldr	r3, [r7, #0]
 800d528:	2200      	movs	r2, #0
 800d52a:	709a      	strb	r2, [r3, #2]
  Capabilities->Pressure    = 0;
 800d52c:	683b      	ldr	r3, [r7, #0]
 800d52e:	2200      	movs	r2, #0
 800d530:	705a      	strb	r2, [r3, #1]
  Capabilities->Temperature = 1;
 800d532:	683b      	ldr	r3, [r7, #0]
 800d534:	2201      	movs	r2, #1
 800d536:	701a      	strb	r2, [r3, #0]
  Capabilities->Gas         = 0;
 800d538:	683b      	ldr	r3, [r7, #0]
 800d53a:	2200      	movs	r2, #0
 800d53c:	70da      	strb	r2, [r3, #3]
  Capabilities->LowPower    = 0;
 800d53e:	683b      	ldr	r3, [r7, #0]
 800d540:	2200      	movs	r2, #0
 800d542:	711a      	strb	r2, [r3, #4]
  Capabilities->HumMaxOdr   = 0.0f;
 800d544:	683b      	ldr	r3, [r7, #0]
 800d546:	f04f 0200 	mov.w	r2, #0
 800d54a:	609a      	str	r2, [r3, #8]
  Capabilities->TempMaxOdr  = 200.0f;
 800d54c:	683b      	ldr	r3, [r7, #0]
 800d54e:	4a08      	ldr	r2, [pc, #32]	@ (800d570 <STTS22H_GetCapabilities+0x54>)
 800d550:	60da      	str	r2, [r3, #12]
  Capabilities->PressMaxOdr = 0.0f;
 800d552:	683b      	ldr	r3, [r7, #0]
 800d554:	f04f 0200 	mov.w	r2, #0
 800d558:	611a      	str	r2, [r3, #16]
  Capabilities->GasMaxOdr   = 0.0f;
 800d55a:	683b      	ldr	r3, [r7, #0]
 800d55c:	f04f 0200 	mov.w	r2, #0
 800d560:	615a      	str	r2, [r3, #20]
  return STTS22H_OK;
 800d562:	2300      	movs	r3, #0
}
 800d564:	4618      	mov	r0, r3
 800d566:	370c      	adds	r7, #12
 800d568:	46bd      	mov	sp, r7
 800d56a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d56e:	4770      	bx	lr
 800d570:	43480000 	.word	0x43480000

0800d574 <STTS22H_TEMP_Enable>:
  * @brief  Enable the STTS22H temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_Enable(STTS22H_Object_t *pObj)
{
 800d574:	b580      	push	{r7, lr}
 800d576:	b082      	sub	sp, #8
 800d578:	af00      	add	r7, sp, #0
 800d57a:	6078      	str	r0, [r7, #4]
  /* Check if the component is already enabled */
  if (pObj->temp_is_enabled == 1U)
 800d57c:	687b      	ldr	r3, [r7, #4]
 800d57e:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800d582:	2b01      	cmp	r3, #1
 800d584:	d101      	bne.n	800d58a <STTS22H_TEMP_Enable+0x16>
  {
    return STTS22H_OK;
 800d586:	2300      	movs	r3, #0
 800d588:	e012      	b.n	800d5b0 <STTS22H_TEMP_Enable+0x3c>
  }

  /* Power on the component and set the odr. */
  if (STTS22H_TEMP_SetOutputDataRate(pObj, pObj->temp_odr) != STTS22H_OK)
 800d58a:	687b      	ldr	r3, [r7, #4]
 800d58c:	edd3 7a0d 	vldr	s15, [r3, #52]	@ 0x34
 800d590:	eeb0 0a67 	vmov.f32	s0, s15
 800d594:	6878      	ldr	r0, [r7, #4]
 800d596:	f000 f8e9 	bl	800d76c <STTS22H_TEMP_SetOutputDataRate>
 800d59a:	4603      	mov	r3, r0
 800d59c:	2b00      	cmp	r3, #0
 800d59e:	d002      	beq.n	800d5a6 <STTS22H_TEMP_Enable+0x32>
  {
    return STTS22H_ERROR;
 800d5a0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d5a4:	e004      	b.n	800d5b0 <STTS22H_TEMP_Enable+0x3c>
  }

  pObj->temp_is_enabled = 1;
 800d5a6:	687b      	ldr	r3, [r7, #4]
 800d5a8:	2201      	movs	r2, #1
 800d5aa:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return STTS22H_OK;
 800d5ae:	2300      	movs	r3, #0
}
 800d5b0:	4618      	mov	r0, r3
 800d5b2:	3708      	adds	r7, #8
 800d5b4:	46bd      	mov	sp, r7
 800d5b6:	bd80      	pop	{r7, pc}

0800d5b8 <STTS22H_TEMP_Disable>:
  * @brief  Disable the STTS22H temperature sensor
  * @param  pObj the device pObj
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_Disable(STTS22H_Object_t *pObj)
{
 800d5b8:	b580      	push	{r7, lr}
 800d5ba:	b082      	sub	sp, #8
 800d5bc:	af00      	add	r7, sp, #0
 800d5be:	6078      	str	r0, [r7, #4]
  /* Check if the component is already disabled */
  if (pObj->temp_is_enabled == 0U)
 800d5c0:	687b      	ldr	r3, [r7, #4]
 800d5c2:	f893 3031 	ldrb.w	r3, [r3, #49]	@ 0x31
 800d5c6:	2b00      	cmp	r3, #0
 800d5c8:	d101      	bne.n	800d5ce <STTS22H_TEMP_Disable+0x16>
  {
    return STTS22H_OK;
 800d5ca:	2300      	movs	r3, #0
 800d5cc:	e01c      	b.n	800d608 <STTS22H_TEMP_Disable+0x50>
  }

  /* Save the current odr. */
  if (STTS22H_TEMP_GetOutputDataRate(pObj, &pObj->temp_odr) != STTS22H_OK)
 800d5ce:	687b      	ldr	r3, [r7, #4]
 800d5d0:	3334      	adds	r3, #52	@ 0x34
 800d5d2:	4619      	mov	r1, r3
 800d5d4:	6878      	ldr	r0, [r7, #4]
 800d5d6:	f000 f81b 	bl	800d610 <STTS22H_TEMP_GetOutputDataRate>
 800d5da:	4603      	mov	r3, r0
 800d5dc:	2b00      	cmp	r3, #0
 800d5de:	d002      	beq.n	800d5e6 <STTS22H_TEMP_Disable+0x2e>
  {
    return STTS22H_ERROR;
 800d5e0:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d5e4:	e010      	b.n	800d608 <STTS22H_TEMP_Disable+0x50>
  }

  /* Put the component in standby mode. */
  if (stts22h_temp_data_rate_set(&(pObj->Ctx), STTS22H_POWER_DOWN) != STTS22H_OK)
 800d5e6:	687b      	ldr	r3, [r7, #4]
 800d5e8:	3320      	adds	r3, #32
 800d5ea:	2100      	movs	r1, #0
 800d5ec:	4618      	mov	r0, r3
 800d5ee:	f000 f9e1 	bl	800d9b4 <stts22h_temp_data_rate_set>
 800d5f2:	4603      	mov	r3, r0
 800d5f4:	2b00      	cmp	r3, #0
 800d5f6:	d002      	beq.n	800d5fe <STTS22H_TEMP_Disable+0x46>
  {
    return STTS22H_ERROR;
 800d5f8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d5fc:	e004      	b.n	800d608 <STTS22H_TEMP_Disable+0x50>
  }

  pObj->temp_is_enabled = 0;
 800d5fe:	687b      	ldr	r3, [r7, #4]
 800d600:	2200      	movs	r2, #0
 800d602:	f883 2031 	strb.w	r2, [r3, #49]	@ 0x31

  return STTS22H_OK;
 800d606:	2300      	movs	r3, #0
}
 800d608:	4618      	mov	r0, r3
 800d60a:	3708      	adds	r7, #8
 800d60c:	46bd      	mov	sp, r7
 800d60e:	bd80      	pop	{r7, pc}

0800d610 <STTS22H_TEMP_GetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr pointer where the output data rate is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_GetOutputDataRate(STTS22H_Object_t *pObj, float *Odr)
{
 800d610:	b580      	push	{r7, lr}
 800d612:	b084      	sub	sp, #16
 800d614:	af00      	add	r7, sp, #0
 800d616:	6078      	str	r0, [r7, #4]
 800d618:	6039      	str	r1, [r7, #0]
  int32_t ret = STTS22H_OK;
 800d61a:	2300      	movs	r3, #0
 800d61c:	60fb      	str	r3, [r7, #12]
  stts22h_odr_temp_t odr_low_level;

  if (stts22h_temp_data_rate_get(&(pObj->Ctx), &odr_low_level) != STTS22H_OK)
 800d61e:	687b      	ldr	r3, [r7, #4]
 800d620:	3320      	adds	r3, #32
 800d622:	f107 020b 	add.w	r2, r7, #11
 800d626:	4611      	mov	r1, r2
 800d628:	4618      	mov	r0, r3
 800d62a:	f000 fa89 	bl	800db40 <stts22h_temp_data_rate_get>
 800d62e:	4603      	mov	r3, r0
 800d630:	2b00      	cmp	r3, #0
 800d632:	d002      	beq.n	800d63a <STTS22H_TEMP_GetOutputDataRate+0x2a>
  {
    return STTS22H_ERROR;
 800d634:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d638:	e08b      	b.n	800d752 <STTS22H_TEMP_GetOutputDataRate+0x142>
  }

  switch (odr_low_level)
 800d63a:	7afb      	ldrb	r3, [r7, #11]
 800d63c:	2b32      	cmp	r3, #50	@ 0x32
 800d63e:	f200 8083 	bhi.w	800d748 <STTS22H_TEMP_GetOutputDataRate+0x138>
 800d642:	a201      	add	r2, pc, #4	@ (adr r2, 800d648 <STTS22H_TEMP_GetOutputDataRate+0x38>)
 800d644:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d648:	0800d715 	.word	0x0800d715
 800d64c:	0800d715 	.word	0x0800d715
 800d650:	0800d729 	.word	0x0800d729
 800d654:	0800d749 	.word	0x0800d749
 800d658:	0800d71f 	.word	0x0800d71f
 800d65c:	0800d749 	.word	0x0800d749
 800d660:	0800d749 	.word	0x0800d749
 800d664:	0800d749 	.word	0x0800d749
 800d668:	0800d749 	.word	0x0800d749
 800d66c:	0800d749 	.word	0x0800d749
 800d670:	0800d749 	.word	0x0800d749
 800d674:	0800d749 	.word	0x0800d749
 800d678:	0800d749 	.word	0x0800d749
 800d67c:	0800d749 	.word	0x0800d749
 800d680:	0800d749 	.word	0x0800d749
 800d684:	0800d749 	.word	0x0800d749
 800d688:	0800d749 	.word	0x0800d749
 800d68c:	0800d749 	.word	0x0800d749
 800d690:	0800d731 	.word	0x0800d731
 800d694:	0800d749 	.word	0x0800d749
 800d698:	0800d749 	.word	0x0800d749
 800d69c:	0800d749 	.word	0x0800d749
 800d6a0:	0800d749 	.word	0x0800d749
 800d6a4:	0800d749 	.word	0x0800d749
 800d6a8:	0800d749 	.word	0x0800d749
 800d6ac:	0800d749 	.word	0x0800d749
 800d6b0:	0800d749 	.word	0x0800d749
 800d6b4:	0800d749 	.word	0x0800d749
 800d6b8:	0800d749 	.word	0x0800d749
 800d6bc:	0800d749 	.word	0x0800d749
 800d6c0:	0800d749 	.word	0x0800d749
 800d6c4:	0800d749 	.word	0x0800d749
 800d6c8:	0800d749 	.word	0x0800d749
 800d6cc:	0800d749 	.word	0x0800d749
 800d6d0:	0800d739 	.word	0x0800d739
 800d6d4:	0800d749 	.word	0x0800d749
 800d6d8:	0800d749 	.word	0x0800d749
 800d6dc:	0800d749 	.word	0x0800d749
 800d6e0:	0800d749 	.word	0x0800d749
 800d6e4:	0800d749 	.word	0x0800d749
 800d6e8:	0800d749 	.word	0x0800d749
 800d6ec:	0800d749 	.word	0x0800d749
 800d6f0:	0800d749 	.word	0x0800d749
 800d6f4:	0800d749 	.word	0x0800d749
 800d6f8:	0800d749 	.word	0x0800d749
 800d6fc:	0800d749 	.word	0x0800d749
 800d700:	0800d749 	.word	0x0800d749
 800d704:	0800d749 	.word	0x0800d749
 800d708:	0800d749 	.word	0x0800d749
 800d70c:	0800d749 	.word	0x0800d749
 800d710:	0800d741 	.word	0x0800d741
  {
    case STTS22H_POWER_DOWN:
    case STTS22H_ONE_SHOT:
      *Odr = 0.0f;
 800d714:	683b      	ldr	r3, [r7, #0]
 800d716:	f04f 0200 	mov.w	r2, #0
 800d71a:	601a      	str	r2, [r3, #0]
      break;
 800d71c:	e018      	b.n	800d750 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_1Hz:
      *Odr = 1.0f;
 800d71e:	683b      	ldr	r3, [r7, #0]
 800d720:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 800d724:	601a      	str	r2, [r3, #0]
      break;
 800d726:	e013      	b.n	800d750 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_25Hz:
      *Odr = 25.0f;
 800d728:	683b      	ldr	r3, [r7, #0]
 800d72a:	4a0c      	ldr	r2, [pc, #48]	@ (800d75c <STTS22H_TEMP_GetOutputDataRate+0x14c>)
 800d72c:	601a      	str	r2, [r3, #0]
      break;
 800d72e:	e00f      	b.n	800d750 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_50Hz:
      *Odr = 50.0f;
 800d730:	683b      	ldr	r3, [r7, #0]
 800d732:	4a0b      	ldr	r2, [pc, #44]	@ (800d760 <STTS22H_TEMP_GetOutputDataRate+0x150>)
 800d734:	601a      	str	r2, [r3, #0]
      break;
 800d736:	e00b      	b.n	800d750 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_100Hz:
      *Odr = 100.0f;
 800d738:	683b      	ldr	r3, [r7, #0]
 800d73a:	4a0a      	ldr	r2, [pc, #40]	@ (800d764 <STTS22H_TEMP_GetOutputDataRate+0x154>)
 800d73c:	601a      	str	r2, [r3, #0]
      break;
 800d73e:	e007      	b.n	800d750 <STTS22H_TEMP_GetOutputDataRate+0x140>

    case STTS22H_200Hz:
      *Odr = 200.0f;
 800d740:	683b      	ldr	r3, [r7, #0]
 800d742:	4a09      	ldr	r2, [pc, #36]	@ (800d768 <STTS22H_TEMP_GetOutputDataRate+0x158>)
 800d744:	601a      	str	r2, [r3, #0]
      break;
 800d746:	e003      	b.n	800d750 <STTS22H_TEMP_GetOutputDataRate+0x140>

    default:
      ret = STTS22H_ERROR;
 800d748:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d74c:	60fb      	str	r3, [r7, #12]
      break;
 800d74e:	bf00      	nop
  }

  return ret;
 800d750:	68fb      	ldr	r3, [r7, #12]
}
 800d752:	4618      	mov	r0, r3
 800d754:	3710      	adds	r7, #16
 800d756:	46bd      	mov	sp, r7
 800d758:	bd80      	pop	{r7, pc}
 800d75a:	bf00      	nop
 800d75c:	41c80000 	.word	0x41c80000
 800d760:	42480000 	.word	0x42480000
 800d764:	42c80000 	.word	0x42c80000
 800d768:	43480000 	.word	0x43480000

0800d76c <STTS22H_TEMP_SetOutputDataRate>:
  * @param  pObj the device pObj
  * @param  Odr the output data rate value to be set
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_SetOutputDataRate(STTS22H_Object_t *pObj, float Odr)
{
 800d76c:	b580      	push	{r7, lr}
 800d76e:	b084      	sub	sp, #16
 800d770:	af00      	add	r7, sp, #0
 800d772:	6078      	str	r0, [r7, #4]
 800d774:	ed87 0a00 	vstr	s0, [r7]
  stts22h_odr_temp_t new_odr;

  new_odr = (Odr <= 1.0f) ? STTS22H_1Hz
            : (Odr <= 25.0f) ? STTS22H_25Hz
 800d778:	edd7 7a00 	vldr	s15, [r7]
 800d77c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800d780:	eef4 7ac7 	vcmpe.f32	s15, s14
 800d784:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d788:	d801      	bhi.n	800d78e <STTS22H_TEMP_SetOutputDataRate+0x22>
 800d78a:	2304      	movs	r3, #4
 800d78c:	e021      	b.n	800d7d2 <STTS22H_TEMP_SetOutputDataRate+0x66>
 800d78e:	edd7 7a00 	vldr	s15, [r7]
 800d792:	eeb3 7a09 	vmov.f32	s14, #57	@ 0x41c80000  25.0
 800d796:	eef4 7ac7 	vcmpe.f32	s15, s14
 800d79a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d79e:	d801      	bhi.n	800d7a4 <STTS22H_TEMP_SetOutputDataRate+0x38>
 800d7a0:	2302      	movs	r3, #2
 800d7a2:	e016      	b.n	800d7d2 <STTS22H_TEMP_SetOutputDataRate+0x66>
 800d7a4:	edd7 7a00 	vldr	s15, [r7]
 800d7a8:	ed9f 7a13 	vldr	s14, [pc, #76]	@ 800d7f8 <STTS22H_TEMP_SetOutputDataRate+0x8c>
 800d7ac:	eef4 7ac7 	vcmpe.f32	s15, s14
 800d7b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d7b4:	d801      	bhi.n	800d7ba <STTS22H_TEMP_SetOutputDataRate+0x4e>
 800d7b6:	2312      	movs	r3, #18
 800d7b8:	e00b      	b.n	800d7d2 <STTS22H_TEMP_SetOutputDataRate+0x66>
 800d7ba:	edd7 7a00 	vldr	s15, [r7]
 800d7be:	ed9f 7a0f 	vldr	s14, [pc, #60]	@ 800d7fc <STTS22H_TEMP_SetOutputDataRate+0x90>
 800d7c2:	eef4 7ac7 	vcmpe.f32	s15, s14
 800d7c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800d7ca:	d801      	bhi.n	800d7d0 <STTS22H_TEMP_SetOutputDataRate+0x64>
 800d7cc:	2322      	movs	r3, #34	@ 0x22
 800d7ce:	e000      	b.n	800d7d2 <STTS22H_TEMP_SetOutputDataRate+0x66>
 800d7d0:	2332      	movs	r3, #50	@ 0x32
  new_odr = (Odr <= 1.0f) ? STTS22H_1Hz
 800d7d2:	73fb      	strb	r3, [r7, #15]
            : (Odr <= 50.0f) ? STTS22H_50Hz
            : (Odr <= 100.0f) ? STTS22H_100Hz
            :                    STTS22H_200Hz;

  if (stts22h_temp_data_rate_set(&(pObj->Ctx), new_odr) != STTS22H_OK)
 800d7d4:	687b      	ldr	r3, [r7, #4]
 800d7d6:	3320      	adds	r3, #32
 800d7d8:	7bfa      	ldrb	r2, [r7, #15]
 800d7da:	4611      	mov	r1, r2
 800d7dc:	4618      	mov	r0, r3
 800d7de:	f000 f8e9 	bl	800d9b4 <stts22h_temp_data_rate_set>
 800d7e2:	4603      	mov	r3, r0
 800d7e4:	2b00      	cmp	r3, #0
 800d7e6:	d002      	beq.n	800d7ee <STTS22H_TEMP_SetOutputDataRate+0x82>
  {
    return STTS22H_ERROR;
 800d7e8:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d7ec:	e000      	b.n	800d7f0 <STTS22H_TEMP_SetOutputDataRate+0x84>
  }

  return STTS22H_OK;
 800d7ee:	2300      	movs	r3, #0
}
 800d7f0:	4618      	mov	r0, r3
 800d7f2:	3710      	adds	r7, #16
 800d7f4:	46bd      	mov	sp, r7
 800d7f6:	bd80      	pop	{r7, pc}
 800d7f8:	42480000 	.word	0x42480000
 800d7fc:	42c80000 	.word	0x42c80000

0800d800 <STTS22H_TEMP_GetTemperature>:
  * @param  pObj the device pObj
  * @param  Value pointer where the temperature value is written
  * @retval 0 in case of success, an error code otherwise
  */
int32_t STTS22H_TEMP_GetTemperature(STTS22H_Object_t *pObj, float *Value)
{
 800d800:	b580      	push	{r7, lr}
 800d802:	b084      	sub	sp, #16
 800d804:	af00      	add	r7, sp, #0
 800d806:	6078      	str	r0, [r7, #4]
 800d808:	6039      	str	r1, [r7, #0]
  int16_t raw_value;

  /* Get the temperature */
  if (stts22h_temperature_raw_get(&(pObj->Ctx), &raw_value) != STTS22H_OK)
 800d80a:	687b      	ldr	r3, [r7, #4]
 800d80c:	3320      	adds	r3, #32
 800d80e:	f107 020e 	add.w	r2, r7, #14
 800d812:	4611      	mov	r1, r2
 800d814:	4618      	mov	r0, r3
 800d816:	f000 fa6f 	bl	800dcf8 <stts22h_temperature_raw_get>
 800d81a:	4603      	mov	r3, r0
 800d81c:	2b00      	cmp	r3, #0
 800d81e:	d002      	beq.n	800d826 <STTS22H_TEMP_GetTemperature+0x26>
  {
    return STTS22H_ERROR;
 800d820:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d824:	e00a      	b.n	800d83c <STTS22H_TEMP_GetTemperature+0x3c>
  }

  *Value = stts22h_from_lsb_to_celsius(raw_value);
 800d826:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800d82a:	4618      	mov	r0, r3
 800d82c:	f000 f8a8 	bl	800d980 <stts22h_from_lsb_to_celsius>
 800d830:	eef0 7a40 	vmov.f32	s15, s0
 800d834:	683b      	ldr	r3, [r7, #0]
 800d836:	edc3 7a00 	vstr	s15, [r3]

  return STTS22H_OK;
 800d83a:	2300      	movs	r3, #0
}
 800d83c:	4618      	mov	r0, r3
 800d83e:	3710      	adds	r7, #16
 800d840:	46bd      	mov	sp, r7
 800d842:	bd80      	pop	{r7, pc}

0800d844 <ReadRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t ReadRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800d844:	b590      	push	{r4, r7, lr}
 800d846:	b089      	sub	sp, #36	@ 0x24
 800d848:	af00      	add	r7, sp, #0
 800d84a:	60f8      	str	r0, [r7, #12]
 800d84c:	607a      	str	r2, [r7, #4]
 800d84e:	461a      	mov	r2, r3
 800d850:	460b      	mov	r3, r1
 800d852:	72fb      	strb	r3, [r7, #11]
 800d854:	4613      	mov	r3, r2
 800d856:	813b      	strh	r3, [r7, #8]
  uint16_t i;
  int32_t ret = STTS22H_OK;
 800d858:	2300      	movs	r3, #0
 800d85a:	61bb      	str	r3, [r7, #24]
  STTS22H_Object_t *pObj = (STTS22H_Object_t *)Handle;
 800d85c:	68fb      	ldr	r3, [r7, #12]
 800d85e:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == (uint32_t)STTS22H_I2C_BUS) /* I2C */
 800d860:	697b      	ldr	r3, [r7, #20]
 800d862:	689b      	ldr	r3, [r3, #8]
 800d864:	2b00      	cmp	r3, #0
 800d866:	d11f      	bne.n	800d8a8 <ReadRegWrap+0x64>
  {
    for (i = 0; i < Length; i++)
 800d868:	2300      	movs	r3, #0
 800d86a:	83fb      	strh	r3, [r7, #30]
 800d86c:	e018      	b.n	800d8a0 <ReadRegWrap+0x5c>
    {
      ret = pObj->IO.ReadReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800d86e:	697b      	ldr	r3, [r7, #20]
 800d870:	695c      	ldr	r4, [r3, #20]
 800d872:	697b      	ldr	r3, [r7, #20]
 800d874:	7b1b      	ldrb	r3, [r3, #12]
 800d876:	4618      	mov	r0, r3
 800d878:	7afb      	ldrb	r3, [r7, #11]
 800d87a:	b29a      	uxth	r2, r3
 800d87c:	8bfb      	ldrh	r3, [r7, #30]
 800d87e:	4413      	add	r3, r2
 800d880:	b299      	uxth	r1, r3
 800d882:	8bfb      	ldrh	r3, [r7, #30]
 800d884:	687a      	ldr	r2, [r7, #4]
 800d886:	441a      	add	r2, r3
 800d888:	2301      	movs	r3, #1
 800d88a:	47a0      	blx	r4
 800d88c:	61b8      	str	r0, [r7, #24]
      if (ret != STTS22H_OK)
 800d88e:	69bb      	ldr	r3, [r7, #24]
 800d890:	2b00      	cmp	r3, #0
 800d892:	d002      	beq.n	800d89a <ReadRegWrap+0x56>
      {
        return STTS22H_ERROR;
 800d894:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d898:	e007      	b.n	800d8aa <ReadRegWrap+0x66>
    for (i = 0; i < Length; i++)
 800d89a:	8bfb      	ldrh	r3, [r7, #30]
 800d89c:	3301      	adds	r3, #1
 800d89e:	83fb      	strh	r3, [r7, #30]
 800d8a0:	8bfa      	ldrh	r2, [r7, #30]
 800d8a2:	893b      	ldrh	r3, [r7, #8]
 800d8a4:	429a      	cmp	r2, r3
 800d8a6:	d3e2      	bcc.n	800d86e <ReadRegWrap+0x2a>
      }
    }
  }

  return ret;
 800d8a8:	69bb      	ldr	r3, [r7, #24]
}
 800d8aa:	4618      	mov	r0, r3
 800d8ac:	3724      	adds	r7, #36	@ 0x24
 800d8ae:	46bd      	mov	sp, r7
 800d8b0:	bd90      	pop	{r4, r7, pc}

0800d8b2 <WriteRegWrap>:
  * @param  pData the stored data pointer
  * @param  Length the length
  * @retval 0 in case of success, an error code otherwise
  */
static int32_t WriteRegWrap(void *Handle, uint8_t Reg, uint8_t *pData, uint16_t Length)
{
 800d8b2:	b590      	push	{r4, r7, lr}
 800d8b4:	b089      	sub	sp, #36	@ 0x24
 800d8b6:	af00      	add	r7, sp, #0
 800d8b8:	60f8      	str	r0, [r7, #12]
 800d8ba:	607a      	str	r2, [r7, #4]
 800d8bc:	461a      	mov	r2, r3
 800d8be:	460b      	mov	r3, r1
 800d8c0:	72fb      	strb	r3, [r7, #11]
 800d8c2:	4613      	mov	r3, r2
 800d8c4:	813b      	strh	r3, [r7, #8]
  uint16_t i;
  int32_t ret = STTS22H_OK;
 800d8c6:	2300      	movs	r3, #0
 800d8c8:	61bb      	str	r3, [r7, #24]
  STTS22H_Object_t *pObj = (STTS22H_Object_t *)Handle;
 800d8ca:	68fb      	ldr	r3, [r7, #12]
 800d8cc:	617b      	str	r3, [r7, #20]

  if (pObj->IO.BusType == (uint32_t)STTS22H_I2C_BUS) /* I2C */
 800d8ce:	697b      	ldr	r3, [r7, #20]
 800d8d0:	689b      	ldr	r3, [r3, #8]
 800d8d2:	2b00      	cmp	r3, #0
 800d8d4:	d11f      	bne.n	800d916 <WriteRegWrap+0x64>
  {
    for (i = 0; i < Length; i++)
 800d8d6:	2300      	movs	r3, #0
 800d8d8:	83fb      	strh	r3, [r7, #30]
 800d8da:	e018      	b.n	800d90e <WriteRegWrap+0x5c>
    {
      ret = pObj->IO.WriteReg(pObj->IO.Address, (Reg + i), &pData[i], 1);
 800d8dc:	697b      	ldr	r3, [r7, #20]
 800d8de:	691c      	ldr	r4, [r3, #16]
 800d8e0:	697b      	ldr	r3, [r7, #20]
 800d8e2:	7b1b      	ldrb	r3, [r3, #12]
 800d8e4:	4618      	mov	r0, r3
 800d8e6:	7afb      	ldrb	r3, [r7, #11]
 800d8e8:	b29a      	uxth	r2, r3
 800d8ea:	8bfb      	ldrh	r3, [r7, #30]
 800d8ec:	4413      	add	r3, r2
 800d8ee:	b299      	uxth	r1, r3
 800d8f0:	8bfb      	ldrh	r3, [r7, #30]
 800d8f2:	687a      	ldr	r2, [r7, #4]
 800d8f4:	441a      	add	r2, r3
 800d8f6:	2301      	movs	r3, #1
 800d8f8:	47a0      	blx	r4
 800d8fa:	61b8      	str	r0, [r7, #24]
      if (ret != STTS22H_OK)
 800d8fc:	69bb      	ldr	r3, [r7, #24]
 800d8fe:	2b00      	cmp	r3, #0
 800d900:	d002      	beq.n	800d908 <WriteRegWrap+0x56>
      {
        return STTS22H_ERROR;
 800d902:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800d906:	e007      	b.n	800d918 <WriteRegWrap+0x66>
    for (i = 0; i < Length; i++)
 800d908:	8bfb      	ldrh	r3, [r7, #30]
 800d90a:	3301      	adds	r3, #1
 800d90c:	83fb      	strh	r3, [r7, #30]
 800d90e:	8bfa      	ldrh	r2, [r7, #30]
 800d910:	893b      	ldrh	r3, [r7, #8]
 800d912:	429a      	cmp	r2, r3
 800d914:	d3e2      	bcc.n	800d8dc <WriteRegWrap+0x2a>
      }
    }
  }

  return ret;
 800d916:	69bb      	ldr	r3, [r7, #24]
}
 800d918:	4618      	mov	r0, r3
 800d91a:	3724      	adds	r7, #36	@ 0x24
 800d91c:	46bd      	mov	sp, r7
 800d91e:	bd90      	pop	{r4, r7, pc}

0800d920 <stts22h_read_reg>:
  *
  */
int32_t __weak stts22h_read_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                uint8_t *data,
                                uint16_t len)
{
 800d920:	b590      	push	{r4, r7, lr}
 800d922:	b087      	sub	sp, #28
 800d924:	af00      	add	r7, sp, #0
 800d926:	60f8      	str	r0, [r7, #12]
 800d928:	607a      	str	r2, [r7, #4]
 800d92a:	461a      	mov	r2, r3
 800d92c:	460b      	mov	r3, r1
 800d92e:	72fb      	strb	r3, [r7, #11]
 800d930:	4613      	mov	r3, r2
 800d932:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->read_reg(ctx->handle, reg, data, len);
 800d934:	68fb      	ldr	r3, [r7, #12]
 800d936:	685c      	ldr	r4, [r3, #4]
 800d938:	68fb      	ldr	r3, [r7, #12]
 800d93a:	68d8      	ldr	r0, [r3, #12]
 800d93c:	893b      	ldrh	r3, [r7, #8]
 800d93e:	7af9      	ldrb	r1, [r7, #11]
 800d940:	687a      	ldr	r2, [r7, #4]
 800d942:	47a0      	blx	r4
 800d944:	6178      	str	r0, [r7, #20]

  return ret;
 800d946:	697b      	ldr	r3, [r7, #20]
}
 800d948:	4618      	mov	r0, r3
 800d94a:	371c      	adds	r7, #28
 800d94c:	46bd      	mov	sp, r7
 800d94e:	bd90      	pop	{r4, r7, pc}

0800d950 <stts22h_write_reg>:
  *
  */
int32_t __weak stts22h_write_reg(stmdev_ctx_t *ctx, uint8_t reg,
                                 uint8_t *data,
                                 uint16_t len)
{
 800d950:	b590      	push	{r4, r7, lr}
 800d952:	b087      	sub	sp, #28
 800d954:	af00      	add	r7, sp, #0
 800d956:	60f8      	str	r0, [r7, #12]
 800d958:	607a      	str	r2, [r7, #4]
 800d95a:	461a      	mov	r2, r3
 800d95c:	460b      	mov	r3, r1
 800d95e:	72fb      	strb	r3, [r7, #11]
 800d960:	4613      	mov	r3, r2
 800d962:	813b      	strh	r3, [r7, #8]
  int32_t ret;

  ret = ctx->write_reg(ctx->handle, reg, data, len);
 800d964:	68fb      	ldr	r3, [r7, #12]
 800d966:	681c      	ldr	r4, [r3, #0]
 800d968:	68fb      	ldr	r3, [r7, #12]
 800d96a:	68d8      	ldr	r0, [r3, #12]
 800d96c:	893b      	ldrh	r3, [r7, #8]
 800d96e:	7af9      	ldrb	r1, [r7, #11]
 800d970:	687a      	ldr	r2, [r7, #4]
 800d972:	47a0      	blx	r4
 800d974:	6178      	str	r0, [r7, #20]

  return ret;
 800d976:	697b      	ldr	r3, [r7, #20]
}
 800d978:	4618      	mov	r0, r3
 800d97a:	371c      	adds	r7, #28
 800d97c:	46bd      	mov	sp, r7
 800d97e:	bd90      	pop	{r4, r7, pc}

0800d980 <stts22h_from_lsb_to_celsius>:
  * @{
  *
  */

float_t stts22h_from_lsb_to_celsius(int16_t lsb)
{
 800d980:	b480      	push	{r7}
 800d982:	b083      	sub	sp, #12
 800d984:	af00      	add	r7, sp, #0
 800d986:	4603      	mov	r3, r0
 800d988:	80fb      	strh	r3, [r7, #6]
  return ((float_t)lsb / 100.0f);
 800d98a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800d98e:	ee07 3a90 	vmov	s15, r3
 800d992:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800d996:	ed9f 7a06 	vldr	s14, [pc, #24]	@ 800d9b0 <stts22h_from_lsb_to_celsius+0x30>
 800d99a:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800d99e:	eef0 7a66 	vmov.f32	s15, s13
}
 800d9a2:	eeb0 0a67 	vmov.f32	s0, s15
 800d9a6:	370c      	adds	r7, #12
 800d9a8:	46bd      	mov	sp, r7
 800d9aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9ae:	4770      	bx	lr
 800d9b0:	42c80000 	.word	0x42c80000

0800d9b4 <stts22h_temp_data_rate_set>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_temp_data_rate_set(stmdev_ctx_t *ctx,
                                   stts22h_odr_temp_t val)
{
 800d9b4:	b580      	push	{r7, lr}
 800d9b6:	b086      	sub	sp, #24
 800d9b8:	af00      	add	r7, sp, #0
 800d9ba:	6078      	str	r0, [r7, #4]
 800d9bc:	460b      	mov	r3, r1
 800d9be:	70fb      	strb	r3, [r7, #3]
  stts22h_software_reset_t software_reset;
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800d9c0:	f107 020c 	add.w	r2, r7, #12
 800d9c4:	2301      	movs	r3, #1
 800d9c6:	2104      	movs	r1, #4
 800d9c8:	6878      	ldr	r0, [r7, #4]
 800d9ca:	f7ff ffa9 	bl	800d920 <stts22h_read_reg>
 800d9ce:	6178      	str	r0, [r7, #20]

  if (ret == 0)
 800d9d0:	697b      	ldr	r3, [r7, #20]
 800d9d2:	2b00      	cmp	r3, #0
 800d9d4:	d107      	bne.n	800d9e6 <stts22h_temp_data_rate_set+0x32>
  {
    ret = stts22h_read_reg(ctx, STTS22H_SOFTWARE_RESET,
 800d9d6:	f107 0210 	add.w	r2, r7, #16
 800d9da:	2301      	movs	r3, #1
 800d9dc:	210c      	movs	r1, #12
 800d9de:	6878      	ldr	r0, [r7, #4]
 800d9e0:	f7ff ff9e 	bl	800d920 <stts22h_read_reg>
 800d9e4:	6178      	str	r0, [r7, #20]
                           (uint8_t *)&software_reset, 1);
  }

  if ((val == STTS22H_ONE_SHOT) && (ret == 0))
 800d9e6:	78fb      	ldrb	r3, [r7, #3]
 800d9e8:	2b01      	cmp	r3, #1
 800d9ea:	d11d      	bne.n	800da28 <stts22h_temp_data_rate_set+0x74>
 800d9ec:	697b      	ldr	r3, [r7, #20]
 800d9ee:	2b00      	cmp	r3, #0
 800d9f0:	d11a      	bne.n	800da28 <stts22h_temp_data_rate_set+0x74>
  {
    software_reset.sw_reset = PROPERTY_ENABLE;
 800d9f2:	7c3b      	ldrb	r3, [r7, #16]
 800d9f4:	f043 0302 	orr.w	r3, r3, #2
 800d9f8:	743b      	strb	r3, [r7, #16]
    ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800d9fa:	f107 0210 	add.w	r2, r7, #16
 800d9fe:	2301      	movs	r3, #1
 800da00:	210c      	movs	r1, #12
 800da02:	6878      	ldr	r0, [r7, #4]
 800da04:	f7ff ffa4 	bl	800d950 <stts22h_write_reg>
 800da08:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&software_reset, 1);

    if (ret == 0)
 800da0a:	697b      	ldr	r3, [r7, #20]
 800da0c:	2b00      	cmp	r3, #0
 800da0e:	d10b      	bne.n	800da28 <stts22h_temp_data_rate_set+0x74>
    {
      software_reset.sw_reset = PROPERTY_DISABLE;
 800da10:	7c3b      	ldrb	r3, [r7, #16]
 800da12:	f36f 0341 	bfc	r3, #1, #1
 800da16:	743b      	strb	r3, [r7, #16]
      ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800da18:	f107 0210 	add.w	r2, r7, #16
 800da1c:	2301      	movs	r3, #1
 800da1e:	210c      	movs	r1, #12
 800da20:	6878      	ldr	r0, [r7, #4]
 800da22:	f7ff ff95 	bl	800d950 <stts22h_write_reg>
 800da26:	6178      	str	r0, [r7, #20]
                              (uint8_t *)&software_reset, 1);
    }
  }

  if (((val == STTS22H_25Hz)  || (val == STTS22H_50Hz)   ||
 800da28:	78fb      	ldrb	r3, [r7, #3]
 800da2a:	2b02      	cmp	r3, #2
 800da2c:	d008      	beq.n	800da40 <stts22h_temp_data_rate_set+0x8c>
 800da2e:	78fb      	ldrb	r3, [r7, #3]
 800da30:	2b12      	cmp	r3, #18
 800da32:	d005      	beq.n	800da40 <stts22h_temp_data_rate_set+0x8c>
 800da34:	78fb      	ldrb	r3, [r7, #3]
 800da36:	2b22      	cmp	r3, #34	@ 0x22
 800da38:	d002      	beq.n	800da40 <stts22h_temp_data_rate_set+0x8c>
       (val == STTS22H_100Hz) || (val == STTS22H_200Hz)) &&
 800da3a:	78fb      	ldrb	r3, [r7, #3]
 800da3c:	2b32      	cmp	r3, #50	@ 0x32
 800da3e:	d123      	bne.n	800da88 <stts22h_temp_data_rate_set+0xd4>
      (ctrl.freerun == PROPERTY_DISABLE) && (ret == 0))
 800da40:	7b3b      	ldrb	r3, [r7, #12]
 800da42:	f003 0304 	and.w	r3, r3, #4
 800da46:	b2db      	uxtb	r3, r3
       (val == STTS22H_100Hz) || (val == STTS22H_200Hz)) &&
 800da48:	2b00      	cmp	r3, #0
 800da4a:	d11d      	bne.n	800da88 <stts22h_temp_data_rate_set+0xd4>
      (ctrl.freerun == PROPERTY_DISABLE) && (ret == 0))
 800da4c:	697b      	ldr	r3, [r7, #20]
 800da4e:	2b00      	cmp	r3, #0
 800da50:	d11a      	bne.n	800da88 <stts22h_temp_data_rate_set+0xd4>
  {
    software_reset.sw_reset = PROPERTY_ENABLE;
 800da52:	7c3b      	ldrb	r3, [r7, #16]
 800da54:	f043 0302 	orr.w	r3, r3, #2
 800da58:	743b      	strb	r3, [r7, #16]
    ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800da5a:	f107 0210 	add.w	r2, r7, #16
 800da5e:	2301      	movs	r3, #1
 800da60:	210c      	movs	r1, #12
 800da62:	6878      	ldr	r0, [r7, #4]
 800da64:	f7ff ff74 	bl	800d950 <stts22h_write_reg>
 800da68:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&software_reset, 1);

    if (ret == 0)
 800da6a:	697b      	ldr	r3, [r7, #20]
 800da6c:	2b00      	cmp	r3, #0
 800da6e:	d10b      	bne.n	800da88 <stts22h_temp_data_rate_set+0xd4>
    {
      software_reset.sw_reset = PROPERTY_DISABLE;
 800da70:	7c3b      	ldrb	r3, [r7, #16]
 800da72:	f36f 0341 	bfc	r3, #1, #1
 800da76:	743b      	strb	r3, [r7, #16]
      ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800da78:	f107 0210 	add.w	r2, r7, #16
 800da7c:	2301      	movs	r3, #1
 800da7e:	210c      	movs	r1, #12
 800da80:	6878      	ldr	r0, [r7, #4]
 800da82:	f7ff ff65 	bl	800d950 <stts22h_write_reg>
 800da86:	6178      	str	r0, [r7, #20]
                              (uint8_t *)&software_reset, 1);
    }
  }

  if ((val == STTS22H_1Hz) && (ret == 0))
 800da88:	78fb      	ldrb	r3, [r7, #3]
 800da8a:	2b04      	cmp	r3, #4
 800da8c:	d125      	bne.n	800dada <stts22h_temp_data_rate_set+0x126>
 800da8e:	697b      	ldr	r3, [r7, #20]
 800da90:	2b00      	cmp	r3, #0
 800da92:	d122      	bne.n	800dada <stts22h_temp_data_rate_set+0x126>
  {
    software_reset.sw_reset = PROPERTY_ENABLE;
 800da94:	7c3b      	ldrb	r3, [r7, #16]
 800da96:	f043 0302 	orr.w	r3, r3, #2
 800da9a:	743b      	strb	r3, [r7, #16]
    software_reset.low_odr_enable = PROPERTY_ENABLE;
 800da9c:	7c3b      	ldrb	r3, [r7, #16]
 800da9e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800daa2:	743b      	strb	r3, [r7, #16]
    ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800daa4:	f107 0210 	add.w	r2, r7, #16
 800daa8:	2301      	movs	r3, #1
 800daaa:	210c      	movs	r1, #12
 800daac:	6878      	ldr	r0, [r7, #4]
 800daae:	f7ff ff4f 	bl	800d950 <stts22h_write_reg>
 800dab2:	6178      	str	r0, [r7, #20]
                            (uint8_t *)&software_reset, 1);

    if (ret == 0)
 800dab4:	697b      	ldr	r3, [r7, #20]
 800dab6:	2b00      	cmp	r3, #0
 800dab8:	d10f      	bne.n	800dada <stts22h_temp_data_rate_set+0x126>
    {
      software_reset.sw_reset = PROPERTY_DISABLE;
 800daba:	7c3b      	ldrb	r3, [r7, #16]
 800dabc:	f36f 0341 	bfc	r3, #1, #1
 800dac0:	743b      	strb	r3, [r7, #16]
      software_reset.low_odr_enable = PROPERTY_ENABLE;
 800dac2:	7c3b      	ldrb	r3, [r7, #16]
 800dac4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800dac8:	743b      	strb	r3, [r7, #16]
      ret = stts22h_write_reg(ctx, STTS22H_SOFTWARE_RESET,
 800daca:	f107 0210 	add.w	r2, r7, #16
 800dace:	2301      	movs	r3, #1
 800dad0:	210c      	movs	r1, #12
 800dad2:	6878      	ldr	r0, [r7, #4]
 800dad4:	f7ff ff3c 	bl	800d950 <stts22h_write_reg>
 800dad8:	6178      	str	r0, [r7, #20]
                              (uint8_t *)&software_reset, 1);
    }
  }

  if (ret == 0)
 800dada:	697b      	ldr	r3, [r7, #20]
 800dadc:	2b00      	cmp	r3, #0
 800dade:	d12a      	bne.n	800db36 <stts22h_temp_data_rate_set+0x182>
  {
    ctrl.one_shot = (uint8_t)val & 0x01U;
 800dae0:	78fb      	ldrb	r3, [r7, #3]
 800dae2:	f003 0301 	and.w	r3, r3, #1
 800dae6:	b2da      	uxtb	r2, r3
 800dae8:	7b3b      	ldrb	r3, [r7, #12]
 800daea:	f362 0300 	bfi	r3, r2, #0, #1
 800daee:	733b      	strb	r3, [r7, #12]
    ctrl.freerun = ((uint8_t)val & 0x02U) >> 1;
 800daf0:	78fb      	ldrb	r3, [r7, #3]
 800daf2:	085b      	lsrs	r3, r3, #1
 800daf4:	f003 0301 	and.w	r3, r3, #1
 800daf8:	b2da      	uxtb	r2, r3
 800dafa:	7b3b      	ldrb	r3, [r7, #12]
 800dafc:	f362 0382 	bfi	r3, r2, #2, #1
 800db00:	733b      	strb	r3, [r7, #12]
    ctrl.low_odr_start = ((uint8_t)val & 0x04U) >> 2;
 800db02:	78fb      	ldrb	r3, [r7, #3]
 800db04:	089b      	lsrs	r3, r3, #2
 800db06:	f003 0301 	and.w	r3, r3, #1
 800db0a:	b2da      	uxtb	r2, r3
 800db0c:	7b3b      	ldrb	r3, [r7, #12]
 800db0e:	f362 13c7 	bfi	r3, r2, #7, #1
 800db12:	733b      	strb	r3, [r7, #12]
    ctrl.avg = ((uint8_t)val & 0x30U) >> 4;
 800db14:	78fb      	ldrb	r3, [r7, #3]
 800db16:	091b      	lsrs	r3, r3, #4
 800db18:	f003 0303 	and.w	r3, r3, #3
 800db1c:	b2da      	uxtb	r2, r3
 800db1e:	7b3b      	ldrb	r3, [r7, #12]
 800db20:	f362 1305 	bfi	r3, r2, #4, #2
 800db24:	733b      	strb	r3, [r7, #12]
    ret = stts22h_write_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800db26:	f107 020c 	add.w	r2, r7, #12
 800db2a:	2301      	movs	r3, #1
 800db2c:	2104      	movs	r1, #4
 800db2e:	6878      	ldr	r0, [r7, #4]
 800db30:	f7ff ff0e 	bl	800d950 <stts22h_write_reg>
 800db34:	6178      	str	r0, [r7, #20]
  }

  return ret;
 800db36:	697b      	ldr	r3, [r7, #20]
}
 800db38:	4618      	mov	r0, r3
 800db3a:	3718      	adds	r7, #24
 800db3c:	46bd      	mov	sp, r7
 800db3e:	bd80      	pop	{r7, pc}

0800db40 <stts22h_temp_data_rate_get>:
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_temp_data_rate_get(stmdev_ctx_t *ctx,
                                   stts22h_odr_temp_t *val)
{
 800db40:	b580      	push	{r7, lr}
 800db42:	b084      	sub	sp, #16
 800db44:	af00      	add	r7, sp, #0
 800db46:	6078      	str	r0, [r7, #4]
 800db48:	6039      	str	r1, [r7, #0]
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL,
 800db4a:	f107 0208 	add.w	r2, r7, #8
 800db4e:	2301      	movs	r3, #1
 800db50:	2104      	movs	r1, #4
 800db52:	6878      	ldr	r0, [r7, #4]
 800db54:	f7ff fee4 	bl	800d920 <stts22h_read_reg>
 800db58:	60f8      	str	r0, [r7, #12]
                         (uint8_t *)&ctrl, 1);

  switch (ctrl.one_shot | (ctrl.freerun << 1) | (ctrl.low_odr_start <<
 800db5a:	7a3b      	ldrb	r3, [r7, #8]
 800db5c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800db60:	b2db      	uxtb	r3, r3
 800db62:	461a      	mov	r2, r3
 800db64:	7a3b      	ldrb	r3, [r7, #8]
 800db66:	f3c3 0380 	ubfx	r3, r3, #2, #1
 800db6a:	b2db      	uxtb	r3, r3
 800db6c:	005b      	lsls	r3, r3, #1
 800db6e:	431a      	orrs	r2, r3
 800db70:	7a3b      	ldrb	r3, [r7, #8]
 800db72:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800db76:	b2db      	uxtb	r3, r3
 800db78:	009b      	lsls	r3, r3, #2
 800db7a:	431a      	orrs	r2, r3
                                                 2) |
          (ctrl.avg << 4))
 800db7c:	7a3b      	ldrb	r3, [r7, #8]
 800db7e:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800db82:	b2db      	uxtb	r3, r3
 800db84:	011b      	lsls	r3, r3, #4
                                                 2) |
 800db86:	4313      	orrs	r3, r2
  switch (ctrl.one_shot | (ctrl.freerun << 1) | (ctrl.low_odr_start <<
 800db88:	2b32      	cmp	r3, #50	@ 0x32
 800db8a:	f200 8085 	bhi.w	800dc98 <stts22h_temp_data_rate_get+0x158>
 800db8e:	a201      	add	r2, pc, #4	@ (adr r2, 800db94 <stts22h_temp_data_rate_get+0x54>)
 800db90:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800db94:	0800dc61 	.word	0x0800dc61
 800db98:	0800dc69 	.word	0x0800dc69
 800db9c:	0800dc79 	.word	0x0800dc79
 800dba0:	0800dc99 	.word	0x0800dc99
 800dba4:	0800dc71 	.word	0x0800dc71
 800dba8:	0800dc99 	.word	0x0800dc99
 800dbac:	0800dc99 	.word	0x0800dc99
 800dbb0:	0800dc99 	.word	0x0800dc99
 800dbb4:	0800dc99 	.word	0x0800dc99
 800dbb8:	0800dc99 	.word	0x0800dc99
 800dbbc:	0800dc99 	.word	0x0800dc99
 800dbc0:	0800dc99 	.word	0x0800dc99
 800dbc4:	0800dc99 	.word	0x0800dc99
 800dbc8:	0800dc99 	.word	0x0800dc99
 800dbcc:	0800dc99 	.word	0x0800dc99
 800dbd0:	0800dc99 	.word	0x0800dc99
 800dbd4:	0800dc99 	.word	0x0800dc99
 800dbd8:	0800dc99 	.word	0x0800dc99
 800dbdc:	0800dc81 	.word	0x0800dc81
 800dbe0:	0800dc99 	.word	0x0800dc99
 800dbe4:	0800dc99 	.word	0x0800dc99
 800dbe8:	0800dc99 	.word	0x0800dc99
 800dbec:	0800dc99 	.word	0x0800dc99
 800dbf0:	0800dc99 	.word	0x0800dc99
 800dbf4:	0800dc99 	.word	0x0800dc99
 800dbf8:	0800dc99 	.word	0x0800dc99
 800dbfc:	0800dc99 	.word	0x0800dc99
 800dc00:	0800dc99 	.word	0x0800dc99
 800dc04:	0800dc99 	.word	0x0800dc99
 800dc08:	0800dc99 	.word	0x0800dc99
 800dc0c:	0800dc99 	.word	0x0800dc99
 800dc10:	0800dc99 	.word	0x0800dc99
 800dc14:	0800dc99 	.word	0x0800dc99
 800dc18:	0800dc99 	.word	0x0800dc99
 800dc1c:	0800dc89 	.word	0x0800dc89
 800dc20:	0800dc99 	.word	0x0800dc99
 800dc24:	0800dc99 	.word	0x0800dc99
 800dc28:	0800dc99 	.word	0x0800dc99
 800dc2c:	0800dc99 	.word	0x0800dc99
 800dc30:	0800dc99 	.word	0x0800dc99
 800dc34:	0800dc99 	.word	0x0800dc99
 800dc38:	0800dc99 	.word	0x0800dc99
 800dc3c:	0800dc99 	.word	0x0800dc99
 800dc40:	0800dc99 	.word	0x0800dc99
 800dc44:	0800dc99 	.word	0x0800dc99
 800dc48:	0800dc99 	.word	0x0800dc99
 800dc4c:	0800dc99 	.word	0x0800dc99
 800dc50:	0800dc99 	.word	0x0800dc99
 800dc54:	0800dc99 	.word	0x0800dc99
 800dc58:	0800dc99 	.word	0x0800dc99
 800dc5c:	0800dc91 	.word	0x0800dc91
  {
    case STTS22H_POWER_DOWN:
      *val = STTS22H_POWER_DOWN;
 800dc60:	683b      	ldr	r3, [r7, #0]
 800dc62:	2200      	movs	r2, #0
 800dc64:	701a      	strb	r2, [r3, #0]
      break;
 800dc66:	e01b      	b.n	800dca0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_ONE_SHOT:
      *val = STTS22H_ONE_SHOT;
 800dc68:	683b      	ldr	r3, [r7, #0]
 800dc6a:	2201      	movs	r2, #1
 800dc6c:	701a      	strb	r2, [r3, #0]
      break;
 800dc6e:	e017      	b.n	800dca0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_1Hz:
      *val = STTS22H_1Hz;
 800dc70:	683b      	ldr	r3, [r7, #0]
 800dc72:	2204      	movs	r2, #4
 800dc74:	701a      	strb	r2, [r3, #0]
      break;
 800dc76:	e013      	b.n	800dca0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_25Hz:
      *val = STTS22H_25Hz;
 800dc78:	683b      	ldr	r3, [r7, #0]
 800dc7a:	2202      	movs	r2, #2
 800dc7c:	701a      	strb	r2, [r3, #0]
      break;
 800dc7e:	e00f      	b.n	800dca0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_50Hz:
      *val = STTS22H_50Hz;
 800dc80:	683b      	ldr	r3, [r7, #0]
 800dc82:	2212      	movs	r2, #18
 800dc84:	701a      	strb	r2, [r3, #0]
      break;
 800dc86:	e00b      	b.n	800dca0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_100Hz:
      *val = STTS22H_100Hz;
 800dc88:	683b      	ldr	r3, [r7, #0]
 800dc8a:	2222      	movs	r2, #34	@ 0x22
 800dc8c:	701a      	strb	r2, [r3, #0]
      break;
 800dc8e:	e007      	b.n	800dca0 <stts22h_temp_data_rate_get+0x160>

    case STTS22H_200Hz:
      *val = STTS22H_200Hz;
 800dc90:	683b      	ldr	r3, [r7, #0]
 800dc92:	2232      	movs	r2, #50	@ 0x32
 800dc94:	701a      	strb	r2, [r3, #0]
      break;
 800dc96:	e003      	b.n	800dca0 <stts22h_temp_data_rate_get+0x160>

    default:
      *val = STTS22H_POWER_DOWN;
 800dc98:	683b      	ldr	r3, [r7, #0]
 800dc9a:	2200      	movs	r2, #0
 800dc9c:	701a      	strb	r2, [r3, #0]
      break;
 800dc9e:	bf00      	nop
  }

  return ret;
 800dca0:	68fb      	ldr	r3, [r7, #12]
}
 800dca2:	4618      	mov	r0, r3
 800dca4:	3710      	adds	r7, #16
 800dca6:	46bd      	mov	sp, r7
 800dca8:	bd80      	pop	{r7, pc}
 800dcaa:	bf00      	nop

0800dcac <stts22h_block_data_update_set>:
  * @param  val    Change the values of bdu in reg CTRL.
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_block_data_update_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800dcac:	b580      	push	{r7, lr}
 800dcae:	b084      	sub	sp, #16
 800dcb0:	af00      	add	r7, sp, #0
 800dcb2:	6078      	str	r0, [r7, #4]
 800dcb4:	460b      	mov	r3, r1
 800dcb6:	70fb      	strb	r3, [r7, #3]
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800dcb8:	f107 0208 	add.w	r2, r7, #8
 800dcbc:	2301      	movs	r3, #1
 800dcbe:	2104      	movs	r1, #4
 800dcc0:	6878      	ldr	r0, [r7, #4]
 800dcc2:	f7ff fe2d 	bl	800d920 <stts22h_read_reg>
 800dcc6:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800dcc8:	68fb      	ldr	r3, [r7, #12]
 800dcca:	2b00      	cmp	r3, #0
 800dccc:	d10f      	bne.n	800dcee <stts22h_block_data_update_set+0x42>
  {
    ctrl.bdu = val;
 800dcce:	78fb      	ldrb	r3, [r7, #3]
 800dcd0:	f003 0301 	and.w	r3, r3, #1
 800dcd4:	b2da      	uxtb	r2, r3
 800dcd6:	7a3b      	ldrb	r3, [r7, #8]
 800dcd8:	f362 1386 	bfi	r3, r2, #6, #1
 800dcdc:	723b      	strb	r3, [r7, #8]
    ret = stts22h_write_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800dcde:	f107 0208 	add.w	r2, r7, #8
 800dce2:	2301      	movs	r3, #1
 800dce4:	2104      	movs	r1, #4
 800dce6:	6878      	ldr	r0, [r7, #4]
 800dce8:	f7ff fe32 	bl	800d950 <stts22h_write_reg>
 800dcec:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800dcee:	68fb      	ldr	r3, [r7, #12]
}
 800dcf0:	4618      	mov	r0, r3
 800dcf2:	3710      	adds	r7, #16
 800dcf4:	46bd      	mov	sp, r7
 800dcf6:	bd80      	pop	{r7, pc}

0800dcf8 <stts22h_temperature_raw_get>:
  * @param  buff   Buffer that stores the data read.(ptr)
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_temperature_raw_get(stmdev_ctx_t *ctx, int16_t *val)
{
 800dcf8:	b580      	push	{r7, lr}
 800dcfa:	b084      	sub	sp, #16
 800dcfc:	af00      	add	r7, sp, #0
 800dcfe:	6078      	str	r0, [r7, #4]
 800dd00:	6039      	str	r1, [r7, #0]
  uint8_t buff[2];
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_TEMP_L_OUT, buff, 2);
 800dd02:	f107 0208 	add.w	r2, r7, #8
 800dd06:	2302      	movs	r3, #2
 800dd08:	2106      	movs	r1, #6
 800dd0a:	6878      	ldr	r0, [r7, #4]
 800dd0c:	f7ff fe08 	bl	800d920 <stts22h_read_reg>
 800dd10:	60f8      	str	r0, [r7, #12]
  *val = (int16_t)buff[1];
 800dd12:	7a7b      	ldrb	r3, [r7, #9]
 800dd14:	b21a      	sxth	r2, r3
 800dd16:	683b      	ldr	r3, [r7, #0]
 800dd18:	801a      	strh	r2, [r3, #0]
  *val = (*val * 256) + (int16_t)buff[0];
 800dd1a:	683b      	ldr	r3, [r7, #0]
 800dd1c:	f9b3 3000 	ldrsh.w	r3, [r3]
 800dd20:	b29b      	uxth	r3, r3
 800dd22:	021b      	lsls	r3, r3, #8
 800dd24:	b29b      	uxth	r3, r3
 800dd26:	7a3a      	ldrb	r2, [r7, #8]
 800dd28:	4413      	add	r3, r2
 800dd2a:	b29b      	uxth	r3, r3
 800dd2c:	b21a      	sxth	r2, r3
 800dd2e:	683b      	ldr	r3, [r7, #0]
 800dd30:	801a      	strh	r2, [r3, #0]

  return ret;
 800dd32:	68fb      	ldr	r3, [r7, #12]
}
 800dd34:	4618      	mov	r0, r3
 800dd36:	3710      	adds	r7, #16
 800dd38:	46bd      	mov	sp, r7
 800dd3a:	bd80      	pop	{r7, pc}

0800dd3c <stts22h_dev_id_get>:
  * @param  buff   Buffer that stores the data read.(ptr)
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_dev_id_get(stmdev_ctx_t *ctx, uint8_t *buff)
{
 800dd3c:	b580      	push	{r7, lr}
 800dd3e:	b084      	sub	sp, #16
 800dd40:	af00      	add	r7, sp, #0
 800dd42:	6078      	str	r0, [r7, #4]
 800dd44:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_WHOAMI, buff, 1);
 800dd46:	2301      	movs	r3, #1
 800dd48:	683a      	ldr	r2, [r7, #0]
 800dd4a:	2101      	movs	r1, #1
 800dd4c:	6878      	ldr	r0, [r7, #4]
 800dd4e:	f7ff fde7 	bl	800d920 <stts22h_read_reg>
 800dd52:	60f8      	str	r0, [r7, #12]

  return ret;
 800dd54:	68fb      	ldr	r3, [r7, #12]
}
 800dd56:	4618      	mov	r0, r3
 800dd58:	3710      	adds	r7, #16
 800dd5a:	46bd      	mov	sp, r7
 800dd5c:	bd80      	pop	{r7, pc}

0800dd5e <stts22h_auto_increment_set>:
  * @param  val    Change the values of "if_add_inc" in reg STTS22H.
  * @retval        Interface status (MANDATORY: return 0 -> no Error).
  *
  */
int32_t stts22h_auto_increment_set(stmdev_ctx_t *ctx, uint8_t val)
{
 800dd5e:	b580      	push	{r7, lr}
 800dd60:	b084      	sub	sp, #16
 800dd62:	af00      	add	r7, sp, #0
 800dd64:	6078      	str	r0, [r7, #4]
 800dd66:	460b      	mov	r3, r1
 800dd68:	70fb      	strb	r3, [r7, #3]
  stts22h_ctrl_t ctrl;
  int32_t ret;

  ret = stts22h_read_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800dd6a:	f107 0208 	add.w	r2, r7, #8
 800dd6e:	2301      	movs	r3, #1
 800dd70:	2104      	movs	r1, #4
 800dd72:	6878      	ldr	r0, [r7, #4]
 800dd74:	f7ff fdd4 	bl	800d920 <stts22h_read_reg>
 800dd78:	60f8      	str	r0, [r7, #12]

  if (ret == 0)
 800dd7a:	68fb      	ldr	r3, [r7, #12]
 800dd7c:	2b00      	cmp	r3, #0
 800dd7e:	d10f      	bne.n	800dda0 <stts22h_auto_increment_set+0x42>
  {
    ctrl.if_add_inc = (uint8_t)val;
 800dd80:	78fb      	ldrb	r3, [r7, #3]
 800dd82:	f003 0301 	and.w	r3, r3, #1
 800dd86:	b2da      	uxtb	r2, r3
 800dd88:	7a3b      	ldrb	r3, [r7, #8]
 800dd8a:	f362 03c3 	bfi	r3, r2, #3, #1
 800dd8e:	723b      	strb	r3, [r7, #8]
    ret = stts22h_write_reg(ctx, STTS22H_CTRL, (uint8_t *)&ctrl, 1);
 800dd90:	f107 0208 	add.w	r2, r7, #8
 800dd94:	2301      	movs	r3, #1
 800dd96:	2104      	movs	r1, #4
 800dd98:	6878      	ldr	r0, [r7, #4]
 800dd9a:	f7ff fdd9 	bl	800d950 <stts22h_write_reg>
 800dd9e:	60f8      	str	r0, [r7, #12]
  }

  return ret;
 800dda0:	68fb      	ldr	r3, [r7, #12]
}
 800dda2:	4618      	mov	r0, r3
 800dda4:	3710      	adds	r7, #16
 800dda6:	46bd      	mov	sp, r7
 800dda8:	bd80      	pop	{r7, pc}
	...

0800ddac <IKS4A1_ENV_SENSOR_Init>:
  *         - ENV_PRESSURE
  *         - ENV_HUMIDITY
  * @retval BSP status
  */
int32_t IKS4A1_ENV_SENSOR_Init(uint32_t Instance, uint32_t Functions)
{
 800ddac:	b580      	push	{r7, lr}
 800ddae:	b08c      	sub	sp, #48	@ 0x30
 800ddb0:	af00      	add	r7, sp, #0
 800ddb2:	6078      	str	r0, [r7, #4]
 800ddb4:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
 800ddb6:	2300      	movs	r3, #0
 800ddb8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t function = ENV_TEMPERATURE;
 800ddba:	2301      	movs	r3, #1
 800ddbc:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t i;
  uint32_t component_functions = 0;
 800ddbe:	2300      	movs	r3, #0
 800ddc0:	623b      	str	r3, [r7, #32]
  IKS4A1_ENV_SENSOR_Capabilities_t cap;

  switch (Instance)
 800ddc2:	687b      	ldr	r3, [r7, #4]
 800ddc4:	2b02      	cmp	r3, #2
 800ddc6:	d07c      	beq.n	800dec2 <IKS4A1_ENV_SENSOR_Init+0x116>
 800ddc8:	687b      	ldr	r3, [r7, #4]
 800ddca:	2b02      	cmp	r3, #2
 800ddcc:	f200 80b2 	bhi.w	800df34 <IKS4A1_ENV_SENSOR_Init+0x188>
 800ddd0:	687b      	ldr	r3, [r7, #4]
 800ddd2:	2b00      	cmp	r3, #0
 800ddd4:	d003      	beq.n	800ddde <IKS4A1_ENV_SENSOR_Init+0x32>
 800ddd6:	687b      	ldr	r3, [r7, #4]
 800ddd8:	2b01      	cmp	r3, #1
 800ddda:	d039      	beq.n	800de50 <IKS4A1_ENV_SENSOR_Init+0xa4>
 800dddc:	e0aa      	b.n	800df34 <IKS4A1_ENV_SENSOR_Init+0x188>
      break;
#endif

#if (USE_IKS4A1_ENV_SENSOR_STTS22H_0 == 1)
    case IKS4A1_STTS22H_0:
      if (STTS22H_0_Probe(Functions) != BSP_ERROR_NONE)
 800ddde:	6838      	ldr	r0, [r7, #0]
 800dde0:	f000 f8f2 	bl	800dfc8 <STTS22H_0_Probe>
 800dde4:	4603      	mov	r3, r0
 800dde6:	2b00      	cmp	r3, #0
 800dde8:	d002      	beq.n	800ddf0 <IKS4A1_ENV_SENSOR_Init+0x44>
      {
        return BSP_ERROR_NO_INIT;
 800ddea:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800ddee:	e0df      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
      }
      if (EnvDrv[Instance]->GetCapabilities(EnvCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800ddf0:	4a71      	ldr	r2, [pc, #452]	@ (800dfb8 <IKS4A1_ENV_SENSOR_Init+0x20c>)
 800ddf2:	687b      	ldr	r3, [r7, #4]
 800ddf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ddf8:	68db      	ldr	r3, [r3, #12]
 800ddfa:	4970      	ldr	r1, [pc, #448]	@ (800dfbc <IKS4A1_ENV_SENSOR_Init+0x210>)
 800ddfc:	687a      	ldr	r2, [r7, #4]
 800ddfe:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800de02:	f107 0108 	add.w	r1, r7, #8
 800de06:	4610      	mov	r0, r2
 800de08:	4798      	blx	r3
 800de0a:	4603      	mov	r3, r0
 800de0c:	2b00      	cmp	r3, #0
 800de0e:	d002      	beq.n	800de16 <IKS4A1_ENV_SENSOR_Init+0x6a>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800de10:	f06f 0306 	mvn.w	r3, #6
 800de14:	e0cc      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
      }
      if (cap.Temperature == 1U)
 800de16:	7a3b      	ldrb	r3, [r7, #8]
 800de18:	2b01      	cmp	r3, #1
 800de1a:	d103      	bne.n	800de24 <IKS4A1_ENV_SENSOR_Init+0x78>
      {
        component_functions |= ENV_TEMPERATURE;
 800de1c:	6a3b      	ldr	r3, [r7, #32]
 800de1e:	f043 0301 	orr.w	r3, r3, #1
 800de22:	623b      	str	r3, [r7, #32]
      }
      if (cap.Humidity == 1U)
 800de24:	7abb      	ldrb	r3, [r7, #10]
 800de26:	2b01      	cmp	r3, #1
 800de28:	d103      	bne.n	800de32 <IKS4A1_ENV_SENSOR_Init+0x86>
      {
        component_functions |= ENV_HUMIDITY;
 800de2a:	6a3b      	ldr	r3, [r7, #32]
 800de2c:	f043 0304 	orr.w	r3, r3, #4
 800de30:	623b      	str	r3, [r7, #32]
      }
      if (cap.Pressure == 1U)
 800de32:	7a7b      	ldrb	r3, [r7, #9]
 800de34:	2b01      	cmp	r3, #1
 800de36:	d103      	bne.n	800de40 <IKS4A1_ENV_SENSOR_Init+0x94>
      {
        component_functions |= ENV_PRESSURE;
 800de38:	6a3b      	ldr	r3, [r7, #32]
 800de3a:	f043 0302 	orr.w	r3, r3, #2
 800de3e:	623b      	str	r3, [r7, #32]
      }
      if (cap.Gas == 1U)
 800de40:	7afb      	ldrb	r3, [r7, #11]
 800de42:	2b01      	cmp	r3, #1
 800de44:	d17a      	bne.n	800df3c <IKS4A1_ENV_SENSOR_Init+0x190>
      {
        component_functions |= ENV_GAS;
 800de46:	6a3b      	ldr	r3, [r7, #32]
 800de48:	f043 0308 	orr.w	r3, r3, #8
 800de4c:	623b      	str	r3, [r7, #32]
      }
      break;
 800de4e:	e075      	b.n	800df3c <IKS4A1_ENV_SENSOR_Init+0x190>
      break;
#endif

#if (USE_IKS4A1_ENV_SENSOR_LPS22DF_0 == 1)
    case IKS4A1_LPS22DF_0:
      if (LPS22DF_0_Probe(Functions) != BSP_ERROR_NONE)
 800de50:	6838      	ldr	r0, [r7, #0]
 800de52:	f000 f96f 	bl	800e134 <LPS22DF_0_Probe>
 800de56:	4603      	mov	r3, r0
 800de58:	2b00      	cmp	r3, #0
 800de5a:	d002      	beq.n	800de62 <IKS4A1_ENV_SENSOR_Init+0xb6>
      {
        return BSP_ERROR_NO_INIT;
 800de5c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800de60:	e0a6      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
      }
      if (EnvDrv[Instance]->GetCapabilities(EnvCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800de62:	4a55      	ldr	r2, [pc, #340]	@ (800dfb8 <IKS4A1_ENV_SENSOR_Init+0x20c>)
 800de64:	687b      	ldr	r3, [r7, #4]
 800de66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800de6a:	68db      	ldr	r3, [r3, #12]
 800de6c:	4953      	ldr	r1, [pc, #332]	@ (800dfbc <IKS4A1_ENV_SENSOR_Init+0x210>)
 800de6e:	687a      	ldr	r2, [r7, #4]
 800de70:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800de74:	f107 0108 	add.w	r1, r7, #8
 800de78:	4610      	mov	r0, r2
 800de7a:	4798      	blx	r3
 800de7c:	4603      	mov	r3, r0
 800de7e:	2b00      	cmp	r3, #0
 800de80:	d002      	beq.n	800de88 <IKS4A1_ENV_SENSOR_Init+0xdc>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800de82:	f06f 0306 	mvn.w	r3, #6
 800de86:	e093      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
      }
      if (cap.Temperature == 1U)
 800de88:	7a3b      	ldrb	r3, [r7, #8]
 800de8a:	2b01      	cmp	r3, #1
 800de8c:	d103      	bne.n	800de96 <IKS4A1_ENV_SENSOR_Init+0xea>
      {
        component_functions |= ENV_TEMPERATURE;
 800de8e:	6a3b      	ldr	r3, [r7, #32]
 800de90:	f043 0301 	orr.w	r3, r3, #1
 800de94:	623b      	str	r3, [r7, #32]
      }
      if (cap.Humidity == 1U)
 800de96:	7abb      	ldrb	r3, [r7, #10]
 800de98:	2b01      	cmp	r3, #1
 800de9a:	d103      	bne.n	800dea4 <IKS4A1_ENV_SENSOR_Init+0xf8>
      {
        component_functions |= ENV_HUMIDITY;
 800de9c:	6a3b      	ldr	r3, [r7, #32]
 800de9e:	f043 0304 	orr.w	r3, r3, #4
 800dea2:	623b      	str	r3, [r7, #32]
      }
      if (cap.Pressure == 1U)
 800dea4:	7a7b      	ldrb	r3, [r7, #9]
 800dea6:	2b01      	cmp	r3, #1
 800dea8:	d103      	bne.n	800deb2 <IKS4A1_ENV_SENSOR_Init+0x106>
      {
        component_functions |= ENV_PRESSURE;
 800deaa:	6a3b      	ldr	r3, [r7, #32]
 800deac:	f043 0302 	orr.w	r3, r3, #2
 800deb0:	623b      	str	r3, [r7, #32]
      }
      if (cap.Gas == 1U)
 800deb2:	7afb      	ldrb	r3, [r7, #11]
 800deb4:	2b01      	cmp	r3, #1
 800deb6:	d143      	bne.n	800df40 <IKS4A1_ENV_SENSOR_Init+0x194>
      {
        component_functions |= ENV_GAS;
 800deb8:	6a3b      	ldr	r3, [r7, #32]
 800deba:	f043 0308 	orr.w	r3, r3, #8
 800debe:	623b      	str	r3, [r7, #32]
      }
      break;
 800dec0:	e03e      	b.n	800df40 <IKS4A1_ENV_SENSOR_Init+0x194>
      break;
#endif

#if (USE_IKS4A1_ENV_SENSOR_SHT40AD1B_0 == 1)
    case IKS4A1_SHT40AD1B_0:
      if (SHT40AD1B_0_Probe(Functions) != BSP_ERROR_NONE)
 800dec2:	6838      	ldr	r0, [r7, #0]
 800dec4:	f000 fa06 	bl	800e2d4 <SHT40AD1B_0_Probe>
 800dec8:	4603      	mov	r3, r0
 800deca:	2b00      	cmp	r3, #0
 800decc:	d002      	beq.n	800ded4 <IKS4A1_ENV_SENSOR_Init+0x128>
      {
        return BSP_ERROR_NO_INIT;
 800dece:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800ded2:	e06d      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
      }
      if (EnvDrv[Instance]->GetCapabilities(EnvCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800ded4:	4a38      	ldr	r2, [pc, #224]	@ (800dfb8 <IKS4A1_ENV_SENSOR_Init+0x20c>)
 800ded6:	687b      	ldr	r3, [r7, #4]
 800ded8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800dedc:	68db      	ldr	r3, [r3, #12]
 800dede:	4937      	ldr	r1, [pc, #220]	@ (800dfbc <IKS4A1_ENV_SENSOR_Init+0x210>)
 800dee0:	687a      	ldr	r2, [r7, #4]
 800dee2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800dee6:	f107 0108 	add.w	r1, r7, #8
 800deea:	4610      	mov	r0, r2
 800deec:	4798      	blx	r3
 800deee:	4603      	mov	r3, r0
 800def0:	2b00      	cmp	r3, #0
 800def2:	d002      	beq.n	800defa <IKS4A1_ENV_SENSOR_Init+0x14e>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800def4:	f06f 0306 	mvn.w	r3, #6
 800def8:	e05a      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
      }
      if (cap.Temperature == 1U)
 800defa:	7a3b      	ldrb	r3, [r7, #8]
 800defc:	2b01      	cmp	r3, #1
 800defe:	d103      	bne.n	800df08 <IKS4A1_ENV_SENSOR_Init+0x15c>
      {
        component_functions |= ENV_TEMPERATURE;
 800df00:	6a3b      	ldr	r3, [r7, #32]
 800df02:	f043 0301 	orr.w	r3, r3, #1
 800df06:	623b      	str	r3, [r7, #32]
      }
      if (cap.Humidity == 1U)
 800df08:	7abb      	ldrb	r3, [r7, #10]
 800df0a:	2b01      	cmp	r3, #1
 800df0c:	d103      	bne.n	800df16 <IKS4A1_ENV_SENSOR_Init+0x16a>
      {
        component_functions |= ENV_HUMIDITY;
 800df0e:	6a3b      	ldr	r3, [r7, #32]
 800df10:	f043 0304 	orr.w	r3, r3, #4
 800df14:	623b      	str	r3, [r7, #32]
      }
      if (cap.Pressure == 1U)
 800df16:	7a7b      	ldrb	r3, [r7, #9]
 800df18:	2b01      	cmp	r3, #1
 800df1a:	d103      	bne.n	800df24 <IKS4A1_ENV_SENSOR_Init+0x178>
      {
        component_functions |= ENV_PRESSURE;
 800df1c:	6a3b      	ldr	r3, [r7, #32]
 800df1e:	f043 0302 	orr.w	r3, r3, #2
 800df22:	623b      	str	r3, [r7, #32]
      }
      if (cap.Gas == 1U)
 800df24:	7afb      	ldrb	r3, [r7, #11]
 800df26:	2b01      	cmp	r3, #1
 800df28:	d10c      	bne.n	800df44 <IKS4A1_ENV_SENSOR_Init+0x198>
      {
        component_functions |= ENV_GAS;
 800df2a:	6a3b      	ldr	r3, [r7, #32]
 800df2c:	f043 0308 	orr.w	r3, r3, #8
 800df30:	623b      	str	r3, [r7, #32]
      }
      break;
 800df32:	e007      	b.n	800df44 <IKS4A1_ENV_SENSOR_Init+0x198>
      }
      break;
#endif

    default:
      ret = BSP_ERROR_WRONG_PARAM;
 800df34:	f06f 0301 	mvn.w	r3, #1
 800df38:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
 800df3a:	e004      	b.n	800df46 <IKS4A1_ENV_SENSOR_Init+0x19a>
      break;
 800df3c:	bf00      	nop
 800df3e:	e002      	b.n	800df46 <IKS4A1_ENV_SENSOR_Init+0x19a>
      break;
 800df40:	bf00      	nop
 800df42:	e000      	b.n	800df46 <IKS4A1_ENV_SENSOR_Init+0x19a>
      break;
 800df44:	bf00      	nop
  }

  if (ret != BSP_ERROR_NONE)
 800df46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800df48:	2b00      	cmp	r3, #0
 800df4a:	d001      	beq.n	800df50 <IKS4A1_ENV_SENSOR_Init+0x1a4>
  {
    return ret;
 800df4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800df4e:	e02f      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
  }

  for (i = 0; i < IKS4A1_ENV_FUNCTIONS_NBR; i++)
 800df50:	2300      	movs	r3, #0
 800df52:	627b      	str	r3, [r7, #36]	@ 0x24
 800df54:	e028      	b.n	800dfa8 <IKS4A1_ENV_SENSOR_Init+0x1fc>
  {
    if (((Functions & function) == function) && ((component_functions & function) == function))
 800df56:	683a      	ldr	r2, [r7, #0]
 800df58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800df5a:	4013      	ands	r3, r2
 800df5c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800df5e:	429a      	cmp	r2, r3
 800df60:	d11c      	bne.n	800df9c <IKS4A1_ENV_SENSOR_Init+0x1f0>
 800df62:	6a3a      	ldr	r2, [r7, #32]
 800df64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800df66:	4013      	ands	r3, r2
 800df68:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800df6a:	429a      	cmp	r2, r3
 800df6c:	d116      	bne.n	800df9c <IKS4A1_ENV_SENSOR_Init+0x1f0>
    {
      if (EnvFuncDrv[Instance][FunctionIndex[function]]->Enable(EnvCompObj[Instance]) != BSP_ERROR_NONE)
 800df6e:	4a14      	ldr	r2, [pc, #80]	@ (800dfc0 <IKS4A1_ENV_SENSOR_Init+0x214>)
 800df70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800df72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800df76:	4913      	ldr	r1, [pc, #76]	@ (800dfc4 <IKS4A1_ENV_SENSOR_Init+0x218>)
 800df78:	687a      	ldr	r2, [r7, #4]
 800df7a:	0092      	lsls	r2, r2, #2
 800df7c:	4413      	add	r3, r2
 800df7e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800df82:	681b      	ldr	r3, [r3, #0]
 800df84:	490d      	ldr	r1, [pc, #52]	@ (800dfbc <IKS4A1_ENV_SENSOR_Init+0x210>)
 800df86:	687a      	ldr	r2, [r7, #4]
 800df88:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800df8c:	4610      	mov	r0, r2
 800df8e:	4798      	blx	r3
 800df90:	4603      	mov	r3, r0
 800df92:	2b00      	cmp	r3, #0
 800df94:	d002      	beq.n	800df9c <IKS4A1_ENV_SENSOR_Init+0x1f0>
      {
        return BSP_ERROR_COMPONENT_FAILURE;
 800df96:	f06f 0304 	mvn.w	r3, #4
 800df9a:	e009      	b.n	800dfb0 <IKS4A1_ENV_SENSOR_Init+0x204>
      }
    }
    function = function << 1;
 800df9c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800df9e:	005b      	lsls	r3, r3, #1
 800dfa0:	62bb      	str	r3, [r7, #40]	@ 0x28
  for (i = 0; i < IKS4A1_ENV_FUNCTIONS_NBR; i++)
 800dfa2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dfa4:	3301      	adds	r3, #1
 800dfa6:	627b      	str	r3, [r7, #36]	@ 0x24
 800dfa8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dfaa:	2b03      	cmp	r3, #3
 800dfac:	d9d3      	bls.n	800df56 <IKS4A1_ENV_SENSOR_Init+0x1aa>
  }

  return ret;
 800dfae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 800dfb0:	4618      	mov	r0, r3
 800dfb2:	3730      	adds	r7, #48	@ 0x30
 800dfb4:	46bd      	mov	sp, r7
 800dfb6:	bd80      	pop	{r7, pc}
 800dfb8:	200020b8 	.word	0x200020b8
 800dfbc:	2000207c 	.word	0x2000207c
 800dfc0:	200002f4 	.word	0x200002f4
 800dfc4:	20002088 	.word	0x20002088

0800dfc8 <STTS22H_0_Probe>:
  * @param  Functions Environmental sensor functions. Could be :
  *         - ENV_TEMPERATURE
  * @retval BSP status
  */
static int32_t STTS22H_0_Probe(uint32_t Functions)
{
 800dfc8:	b580      	push	{r7, lr}
 800dfca:	b092      	sub	sp, #72	@ 0x48
 800dfcc:	af00      	add	r7, sp, #0
 800dfce:	6078      	str	r0, [r7, #4]
  STTS22H_IO_t            io_ctx;
  uint8_t                 id;
  int32_t                 ret = BSP_ERROR_NONE;
 800dfd0:	2300      	movs	r3, #0
 800dfd2:	647b      	str	r3, [r7, #68]	@ 0x44
  static STTS22H_Object_t stts22h_obj_0;
  STTS22H_Capabilities_t  cap;

  /* Configure the driver */
  io_ctx.BusType     = STTS22H_I2C_BUS; /* I2C */
 800dfd4:	2300      	movs	r3, #0
 800dfd6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.Address     = STTS22H_I2C_ADD_H;
 800dfd8:	2371      	movs	r3, #113	@ 0x71
 800dfda:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  io_ctx.Init        = IKS4A1_I2C_Init;
 800dfde:	4b47      	ldr	r3, [pc, #284]	@ (800e0fc <STTS22H_0_Probe+0x134>)
 800dfe0:	627b      	str	r3, [r7, #36]	@ 0x24
  io_ctx.DeInit      = IKS4A1_I2C_DeInit;
 800dfe2:	4b47      	ldr	r3, [pc, #284]	@ (800e100 <STTS22H_0_Probe+0x138>)
 800dfe4:	62bb      	str	r3, [r7, #40]	@ 0x28
  io_ctx.ReadReg     = IKS4A1_I2C_ReadReg;
 800dfe6:	4b47      	ldr	r3, [pc, #284]	@ (800e104 <STTS22H_0_Probe+0x13c>)
 800dfe8:	63bb      	str	r3, [r7, #56]	@ 0x38
  io_ctx.WriteReg    = IKS4A1_I2C_WriteReg;
 800dfea:	4b47      	ldr	r3, [pc, #284]	@ (800e108 <STTS22H_0_Probe+0x140>)
 800dfec:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.GetTick     = IKS4A1_GetTick;
 800dfee:	4b47      	ldr	r3, [pc, #284]	@ (800e10c <STTS22H_0_Probe+0x144>)
 800dff0:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.Delay       = IKS4A1_Delay;
 800dff2:	4b47      	ldr	r3, [pc, #284]	@ (800e110 <STTS22H_0_Probe+0x148>)
 800dff4:	643b      	str	r3, [r7, #64]	@ 0x40

  if (STTS22H_RegisterBusIO(&stts22h_obj_0, &io_ctx) != STTS22H_OK)
 800dff6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800dffa:	4619      	mov	r1, r3
 800dffc:	4845      	ldr	r0, [pc, #276]	@ (800e114 <STTS22H_0_Probe+0x14c>)
 800dffe:	f7ff f9d3 	bl	800d3a8 <STTS22H_RegisterBusIO>
 800e002:	4603      	mov	r3, r0
 800e004:	2b00      	cmp	r3, #0
 800e006:	d003      	beq.n	800e010 <STTS22H_0_Probe+0x48>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e008:	f06f 0306 	mvn.w	r3, #6
 800e00c:	647b      	str	r3, [r7, #68]	@ 0x44
 800e00e:	e06f      	b.n	800e0f0 <STTS22H_0_Probe+0x128>
  }
  else if (STTS22H_ReadID(&stts22h_obj_0, &id) != STTS22H_OK)
 800e010:	f107 0323 	add.w	r3, r7, #35	@ 0x23
 800e014:	4619      	mov	r1, r3
 800e016:	483f      	ldr	r0, [pc, #252]	@ (800e114 <STTS22H_0_Probe+0x14c>)
 800e018:	f7ff fa65 	bl	800d4e6 <STTS22H_ReadID>
 800e01c:	4603      	mov	r3, r0
 800e01e:	2b00      	cmp	r3, #0
 800e020:	d003      	beq.n	800e02a <STTS22H_0_Probe+0x62>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e022:	f06f 0306 	mvn.w	r3, #6
 800e026:	647b      	str	r3, [r7, #68]	@ 0x44
 800e028:	e062      	b.n	800e0f0 <STTS22H_0_Probe+0x128>
  }
  else if (id != STTS22H_ID)
 800e02a:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 800e02e:	2ba0      	cmp	r3, #160	@ 0xa0
 800e030:	d003      	beq.n	800e03a <STTS22H_0_Probe+0x72>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e032:	f06f 0306 	mvn.w	r3, #6
 800e036:	647b      	str	r3, [r7, #68]	@ 0x44
 800e038:	e05a      	b.n	800e0f0 <STTS22H_0_Probe+0x128>
  }
  else
  {
    (void)STTS22H_GetCapabilities(&stts22h_obj_0, &cap);
 800e03a:	f107 0308 	add.w	r3, r7, #8
 800e03e:	4619      	mov	r1, r3
 800e040:	4834      	ldr	r0, [pc, #208]	@ (800e114 <STTS22H_0_Probe+0x14c>)
 800e042:	f7ff fa6b 	bl	800d51c <STTS22H_GetCapabilities>

    EnvCtx[IKS4A1_STTS22H_0].Functions = ((uint32_t)cap.Temperature)
 800e046:	7a3b      	ldrb	r3, [r7, #8]
 800e048:	461a      	mov	r2, r3
                                       | ((uint32_t)cap.Pressure << 1)
 800e04a:	7a7b      	ldrb	r3, [r7, #9]
 800e04c:	005b      	lsls	r3, r3, #1
 800e04e:	431a      	orrs	r2, r3
                                       | ((uint32_t)cap.Humidity << 2)
 800e050:	7abb      	ldrb	r3, [r7, #10]
 800e052:	009b      	lsls	r3, r3, #2
 800e054:	431a      	orrs	r2, r3
                                       | ((uint32_t)cap.Gas      << 3);
 800e056:	7afb      	ldrb	r3, [r7, #11]
 800e058:	00db      	lsls	r3, r3, #3
 800e05a:	4313      	orrs	r3, r2
    EnvCtx[IKS4A1_STTS22H_0].Functions = ((uint32_t)cap.Temperature)
 800e05c:	4a2e      	ldr	r2, [pc, #184]	@ (800e118 <STTS22H_0_Probe+0x150>)
 800e05e:	6013      	str	r3, [r2, #0]

    EnvCompObj[IKS4A1_STTS22H_0] = &stts22h_obj_0;
 800e060:	4b2e      	ldr	r3, [pc, #184]	@ (800e11c <STTS22H_0_Probe+0x154>)
 800e062:	4a2c      	ldr	r2, [pc, #176]	@ (800e114 <STTS22H_0_Probe+0x14c>)
 800e064:	601a      	str	r2, [r3, #0]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    EnvDrv[IKS4A1_STTS22H_0] = (ENV_SENSOR_CommonDrv_t *)(void *)&STTS22H_COMMON_Driver;
 800e066:	4b2e      	ldr	r3, [pc, #184]	@ (800e120 <STTS22H_0_Probe+0x158>)
 800e068:	4a2e      	ldr	r2, [pc, #184]	@ (800e124 <STTS22H_0_Probe+0x15c>)
 800e06a:	601a      	str	r2, [r3, #0]

    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_TEMPERATURE) == ENV_TEMPERATURE) && (cap.Temperature == 1U))
 800e06c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e06e:	2b00      	cmp	r3, #0
 800e070:	d11d      	bne.n	800e0ae <STTS22H_0_Probe+0xe6>
 800e072:	687b      	ldr	r3, [r7, #4]
 800e074:	f003 0301 	and.w	r3, r3, #1
 800e078:	2b00      	cmp	r3, #0
 800e07a:	d018      	beq.n	800e0ae <STTS22H_0_Probe+0xe6>
 800e07c:	7a3b      	ldrb	r3, [r7, #8]
 800e07e:	2b01      	cmp	r3, #1
 800e080:	d115      	bne.n	800e0ae <STTS22H_0_Probe+0xe6>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[IKS4A1_STTS22H_0][FunctionIndex[ENV_TEMPERATURE]] = (ENV_SENSOR_FuncDrv_t *)(void *)&STTS22H_TEMP_Driver;
 800e082:	4b29      	ldr	r3, [pc, #164]	@ (800e128 <STTS22H_0_Probe+0x160>)
 800e084:	685b      	ldr	r3, [r3, #4]
 800e086:	4a29      	ldr	r2, [pc, #164]	@ (800e12c <STTS22H_0_Probe+0x164>)
 800e088:	4929      	ldr	r1, [pc, #164]	@ (800e130 <STTS22H_0_Probe+0x168>)
 800e08a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[IKS4A1_STTS22H_0]->Init(EnvCompObj[IKS4A1_STTS22H_0]) != STTS22H_OK)
 800e08e:	4b24      	ldr	r3, [pc, #144]	@ (800e120 <STTS22H_0_Probe+0x158>)
 800e090:	681b      	ldr	r3, [r3, #0]
 800e092:	681b      	ldr	r3, [r3, #0]
 800e094:	4a21      	ldr	r2, [pc, #132]	@ (800e11c <STTS22H_0_Probe+0x154>)
 800e096:	6812      	ldr	r2, [r2, #0]
 800e098:	4610      	mov	r0, r2
 800e09a:	4798      	blx	r3
 800e09c:	4603      	mov	r3, r0
 800e09e:	2b00      	cmp	r3, #0
 800e0a0:	d003      	beq.n	800e0aa <STTS22H_0_Probe+0xe2>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e0a2:	f06f 0304 	mvn.w	r3, #4
 800e0a6:	647b      	str	r3, [r7, #68]	@ 0x44
 800e0a8:	e001      	b.n	800e0ae <STTS22H_0_Probe+0xe6>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e0aa:	2300      	movs	r3, #0
 800e0ac:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_HUMIDITY) == ENV_HUMIDITY))
 800e0ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e0b0:	2b00      	cmp	r3, #0
 800e0b2:	d107      	bne.n	800e0c4 <STTS22H_0_Probe+0xfc>
 800e0b4:	687b      	ldr	r3, [r7, #4]
 800e0b6:	f003 0304 	and.w	r3, r3, #4
 800e0ba:	2b00      	cmp	r3, #0
 800e0bc:	d002      	beq.n	800e0c4 <STTS22H_0_Probe+0xfc>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e0be:	f06f 0304 	mvn.w	r3, #4
 800e0c2:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_PRESSURE) == ENV_PRESSURE))
 800e0c4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e0c6:	2b00      	cmp	r3, #0
 800e0c8:	d107      	bne.n	800e0da <STTS22H_0_Probe+0x112>
 800e0ca:	687b      	ldr	r3, [r7, #4]
 800e0cc:	f003 0302 	and.w	r3, r3, #2
 800e0d0:	2b00      	cmp	r3, #0
 800e0d2:	d002      	beq.n	800e0da <STTS22H_0_Probe+0x112>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e0d4:	f06f 0304 	mvn.w	r3, #4
 800e0d8:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_GAS) == ENV_GAS))
 800e0da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e0dc:	2b00      	cmp	r3, #0
 800e0de:	d107      	bne.n	800e0f0 <STTS22H_0_Probe+0x128>
 800e0e0:	687b      	ldr	r3, [r7, #4]
 800e0e2:	f003 0308 	and.w	r3, r3, #8
 800e0e6:	2b00      	cmp	r3, #0
 800e0e8:	d002      	beq.n	800e0f0 <STTS22H_0_Probe+0x128>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e0ea:	f06f 0304 	mvn.w	r3, #4
 800e0ee:	647b      	str	r3, [r7, #68]	@ 0x44
    }
  }

  return ret;
 800e0f0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 800e0f2:	4618      	mov	r0, r3
 800e0f4:	3748      	adds	r7, #72	@ 0x48
 800e0f6:	46bd      	mov	sp, r7
 800e0f8:	bd80      	pop	{r7, pc}
 800e0fa:	bf00      	nop
 800e0fc:	08005bd5 	.word	0x08005bd5
 800e100:	08005c39 	.word	0x08005c39
 800e104:	08005ced 	.word	0x08005ced
 800e108:	08005c89 	.word	0x08005c89
 800e10c:	08005df9 	.word	0x08005df9
 800e110:	0800f315 	.word	0x0800f315
 800e114:	200020d0 	.word	0x200020d0
 800e118:	200020c4 	.word	0x200020c4
 800e11c:	2000207c 	.word	0x2000207c
 800e120:	200020b8 	.word	0x200020b8
 800e124:	200002d0 	.word	0x200002d0
 800e128:	200002f4 	.word	0x200002f4
 800e12c:	20002088 	.word	0x20002088
 800e130:	200002e0 	.word	0x200002e0

0800e134 <LPS22DF_0_Probe>:
  * @param  Functions Environmental sensor functions. Could be :
  *         - ENV_TEMPERATURE and/or ENV_PRESSURE
  * @retval BSP status
  */
static int32_t LPS22DF_0_Probe(uint32_t Functions)
{
 800e134:	b580      	push	{r7, lr}
 800e136:	b092      	sub	sp, #72	@ 0x48
 800e138:	af00      	add	r7, sp, #0
 800e13a:	6078      	str	r0, [r7, #4]
  LPS22DF_IO_t            io_ctx;
  uint8_t                 id;
  int32_t                 ret = BSP_ERROR_NONE;
 800e13c:	2300      	movs	r3, #0
 800e13e:	647b      	str	r3, [r7, #68]	@ 0x44
  static LPS22DF_Object_t lps22df_obj_0;
  LPS22DF_Capabilities_t  cap;

  /* Configure the driver */
  io_ctx.BusType     = LPS22DF_I2C_BUS; /* I2C */
 800e140:	2300      	movs	r3, #0
 800e142:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.Address     = LPS22DF_I2C_ADD_H;
 800e144:	23bb      	movs	r3, #187	@ 0xbb
 800e146:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  io_ctx.Init        = IKS4A1_I2C_Init;
 800e14a:	4b53      	ldr	r3, [pc, #332]	@ (800e298 <LPS22DF_0_Probe+0x164>)
 800e14c:	627b      	str	r3, [r7, #36]	@ 0x24
  io_ctx.DeInit      = IKS4A1_I2C_DeInit;
 800e14e:	4b53      	ldr	r3, [pc, #332]	@ (800e29c <LPS22DF_0_Probe+0x168>)
 800e150:	62bb      	str	r3, [r7, #40]	@ 0x28
  io_ctx.ReadReg     = IKS4A1_I2C_ReadReg;
 800e152:	4b53      	ldr	r3, [pc, #332]	@ (800e2a0 <LPS22DF_0_Probe+0x16c>)
 800e154:	63bb      	str	r3, [r7, #56]	@ 0x38
  io_ctx.WriteReg    = IKS4A1_I2C_WriteReg;
 800e156:	4b53      	ldr	r3, [pc, #332]	@ (800e2a4 <LPS22DF_0_Probe+0x170>)
 800e158:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.GetTick     = IKS4A1_GetTick;
 800e15a:	4b53      	ldr	r3, [pc, #332]	@ (800e2a8 <LPS22DF_0_Probe+0x174>)
 800e15c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.Delay       = IKS4A1_Delay;
 800e15e:	4b53      	ldr	r3, [pc, #332]	@ (800e2ac <LPS22DF_0_Probe+0x178>)
 800e160:	643b      	str	r3, [r7, #64]	@ 0x40

  if (LPS22DF_RegisterBusIO(&lps22df_obj_0, &io_ctx) != LPS22DF_OK)
 800e162:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800e166:	4619      	mov	r1, r3
 800e168:	4851      	ldr	r0, [pc, #324]	@ (800e2b0 <LPS22DF_0_Probe+0x17c>)
 800e16a:	f7fa fc17 	bl	800899c <LPS22DF_RegisterBusIO>
 800e16e:	4603      	mov	r3, r0
 800e170:	2b00      	cmp	r3, #0
 800e172:	d003      	beq.n	800e17c <LPS22DF_0_Probe+0x48>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e174:	f06f 0306 	mvn.w	r3, #6
 800e178:	647b      	str	r3, [r7, #68]	@ 0x44
 800e17a:	e087      	b.n	800e28c <LPS22DF_0_Probe+0x158>
  }
  else if (LPS22DF_ReadID(&lps22df_obj_0, &id) != LPS22DF_OK)
 800e17c:	f107 0323 	add.w	r3, r7, #35	@ 0x23
 800e180:	4619      	mov	r1, r3
 800e182:	484b      	ldr	r0, [pc, #300]	@ (800e2b0 <LPS22DF_0_Probe+0x17c>)
 800e184:	f7fa fcb3 	bl	8008aee <LPS22DF_ReadID>
 800e188:	4603      	mov	r3, r0
 800e18a:	2b00      	cmp	r3, #0
 800e18c:	d003      	beq.n	800e196 <LPS22DF_0_Probe+0x62>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e18e:	f06f 0306 	mvn.w	r3, #6
 800e192:	647b      	str	r3, [r7, #68]	@ 0x44
 800e194:	e07a      	b.n	800e28c <LPS22DF_0_Probe+0x158>
  }
  else if (id != LPS22DF_ID)
 800e196:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 800e19a:	2bb4      	cmp	r3, #180	@ 0xb4
 800e19c:	d003      	beq.n	800e1a6 <LPS22DF_0_Probe+0x72>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e19e:	f06f 0306 	mvn.w	r3, #6
 800e1a2:	647b      	str	r3, [r7, #68]	@ 0x44
 800e1a4:	e072      	b.n	800e28c <LPS22DF_0_Probe+0x158>
  }
  else
  {
    (void)LPS22DF_GetCapabilities(&lps22df_obj_0, &cap);
 800e1a6:	f107 0308 	add.w	r3, r7, #8
 800e1aa:	4619      	mov	r1, r3
 800e1ac:	4840      	ldr	r0, [pc, #256]	@ (800e2b0 <LPS22DF_0_Probe+0x17c>)
 800e1ae:	f7fa fcb9 	bl	8008b24 <LPS22DF_GetCapabilities>

    EnvCtx[IKS4A1_LPS22DF_0].Functions = ((uint32_t)cap.Temperature)
 800e1b2:	7a3b      	ldrb	r3, [r7, #8]
 800e1b4:	461a      	mov	r2, r3
                                       | ((uint32_t)cap.Pressure << 1)
 800e1b6:	7a7b      	ldrb	r3, [r7, #9]
 800e1b8:	005b      	lsls	r3, r3, #1
 800e1ba:	431a      	orrs	r2, r3
                                       | ((uint32_t)cap.Humidity << 2)
 800e1bc:	7abb      	ldrb	r3, [r7, #10]
 800e1be:	009b      	lsls	r3, r3, #2
 800e1c0:	431a      	orrs	r2, r3
                                       | ((uint32_t)cap.Gas      << 3);
 800e1c2:	7afb      	ldrb	r3, [r7, #11]
 800e1c4:	00db      	lsls	r3, r3, #3
 800e1c6:	4313      	orrs	r3, r2
    EnvCtx[IKS4A1_LPS22DF_0].Functions = ((uint32_t)cap.Temperature)
 800e1c8:	4a3a      	ldr	r2, [pc, #232]	@ (800e2b4 <LPS22DF_0_Probe+0x180>)
 800e1ca:	6053      	str	r3, [r2, #4]

    EnvCompObj[IKS4A1_LPS22DF_0] = &lps22df_obj_0;
 800e1cc:	4b3a      	ldr	r3, [pc, #232]	@ (800e2b8 <LPS22DF_0_Probe+0x184>)
 800e1ce:	4a38      	ldr	r2, [pc, #224]	@ (800e2b0 <LPS22DF_0_Probe+0x17c>)
 800e1d0:	605a      	str	r2, [r3, #4]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    EnvDrv[IKS4A1_LPS22DF_0] = (ENV_SENSOR_CommonDrv_t *)(void *)&LPS22DF_COMMON_Driver;
 800e1d2:	4b3a      	ldr	r3, [pc, #232]	@ (800e2bc <LPS22DF_0_Probe+0x188>)
 800e1d4:	4a3a      	ldr	r2, [pc, #232]	@ (800e2c0 <LPS22DF_0_Probe+0x18c>)
 800e1d6:	605a      	str	r2, [r3, #4]

    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_TEMPERATURE) == ENV_TEMPERATURE) && (cap.Temperature == 1U))
 800e1d8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e1da:	2b00      	cmp	r3, #0
 800e1dc:	d11e      	bne.n	800e21c <LPS22DF_0_Probe+0xe8>
 800e1de:	687b      	ldr	r3, [r7, #4]
 800e1e0:	f003 0301 	and.w	r3, r3, #1
 800e1e4:	2b00      	cmp	r3, #0
 800e1e6:	d019      	beq.n	800e21c <LPS22DF_0_Probe+0xe8>
 800e1e8:	7a3b      	ldrb	r3, [r7, #8]
 800e1ea:	2b01      	cmp	r3, #1
 800e1ec:	d116      	bne.n	800e21c <LPS22DF_0_Probe+0xe8>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[IKS4A1_LPS22DF_0][FunctionIndex[ENV_TEMPERATURE]] = (ENV_SENSOR_FuncDrv_t *)(void *)&LPS22DF_TEMP_Driver;
 800e1ee:	4b35      	ldr	r3, [pc, #212]	@ (800e2c4 <LPS22DF_0_Probe+0x190>)
 800e1f0:	685b      	ldr	r3, [r3, #4]
 800e1f2:	4a35      	ldr	r2, [pc, #212]	@ (800e2c8 <LPS22DF_0_Probe+0x194>)
 800e1f4:	3304      	adds	r3, #4
 800e1f6:	4935      	ldr	r1, [pc, #212]	@ (800e2cc <LPS22DF_0_Probe+0x198>)
 800e1f8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[IKS4A1_LPS22DF_0]->Init(EnvCompObj[IKS4A1_LPS22DF_0]) != LPS22DF_OK)
 800e1fc:	4b2f      	ldr	r3, [pc, #188]	@ (800e2bc <LPS22DF_0_Probe+0x188>)
 800e1fe:	685b      	ldr	r3, [r3, #4]
 800e200:	681b      	ldr	r3, [r3, #0]
 800e202:	4a2d      	ldr	r2, [pc, #180]	@ (800e2b8 <LPS22DF_0_Probe+0x184>)
 800e204:	6852      	ldr	r2, [r2, #4]
 800e206:	4610      	mov	r0, r2
 800e208:	4798      	blx	r3
 800e20a:	4603      	mov	r3, r0
 800e20c:	2b00      	cmp	r3, #0
 800e20e:	d003      	beq.n	800e218 <LPS22DF_0_Probe+0xe4>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e210:	f06f 0304 	mvn.w	r3, #4
 800e214:	647b      	str	r3, [r7, #68]	@ 0x44
 800e216:	e001      	b.n	800e21c <LPS22DF_0_Probe+0xe8>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e218:	2300      	movs	r3, #0
 800e21a:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_PRESSURE) == ENV_PRESSURE) && (cap.Pressure == 1U))
 800e21c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e21e:	2b00      	cmp	r3, #0
 800e220:	d11e      	bne.n	800e260 <LPS22DF_0_Probe+0x12c>
 800e222:	687b      	ldr	r3, [r7, #4]
 800e224:	f003 0302 	and.w	r3, r3, #2
 800e228:	2b00      	cmp	r3, #0
 800e22a:	d019      	beq.n	800e260 <LPS22DF_0_Probe+0x12c>
 800e22c:	7a7b      	ldrb	r3, [r7, #9]
 800e22e:	2b01      	cmp	r3, #1
 800e230:	d116      	bne.n	800e260 <LPS22DF_0_Probe+0x12c>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[IKS4A1_LPS22DF_0][FunctionIndex[ENV_PRESSURE]] = (ENV_SENSOR_FuncDrv_t *)(void *)&LPS22DF_PRESS_Driver;
 800e232:	4b24      	ldr	r3, [pc, #144]	@ (800e2c4 <LPS22DF_0_Probe+0x190>)
 800e234:	689b      	ldr	r3, [r3, #8]
 800e236:	4a24      	ldr	r2, [pc, #144]	@ (800e2c8 <LPS22DF_0_Probe+0x194>)
 800e238:	3304      	adds	r3, #4
 800e23a:	4925      	ldr	r1, [pc, #148]	@ (800e2d0 <LPS22DF_0_Probe+0x19c>)
 800e23c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[IKS4A1_LPS22DF_0]->Init(EnvCompObj[IKS4A1_LPS22DF_0]) != LPS22DF_OK)
 800e240:	4b1e      	ldr	r3, [pc, #120]	@ (800e2bc <LPS22DF_0_Probe+0x188>)
 800e242:	685b      	ldr	r3, [r3, #4]
 800e244:	681b      	ldr	r3, [r3, #0]
 800e246:	4a1c      	ldr	r2, [pc, #112]	@ (800e2b8 <LPS22DF_0_Probe+0x184>)
 800e248:	6852      	ldr	r2, [r2, #4]
 800e24a:	4610      	mov	r0, r2
 800e24c:	4798      	blx	r3
 800e24e:	4603      	mov	r3, r0
 800e250:	2b00      	cmp	r3, #0
 800e252:	d003      	beq.n	800e25c <LPS22DF_0_Probe+0x128>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e254:	f06f 0304 	mvn.w	r3, #4
 800e258:	647b      	str	r3, [r7, #68]	@ 0x44
 800e25a:	e001      	b.n	800e260 <LPS22DF_0_Probe+0x12c>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e25c:	2300      	movs	r3, #0
 800e25e:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_HUMIDITY) == ENV_HUMIDITY))
 800e260:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e262:	2b00      	cmp	r3, #0
 800e264:	d107      	bne.n	800e276 <LPS22DF_0_Probe+0x142>
 800e266:	687b      	ldr	r3, [r7, #4]
 800e268:	f003 0304 	and.w	r3, r3, #4
 800e26c:	2b00      	cmp	r3, #0
 800e26e:	d002      	beq.n	800e276 <LPS22DF_0_Probe+0x142>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e270:	f06f 0304 	mvn.w	r3, #4
 800e274:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_GAS) == ENV_GAS))
 800e276:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e278:	2b00      	cmp	r3, #0
 800e27a:	d107      	bne.n	800e28c <LPS22DF_0_Probe+0x158>
 800e27c:	687b      	ldr	r3, [r7, #4]
 800e27e:	f003 0308 	and.w	r3, r3, #8
 800e282:	2b00      	cmp	r3, #0
 800e284:	d002      	beq.n	800e28c <LPS22DF_0_Probe+0x158>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e286:	f06f 0304 	mvn.w	r3, #4
 800e28a:	647b      	str	r3, [r7, #68]	@ 0x44
    }
  }

  return ret;
 800e28c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 800e28e:	4618      	mov	r0, r3
 800e290:	3748      	adds	r7, #72	@ 0x48
 800e292:	46bd      	mov	sp, r7
 800e294:	bd80      	pop	{r7, pc}
 800e296:	bf00      	nop
 800e298:	08005bd5 	.word	0x08005bd5
 800e29c:	08005c39 	.word	0x08005c39
 800e2a0:	08005ced 	.word	0x08005ced
 800e2a4:	08005c89 	.word	0x08005c89
 800e2a8:	08005df9 	.word	0x08005df9
 800e2ac:	0800f315 	.word	0x0800f315
 800e2b0:	20002108 	.word	0x20002108
 800e2b4:	200020c4 	.word	0x200020c4
 800e2b8:	2000207c 	.word	0x2000207c
 800e2bc:	200020b8 	.word	0x200020b8
 800e2c0:	200001b0 	.word	0x200001b0
 800e2c4:	200002f4 	.word	0x200002f4
 800e2c8:	20002088 	.word	0x20002088
 800e2cc:	200001d4 	.word	0x200001d4
 800e2d0:	200001c0 	.word	0x200001c0

0800e2d4 <SHT40AD1B_0_Probe>:
  * @param  Functions Environmental sensor functions. Could be :
  *         - ENV_TEMPERATURE and/or ENV_HUMIDITY
  * @retval BSP status
  */
static int32_t SHT40AD1B_0_Probe(uint32_t Functions)
{
 800e2d4:	b580      	push	{r7, lr}
 800e2d6:	b092      	sub	sp, #72	@ 0x48
 800e2d8:	af00      	add	r7, sp, #0
 800e2da:	6078      	str	r0, [r7, #4]
  SHT40AD1B_IO_t            io_ctx;
  uint8_t                   id;
  int32_t                   ret = BSP_ERROR_NONE;
 800e2dc:	2300      	movs	r3, #0
 800e2de:	647b      	str	r3, [r7, #68]	@ 0x44
  static SHT40AD1B_Object_t sht40ad1b_obj_0;
  SHT40AD1B_Capabilities_t  cap;

  /* Configure the driver */
  io_ctx.BusType     = SHT40AD1B_I2C_BUS; /* I2C */
 800e2e0:	2300      	movs	r3, #0
 800e2e2:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.Address     = SHT40AD1B_I2C_ADDRESS;
 800e2e4:	2389      	movs	r3, #137	@ 0x89
 800e2e6:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  io_ctx.Init        = IKS4A1_I2C_Init;
 800e2ea:	4b53      	ldr	r3, [pc, #332]	@ (800e438 <SHT40AD1B_0_Probe+0x164>)
 800e2ec:	627b      	str	r3, [r7, #36]	@ 0x24
  io_ctx.DeInit      = IKS4A1_I2C_DeInit;
 800e2ee:	4b53      	ldr	r3, [pc, #332]	@ (800e43c <SHT40AD1B_0_Probe+0x168>)
 800e2f0:	62bb      	str	r3, [r7, #40]	@ 0x28
  io_ctx.Read        = IKS4A1_I2C_Read;
 800e2f2:	4b53      	ldr	r3, [pc, #332]	@ (800e440 <SHT40AD1B_0_Probe+0x16c>)
 800e2f4:	63bb      	str	r3, [r7, #56]	@ 0x38
  io_ctx.Write       = IKS4A1_I2C_Write;
 800e2f6:	4b53      	ldr	r3, [pc, #332]	@ (800e444 <SHT40AD1B_0_Probe+0x170>)
 800e2f8:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.GetTick     = IKS4A1_GetTick;
 800e2fa:	4b53      	ldr	r3, [pc, #332]	@ (800e448 <SHT40AD1B_0_Probe+0x174>)
 800e2fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.Delay       = IKS4A1_Delay;
 800e2fe:	4b53      	ldr	r3, [pc, #332]	@ (800e44c <SHT40AD1B_0_Probe+0x178>)
 800e300:	643b      	str	r3, [r7, #64]	@ 0x40

  if (SHT40AD1B_RegisterBusIO(&sht40ad1b_obj_0, &io_ctx) != SHT40AD1B_OK)
 800e302:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800e306:	4619      	mov	r1, r3
 800e308:	4851      	ldr	r0, [pc, #324]	@ (800e450 <SHT40AD1B_0_Probe+0x17c>)
 800e30a:	f7fe fd4b 	bl	800cda4 <SHT40AD1B_RegisterBusIO>
 800e30e:	4603      	mov	r3, r0
 800e310:	2b00      	cmp	r3, #0
 800e312:	d003      	beq.n	800e31c <SHT40AD1B_0_Probe+0x48>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e314:	f06f 0306 	mvn.w	r3, #6
 800e318:	647b      	str	r3, [r7, #68]	@ 0x44
 800e31a:	e087      	b.n	800e42c <SHT40AD1B_0_Probe+0x158>
  }
  else if (SHT40AD1B_ReadID(&sht40ad1b_obj_0, &id) != SHT40AD1B_OK)
 800e31c:	f107 0323 	add.w	r3, r7, #35	@ 0x23
 800e320:	4619      	mov	r1, r3
 800e322:	484b      	ldr	r0, [pc, #300]	@ (800e450 <SHT40AD1B_0_Probe+0x17c>)
 800e324:	f7fe fdae 	bl	800ce84 <SHT40AD1B_ReadID>
 800e328:	4603      	mov	r3, r0
 800e32a:	2b00      	cmp	r3, #0
 800e32c:	d003      	beq.n	800e336 <SHT40AD1B_0_Probe+0x62>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e32e:	f06f 0306 	mvn.w	r3, #6
 800e332:	647b      	str	r3, [r7, #68]	@ 0x44
 800e334:	e07a      	b.n	800e42c <SHT40AD1B_0_Probe+0x158>
  }
  else if (id != SHT40AD1B_ID)
 800e336:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 800e33a:	2b00      	cmp	r3, #0
 800e33c:	d003      	beq.n	800e346 <SHT40AD1B_0_Probe+0x72>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e33e:	f06f 0306 	mvn.w	r3, #6
 800e342:	647b      	str	r3, [r7, #68]	@ 0x44
 800e344:	e072      	b.n	800e42c <SHT40AD1B_0_Probe+0x158>
  }
  else
  {
    (void)SHT40AD1B_GetCapabilities(&sht40ad1b_obj_0, &cap);
 800e346:	f107 0308 	add.w	r3, r7, #8
 800e34a:	4619      	mov	r1, r3
 800e34c:	4840      	ldr	r0, [pc, #256]	@ (800e450 <SHT40AD1B_0_Probe+0x17c>)
 800e34e:	f7fe fda9 	bl	800cea4 <SHT40AD1B_GetCapabilities>

    EnvCtx[IKS4A1_SHT40AD1B_0].Functions = ((uint32_t)cap.Temperature)
 800e352:	7a3b      	ldrb	r3, [r7, #8]
 800e354:	461a      	mov	r2, r3
                                         | ((uint32_t)cap.Pressure << 1)
 800e356:	7a7b      	ldrb	r3, [r7, #9]
 800e358:	005b      	lsls	r3, r3, #1
 800e35a:	431a      	orrs	r2, r3
                                         | ((uint32_t)cap.Humidity << 2)
 800e35c:	7abb      	ldrb	r3, [r7, #10]
 800e35e:	009b      	lsls	r3, r3, #2
 800e360:	431a      	orrs	r2, r3
                                         | ((uint32_t)cap.Gas      << 3);
 800e362:	7afb      	ldrb	r3, [r7, #11]
 800e364:	00db      	lsls	r3, r3, #3
 800e366:	4313      	orrs	r3, r2
    EnvCtx[IKS4A1_SHT40AD1B_0].Functions = ((uint32_t)cap.Temperature)
 800e368:	4a3a      	ldr	r2, [pc, #232]	@ (800e454 <SHT40AD1B_0_Probe+0x180>)
 800e36a:	6093      	str	r3, [r2, #8]

    EnvCompObj[IKS4A1_SHT40AD1B_0] = &sht40ad1b_obj_0;
 800e36c:	4b3a      	ldr	r3, [pc, #232]	@ (800e458 <SHT40AD1B_0_Probe+0x184>)
 800e36e:	4a38      	ldr	r2, [pc, #224]	@ (800e450 <SHT40AD1B_0_Probe+0x17c>)
 800e370:	609a      	str	r2, [r3, #8]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    EnvDrv[IKS4A1_SHT40AD1B_0] = (ENV_SENSOR_CommonDrv_t *)(void *)&SHT40AD1B_COMMON_Driver;
 800e372:	4b3a      	ldr	r3, [pc, #232]	@ (800e45c <SHT40AD1B_0_Probe+0x188>)
 800e374:	4a3a      	ldr	r2, [pc, #232]	@ (800e460 <SHT40AD1B_0_Probe+0x18c>)
 800e376:	609a      	str	r2, [r3, #8]

    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_TEMPERATURE) == ENV_TEMPERATURE) && (cap.Temperature == 1U))
 800e378:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e37a:	2b00      	cmp	r3, #0
 800e37c:	d11e      	bne.n	800e3bc <SHT40AD1B_0_Probe+0xe8>
 800e37e:	687b      	ldr	r3, [r7, #4]
 800e380:	f003 0301 	and.w	r3, r3, #1
 800e384:	2b00      	cmp	r3, #0
 800e386:	d019      	beq.n	800e3bc <SHT40AD1B_0_Probe+0xe8>
 800e388:	7a3b      	ldrb	r3, [r7, #8]
 800e38a:	2b01      	cmp	r3, #1
 800e38c:	d116      	bne.n	800e3bc <SHT40AD1B_0_Probe+0xe8>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[IKS4A1_SHT40AD1B_0][FunctionIndex[ENV_TEMPERATURE]] = (ENV_SENSOR_FuncDrv_t *)(void *)&SHT40AD1B_TEMP_Driver;
 800e38e:	4b35      	ldr	r3, [pc, #212]	@ (800e464 <SHT40AD1B_0_Probe+0x190>)
 800e390:	685b      	ldr	r3, [r3, #4]
 800e392:	4a35      	ldr	r2, [pc, #212]	@ (800e468 <SHT40AD1B_0_Probe+0x194>)
 800e394:	3308      	adds	r3, #8
 800e396:	4935      	ldr	r1, [pc, #212]	@ (800e46c <SHT40AD1B_0_Probe+0x198>)
 800e398:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[IKS4A1_SHT40AD1B_0]->Init(EnvCompObj[IKS4A1_SHT40AD1B_0]) != SHT40AD1B_OK)
 800e39c:	4b2f      	ldr	r3, [pc, #188]	@ (800e45c <SHT40AD1B_0_Probe+0x188>)
 800e39e:	689b      	ldr	r3, [r3, #8]
 800e3a0:	681b      	ldr	r3, [r3, #0]
 800e3a2:	4a2d      	ldr	r2, [pc, #180]	@ (800e458 <SHT40AD1B_0_Probe+0x184>)
 800e3a4:	6892      	ldr	r2, [r2, #8]
 800e3a6:	4610      	mov	r0, r2
 800e3a8:	4798      	blx	r3
 800e3aa:	4603      	mov	r3, r0
 800e3ac:	2b00      	cmp	r3, #0
 800e3ae:	d003      	beq.n	800e3b8 <SHT40AD1B_0_Probe+0xe4>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e3b0:	f06f 0304 	mvn.w	r3, #4
 800e3b4:	647b      	str	r3, [r7, #68]	@ 0x44
 800e3b6:	e001      	b.n	800e3bc <SHT40AD1B_0_Probe+0xe8>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e3b8:	2300      	movs	r3, #0
 800e3ba:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_HUMIDITY) == ENV_HUMIDITY) && (cap.Humidity == 1U))
 800e3bc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e3be:	2b00      	cmp	r3, #0
 800e3c0:	d11e      	bne.n	800e400 <SHT40AD1B_0_Probe+0x12c>
 800e3c2:	687b      	ldr	r3, [r7, #4]
 800e3c4:	f003 0304 	and.w	r3, r3, #4
 800e3c8:	2b00      	cmp	r3, #0
 800e3ca:	d019      	beq.n	800e400 <SHT40AD1B_0_Probe+0x12c>
 800e3cc:	7abb      	ldrb	r3, [r7, #10]
 800e3ce:	2b01      	cmp	r3, #1
 800e3d0:	d116      	bne.n	800e400 <SHT40AD1B_0_Probe+0x12c>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      EnvFuncDrv[IKS4A1_SHT40AD1B_0][FunctionIndex[ENV_HUMIDITY]] = (ENV_SENSOR_FuncDrv_t *)(void *)&SHT40AD1B_HUM_Driver;
 800e3d2:	4b24      	ldr	r3, [pc, #144]	@ (800e464 <SHT40AD1B_0_Probe+0x190>)
 800e3d4:	691b      	ldr	r3, [r3, #16]
 800e3d6:	4a24      	ldr	r2, [pc, #144]	@ (800e468 <SHT40AD1B_0_Probe+0x194>)
 800e3d8:	3308      	adds	r3, #8
 800e3da:	4925      	ldr	r1, [pc, #148]	@ (800e470 <SHT40AD1B_0_Probe+0x19c>)
 800e3dc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

      if (EnvDrv[IKS4A1_SHT40AD1B_0]->Init(EnvCompObj[IKS4A1_SHT40AD1B_0]) != SHT40AD1B_OK)
 800e3e0:	4b1e      	ldr	r3, [pc, #120]	@ (800e45c <SHT40AD1B_0_Probe+0x188>)
 800e3e2:	689b      	ldr	r3, [r3, #8]
 800e3e4:	681b      	ldr	r3, [r3, #0]
 800e3e6:	4a1c      	ldr	r2, [pc, #112]	@ (800e458 <SHT40AD1B_0_Probe+0x184>)
 800e3e8:	6892      	ldr	r2, [r2, #8]
 800e3ea:	4610      	mov	r0, r2
 800e3ec:	4798      	blx	r3
 800e3ee:	4603      	mov	r3, r0
 800e3f0:	2b00      	cmp	r3, #0
 800e3f2:	d003      	beq.n	800e3fc <SHT40AD1B_0_Probe+0x128>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e3f4:	f06f 0304 	mvn.w	r3, #4
 800e3f8:	647b      	str	r3, [r7, #68]	@ 0x44
 800e3fa:	e001      	b.n	800e400 <SHT40AD1B_0_Probe+0x12c>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e3fc:	2300      	movs	r3, #0
 800e3fe:	647b      	str	r3, [r7, #68]	@ 0x44
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_PRESSURE) == ENV_PRESSURE))
 800e400:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e402:	2b00      	cmp	r3, #0
 800e404:	d107      	bne.n	800e416 <SHT40AD1B_0_Probe+0x142>
 800e406:	687b      	ldr	r3, [r7, #4]
 800e408:	f003 0302 	and.w	r3, r3, #2
 800e40c:	2b00      	cmp	r3, #0
 800e40e:	d002      	beq.n	800e416 <SHT40AD1B_0_Probe+0x142>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e410:	f06f 0304 	mvn.w	r3, #4
 800e414:	647b      	str	r3, [r7, #68]	@ 0x44
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & ENV_GAS) == ENV_GAS))
 800e416:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800e418:	2b00      	cmp	r3, #0
 800e41a:	d107      	bne.n	800e42c <SHT40AD1B_0_Probe+0x158>
 800e41c:	687b      	ldr	r3, [r7, #4]
 800e41e:	f003 0308 	and.w	r3, r3, #8
 800e422:	2b00      	cmp	r3, #0
 800e424:	d002      	beq.n	800e42c <SHT40AD1B_0_Probe+0x158>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e426:	f06f 0304 	mvn.w	r3, #4
 800e42a:	647b      	str	r3, [r7, #68]	@ 0x44
    }
  }

  return ret;
 800e42c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
 800e42e:	4618      	mov	r0, r3
 800e430:	3748      	adds	r7, #72	@ 0x48
 800e432:	46bd      	mov	sp, r7
 800e434:	bd80      	pop	{r7, pc}
 800e436:	bf00      	nop
 800e438:	08005bd5 	.word	0x08005bd5
 800e43c:	08005c39 	.word	0x08005c39
 800e440:	08005da5 	.word	0x08005da5
 800e444:	08005d51 	.word	0x08005d51
 800e448:	08005df9 	.word	0x08005df9
 800e44c:	0800f315 	.word	0x0800f315
 800e450:	20002140 	.word	0x20002140
 800e454:	200020c4 	.word	0x200020c4
 800e458:	2000207c 	.word	0x2000207c
 800e45c:	200020b8 	.word	0x200020b8
 800e460:	20000298 	.word	0x20000298
 800e464:	200002f4 	.word	0x200002f4
 800e468:	20002088 	.word	0x20002088
 800e46c:	200002bc 	.word	0x200002bc
 800e470:	200002a8 	.word	0x200002a8

0800e474 <IKS4A1_MOTION_SENSOR_Init>:
  *         - MOTION_ACCELERO
  *         - MOTION_MAGNETO
  * @retval BSP status
  */
int32_t IKS4A1_MOTION_SENSOR_Init(uint32_t Instance, uint32_t Functions)
{
 800e474:	b580      	push	{r7, lr}
 800e476:	b08e      	sub	sp, #56	@ 0x38
 800e478:	af00      	add	r7, sp, #0
 800e47a:	6078      	str	r0, [r7, #4]
 800e47c:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
 800e47e:	2300      	movs	r3, #0
 800e480:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t function = MOTION_GYRO;
 800e482:	2301      	movs	r3, #1
 800e484:	633b      	str	r3, [r7, #48]	@ 0x30
  uint32_t i;
  uint32_t component_functions = 0;
 800e486:	2300      	movs	r3, #0
 800e488:	62bb      	str	r3, [r7, #40]	@ 0x28
  IKS4A1_MOTION_SENSOR_Capabilities_t cap;

  switch (Instance)
 800e48a:	687b      	ldr	r3, [r7, #4]
 800e48c:	2b03      	cmp	r3, #3
 800e48e:	f200 80d4 	bhi.w	800e63a <IKS4A1_MOTION_SENSOR_Init+0x1c6>
 800e492:	a201      	add	r2, pc, #4	@ (adr r2, 800e498 <IKS4A1_MOTION_SENSOR_Init+0x24>)
 800e494:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e498:	0800e4a9 	.word	0x0800e4a9
 800e49c:	0800e50f 	.word	0x0800e50f
 800e4a0:	0800e573 	.word	0x0800e573
 800e4a4:	0800e5d7 	.word	0x0800e5d7
      break;
#endif

#if (USE_IKS4A1_MOTION_SENSOR_LIS2MDL_0 == 1)
    case IKS4A1_LIS2MDL_0:
      if (LIS2MDL_0_Probe(Functions) != BSP_ERROR_NONE)
 800e4a8:	6838      	ldr	r0, [r7, #0]
 800e4aa:	f000 f9e3 	bl	800e874 <LIS2MDL_0_Probe>
 800e4ae:	4603      	mov	r3, r0
 800e4b0:	2b00      	cmp	r3, #0
 800e4b2:	d002      	beq.n	800e4ba <IKS4A1_MOTION_SENSOR_Init+0x46>
      {
        return BSP_ERROR_NO_INIT;
 800e4b4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800e4b8:	e101      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800e4ba:	4a83      	ldr	r2, [pc, #524]	@ (800e6c8 <IKS4A1_MOTION_SENSOR_Init+0x254>)
 800e4bc:	687b      	ldr	r3, [r7, #4]
 800e4be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e4c2:	68db      	ldr	r3, [r3, #12]
 800e4c4:	4981      	ldr	r1, [pc, #516]	@ (800e6cc <IKS4A1_MOTION_SENSOR_Init+0x258>)
 800e4c6:	687a      	ldr	r2, [r7, #4]
 800e4c8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e4cc:	f107 010c 	add.w	r1, r7, #12
 800e4d0:	4610      	mov	r0, r2
 800e4d2:	4798      	blx	r3
 800e4d4:	4603      	mov	r3, r0
 800e4d6:	2b00      	cmp	r3, #0
 800e4d8:	d002      	beq.n	800e4e0 <IKS4A1_MOTION_SENSOR_Init+0x6c>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800e4da:	f06f 0306 	mvn.w	r3, #6
 800e4de:	e0ee      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (cap.Acc == 1U)
 800e4e0:	7b3b      	ldrb	r3, [r7, #12]
 800e4e2:	2b01      	cmp	r3, #1
 800e4e4:	d103      	bne.n	800e4ee <IKS4A1_MOTION_SENSOR_Init+0x7a>
      {
        component_functions |= MOTION_ACCELERO;
 800e4e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e4e8:	f043 0302 	orr.w	r3, r3, #2
 800e4ec:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Gyro == 1U)
 800e4ee:	7b7b      	ldrb	r3, [r7, #13]
 800e4f0:	2b01      	cmp	r3, #1
 800e4f2:	d103      	bne.n	800e4fc <IKS4A1_MOTION_SENSOR_Init+0x88>
      {
        component_functions |= MOTION_GYRO;
 800e4f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e4f6:	f043 0301 	orr.w	r3, r3, #1
 800e4fa:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Magneto == 1U)
 800e4fc:	7bbb      	ldrb	r3, [r7, #14]
 800e4fe:	2b01      	cmp	r3, #1
 800e500:	f040 809f 	bne.w	800e642 <IKS4A1_MOTION_SENSOR_Init+0x1ce>
      {
        component_functions |= MOTION_MAGNETO;
 800e504:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e506:	f043 0304 	orr.w	r3, r3, #4
 800e50a:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      break;
 800e50c:	e099      	b.n	800e642 <IKS4A1_MOTION_SENSOR_Init+0x1ce>
      break;
#endif

#if (USE_IKS4A1_MOTION_SENSOR_LSM6DSV16X_0 == 1)
    case IKS4A1_LSM6DSV16X_0:
      if (LSM6DSV16X_0_Probe(Functions) != BSP_ERROR_NONE)
 800e50e:	6838      	ldr	r0, [r7, #0]
 800e510:	f000 fa58 	bl	800e9c4 <LSM6DSV16X_0_Probe>
 800e514:	4603      	mov	r3, r0
 800e516:	2b00      	cmp	r3, #0
 800e518:	d002      	beq.n	800e520 <IKS4A1_MOTION_SENSOR_Init+0xac>
      {
        return BSP_ERROR_NO_INIT;
 800e51a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800e51e:	e0ce      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800e520:	4a69      	ldr	r2, [pc, #420]	@ (800e6c8 <IKS4A1_MOTION_SENSOR_Init+0x254>)
 800e522:	687b      	ldr	r3, [r7, #4]
 800e524:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e528:	68db      	ldr	r3, [r3, #12]
 800e52a:	4968      	ldr	r1, [pc, #416]	@ (800e6cc <IKS4A1_MOTION_SENSOR_Init+0x258>)
 800e52c:	687a      	ldr	r2, [r7, #4]
 800e52e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e532:	f107 010c 	add.w	r1, r7, #12
 800e536:	4610      	mov	r0, r2
 800e538:	4798      	blx	r3
 800e53a:	4603      	mov	r3, r0
 800e53c:	2b00      	cmp	r3, #0
 800e53e:	d002      	beq.n	800e546 <IKS4A1_MOTION_SENSOR_Init+0xd2>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800e540:	f06f 0306 	mvn.w	r3, #6
 800e544:	e0bb      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (cap.Acc == 1U)
 800e546:	7b3b      	ldrb	r3, [r7, #12]
 800e548:	2b01      	cmp	r3, #1
 800e54a:	d103      	bne.n	800e554 <IKS4A1_MOTION_SENSOR_Init+0xe0>
      {
        component_functions |= MOTION_ACCELERO;
 800e54c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e54e:	f043 0302 	orr.w	r3, r3, #2
 800e552:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Gyro == 1U)
 800e554:	7b7b      	ldrb	r3, [r7, #13]
 800e556:	2b01      	cmp	r3, #1
 800e558:	d103      	bne.n	800e562 <IKS4A1_MOTION_SENSOR_Init+0xee>
      {
        component_functions |= MOTION_GYRO;
 800e55a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e55c:	f043 0301 	orr.w	r3, r3, #1
 800e560:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Magneto == 1U)
 800e562:	7bbb      	ldrb	r3, [r7, #14]
 800e564:	2b01      	cmp	r3, #1
 800e566:	d16e      	bne.n	800e646 <IKS4A1_MOTION_SENSOR_Init+0x1d2>
      {
        component_functions |= MOTION_MAGNETO;
 800e568:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e56a:	f043 0304 	orr.w	r3, r3, #4
 800e56e:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      break;
 800e570:	e069      	b.n	800e646 <IKS4A1_MOTION_SENSOR_Init+0x1d2>
      break;
#endif

#if (USE_IKS4A1_MOTION_SENSOR_LIS2DUXS12_0 == 1)
    case IKS4A1_LIS2DUXS12_0:
      if (LIS2DUXS12_0_Probe(Functions) != BSP_ERROR_NONE)
 800e572:	6838      	ldr	r0, [r7, #0]
 800e574:	f000 fae8 	bl	800eb48 <LIS2DUXS12_0_Probe>
 800e578:	4603      	mov	r3, r0
 800e57a:	2b00      	cmp	r3, #0
 800e57c:	d002      	beq.n	800e584 <IKS4A1_MOTION_SENSOR_Init+0x110>
      {
        return BSP_ERROR_NO_INIT;
 800e57e:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800e582:	e09c      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800e584:	4a50      	ldr	r2, [pc, #320]	@ (800e6c8 <IKS4A1_MOTION_SENSOR_Init+0x254>)
 800e586:	687b      	ldr	r3, [r7, #4]
 800e588:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e58c:	68db      	ldr	r3, [r3, #12]
 800e58e:	494f      	ldr	r1, [pc, #316]	@ (800e6cc <IKS4A1_MOTION_SENSOR_Init+0x258>)
 800e590:	687a      	ldr	r2, [r7, #4]
 800e592:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e596:	f107 010c 	add.w	r1, r7, #12
 800e59a:	4610      	mov	r0, r2
 800e59c:	4798      	blx	r3
 800e59e:	4603      	mov	r3, r0
 800e5a0:	2b00      	cmp	r3, #0
 800e5a2:	d002      	beq.n	800e5aa <IKS4A1_MOTION_SENSOR_Init+0x136>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800e5a4:	f06f 0306 	mvn.w	r3, #6
 800e5a8:	e089      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (cap.Acc == 1U)
 800e5aa:	7b3b      	ldrb	r3, [r7, #12]
 800e5ac:	2b01      	cmp	r3, #1
 800e5ae:	d103      	bne.n	800e5b8 <IKS4A1_MOTION_SENSOR_Init+0x144>
      {
        component_functions |= MOTION_ACCELERO;
 800e5b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e5b2:	f043 0302 	orr.w	r3, r3, #2
 800e5b6:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Gyro == 1U)
 800e5b8:	7b7b      	ldrb	r3, [r7, #13]
 800e5ba:	2b01      	cmp	r3, #1
 800e5bc:	d103      	bne.n	800e5c6 <IKS4A1_MOTION_SENSOR_Init+0x152>
      {
        component_functions |= MOTION_GYRO;
 800e5be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e5c0:	f043 0301 	orr.w	r3, r3, #1
 800e5c4:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Magneto == 1U)
 800e5c6:	7bbb      	ldrb	r3, [r7, #14]
 800e5c8:	2b01      	cmp	r3, #1
 800e5ca:	d13e      	bne.n	800e64a <IKS4A1_MOTION_SENSOR_Init+0x1d6>
      {
        component_functions |= MOTION_MAGNETO;
 800e5cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e5ce:	f043 0304 	orr.w	r3, r3, #4
 800e5d2:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      break;
 800e5d4:	e039      	b.n	800e64a <IKS4A1_MOTION_SENSOR_Init+0x1d6>
      break;
#endif

#if (USE_IKS4A1_MOTION_SENSOR_LSM6DSO16IS_0 == 1)
    case IKS4A1_LSM6DSO16IS_0:
      if (LSM6DSO16IS_0_Probe(Functions) != BSP_ERROR_NONE)
 800e5d6:	6838      	ldr	r0, [r7, #0]
 800e5d8:	f000 fb62 	bl	800eca0 <LSM6DSO16IS_0_Probe>
 800e5dc:	4603      	mov	r3, r0
 800e5de:	2b00      	cmp	r3, #0
 800e5e0:	d002      	beq.n	800e5e8 <IKS4A1_MOTION_SENSOR_Init+0x174>
      {
        return BSP_ERROR_NO_INIT;
 800e5e2:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 800e5e6:	e06a      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (MotionDrv[Instance]->GetCapabilities(MotionCompObj[Instance], (void *)&cap) != BSP_ERROR_NONE)
 800e5e8:	4a37      	ldr	r2, [pc, #220]	@ (800e6c8 <IKS4A1_MOTION_SENSOR_Init+0x254>)
 800e5ea:	687b      	ldr	r3, [r7, #4]
 800e5ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e5f0:	68db      	ldr	r3, [r3, #12]
 800e5f2:	4936      	ldr	r1, [pc, #216]	@ (800e6cc <IKS4A1_MOTION_SENSOR_Init+0x258>)
 800e5f4:	687a      	ldr	r2, [r7, #4]
 800e5f6:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e5fa:	f107 010c 	add.w	r1, r7, #12
 800e5fe:	4610      	mov	r0, r2
 800e600:	4798      	blx	r3
 800e602:	4603      	mov	r3, r0
 800e604:	2b00      	cmp	r3, #0
 800e606:	d002      	beq.n	800e60e <IKS4A1_MOTION_SENSOR_Init+0x19a>
      {
        return BSP_ERROR_UNKNOWN_COMPONENT;
 800e608:	f06f 0306 	mvn.w	r3, #6
 800e60c:	e057      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
      if (cap.Acc == 1U)
 800e60e:	7b3b      	ldrb	r3, [r7, #12]
 800e610:	2b01      	cmp	r3, #1
 800e612:	d103      	bne.n	800e61c <IKS4A1_MOTION_SENSOR_Init+0x1a8>
      {
        component_functions |= MOTION_ACCELERO;
 800e614:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e616:	f043 0302 	orr.w	r3, r3, #2
 800e61a:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Gyro == 1U)
 800e61c:	7b7b      	ldrb	r3, [r7, #13]
 800e61e:	2b01      	cmp	r3, #1
 800e620:	d103      	bne.n	800e62a <IKS4A1_MOTION_SENSOR_Init+0x1b6>
      {
        component_functions |= MOTION_GYRO;
 800e622:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e624:	f043 0301 	orr.w	r3, r3, #1
 800e628:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      if (cap.Magneto == 1U)
 800e62a:	7bbb      	ldrb	r3, [r7, #14]
 800e62c:	2b01      	cmp	r3, #1
 800e62e:	d10e      	bne.n	800e64e <IKS4A1_MOTION_SENSOR_Init+0x1da>
      {
        component_functions |= MOTION_MAGNETO;
 800e630:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e632:	f043 0304 	orr.w	r3, r3, #4
 800e636:	62bb      	str	r3, [r7, #40]	@ 0x28
      }
      break;
 800e638:	e009      	b.n	800e64e <IKS4A1_MOTION_SENSOR_Init+0x1da>
#endif

    default:
      ret = BSP_ERROR_WRONG_PARAM;
 800e63a:	f06f 0301 	mvn.w	r3, #1
 800e63e:	637b      	str	r3, [r7, #52]	@ 0x34
      break;
 800e640:	e006      	b.n	800e650 <IKS4A1_MOTION_SENSOR_Init+0x1dc>
      break;
 800e642:	bf00      	nop
 800e644:	e004      	b.n	800e650 <IKS4A1_MOTION_SENSOR_Init+0x1dc>
      break;
 800e646:	bf00      	nop
 800e648:	e002      	b.n	800e650 <IKS4A1_MOTION_SENSOR_Init+0x1dc>
      break;
 800e64a:	bf00      	nop
 800e64c:	e000      	b.n	800e650 <IKS4A1_MOTION_SENSOR_Init+0x1dc>
      break;
 800e64e:	bf00      	nop
  }

  if (ret != BSP_ERROR_NONE)
 800e650:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e652:	2b00      	cmp	r3, #0
 800e654:	d001      	beq.n	800e65a <IKS4A1_MOTION_SENSOR_Init+0x1e6>
  {
    return ret;
 800e656:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e658:	e031      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
  }

  for (i = 0; i < IKS4A1_MOTION_FUNCTIONS_NBR; i++)
 800e65a:	2300      	movs	r3, #0
 800e65c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800e65e:	e02a      	b.n	800e6b6 <IKS4A1_MOTION_SENSOR_Init+0x242>
  {
    if (((Functions & function) == function) && ((component_functions & function) == function))
 800e660:	683a      	ldr	r2, [r7, #0]
 800e662:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e664:	4013      	ands	r3, r2
 800e666:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800e668:	429a      	cmp	r2, r3
 800e66a:	d11e      	bne.n	800e6aa <IKS4A1_MOTION_SENSOR_Init+0x236>
 800e66c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800e66e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e670:	4013      	ands	r3, r2
 800e672:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800e674:	429a      	cmp	r2, r3
 800e676:	d118      	bne.n	800e6aa <IKS4A1_MOTION_SENSOR_Init+0x236>
    {
      if (MotionFuncDrv[Instance][FunctionIndex[function]]->Enable(MotionCompObj[Instance]) != BSP_ERROR_NONE)
 800e678:	4a15      	ldr	r2, [pc, #84]	@ (800e6d0 <IKS4A1_MOTION_SENSOR_Init+0x25c>)
 800e67a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e67c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800e680:	4814      	ldr	r0, [pc, #80]	@ (800e6d4 <IKS4A1_MOTION_SENSOR_Init+0x260>)
 800e682:	687a      	ldr	r2, [r7, #4]
 800e684:	4613      	mov	r3, r2
 800e686:	005b      	lsls	r3, r3, #1
 800e688:	4413      	add	r3, r2
 800e68a:	440b      	add	r3, r1
 800e68c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800e690:	681b      	ldr	r3, [r3, #0]
 800e692:	490e      	ldr	r1, [pc, #56]	@ (800e6cc <IKS4A1_MOTION_SENSOR_Init+0x258>)
 800e694:	687a      	ldr	r2, [r7, #4]
 800e696:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e69a:	4610      	mov	r0, r2
 800e69c:	4798      	blx	r3
 800e69e:	4603      	mov	r3, r0
 800e6a0:	2b00      	cmp	r3, #0
 800e6a2:	d002      	beq.n	800e6aa <IKS4A1_MOTION_SENSOR_Init+0x236>
      {
        return BSP_ERROR_COMPONENT_FAILURE;
 800e6a4:	f06f 0304 	mvn.w	r3, #4
 800e6a8:	e009      	b.n	800e6be <IKS4A1_MOTION_SENSOR_Init+0x24a>
      }
    }
    function = function << 1;
 800e6aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e6ac:	005b      	lsls	r3, r3, #1
 800e6ae:	633b      	str	r3, [r7, #48]	@ 0x30
  for (i = 0; i < IKS4A1_MOTION_FUNCTIONS_NBR; i++)
 800e6b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e6b2:	3301      	adds	r3, #1
 800e6b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800e6b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e6b8:	2b02      	cmp	r3, #2
 800e6ba:	d9d1      	bls.n	800e660 <IKS4A1_MOTION_SENSOR_Init+0x1ec>
  }

  return ret;
 800e6bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 800e6be:	4618      	mov	r0, r3
 800e6c0:	3738      	adds	r7, #56	@ 0x38
 800e6c2:	46bd      	mov	sp, r7
 800e6c4:	bd80      	pop	{r7, pc}
 800e6c6:	bf00      	nop
 800e6c8:	200021c4 	.word	0x200021c4
 800e6cc:	20002184 	.word	0x20002184
 800e6d0:	20000318 	.word	0x20000318
 800e6d4:	20002194 	.word	0x20002194

0800e6d8 <IKS4A1_MOTION_SENSOR_GetAxes>:
  *         - MOTION_MAGNETO
  * @param  Axes pointer to axes data structure
  * @retval BSP status
  */
int32_t IKS4A1_MOTION_SENSOR_GetAxes(uint32_t Instance, uint32_t Function, IKS4A1_MOTION_SENSOR_Axes_t *Axes)
{
 800e6d8:	b580      	push	{r7, lr}
 800e6da:	b086      	sub	sp, #24
 800e6dc:	af00      	add	r7, sp, #0
 800e6de:	60f8      	str	r0, [r7, #12]
 800e6e0:	60b9      	str	r1, [r7, #8]
 800e6e2:	607a      	str	r2, [r7, #4]
  int32_t ret;

  if (Instance >= IKS4A1_MOTION_INSTANCES_NBR)
 800e6e4:	68fb      	ldr	r3, [r7, #12]
 800e6e6:	2b03      	cmp	r3, #3
 800e6e8:	d903      	bls.n	800e6f2 <IKS4A1_MOTION_SENSOR_GetAxes+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800e6ea:	f06f 0301 	mvn.w	r3, #1
 800e6ee:	617b      	str	r3, [r7, #20]
 800e6f0:	e029      	b.n	800e746 <IKS4A1_MOTION_SENSOR_GetAxes+0x6e>
  }
  else
  {
    if ((MotionCtx[Instance].Functions & Function) == Function)
 800e6f2:	4a17      	ldr	r2, [pc, #92]	@ (800e750 <IKS4A1_MOTION_SENSOR_GetAxes+0x78>)
 800e6f4:	68fb      	ldr	r3, [r7, #12]
 800e6f6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800e6fa:	68bb      	ldr	r3, [r7, #8]
 800e6fc:	4013      	ands	r3, r2
 800e6fe:	68ba      	ldr	r2, [r7, #8]
 800e700:	429a      	cmp	r2, r3
 800e702:	d11d      	bne.n	800e740 <IKS4A1_MOTION_SENSOR_GetAxes+0x68>
    {
      if (MotionFuncDrv[Instance][FunctionIndex[Function]]->GetAxes(MotionCompObj[Instance], Axes) != BSP_ERROR_NONE)
 800e704:	4a13      	ldr	r2, [pc, #76]	@ (800e754 <IKS4A1_MOTION_SENSOR_GetAxes+0x7c>)
 800e706:	68bb      	ldr	r3, [r7, #8]
 800e708:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800e70c:	4812      	ldr	r0, [pc, #72]	@ (800e758 <IKS4A1_MOTION_SENSOR_GetAxes+0x80>)
 800e70e:	68fa      	ldr	r2, [r7, #12]
 800e710:	4613      	mov	r3, r2
 800e712:	005b      	lsls	r3, r3, #1
 800e714:	4413      	add	r3, r2
 800e716:	440b      	add	r3, r1
 800e718:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800e71c:	69db      	ldr	r3, [r3, #28]
 800e71e:	490f      	ldr	r1, [pc, #60]	@ (800e75c <IKS4A1_MOTION_SENSOR_GetAxes+0x84>)
 800e720:	68fa      	ldr	r2, [r7, #12]
 800e722:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e726:	6879      	ldr	r1, [r7, #4]
 800e728:	4610      	mov	r0, r2
 800e72a:	4798      	blx	r3
 800e72c:	4603      	mov	r3, r0
 800e72e:	2b00      	cmp	r3, #0
 800e730:	d003      	beq.n	800e73a <IKS4A1_MOTION_SENSOR_GetAxes+0x62>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e732:	f06f 0304 	mvn.w	r3, #4
 800e736:	617b      	str	r3, [r7, #20]
 800e738:	e005      	b.n	800e746 <IKS4A1_MOTION_SENSOR_GetAxes+0x6e>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e73a:	2300      	movs	r3, #0
 800e73c:	617b      	str	r3, [r7, #20]
 800e73e:	e002      	b.n	800e746 <IKS4A1_MOTION_SENSOR_GetAxes+0x6e>
      }
    }
    else
    {
      ret = BSP_ERROR_WRONG_PARAM;
 800e740:	f06f 0301 	mvn.w	r3, #1
 800e744:	617b      	str	r3, [r7, #20]
    }
  }

  return ret;
 800e746:	697b      	ldr	r3, [r7, #20]
}
 800e748:	4618      	mov	r0, r3
 800e74a:	3718      	adds	r7, #24
 800e74c:	46bd      	mov	sp, r7
 800e74e:	bd80      	pop	{r7, pc}
 800e750:	200021d4 	.word	0x200021d4
 800e754:	20000318 	.word	0x20000318
 800e758:	20002194 	.word	0x20002194
 800e75c:	20002184 	.word	0x20002184

0800e760 <IKS4A1_MOTION_SENSOR_SetOutputDataRate>:
  *         - MOTION_MAGNETO
  * @param  Odr Output Data Rate value to be set
  * @retval BSP status
  */
int32_t IKS4A1_MOTION_SENSOR_SetOutputDataRate(uint32_t Instance, uint32_t Function, float_t Odr)
{
 800e760:	b580      	push	{r7, lr}
 800e762:	b086      	sub	sp, #24
 800e764:	af00      	add	r7, sp, #0
 800e766:	60f8      	str	r0, [r7, #12]
 800e768:	60b9      	str	r1, [r7, #8]
 800e76a:	ed87 0a01 	vstr	s0, [r7, #4]
  int32_t ret;

  if (Instance >= IKS4A1_MOTION_INSTANCES_NBR)
 800e76e:	68fb      	ldr	r3, [r7, #12]
 800e770:	2b03      	cmp	r3, #3
 800e772:	d903      	bls.n	800e77c <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800e774:	f06f 0301 	mvn.w	r3, #1
 800e778:	617b      	str	r3, [r7, #20]
 800e77a:	e02a      	b.n	800e7d2 <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x72>
  }
  else
  {
    if ((MotionCtx[Instance].Functions & Function) == Function)
 800e77c:	4a17      	ldr	r2, [pc, #92]	@ (800e7dc <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x7c>)
 800e77e:	68fb      	ldr	r3, [r7, #12]
 800e780:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800e784:	68bb      	ldr	r3, [r7, #8]
 800e786:	4013      	ands	r3, r2
 800e788:	68ba      	ldr	r2, [r7, #8]
 800e78a:	429a      	cmp	r2, r3
 800e78c:	d11e      	bne.n	800e7cc <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x6c>
    {
      if (MotionFuncDrv[Instance][FunctionIndex[Function]]->SetOutputDataRate(MotionCompObj[Instance], Odr) != BSP_ERROR_NONE)
 800e78e:	4a14      	ldr	r2, [pc, #80]	@ (800e7e0 <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x80>)
 800e790:	68bb      	ldr	r3, [r7, #8]
 800e792:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800e796:	4813      	ldr	r0, [pc, #76]	@ (800e7e4 <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x84>)
 800e798:	68fa      	ldr	r2, [r7, #12]
 800e79a:	4613      	mov	r3, r2
 800e79c:	005b      	lsls	r3, r3, #1
 800e79e:	4413      	add	r3, r2
 800e7a0:	440b      	add	r3, r1
 800e7a2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800e7a6:	691b      	ldr	r3, [r3, #16]
 800e7a8:	490f      	ldr	r1, [pc, #60]	@ (800e7e8 <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x88>)
 800e7aa:	68fa      	ldr	r2, [r7, #12]
 800e7ac:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e7b0:	ed97 0a01 	vldr	s0, [r7, #4]
 800e7b4:	4610      	mov	r0, r2
 800e7b6:	4798      	blx	r3
 800e7b8:	4603      	mov	r3, r0
 800e7ba:	2b00      	cmp	r3, #0
 800e7bc:	d003      	beq.n	800e7c6 <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x66>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e7be:	f06f 0304 	mvn.w	r3, #4
 800e7c2:	617b      	str	r3, [r7, #20]
 800e7c4:	e005      	b.n	800e7d2 <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x72>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e7c6:	2300      	movs	r3, #0
 800e7c8:	617b      	str	r3, [r7, #20]
 800e7ca:	e002      	b.n	800e7d2 <IKS4A1_MOTION_SENSOR_SetOutputDataRate+0x72>
      }
    }
    else
    {
      ret = BSP_ERROR_WRONG_PARAM;
 800e7cc:	f06f 0301 	mvn.w	r3, #1
 800e7d0:	617b      	str	r3, [r7, #20]
    }
  }

  return ret;
 800e7d2:	697b      	ldr	r3, [r7, #20]
}
 800e7d4:	4618      	mov	r0, r3
 800e7d6:	3718      	adds	r7, #24
 800e7d8:	46bd      	mov	sp, r7
 800e7da:	bd80      	pop	{r7, pc}
 800e7dc:	200021d4 	.word	0x200021d4
 800e7e0:	20000318 	.word	0x20000318
 800e7e4:	20002194 	.word	0x20002194
 800e7e8:	20002184 	.word	0x20002184

0800e7ec <IKS4A1_MOTION_SENSOR_SetFullScale>:
  *         - MOTION_MAGNETO
  * @param  Fullscale Fullscale value to be set
  * @retval BSP status
  */
int32_t IKS4A1_MOTION_SENSOR_SetFullScale(uint32_t Instance, uint32_t Function, int32_t Fullscale)
{
 800e7ec:	b580      	push	{r7, lr}
 800e7ee:	b086      	sub	sp, #24
 800e7f0:	af00      	add	r7, sp, #0
 800e7f2:	60f8      	str	r0, [r7, #12]
 800e7f4:	60b9      	str	r1, [r7, #8]
 800e7f6:	607a      	str	r2, [r7, #4]
  int32_t ret;

  if (Instance >= IKS4A1_MOTION_INSTANCES_NBR)
 800e7f8:	68fb      	ldr	r3, [r7, #12]
 800e7fa:	2b03      	cmp	r3, #3
 800e7fc:	d903      	bls.n	800e806 <IKS4A1_MOTION_SENSOR_SetFullScale+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800e7fe:	f06f 0301 	mvn.w	r3, #1
 800e802:	617b      	str	r3, [r7, #20]
 800e804:	e029      	b.n	800e85a <IKS4A1_MOTION_SENSOR_SetFullScale+0x6e>
  }
  else
  {
    if ((MotionCtx[Instance].Functions & Function) == Function)
 800e806:	4a17      	ldr	r2, [pc, #92]	@ (800e864 <IKS4A1_MOTION_SENSOR_SetFullScale+0x78>)
 800e808:	68fb      	ldr	r3, [r7, #12]
 800e80a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800e80e:	68bb      	ldr	r3, [r7, #8]
 800e810:	4013      	ands	r3, r2
 800e812:	68ba      	ldr	r2, [r7, #8]
 800e814:	429a      	cmp	r2, r3
 800e816:	d11d      	bne.n	800e854 <IKS4A1_MOTION_SENSOR_SetFullScale+0x68>
    {
      if (MotionFuncDrv[Instance][FunctionIndex[Function]]->SetFullScale(MotionCompObj[Instance],
 800e818:	4a13      	ldr	r2, [pc, #76]	@ (800e868 <IKS4A1_MOTION_SENSOR_SetFullScale+0x7c>)
 800e81a:	68bb      	ldr	r3, [r7, #8]
 800e81c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800e820:	4812      	ldr	r0, [pc, #72]	@ (800e86c <IKS4A1_MOTION_SENSOR_SetFullScale+0x80>)
 800e822:	68fa      	ldr	r2, [r7, #12]
 800e824:	4613      	mov	r3, r2
 800e826:	005b      	lsls	r3, r3, #1
 800e828:	4413      	add	r3, r2
 800e82a:	440b      	add	r3, r1
 800e82c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 800e830:	699b      	ldr	r3, [r3, #24]
 800e832:	490f      	ldr	r1, [pc, #60]	@ (800e870 <IKS4A1_MOTION_SENSOR_SetFullScale+0x84>)
 800e834:	68fa      	ldr	r2, [r7, #12]
 800e836:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800e83a:	6879      	ldr	r1, [r7, #4]
 800e83c:	4610      	mov	r0, r2
 800e83e:	4798      	blx	r3
 800e840:	4603      	mov	r3, r0
 800e842:	2b00      	cmp	r3, #0
 800e844:	d003      	beq.n	800e84e <IKS4A1_MOTION_SENSOR_SetFullScale+0x62>
                                                                         Fullscale) != BSP_ERROR_NONE)
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e846:	f06f 0304 	mvn.w	r3, #4
 800e84a:	617b      	str	r3, [r7, #20]
 800e84c:	e005      	b.n	800e85a <IKS4A1_MOTION_SENSOR_SetFullScale+0x6e>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e84e:	2300      	movs	r3, #0
 800e850:	617b      	str	r3, [r7, #20]
 800e852:	e002      	b.n	800e85a <IKS4A1_MOTION_SENSOR_SetFullScale+0x6e>
      }
    }
    else
    {
      ret = BSP_ERROR_WRONG_PARAM;
 800e854:	f06f 0301 	mvn.w	r3, #1
 800e858:	617b      	str	r3, [r7, #20]
    }
  }

  return ret;
 800e85a:	697b      	ldr	r3, [r7, #20]
}
 800e85c:	4618      	mov	r0, r3
 800e85e:	3718      	adds	r7, #24
 800e860:	46bd      	mov	sp, r7
 800e862:	bd80      	pop	{r7, pc}
 800e864:	200021d4 	.word	0x200021d4
 800e868:	20000318 	.word	0x20000318
 800e86c:	20002194 	.word	0x20002194
 800e870:	20002184 	.word	0x20002184

0800e874 <LIS2MDL_0_Probe>:
  * @param  Functions Motion sensor functions. Could be :
  *         - MOTION_MAGNETO
  * @retval BSP status
  */
static int32_t LIS2MDL_0_Probe(uint32_t Functions)
{
 800e874:	b580      	push	{r7, lr}
 800e876:	b094      	sub	sp, #80	@ 0x50
 800e878:	af00      	add	r7, sp, #0
 800e87a:	6078      	str	r0, [r7, #4]
  LIS2MDL_IO_t            io_ctx;
  uint8_t                 id;
  static LIS2MDL_Object_t lis2mdl_obj_0;
  LIS2MDL_Capabilities_t  cap;
  int32_t                 ret = BSP_ERROR_NONE;
 800e87c:	2300      	movs	r3, #0
 800e87e:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* Configure the driver */
  io_ctx.BusType     = LIS2MDL_I2C_BUS; /* I2C */
 800e880:	2300      	movs	r3, #0
 800e882:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.Address     = LIS2MDL_I2C_ADD;
 800e884:	233d      	movs	r3, #61	@ 0x3d
 800e886:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  io_ctx.Init        = IKS4A1_I2C_Init;
 800e88a:	4b40      	ldr	r3, [pc, #256]	@ (800e98c <LIS2MDL_0_Probe+0x118>)
 800e88c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.DeInit      = IKS4A1_I2C_DeInit;
 800e88e:	4b40      	ldr	r3, [pc, #256]	@ (800e990 <LIS2MDL_0_Probe+0x11c>)
 800e890:	633b      	str	r3, [r7, #48]	@ 0x30
  io_ctx.ReadReg     = IKS4A1_I2C_ReadReg;
 800e892:	4b40      	ldr	r3, [pc, #256]	@ (800e994 <LIS2MDL_0_Probe+0x120>)
 800e894:	643b      	str	r3, [r7, #64]	@ 0x40
  io_ctx.WriteReg    = IKS4A1_I2C_WriteReg;
 800e896:	4b40      	ldr	r3, [pc, #256]	@ (800e998 <LIS2MDL_0_Probe+0x124>)
 800e898:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.GetTick     = IKS4A1_GetTick;
 800e89a:	4b40      	ldr	r3, [pc, #256]	@ (800e99c <LIS2MDL_0_Probe+0x128>)
 800e89c:	647b      	str	r3, [r7, #68]	@ 0x44
  io_ctx.Delay       = IKS4A1_Delay;
 800e89e:	4b40      	ldr	r3, [pc, #256]	@ (800e9a0 <LIS2MDL_0_Probe+0x12c>)
 800e8a0:	64bb      	str	r3, [r7, #72]	@ 0x48

  if (LIS2MDL_RegisterBusIO(&lis2mdl_obj_0, &io_ctx) != LIS2MDL_OK)
 800e8a2:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800e8a6:	4619      	mov	r1, r3
 800e8a8:	483e      	ldr	r0, [pc, #248]	@ (800e9a4 <LIS2MDL_0_Probe+0x130>)
 800e8aa:	f7f9 f877 	bl	800799c <LIS2MDL_RegisterBusIO>
 800e8ae:	4603      	mov	r3, r0
 800e8b0:	2b00      	cmp	r3, #0
 800e8b2:	d003      	beq.n	800e8bc <LIS2MDL_0_Probe+0x48>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e8b4:	f06f 0306 	mvn.w	r3, #6
 800e8b8:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800e8ba:	e061      	b.n	800e980 <LIS2MDL_0_Probe+0x10c>
  }
  else if (LIS2MDL_ReadID(&lis2mdl_obj_0, &id) != LIS2MDL_OK)
 800e8bc:	f107 032b 	add.w	r3, r7, #43	@ 0x2b
 800e8c0:	4619      	mov	r1, r3
 800e8c2:	4838      	ldr	r0, [pc, #224]	@ (800e9a4 <LIS2MDL_0_Probe+0x130>)
 800e8c4:	f7f9 f986 	bl	8007bd4 <LIS2MDL_ReadID>
 800e8c8:	4603      	mov	r3, r0
 800e8ca:	2b00      	cmp	r3, #0
 800e8cc:	d003      	beq.n	800e8d6 <LIS2MDL_0_Probe+0x62>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e8ce:	f06f 0306 	mvn.w	r3, #6
 800e8d2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800e8d4:	e054      	b.n	800e980 <LIS2MDL_0_Probe+0x10c>
  }
  else if (id != LIS2MDL_ID)
 800e8d6:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800e8da:	2b40      	cmp	r3, #64	@ 0x40
 800e8dc:	d003      	beq.n	800e8e6 <LIS2MDL_0_Probe+0x72>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800e8de:	f06f 0306 	mvn.w	r3, #6
 800e8e2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800e8e4:	e04c      	b.n	800e980 <LIS2MDL_0_Probe+0x10c>
  }
  else
  {
    (void)LIS2MDL_GetCapabilities(&lis2mdl_obj_0, &cap);
 800e8e6:	f107 030c 	add.w	r3, r7, #12
 800e8ea:	4619      	mov	r1, r3
 800e8ec:	482d      	ldr	r0, [pc, #180]	@ (800e9a4 <LIS2MDL_0_Probe+0x130>)
 800e8ee:	f7f9 f997 	bl	8007c20 <LIS2MDL_GetCapabilities>
    MotionCtx[IKS4A1_LIS2MDL_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
 800e8f2:	7b7b      	ldrb	r3, [r7, #13]
 800e8f4:	461a      	mov	r2, r3
 800e8f6:	7b3b      	ldrb	r3, [r7, #12]
 800e8f8:	005b      	lsls	r3, r3, #1
 800e8fa:	431a      	orrs	r2, r3
 800e8fc:	7bbb      	ldrb	r3, [r7, #14]
 800e8fe:	009b      	lsls	r3, r3, #2
 800e900:	4313      	orrs	r3, r2
 800e902:	4a29      	ldr	r2, [pc, #164]	@ (800e9a8 <LIS2MDL_0_Probe+0x134>)
 800e904:	6013      	str	r3, [r2, #0]

    MotionCompObj[IKS4A1_LIS2MDL_0] = &lis2mdl_obj_0;
 800e906:	4b29      	ldr	r3, [pc, #164]	@ (800e9ac <LIS2MDL_0_Probe+0x138>)
 800e908:	4a26      	ldr	r2, [pc, #152]	@ (800e9a4 <LIS2MDL_0_Probe+0x130>)
 800e90a:	601a      	str	r2, [r3, #0]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    MotionDrv[IKS4A1_LIS2MDL_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LIS2MDL_COMMON_Driver;
 800e90c:	4b28      	ldr	r3, [pc, #160]	@ (800e9b0 <LIS2MDL_0_Probe+0x13c>)
 800e90e:	4a29      	ldr	r2, [pc, #164]	@ (800e9b4 <LIS2MDL_0_Probe+0x140>)
 800e910:	601a      	str	r2, [r3, #0]

    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO) && (cap.Magneto == 1U))
 800e912:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e914:	2b00      	cmp	r3, #0
 800e916:	d11d      	bne.n	800e954 <LIS2MDL_0_Probe+0xe0>
 800e918:	687b      	ldr	r3, [r7, #4]
 800e91a:	f003 0304 	and.w	r3, r3, #4
 800e91e:	2b00      	cmp	r3, #0
 800e920:	d018      	beq.n	800e954 <LIS2MDL_0_Probe+0xe0>
 800e922:	7bbb      	ldrb	r3, [r7, #14]
 800e924:	2b01      	cmp	r3, #1
 800e926:	d115      	bne.n	800e954 <LIS2MDL_0_Probe+0xe0>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[IKS4A1_LIS2MDL_0][FunctionIndex[MOTION_MAGNETO]] = (MOTION_SENSOR_FuncDrv_t *)(
 800e928:	4b23      	ldr	r3, [pc, #140]	@ (800e9b8 <LIS2MDL_0_Probe+0x144>)
 800e92a:	691b      	ldr	r3, [r3, #16]
 800e92c:	4a23      	ldr	r2, [pc, #140]	@ (800e9bc <LIS2MDL_0_Probe+0x148>)
 800e92e:	4924      	ldr	r1, [pc, #144]	@ (800e9c0 <LIS2MDL_0_Probe+0x14c>)
 800e930:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                                                        void *)&LIS2MDL_MAG_Driver;

      if (MotionDrv[IKS4A1_LIS2MDL_0]->Init(MotionCompObj[IKS4A1_LIS2MDL_0]) != LIS2MDL_OK)
 800e934:	4b1e      	ldr	r3, [pc, #120]	@ (800e9b0 <LIS2MDL_0_Probe+0x13c>)
 800e936:	681b      	ldr	r3, [r3, #0]
 800e938:	681b      	ldr	r3, [r3, #0]
 800e93a:	4a1c      	ldr	r2, [pc, #112]	@ (800e9ac <LIS2MDL_0_Probe+0x138>)
 800e93c:	6812      	ldr	r2, [r2, #0]
 800e93e:	4610      	mov	r0, r2
 800e940:	4798      	blx	r3
 800e942:	4603      	mov	r3, r0
 800e944:	2b00      	cmp	r3, #0
 800e946:	d003      	beq.n	800e950 <LIS2MDL_0_Probe+0xdc>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800e948:	f06f 0304 	mvn.w	r3, #4
 800e94c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800e94e:	e001      	b.n	800e954 <LIS2MDL_0_Probe+0xe0>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800e950:	2300      	movs	r3, #0
 800e952:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO))
 800e954:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e956:	2b00      	cmp	r3, #0
 800e958:	d107      	bne.n	800e96a <LIS2MDL_0_Probe+0xf6>
 800e95a:	687b      	ldr	r3, [r7, #4]
 800e95c:	f003 0302 	and.w	r3, r3, #2
 800e960:	2b00      	cmp	r3, #0
 800e962:	d002      	beq.n	800e96a <LIS2MDL_0_Probe+0xf6>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e964:	f06f 0304 	mvn.w	r3, #4
 800e968:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO))
 800e96a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800e96c:	2b00      	cmp	r3, #0
 800e96e:	d107      	bne.n	800e980 <LIS2MDL_0_Probe+0x10c>
 800e970:	687b      	ldr	r3, [r7, #4]
 800e972:	f003 0301 	and.w	r3, r3, #1
 800e976:	2b00      	cmp	r3, #0
 800e978:	d002      	beq.n	800e980 <LIS2MDL_0_Probe+0x10c>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800e97a:	f06f 0304 	mvn.w	r3, #4
 800e97e:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  return ret;
 800e980:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 800e982:	4618      	mov	r0, r3
 800e984:	3750      	adds	r7, #80	@ 0x50
 800e986:	46bd      	mov	sp, r7
 800e988:	bd80      	pop	{r7, pc}
 800e98a:	bf00      	nop
 800e98c:	08005bd5 	.word	0x08005bd5
 800e990:	08005c39 	.word	0x08005c39
 800e994:	08005ced 	.word	0x08005ced
 800e998:	08005c89 	.word	0x08005c89
 800e99c:	08005df9 	.word	0x08005df9
 800e9a0:	0800f315 	.word	0x0800f315
 800e9a4:	200021e4 	.word	0x200021e4
 800e9a8:	200021d4 	.word	0x200021d4
 800e9ac:	20002184 	.word	0x20002184
 800e9b0:	200021c4 	.word	0x200021c4
 800e9b4:	2000017c 	.word	0x2000017c
 800e9b8:	20000318 	.word	0x20000318
 800e9bc:	20002194 	.word	0x20002194
 800e9c0:	2000018c 	.word	0x2000018c

0800e9c4 <LSM6DSV16X_0_Probe>:
  * @param  Functions Motion sensor functions. Could be :
  *         - MOTION_GYRO and/or MOTION_ACCELERO
  * @retval BSP status
  */
static int32_t LSM6DSV16X_0_Probe(uint32_t Functions)
{
 800e9c4:	b580      	push	{r7, lr}
 800e9c6:	b094      	sub	sp, #80	@ 0x50
 800e9c8:	af00      	add	r7, sp, #0
 800e9ca:	6078      	str	r0, [r7, #4]
  LSM6DSV16X_IO_t            io_ctx;
  uint8_t                    id;
  static LSM6DSV16X_Object_t lsm6dsv16x_obj_0;
  LSM6DSV16X_Capabilities_t  cap;
  int32_t                    ret = BSP_ERROR_NONE;
 800e9cc:	2300      	movs	r3, #0
 800e9ce:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* Configure the driver */
  io_ctx.BusType     = LSM6DSV16X_I2C_BUS; /* I2C */
 800e9d0:	2300      	movs	r3, #0
 800e9d2:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.Address     = LSM6DSV16X_I2C_ADD_H;
 800e9d4:	23d7      	movs	r3, #215	@ 0xd7
 800e9d6:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  io_ctx.Init        = IKS4A1_I2C_Init;
 800e9da:	4b4c      	ldr	r3, [pc, #304]	@ (800eb0c <LSM6DSV16X_0_Probe+0x148>)
 800e9dc:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.DeInit      = IKS4A1_I2C_DeInit;
 800e9de:	4b4c      	ldr	r3, [pc, #304]	@ (800eb10 <LSM6DSV16X_0_Probe+0x14c>)
 800e9e0:	633b      	str	r3, [r7, #48]	@ 0x30
  io_ctx.ReadReg     = IKS4A1_I2C_ReadReg;
 800e9e2:	4b4c      	ldr	r3, [pc, #304]	@ (800eb14 <LSM6DSV16X_0_Probe+0x150>)
 800e9e4:	643b      	str	r3, [r7, #64]	@ 0x40
  io_ctx.WriteReg    = IKS4A1_I2C_WriteReg;
 800e9e6:	4b4c      	ldr	r3, [pc, #304]	@ (800eb18 <LSM6DSV16X_0_Probe+0x154>)
 800e9e8:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.GetTick     = IKS4A1_GetTick;
 800e9ea:	4b4c      	ldr	r3, [pc, #304]	@ (800eb1c <LSM6DSV16X_0_Probe+0x158>)
 800e9ec:	647b      	str	r3, [r7, #68]	@ 0x44
  io_ctx.Delay       = IKS4A1_Delay;
 800e9ee:	4b4c      	ldr	r3, [pc, #304]	@ (800eb20 <LSM6DSV16X_0_Probe+0x15c>)
 800e9f0:	64bb      	str	r3, [r7, #72]	@ 0x48

  if (LSM6DSV16X_RegisterBusIO(&lsm6dsv16x_obj_0, &io_ctx) != LSM6DSV16X_OK)
 800e9f2:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800e9f6:	4619      	mov	r1, r3
 800e9f8:	484a      	ldr	r0, [pc, #296]	@ (800eb24 <LSM6DSV16X_0_Probe+0x160>)
 800e9fa:	f7fc fc1f 	bl	800b23c <LSM6DSV16X_RegisterBusIO>
 800e9fe:	4603      	mov	r3, r0
 800ea00:	2b00      	cmp	r3, #0
 800ea02:	d003      	beq.n	800ea0c <LSM6DSV16X_0_Probe+0x48>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ea04:	f06f 0306 	mvn.w	r3, #6
 800ea08:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ea0a:	e079      	b.n	800eb00 <LSM6DSV16X_0_Probe+0x13c>
  }
  else if (LSM6DSV16X_ReadID(&lsm6dsv16x_obj_0, &id) != LSM6DSV16X_OK)
 800ea0c:	f107 032b 	add.w	r3, r7, #43	@ 0x2b
 800ea10:	4619      	mov	r1, r3
 800ea12:	4844      	ldr	r0, [pc, #272]	@ (800eb24 <LSM6DSV16X_0_Probe+0x160>)
 800ea14:	f7fc fd38 	bl	800b488 <LSM6DSV16X_ReadID>
 800ea18:	4603      	mov	r3, r0
 800ea1a:	2b00      	cmp	r3, #0
 800ea1c:	d003      	beq.n	800ea26 <LSM6DSV16X_0_Probe+0x62>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ea1e:	f06f 0306 	mvn.w	r3, #6
 800ea22:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ea24:	e06c      	b.n	800eb00 <LSM6DSV16X_0_Probe+0x13c>
  }
  else if (id != LSM6DSV16X_ID)
 800ea26:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800ea2a:	2b70      	cmp	r3, #112	@ 0x70
 800ea2c:	d003      	beq.n	800ea36 <LSM6DSV16X_0_Probe+0x72>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ea2e:	f06f 0306 	mvn.w	r3, #6
 800ea32:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ea34:	e064      	b.n	800eb00 <LSM6DSV16X_0_Probe+0x13c>
  }
  else
  {
    (void)LSM6DSV16X_GetCapabilities(&lsm6dsv16x_obj_0, &cap);
 800ea36:	f107 030c 	add.w	r3, r7, #12
 800ea3a:	4619      	mov	r1, r3
 800ea3c:	4839      	ldr	r0, [pc, #228]	@ (800eb24 <LSM6DSV16X_0_Probe+0x160>)
 800ea3e:	f7fc fd39 	bl	800b4b4 <LSM6DSV16X_GetCapabilities>
    MotionCtx[IKS4A1_LSM6DSV16X_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
 800ea42:	7b7b      	ldrb	r3, [r7, #13]
 800ea44:	461a      	mov	r2, r3
 800ea46:	7b3b      	ldrb	r3, [r7, #12]
 800ea48:	005b      	lsls	r3, r3, #1
 800ea4a:	431a      	orrs	r2, r3
 800ea4c:	7bbb      	ldrb	r3, [r7, #14]
 800ea4e:	009b      	lsls	r3, r3, #2
 800ea50:	4313      	orrs	r3, r2
 800ea52:	4a35      	ldr	r2, [pc, #212]	@ (800eb28 <LSM6DSV16X_0_Probe+0x164>)
 800ea54:	6053      	str	r3, [r2, #4]

    MotionCompObj[IKS4A1_LSM6DSV16X_0] = &lsm6dsv16x_obj_0;
 800ea56:	4b35      	ldr	r3, [pc, #212]	@ (800eb2c <LSM6DSV16X_0_Probe+0x168>)
 800ea58:	4a32      	ldr	r2, [pc, #200]	@ (800eb24 <LSM6DSV16X_0_Probe+0x160>)
 800ea5a:	605a      	str	r2, [r3, #4]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    MotionDrv[IKS4A1_LSM6DSV16X_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LSM6DSV16X_COMMON_Driver;
 800ea5c:	4b34      	ldr	r3, [pc, #208]	@ (800eb30 <LSM6DSV16X_0_Probe+0x16c>)
 800ea5e:	4a35      	ldr	r2, [pc, #212]	@ (800eb34 <LSM6DSV16X_0_Probe+0x170>)
 800ea60:	605a      	str	r2, [r3, #4]

    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO) && (cap.Gyro == 1U))
 800ea62:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ea64:	2b00      	cmp	r3, #0
 800ea66:	d11e      	bne.n	800eaa6 <LSM6DSV16X_0_Probe+0xe2>
 800ea68:	687b      	ldr	r3, [r7, #4]
 800ea6a:	f003 0301 	and.w	r3, r3, #1
 800ea6e:	2b00      	cmp	r3, #0
 800ea70:	d019      	beq.n	800eaa6 <LSM6DSV16X_0_Probe+0xe2>
 800ea72:	7b7b      	ldrb	r3, [r7, #13]
 800ea74:	2b01      	cmp	r3, #1
 800ea76:	d116      	bne.n	800eaa6 <LSM6DSV16X_0_Probe+0xe2>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[IKS4A1_LSM6DSV16X_0][FunctionIndex[MOTION_GYRO]] = (MOTION_SENSOR_FuncDrv_t *)(
 800ea78:	4b2f      	ldr	r3, [pc, #188]	@ (800eb38 <LSM6DSV16X_0_Probe+0x174>)
 800ea7a:	685b      	ldr	r3, [r3, #4]
 800ea7c:	4a2f      	ldr	r2, [pc, #188]	@ (800eb3c <LSM6DSV16X_0_Probe+0x178>)
 800ea7e:	3303      	adds	r3, #3
 800ea80:	492f      	ldr	r1, [pc, #188]	@ (800eb40 <LSM6DSV16X_0_Probe+0x17c>)
 800ea82:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                                                        void *)&LSM6DSV16X_GYRO_Driver;

      if (MotionDrv[IKS4A1_LSM6DSV16X_0]->Init(MotionCompObj[IKS4A1_LSM6DSV16X_0]) != LSM6DSV16X_OK)
 800ea86:	4b2a      	ldr	r3, [pc, #168]	@ (800eb30 <LSM6DSV16X_0_Probe+0x16c>)
 800ea88:	685b      	ldr	r3, [r3, #4]
 800ea8a:	681b      	ldr	r3, [r3, #0]
 800ea8c:	4a27      	ldr	r2, [pc, #156]	@ (800eb2c <LSM6DSV16X_0_Probe+0x168>)
 800ea8e:	6852      	ldr	r2, [r2, #4]
 800ea90:	4610      	mov	r0, r2
 800ea92:	4798      	blx	r3
 800ea94:	4603      	mov	r3, r0
 800ea96:	2b00      	cmp	r3, #0
 800ea98:	d003      	beq.n	800eaa2 <LSM6DSV16X_0_Probe+0xde>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800ea9a:	f06f 0304 	mvn.w	r3, #4
 800ea9e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800eaa0:	e001      	b.n	800eaa6 <LSM6DSV16X_0_Probe+0xe2>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800eaa2:	2300      	movs	r3, #0
 800eaa4:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO) && (cap.Acc == 1U))
 800eaa6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800eaa8:	2b00      	cmp	r3, #0
 800eaaa:	d11e      	bne.n	800eaea <LSM6DSV16X_0_Probe+0x126>
 800eaac:	687b      	ldr	r3, [r7, #4]
 800eaae:	f003 0302 	and.w	r3, r3, #2
 800eab2:	2b00      	cmp	r3, #0
 800eab4:	d019      	beq.n	800eaea <LSM6DSV16X_0_Probe+0x126>
 800eab6:	7b3b      	ldrb	r3, [r7, #12]
 800eab8:	2b01      	cmp	r3, #1
 800eaba:	d116      	bne.n	800eaea <LSM6DSV16X_0_Probe+0x126>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[IKS4A1_LSM6DSV16X_0][FunctionIndex[MOTION_ACCELERO]] = (MOTION_SENSOR_FuncDrv_t *)(
 800eabc:	4b1e      	ldr	r3, [pc, #120]	@ (800eb38 <LSM6DSV16X_0_Probe+0x174>)
 800eabe:	689b      	ldr	r3, [r3, #8]
 800eac0:	4a1e      	ldr	r2, [pc, #120]	@ (800eb3c <LSM6DSV16X_0_Probe+0x178>)
 800eac2:	3303      	adds	r3, #3
 800eac4:	491f      	ldr	r1, [pc, #124]	@ (800eb44 <LSM6DSV16X_0_Probe+0x180>)
 800eac6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                                                            void *)&LSM6DSV16X_ACC_Driver;

      if (MotionDrv[IKS4A1_LSM6DSV16X_0]->Init(MotionCompObj[IKS4A1_LSM6DSV16X_0]) != LSM6DSV16X_OK)
 800eaca:	4b19      	ldr	r3, [pc, #100]	@ (800eb30 <LSM6DSV16X_0_Probe+0x16c>)
 800eacc:	685b      	ldr	r3, [r3, #4]
 800eace:	681b      	ldr	r3, [r3, #0]
 800ead0:	4a16      	ldr	r2, [pc, #88]	@ (800eb2c <LSM6DSV16X_0_Probe+0x168>)
 800ead2:	6852      	ldr	r2, [r2, #4]
 800ead4:	4610      	mov	r0, r2
 800ead6:	4798      	blx	r3
 800ead8:	4603      	mov	r3, r0
 800eada:	2b00      	cmp	r3, #0
 800eadc:	d003      	beq.n	800eae6 <LSM6DSV16X_0_Probe+0x122>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800eade:	f06f 0304 	mvn.w	r3, #4
 800eae2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800eae4:	e001      	b.n	800eaea <LSM6DSV16X_0_Probe+0x126>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800eae6:	2300      	movs	r3, #0
 800eae8:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO))
 800eaea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800eaec:	2b00      	cmp	r3, #0
 800eaee:	d107      	bne.n	800eb00 <LSM6DSV16X_0_Probe+0x13c>
 800eaf0:	687b      	ldr	r3, [r7, #4]
 800eaf2:	f003 0304 	and.w	r3, r3, #4
 800eaf6:	2b00      	cmp	r3, #0
 800eaf8:	d002      	beq.n	800eb00 <LSM6DSV16X_0_Probe+0x13c>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800eafa:	f06f 0304 	mvn.w	r3, #4
 800eafe:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  return ret;
 800eb00:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 800eb02:	4618      	mov	r0, r3
 800eb04:	3750      	adds	r7, #80	@ 0x50
 800eb06:	46bd      	mov	sp, r7
 800eb08:	bd80      	pop	{r7, pc}
 800eb0a:	bf00      	nop
 800eb0c:	08005bd5 	.word	0x08005bd5
 800eb10:	08005c39 	.word	0x08005c39
 800eb14:	08005ced 	.word	0x08005ced
 800eb18:	08005c89 	.word	0x08005c89
 800eb1c:	08005df9 	.word	0x08005df9
 800eb20:	0800f315 	.word	0x0800f315
 800eb24:	20002218 	.word	0x20002218
 800eb28:	200021d4 	.word	0x200021d4
 800eb2c:	20002184 	.word	0x20002184
 800eb30:	200021c4 	.word	0x200021c4
 800eb34:	20000240 	.word	0x20000240
 800eb38:	20000318 	.word	0x20000318
 800eb3c:	20002194 	.word	0x20002194
 800eb40:	20000274 	.word	0x20000274
 800eb44:	20000250 	.word	0x20000250

0800eb48 <LIS2DUXS12_0_Probe>:
  * @param  Functions Motion sensor functions. Could be :
  *         - MOTION_ACCELERO
  * @retval BSP status
  */
static int32_t LIS2DUXS12_0_Probe(uint32_t Functions)
{
 800eb48:	b580      	push	{r7, lr}
 800eb4a:	b094      	sub	sp, #80	@ 0x50
 800eb4c:	af00      	add	r7, sp, #0
 800eb4e:	6078      	str	r0, [r7, #4]
  LIS2DUXS12_IO_t            io_ctx;
  uint8_t                    id;
  static LIS2DUXS12_Object_t lis2duxs12_obj_0;
  LIS2DUXS12_Capabilities_t  cap;
  int32_t                    ret = BSP_ERROR_NONE;
 800eb50:	2300      	movs	r3, #0
 800eb52:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* Configure the driver */
  io_ctx.BusType     = LIS2DUXS12_I2C_BUS; /* I2C */
 800eb54:	2300      	movs	r3, #0
 800eb56:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.Address     = LIS2DUXS12_I2C_ADD_H;
 800eb58:	2333      	movs	r3, #51	@ 0x33
 800eb5a:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  io_ctx.Init        = IKS4A1_I2C_Init;
 800eb5e:	4b42      	ldr	r3, [pc, #264]	@ (800ec68 <LIS2DUXS12_0_Probe+0x120>)
 800eb60:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.DeInit      = IKS4A1_I2C_DeInit;
 800eb62:	4b42      	ldr	r3, [pc, #264]	@ (800ec6c <LIS2DUXS12_0_Probe+0x124>)
 800eb64:	633b      	str	r3, [r7, #48]	@ 0x30
  io_ctx.ReadReg     = IKS4A1_I2C_ReadReg;
 800eb66:	4b42      	ldr	r3, [pc, #264]	@ (800ec70 <LIS2DUXS12_0_Probe+0x128>)
 800eb68:	643b      	str	r3, [r7, #64]	@ 0x40
  io_ctx.WriteReg    = IKS4A1_I2C_WriteReg;
 800eb6a:	4b42      	ldr	r3, [pc, #264]	@ (800ec74 <LIS2DUXS12_0_Probe+0x12c>)
 800eb6c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.GetTick     = IKS4A1_GetTick;
 800eb6e:	4b42      	ldr	r3, [pc, #264]	@ (800ec78 <LIS2DUXS12_0_Probe+0x130>)
 800eb70:	647b      	str	r3, [r7, #68]	@ 0x44
  io_ctx.Delay       = IKS4A1_Delay;
 800eb72:	4b42      	ldr	r3, [pc, #264]	@ (800ec7c <LIS2DUXS12_0_Probe+0x134>)
 800eb74:	64bb      	str	r3, [r7, #72]	@ 0x48

  if (LIS2DUXS12_RegisterBusIO(&lis2duxs12_obj_0, &io_ctx) != LIS2DUXS12_OK)
 800eb76:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800eb7a:	4619      	mov	r1, r3
 800eb7c:	4840      	ldr	r0, [pc, #256]	@ (800ec80 <LIS2DUXS12_0_Probe+0x138>)
 800eb7e:	f7f7 faf5 	bl	800616c <LIS2DUXS12_RegisterBusIO>
 800eb82:	4603      	mov	r3, r0
 800eb84:	2b00      	cmp	r3, #0
 800eb86:	d003      	beq.n	800eb90 <LIS2DUXS12_0_Probe+0x48>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800eb88:	f06f 0306 	mvn.w	r3, #6
 800eb8c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800eb8e:	e065      	b.n	800ec5c <LIS2DUXS12_0_Probe+0x114>
  }
  else if (LIS2DUXS12_ReadID(&lis2duxs12_obj_0, &id) != LIS2DUXS12_OK)
 800eb90:	f107 032b 	add.w	r3, r7, #43	@ 0x2b
 800eb94:	4619      	mov	r1, r3
 800eb96:	483a      	ldr	r0, [pc, #232]	@ (800ec80 <LIS2DUXS12_0_Probe+0x138>)
 800eb98:	f7f7 fc39 	bl	800640e <LIS2DUXS12_ReadID>
 800eb9c:	4603      	mov	r3, r0
 800eb9e:	2b00      	cmp	r3, #0
 800eba0:	d003      	beq.n	800ebaa <LIS2DUXS12_0_Probe+0x62>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800eba2:	f06f 0306 	mvn.w	r3, #6
 800eba6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800eba8:	e058      	b.n	800ec5c <LIS2DUXS12_0_Probe+0x114>
  }
  else if (id != LIS2DUXS12_ID)
 800ebaa:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800ebae:	2b47      	cmp	r3, #71	@ 0x47
 800ebb0:	d003      	beq.n	800ebba <LIS2DUXS12_0_Probe+0x72>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ebb2:	f06f 0306 	mvn.w	r3, #6
 800ebb6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ebb8:	e050      	b.n	800ec5c <LIS2DUXS12_0_Probe+0x114>
  }
  else
  {
    (void)LIS2DUXS12_GetCapabilities(&lis2duxs12_obj_0, &cap);
 800ebba:	f107 030c 	add.w	r3, r7, #12
 800ebbe:	4619      	mov	r1, r3
 800ebc0:	482f      	ldr	r0, [pc, #188]	@ (800ec80 <LIS2DUXS12_0_Probe+0x138>)
 800ebc2:	f7f7 fc3f 	bl	8006444 <LIS2DUXS12_GetCapabilities>
    MotionCtx[IKS4A1_LIS2DUXS12_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
 800ebc6:	7b7b      	ldrb	r3, [r7, #13]
 800ebc8:	461a      	mov	r2, r3
 800ebca:	7b3b      	ldrb	r3, [r7, #12]
 800ebcc:	005b      	lsls	r3, r3, #1
 800ebce:	431a      	orrs	r2, r3
 800ebd0:	7bbb      	ldrb	r3, [r7, #14]
 800ebd2:	009b      	lsls	r3, r3, #2
 800ebd4:	4313      	orrs	r3, r2
 800ebd6:	4a2b      	ldr	r2, [pc, #172]	@ (800ec84 <LIS2DUXS12_0_Probe+0x13c>)
 800ebd8:	6093      	str	r3, [r2, #8]

    MotionCompObj[IKS4A1_LIS2DUXS12_0] = &lis2duxs12_obj_0;
 800ebda:	4b2b      	ldr	r3, [pc, #172]	@ (800ec88 <LIS2DUXS12_0_Probe+0x140>)
 800ebdc:	4a28      	ldr	r2, [pc, #160]	@ (800ec80 <LIS2DUXS12_0_Probe+0x138>)
 800ebde:	609a      	str	r2, [r3, #8]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    MotionDrv[IKS4A1_LIS2DUXS12_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LIS2DUXS12_COMMON_Driver;
 800ebe0:	4b2a      	ldr	r3, [pc, #168]	@ (800ec8c <LIS2DUXS12_0_Probe+0x144>)
 800ebe2:	4a2b      	ldr	r2, [pc, #172]	@ (800ec90 <LIS2DUXS12_0_Probe+0x148>)
 800ebe4:	609a      	str	r2, [r3, #8]

    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO) && (cap.Gyro == 1U))
 800ebe6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ebe8:	2b00      	cmp	r3, #0
 800ebea:	d10a      	bne.n	800ec02 <LIS2DUXS12_0_Probe+0xba>
 800ebec:	687b      	ldr	r3, [r7, #4]
 800ebee:	f003 0301 	and.w	r3, r3, #1
 800ebf2:	2b00      	cmp	r3, #0
 800ebf4:	d005      	beq.n	800ec02 <LIS2DUXS12_0_Probe+0xba>
 800ebf6:	7b7b      	ldrb	r3, [r7, #13]
 800ebf8:	2b01      	cmp	r3, #1
 800ebfa:	d102      	bne.n	800ec02 <LIS2DUXS12_0_Probe+0xba>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800ebfc:	f06f 0304 	mvn.w	r3, #4
 800ec00:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO) && (cap.Acc == 1U))
 800ec02:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ec04:	2b00      	cmp	r3, #0
 800ec06:	d11e      	bne.n	800ec46 <LIS2DUXS12_0_Probe+0xfe>
 800ec08:	687b      	ldr	r3, [r7, #4]
 800ec0a:	f003 0302 	and.w	r3, r3, #2
 800ec0e:	2b00      	cmp	r3, #0
 800ec10:	d019      	beq.n	800ec46 <LIS2DUXS12_0_Probe+0xfe>
 800ec12:	7b3b      	ldrb	r3, [r7, #12]
 800ec14:	2b01      	cmp	r3, #1
 800ec16:	d116      	bne.n	800ec46 <LIS2DUXS12_0_Probe+0xfe>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[IKS4A1_LIS2DUXS12_0][FunctionIndex[MOTION_ACCELERO]] = (MOTION_SENSOR_FuncDrv_t *)(
 800ec18:	4b1e      	ldr	r3, [pc, #120]	@ (800ec94 <LIS2DUXS12_0_Probe+0x14c>)
 800ec1a:	689b      	ldr	r3, [r3, #8]
 800ec1c:	4a1e      	ldr	r2, [pc, #120]	@ (800ec98 <LIS2DUXS12_0_Probe+0x150>)
 800ec1e:	3306      	adds	r3, #6
 800ec20:	491e      	ldr	r1, [pc, #120]	@ (800ec9c <LIS2DUXS12_0_Probe+0x154>)
 800ec22:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                                                            void *)&LIS2DUXS12_ACC_Driver;

      if (MotionDrv[IKS4A1_LIS2DUXS12_0]->Init(MotionCompObj[IKS4A1_LIS2DUXS12_0]) != LIS2DUXS12_OK)
 800ec26:	4b19      	ldr	r3, [pc, #100]	@ (800ec8c <LIS2DUXS12_0_Probe+0x144>)
 800ec28:	689b      	ldr	r3, [r3, #8]
 800ec2a:	681b      	ldr	r3, [r3, #0]
 800ec2c:	4a16      	ldr	r2, [pc, #88]	@ (800ec88 <LIS2DUXS12_0_Probe+0x140>)
 800ec2e:	6892      	ldr	r2, [r2, #8]
 800ec30:	4610      	mov	r0, r2
 800ec32:	4798      	blx	r3
 800ec34:	4603      	mov	r3, r0
 800ec36:	2b00      	cmp	r3, #0
 800ec38:	d003      	beq.n	800ec42 <LIS2DUXS12_0_Probe+0xfa>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800ec3a:	f06f 0304 	mvn.w	r3, #4
 800ec3e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ec40:	e001      	b.n	800ec46 <LIS2DUXS12_0_Probe+0xfe>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800ec42:	2300      	movs	r3, #0
 800ec44:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO))
 800ec46:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ec48:	2b00      	cmp	r3, #0
 800ec4a:	d107      	bne.n	800ec5c <LIS2DUXS12_0_Probe+0x114>
 800ec4c:	687b      	ldr	r3, [r7, #4]
 800ec4e:	f003 0304 	and.w	r3, r3, #4
 800ec52:	2b00      	cmp	r3, #0
 800ec54:	d002      	beq.n	800ec5c <LIS2DUXS12_0_Probe+0x114>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800ec56:	f06f 0304 	mvn.w	r3, #4
 800ec5a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  return ret;
 800ec5c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 800ec5e:	4618      	mov	r0, r3
 800ec60:	3750      	adds	r7, #80	@ 0x50
 800ec62:	46bd      	mov	sp, r7
 800ec64:	bd80      	pop	{r7, pc}
 800ec66:	bf00      	nop
 800ec68:	08005bd5 	.word	0x08005bd5
 800ec6c:	08005c39 	.word	0x08005c39
 800ec70:	08005ced 	.word	0x08005ced
 800ec74:	08005c89 	.word	0x08005c89
 800ec78:	08005df9 	.word	0x08005df9
 800ec7c:	0800f315 	.word	0x0800f315
 800ec80:	20002250 	.word	0x20002250
 800ec84:	200021d4 	.word	0x200021d4
 800ec88:	20002184 	.word	0x20002184
 800ec8c:	200021c4 	.word	0x200021c4
 800ec90:	20000148 	.word	0x20000148
 800ec94:	20000318 	.word	0x20000318
 800ec98:	20002194 	.word	0x20002194
 800ec9c:	20000158 	.word	0x20000158

0800eca0 <LSM6DSO16IS_0_Probe>:
  * @param  Functions Motion sensor functions. Could be :
  *         - MOTION_GYRO and/or MOTION_ACCELERO
  * @retval BSP status
  */
static int32_t LSM6DSO16IS_0_Probe(uint32_t Functions)
{
 800eca0:	b580      	push	{r7, lr}
 800eca2:	b094      	sub	sp, #80	@ 0x50
 800eca4:	af00      	add	r7, sp, #0
 800eca6:	6078      	str	r0, [r7, #4]
  LSM6DSO16IS_IO_t            io_ctx;
  uint8_t                     id;
  static LSM6DSO16IS_Object_t lsm6dso16is_obj_0;
  LSM6DSO16IS_Capabilities_t  cap;
  int32_t                     ret = BSP_ERROR_NONE;
 800eca8:	2300      	movs	r3, #0
 800ecaa:	64fb      	str	r3, [r7, #76]	@ 0x4c

  /* Configure the driver */
  io_ctx.BusType     = LSM6DSO16IS_I2C_BUS; /* I2C */
 800ecac:	2300      	movs	r3, #0
 800ecae:	637b      	str	r3, [r7, #52]	@ 0x34
  io_ctx.Address     = LSM6DSO16IS_I2C_ADD_L;
 800ecb0:	23d5      	movs	r3, #213	@ 0xd5
 800ecb2:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
  io_ctx.Init        = IKS4A1_I2C_Init;
 800ecb6:	4b4c      	ldr	r3, [pc, #304]	@ (800ede8 <LSM6DSO16IS_0_Probe+0x148>)
 800ecb8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  io_ctx.DeInit      = IKS4A1_I2C_DeInit;
 800ecba:	4b4c      	ldr	r3, [pc, #304]	@ (800edec <LSM6DSO16IS_0_Probe+0x14c>)
 800ecbc:	633b      	str	r3, [r7, #48]	@ 0x30
  io_ctx.ReadReg     = IKS4A1_I2C_ReadReg;
 800ecbe:	4b4c      	ldr	r3, [pc, #304]	@ (800edf0 <LSM6DSO16IS_0_Probe+0x150>)
 800ecc0:	643b      	str	r3, [r7, #64]	@ 0x40
  io_ctx.WriteReg    = IKS4A1_I2C_WriteReg;
 800ecc2:	4b4c      	ldr	r3, [pc, #304]	@ (800edf4 <LSM6DSO16IS_0_Probe+0x154>)
 800ecc4:	63fb      	str	r3, [r7, #60]	@ 0x3c
  io_ctx.GetTick     = IKS4A1_GetTick;
 800ecc6:	4b4c      	ldr	r3, [pc, #304]	@ (800edf8 <LSM6DSO16IS_0_Probe+0x158>)
 800ecc8:	647b      	str	r3, [r7, #68]	@ 0x44
  io_ctx.Delay       = IKS4A1_Delay;
 800ecca:	4b4c      	ldr	r3, [pc, #304]	@ (800edfc <LSM6DSO16IS_0_Probe+0x15c>)
 800eccc:	64bb      	str	r3, [r7, #72]	@ 0x48

  if (LSM6DSO16IS_RegisterBusIO(&lsm6dso16is_obj_0, &io_ctx) != LSM6DSO16IS_OK)
 800ecce:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800ecd2:	4619      	mov	r1, r3
 800ecd4:	484a      	ldr	r0, [pc, #296]	@ (800ee00 <LSM6DSO16IS_0_Probe+0x160>)
 800ecd6:	f7fa fd89 	bl	80097ec <LSM6DSO16IS_RegisterBusIO>
 800ecda:	4603      	mov	r3, r0
 800ecdc:	2b00      	cmp	r3, #0
 800ecde:	d003      	beq.n	800ece8 <LSM6DSO16IS_0_Probe+0x48>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ece0:	f06f 0306 	mvn.w	r3, #6
 800ece4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ece6:	e079      	b.n	800eddc <LSM6DSO16IS_0_Probe+0x13c>
  }
  else if (LSM6DSO16IS_ReadID(&lsm6dso16is_obj_0, &id) != LSM6DSO16IS_OK)
 800ece8:	f107 032b 	add.w	r3, r7, #43	@ 0x2b
 800ecec:	4619      	mov	r1, r3
 800ecee:	4844      	ldr	r0, [pc, #272]	@ (800ee00 <LSM6DSO16IS_0_Probe+0x160>)
 800ecf0:	f7fa fe7a 	bl	80099e8 <LSM6DSO16IS_ReadID>
 800ecf4:	4603      	mov	r3, r0
 800ecf6:	2b00      	cmp	r3, #0
 800ecf8:	d003      	beq.n	800ed02 <LSM6DSO16IS_0_Probe+0x62>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ecfa:	f06f 0306 	mvn.w	r3, #6
 800ecfe:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ed00:	e06c      	b.n	800eddc <LSM6DSO16IS_0_Probe+0x13c>
  }
  else if (id != LSM6DSO16IS_ID)
 800ed02:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800ed06:	2b22      	cmp	r3, #34	@ 0x22
 800ed08:	d003      	beq.n	800ed12 <LSM6DSO16IS_0_Probe+0x72>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
 800ed0a:	f06f 0306 	mvn.w	r3, #6
 800ed0e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ed10:	e064      	b.n	800eddc <LSM6DSO16IS_0_Probe+0x13c>
  }
  else
  {
    (void)LSM6DSO16IS_GetCapabilities(&lsm6dso16is_obj_0, &cap);
 800ed12:	f107 030c 	add.w	r3, r7, #12
 800ed16:	4619      	mov	r1, r3
 800ed18:	4839      	ldr	r0, [pc, #228]	@ (800ee00 <LSM6DSO16IS_0_Probe+0x160>)
 800ed1a:	f7fa fe7d 	bl	8009a18 <LSM6DSO16IS_GetCapabilities>
    MotionCtx[IKS4A1_LSM6DSO16IS_0].Functions = ((uint32_t)cap.Gyro) | ((uint32_t)cap.Acc << 1) | ((uint32_t)cap.Magneto << 2);
 800ed1e:	7b7b      	ldrb	r3, [r7, #13]
 800ed20:	461a      	mov	r2, r3
 800ed22:	7b3b      	ldrb	r3, [r7, #12]
 800ed24:	005b      	lsls	r3, r3, #1
 800ed26:	431a      	orrs	r2, r3
 800ed28:	7bbb      	ldrb	r3, [r7, #14]
 800ed2a:	009b      	lsls	r3, r3, #2
 800ed2c:	4313      	orrs	r3, r2
 800ed2e:	4a35      	ldr	r2, [pc, #212]	@ (800ee04 <LSM6DSO16IS_0_Probe+0x164>)
 800ed30:	60d3      	str	r3, [r2, #12]

    MotionCompObj[IKS4A1_LSM6DSO16IS_0] = &lsm6dso16is_obj_0;
 800ed32:	4b35      	ldr	r3, [pc, #212]	@ (800ee08 <LSM6DSO16IS_0_Probe+0x168>)
 800ed34:	4a32      	ldr	r2, [pc, #200]	@ (800ee00 <LSM6DSO16IS_0_Probe+0x160>)
 800ed36:	60da      	str	r2, [r3, #12]
    /* The second cast (void *) is added to bypass Misra R11.3 rule */
    MotionDrv[IKS4A1_LSM6DSO16IS_0] = (MOTION_SENSOR_CommonDrv_t *)(void *)&LSM6DSO16IS_COMMON_Driver;
 800ed38:	4b34      	ldr	r3, [pc, #208]	@ (800ee0c <LSM6DSO16IS_0_Probe+0x16c>)
 800ed3a:	4a35      	ldr	r2, [pc, #212]	@ (800ee10 <LSM6DSO16IS_0_Probe+0x170>)
 800ed3c:	60da      	str	r2, [r3, #12]

    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_GYRO) == MOTION_GYRO) && (cap.Gyro == 1U))
 800ed3e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ed40:	2b00      	cmp	r3, #0
 800ed42:	d11e      	bne.n	800ed82 <LSM6DSO16IS_0_Probe+0xe2>
 800ed44:	687b      	ldr	r3, [r7, #4]
 800ed46:	f003 0301 	and.w	r3, r3, #1
 800ed4a:	2b00      	cmp	r3, #0
 800ed4c:	d019      	beq.n	800ed82 <LSM6DSO16IS_0_Probe+0xe2>
 800ed4e:	7b7b      	ldrb	r3, [r7, #13]
 800ed50:	2b01      	cmp	r3, #1
 800ed52:	d116      	bne.n	800ed82 <LSM6DSO16IS_0_Probe+0xe2>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[IKS4A1_LSM6DSO16IS_0][FunctionIndex[MOTION_GYRO]] = (MOTION_SENSOR_FuncDrv_t *)(
 800ed54:	4b2f      	ldr	r3, [pc, #188]	@ (800ee14 <LSM6DSO16IS_0_Probe+0x174>)
 800ed56:	685b      	ldr	r3, [r3, #4]
 800ed58:	4a2f      	ldr	r2, [pc, #188]	@ (800ee18 <LSM6DSO16IS_0_Probe+0x178>)
 800ed5a:	3309      	adds	r3, #9
 800ed5c:	492f      	ldr	r1, [pc, #188]	@ (800ee1c <LSM6DSO16IS_0_Probe+0x17c>)
 800ed5e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                                                         void *)&LSM6DSO16IS_GYRO_Driver;

      if (MotionDrv[IKS4A1_LSM6DSO16IS_0]->Init(MotionCompObj[IKS4A1_LSM6DSO16IS_0]) != LSM6DSO16IS_OK)
 800ed62:	4b2a      	ldr	r3, [pc, #168]	@ (800ee0c <LSM6DSO16IS_0_Probe+0x16c>)
 800ed64:	68db      	ldr	r3, [r3, #12]
 800ed66:	681b      	ldr	r3, [r3, #0]
 800ed68:	4a27      	ldr	r2, [pc, #156]	@ (800ee08 <LSM6DSO16IS_0_Probe+0x168>)
 800ed6a:	68d2      	ldr	r2, [r2, #12]
 800ed6c:	4610      	mov	r0, r2
 800ed6e:	4798      	blx	r3
 800ed70:	4603      	mov	r3, r0
 800ed72:	2b00      	cmp	r3, #0
 800ed74:	d003      	beq.n	800ed7e <LSM6DSO16IS_0_Probe+0xde>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800ed76:	f06f 0304 	mvn.w	r3, #4
 800ed7a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ed7c:	e001      	b.n	800ed82 <LSM6DSO16IS_0_Probe+0xe2>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800ed7e:	2300      	movs	r3, #0
 800ed80:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_ACCELERO) == MOTION_ACCELERO) && (cap.Acc == 1U))
 800ed82:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ed84:	2b00      	cmp	r3, #0
 800ed86:	d11e      	bne.n	800edc6 <LSM6DSO16IS_0_Probe+0x126>
 800ed88:	687b      	ldr	r3, [r7, #4]
 800ed8a:	f003 0302 	and.w	r3, r3, #2
 800ed8e:	2b00      	cmp	r3, #0
 800ed90:	d019      	beq.n	800edc6 <LSM6DSO16IS_0_Probe+0x126>
 800ed92:	7b3b      	ldrb	r3, [r7, #12]
 800ed94:	2b01      	cmp	r3, #1
 800ed96:	d116      	bne.n	800edc6 <LSM6DSO16IS_0_Probe+0x126>
    {
      /* The second cast (void *) is added to bypass Misra R11.3 rule */
      MotionFuncDrv[IKS4A1_LSM6DSO16IS_0][FunctionIndex[MOTION_ACCELERO]] = (MOTION_SENSOR_FuncDrv_t *)(
 800ed98:	4b1e      	ldr	r3, [pc, #120]	@ (800ee14 <LSM6DSO16IS_0_Probe+0x174>)
 800ed9a:	689b      	ldr	r3, [r3, #8]
 800ed9c:	4a1e      	ldr	r2, [pc, #120]	@ (800ee18 <LSM6DSO16IS_0_Probe+0x178>)
 800ed9e:	3309      	adds	r3, #9
 800eda0:	491f      	ldr	r1, [pc, #124]	@ (800ee20 <LSM6DSO16IS_0_Probe+0x180>)
 800eda2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                                                             void *)&LSM6DSO16IS_ACC_Driver;

      if (MotionDrv[IKS4A1_LSM6DSO16IS_0]->Init(MotionCompObj[IKS4A1_LSM6DSO16IS_0]) != LSM6DSO16IS_OK)
 800eda6:	4b19      	ldr	r3, [pc, #100]	@ (800ee0c <LSM6DSO16IS_0_Probe+0x16c>)
 800eda8:	68db      	ldr	r3, [r3, #12]
 800edaa:	681b      	ldr	r3, [r3, #0]
 800edac:	4a16      	ldr	r2, [pc, #88]	@ (800ee08 <LSM6DSO16IS_0_Probe+0x168>)
 800edae:	68d2      	ldr	r2, [r2, #12]
 800edb0:	4610      	mov	r0, r2
 800edb2:	4798      	blx	r3
 800edb4:	4603      	mov	r3, r0
 800edb6:	2b00      	cmp	r3, #0
 800edb8:	d003      	beq.n	800edc2 <LSM6DSO16IS_0_Probe+0x122>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
 800edba:	f06f 0304 	mvn.w	r3, #4
 800edbe:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800edc0:	e001      	b.n	800edc6 <LSM6DSO16IS_0_Probe+0x126>
      }
      else
      {
        ret = BSP_ERROR_NONE;
 800edc2:	2300      	movs	r3, #0
 800edc4:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
    }
    if ((ret == BSP_ERROR_NONE) && ((Functions & MOTION_MAGNETO) == MOTION_MAGNETO))
 800edc6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800edc8:	2b00      	cmp	r3, #0
 800edca:	d107      	bne.n	800eddc <LSM6DSO16IS_0_Probe+0x13c>
 800edcc:	687b      	ldr	r3, [r7, #4]
 800edce:	f003 0304 	and.w	r3, r3, #4
 800edd2:	2b00      	cmp	r3, #0
 800edd4:	d002      	beq.n	800eddc <LSM6DSO16IS_0_Probe+0x13c>
    {
      /* Return an error if the application try to initialize a function not supported by the component */
      ret = BSP_ERROR_COMPONENT_FAILURE;
 800edd6:	f06f 0304 	mvn.w	r3, #4
 800edda:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }
  }

  return ret;
 800eddc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
 800edde:	4618      	mov	r0, r3
 800ede0:	3750      	adds	r7, #80	@ 0x50
 800ede2:	46bd      	mov	sp, r7
 800ede4:	bd80      	pop	{r7, pc}
 800ede6:	bf00      	nop
 800ede8:	08005bd5 	.word	0x08005bd5
 800edec:	08005c39 	.word	0x08005c39
 800edf0:	08005ced 	.word	0x08005ced
 800edf4:	08005c89 	.word	0x08005c89
 800edf8:	08005df9 	.word	0x08005df9
 800edfc:	0800f315 	.word	0x0800f315
 800ee00:	2000228c 	.word	0x2000228c
 800ee04:	200021d4 	.word	0x200021d4
 800ee08:	20002184 	.word	0x20002184
 800ee0c:	200021c4 	.word	0x200021c4
 800ee10:	200001e8 	.word	0x200001e8
 800ee14:	20000318 	.word	0x20000318
 800ee18:	20002194 	.word	0x20002194
 800ee1c:	2000021c 	.word	0x2000021c
 800ee20:	200001f8 	.word	0x200001f8

0800ee24 <BSP_LED_Init>:
 *              This parameter can be one of the following values:
 *              @arg  LED2, LED4, ...
 * @retval HAL status
 */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 800ee24:	b580      	push	{r7, lr}
 800ee26:	b082      	sub	sp, #8
 800ee28:	af00      	add	r7, sp, #0
 800ee2a:	4603      	mov	r3, r0
 800ee2c:	71fb      	strb	r3, [r7, #7]
  static const BSP_LED_GPIO_Init LedGpioInit[LEDn] = {LED_USER_GPIO_Init};
  LedGpioInit[Led]();
 800ee2e:	79fb      	ldrb	r3, [r7, #7]
 800ee30:	4a04      	ldr	r2, [pc, #16]	@ (800ee44 <BSP_LED_Init+0x20>)
 800ee32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ee36:	4798      	blx	r3
  return BSP_ERROR_NONE;
 800ee38:	2300      	movs	r3, #0
}
 800ee3a:	4618      	mov	r0, r3
 800ee3c:	3708      	adds	r7, #8
 800ee3e:	46bd      	mov	sp, r7
 800ee40:	bd80      	pop	{r7, pc}
 800ee42:	bf00      	nop
 800ee44:	08023a34 	.word	0x08023a34

0800ee48 <BSP_LED_On>:
 *              @arg  LED3
 *              @arg  LED4
 * @retval HAL status
 */
int32_t BSP_LED_On(Led_TypeDef Led)
{
 800ee48:	b580      	push	{r7, lr}
 800ee4a:	b082      	sub	sp, #8
 800ee4c:	af00      	add	r7, sp, #0
 800ee4e:	4603      	mov	r3, r0
 800ee50:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(LED_PORT [Led], LED_PIN [Led], GPIO_PIN_SET);
 800ee52:	79fb      	ldrb	r3, [r7, #7]
 800ee54:	4a06      	ldr	r2, [pc, #24]	@ (800ee70 <BSP_LED_On+0x28>)
 800ee56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ee5a:	2120      	movs	r1, #32
 800ee5c:	2201      	movs	r2, #1
 800ee5e:	4618      	mov	r0, r3
 800ee60:	f000 ff64 	bl	800fd2c <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
 800ee64:	2300      	movs	r3, #0
}
 800ee66:	4618      	mov	r0, r3
 800ee68:	3708      	adds	r7, #8
 800ee6a:	46bd      	mov	sp, r7
 800ee6c:	bd80      	pop	{r7, pc}
 800ee6e:	bf00      	nop
 800ee70:	20000338 	.word	0x20000338

0800ee74 <BSP_LED_Off>:
 *              @arg  LED3
 *              @arg  LED4
 * @retval HAL status
 */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 800ee74:	b580      	push	{r7, lr}
 800ee76:	b082      	sub	sp, #8
 800ee78:	af00      	add	r7, sp, #0
 800ee7a:	4603      	mov	r3, r0
 800ee7c:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(LED_PORT [Led], LED_PIN [Led], GPIO_PIN_RESET);
 800ee7e:	79fb      	ldrb	r3, [r7, #7]
 800ee80:	4a06      	ldr	r2, [pc, #24]	@ (800ee9c <BSP_LED_Off+0x28>)
 800ee82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ee86:	2120      	movs	r1, #32
 800ee88:	2200      	movs	r2, #0
 800ee8a:	4618      	mov	r0, r3
 800ee8c:	f000 ff4e 	bl	800fd2c <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
 800ee90:	2300      	movs	r3, #0
}
 800ee92:	4618      	mov	r0, r3
 800ee94:	3708      	adds	r7, #8
 800ee96:	46bd      	mov	sp, r7
 800ee98:	bd80      	pop	{r7, pc}
 800ee9a:	bf00      	nop
 800ee9c:	20000338 	.word	0x20000338

0800eea0 <LED_USER_GPIO_Init>:
}
/**
  * @brief
  * @retval None
  */
static void LED_USER_GPIO_Init(void) {
 800eea0:	b580      	push	{r7, lr}
 800eea2:	b088      	sub	sp, #32
 800eea4:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800eea6:	2300      	movs	r3, #0
 800eea8:	60bb      	str	r3, [r7, #8]
 800eeaa:	4b1c      	ldr	r3, [pc, #112]	@ (800ef1c <LED_USER_GPIO_Init+0x7c>)
 800eeac:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800eeae:	4a1b      	ldr	r2, [pc, #108]	@ (800ef1c <LED_USER_GPIO_Init+0x7c>)
 800eeb0:	f043 0301 	orr.w	r3, r3, #1
 800eeb4:	6313      	str	r3, [r2, #48]	@ 0x30
 800eeb6:	4b19      	ldr	r3, [pc, #100]	@ (800ef1c <LED_USER_GPIO_Init+0x7c>)
 800eeb8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800eeba:	f003 0301 	and.w	r3, r3, #1
 800eebe:	60bb      	str	r3, [r7, #8]
 800eec0:	68bb      	ldr	r3, [r7, #8]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800eec2:	f107 030c 	add.w	r3, r7, #12
 800eec6:	2200      	movs	r2, #0
 800eec8:	601a      	str	r2, [r3, #0]
 800eeca:	605a      	str	r2, [r3, #4]
 800eecc:	609a      	str	r2, [r3, #8]
 800eece:	60da      	str	r2, [r3, #12]
 800eed0:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800eed2:	2300      	movs	r3, #0
 800eed4:	607b      	str	r3, [r7, #4]
 800eed6:	4b11      	ldr	r3, [pc, #68]	@ (800ef1c <LED_USER_GPIO_Init+0x7c>)
 800eed8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800eeda:	4a10      	ldr	r2, [pc, #64]	@ (800ef1c <LED_USER_GPIO_Init+0x7c>)
 800eedc:	f043 0301 	orr.w	r3, r3, #1
 800eee0:	6313      	str	r3, [r2, #48]	@ 0x30
 800eee2:	4b0e      	ldr	r3, [pc, #56]	@ (800ef1c <LED_USER_GPIO_Init+0x7c>)
 800eee4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800eee6:	f003 0301 	and.w	r3, r3, #1
 800eeea:	607b      	str	r3, [r7, #4]
 800eeec:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(BUS_BSP_LED_GPIO_PORT, BUS_BSP_LED_GPIO_PIN, GPIO_PIN_RESET);
 800eeee:	2200      	movs	r2, #0
 800eef0:	2120      	movs	r1, #32
 800eef2:	480b      	ldr	r0, [pc, #44]	@ (800ef20 <LED_USER_GPIO_Init+0x80>)
 800eef4:	f000 ff1a 	bl	800fd2c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PTPIN */
  GPIO_InitStruct.Pin = BUS_BSP_LED_GPIO_PIN;
 800eef8:	2320      	movs	r3, #32
 800eefa:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800eefc:	2301      	movs	r3, #1
 800eefe:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ef00:	2300      	movs	r3, #0
 800ef02:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800ef04:	2300      	movs	r3, #0
 800ef06:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(BUS_BSP_LED_GPIO_PORT, &GPIO_InitStruct);
 800ef08:	f107 030c 	add.w	r3, r7, #12
 800ef0c:	4619      	mov	r1, r3
 800ef0e:	4804      	ldr	r0, [pc, #16]	@ (800ef20 <LED_USER_GPIO_Init+0x80>)
 800ef10:	f000 fc8c 	bl	800f82c <HAL_GPIO_Init>

}
 800ef14:	bf00      	nop
 800ef16:	3720      	adds	r7, #32
 800ef18:	46bd      	mov	sp, r7
 800ef1a:	bd80      	pop	{r7, pc}
 800ef1c:	40023800 	.word	0x40023800
 800ef20:	40020000 	.word	0x40020000

0800ef24 <BSP_PB_Init>:
  *                    @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line
  *                                            with interrupt generation capability
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 800ef24:	b580      	push	{r7, lr}
 800ef26:	b084      	sub	sp, #16
 800ef28:	af00      	add	r7, sp, #0
 800ef2a:	4603      	mov	r3, r0
 800ef2c:	460a      	mov	r2, r1
 800ef2e:	71fb      	strb	r3, [r7, #7]
 800ef30:	4613      	mov	r3, r2
 800ef32:	71bb      	strb	r3, [r7, #6]
  int32_t ret = BSP_ERROR_NONE;
 800ef34:	2300      	movs	r3, #0
 800ef36:	60fb      	str	r3, [r7, #12]
  static const BSP_EXTI_LineCallback ButtonCallback[BUTTONn] ={BUTTON_USER_EXTI_Callback};
  static const uint32_t  BSP_BUTTON_PRIO [BUTTONn] ={BSP_BUTTON_USER_IT_PRIORITY};
  static const uint32_t BUTTON_EXTI_LINE[BUTTONn] ={USER_BUTTON_EXTI_LINE};
  static const BSP_BUTTON_GPIO_Init ButtonGpioInit[BUTTONn] = {BUTTON_USER_GPIO_Init};

  ButtonGpioInit[Button]();
 800ef38:	79fb      	ldrb	r3, [r7, #7]
 800ef3a:	4a1f      	ldr	r2, [pc, #124]	@ (800efb8 <BSP_PB_Init+0x94>)
 800ef3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ef40:	4798      	blx	r3

  if (ButtonMode == BUTTON_MODE_EXTI)
 800ef42:	79bb      	ldrb	r3, [r7, #6]
 800ef44:	2b01      	cmp	r3, #1
 800ef46:	d132      	bne.n	800efae <BSP_PB_Init+0x8a>
  {
    if(HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]) != HAL_OK)
 800ef48:	79fb      	ldrb	r3, [r7, #7]
 800ef4a:	00db      	lsls	r3, r3, #3
 800ef4c:	4a1b      	ldr	r2, [pc, #108]	@ (800efbc <BSP_PB_Init+0x98>)
 800ef4e:	441a      	add	r2, r3
 800ef50:	79fb      	ldrb	r3, [r7, #7]
 800ef52:	491b      	ldr	r1, [pc, #108]	@ (800efc0 <BSP_PB_Init+0x9c>)
 800ef54:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800ef58:	4619      	mov	r1, r3
 800ef5a:	4610      	mov	r0, r2
 800ef5c:	f000 fc2d 	bl	800f7ba <HAL_EXTI_GetHandle>
 800ef60:	4603      	mov	r3, r0
 800ef62:	2b00      	cmp	r3, #0
 800ef64:	d003      	beq.n	800ef6e <BSP_PB_Init+0x4a>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 800ef66:	f06f 0303 	mvn.w	r3, #3
 800ef6a:	60fb      	str	r3, [r7, #12]
 800ef6c:	e01f      	b.n	800efae <BSP_PB_Init+0x8a>
    }
    else if (HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]) != HAL_OK)
 800ef6e:	79fb      	ldrb	r3, [r7, #7]
 800ef70:	00db      	lsls	r3, r3, #3
 800ef72:	4a12      	ldr	r2, [pc, #72]	@ (800efbc <BSP_PB_Init+0x98>)
 800ef74:	1898      	adds	r0, r3, r2
 800ef76:	79fb      	ldrb	r3, [r7, #7]
 800ef78:	4a12      	ldr	r2, [pc, #72]	@ (800efc4 <BSP_PB_Init+0xa0>)
 800ef7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ef7e:	461a      	mov	r2, r3
 800ef80:	2100      	movs	r1, #0
 800ef82:	f000 fc00 	bl	800f786 <HAL_EXTI_RegisterCallback>
 800ef86:	4603      	mov	r3, r0
 800ef88:	2b00      	cmp	r3, #0
 800ef8a:	d003      	beq.n	800ef94 <BSP_PB_Init+0x70>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 800ef8c:	f06f 0303 	mvn.w	r3, #3
 800ef90:	60fb      	str	r3, [r7, #12]
 800ef92:	e00c      	b.n	800efae <BSP_PB_Init+0x8a>
    }
	else
    {
      /* Enable and set Button EXTI Interrupt to the lowest priority */
      HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), BSP_BUTTON_PRIO[Button], 0x00);
 800ef94:	2028      	movs	r0, #40	@ 0x28
 800ef96:	79fb      	ldrb	r3, [r7, #7]
 800ef98:	4a0b      	ldr	r2, [pc, #44]	@ (800efc8 <BSP_PB_Init+0xa4>)
 800ef9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800ef9e:	2200      	movs	r2, #0
 800efa0:	4619      	mov	r1, r3
 800efa2:	f000 fada 	bl	800f55a <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 800efa6:	2328      	movs	r3, #40	@ 0x28
 800efa8:	4618      	mov	r0, r3
 800efaa:	f000 faf2 	bl	800f592 <HAL_NVIC_EnableIRQ>
    }
  }

  return ret;
 800efae:	68fb      	ldr	r3, [r7, #12]
}
 800efb0:	4618      	mov	r0, r3
 800efb2:	3710      	adds	r7, #16
 800efb4:	46bd      	mov	sp, r7
 800efb6:	bd80      	pop	{r7, pc}
 800efb8:	08023a38 	.word	0x08023a38
 800efbc:	20000340 	.word	0x20000340
 800efc0:	08023a3c 	.word	0x08023a3c
 800efc4:	08023a40 	.word	0x08023a40
 800efc8:	08023a44 	.word	0x08023a44

0800efcc <BSP_PB_GetState>:
 *                This parameter can be one of the following values:
 *                @arg  BUTTON_USER
 * @retval The Button GPIO pin value (GPIO_PIN_RESET = button pressed)
 */
int32_t BSP_PB_GetState(Button_TypeDef Button)
{
 800efcc:	b580      	push	{r7, lr}
 800efce:	b082      	sub	sp, #8
 800efd0:	af00      	add	r7, sp, #0
 800efd2:	4603      	mov	r3, r0
 800efd4:	71fb      	strb	r3, [r7, #7]
  return (int32_t)(HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]) == GPIO_PIN_RESET);
 800efd6:	79fb      	ldrb	r3, [r7, #7]
 800efd8:	4a09      	ldr	r2, [pc, #36]	@ (800f000 <BSP_PB_GetState+0x34>)
 800efda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800efde:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800efe2:	4611      	mov	r1, r2
 800efe4:	4618      	mov	r0, r3
 800efe6:	f000 fe89 	bl	800fcfc <HAL_GPIO_ReadPin>
 800efea:	4603      	mov	r3, r0
 800efec:	2b00      	cmp	r3, #0
 800efee:	bf0c      	ite	eq
 800eff0:	2301      	moveq	r3, #1
 800eff2:	2300      	movne	r3, #0
 800eff4:	b2db      	uxtb	r3, r3
}
 800eff6:	4618      	mov	r0, r3
 800eff8:	3708      	adds	r7, #8
 800effa:	46bd      	mov	sp, r7
 800effc:	bd80      	pop	{r7, pc}
 800effe:	bf00      	nop
 800f000:	2000033c 	.word	0x2000033c

0800f004 <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  User EXTI line detection callbacks.
  * @retval None
  */
static void BUTTON_USER_EXTI_Callback(void)
{
 800f004:	b580      	push	{r7, lr}
 800f006:	af00      	add	r7, sp, #0
  BSP_PB_Callback(BUTTON_USER);
 800f008:	2000      	movs	r0, #0
 800f00a:	f7f2 f877 	bl	80010fc <BSP_PB_Callback>
}
 800f00e:	bf00      	nop
 800f010:	bd80      	pop	{r7, pc}
	...

0800f014 <BUTTON_USER_GPIO_Init>:

/**
  * @brief
  * @retval None
  */
static void BUTTON_USER_GPIO_Init(void) {
 800f014:	b580      	push	{r7, lr}
 800f016:	b088      	sub	sp, #32
 800f018:	af00      	add	r7, sp, #0

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800f01a:	2300      	movs	r3, #0
 800f01c:	60bb      	str	r3, [r7, #8]
 800f01e:	4b1a      	ldr	r3, [pc, #104]	@ (800f088 <BUTTON_USER_GPIO_Init+0x74>)
 800f020:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f022:	4a19      	ldr	r2, [pc, #100]	@ (800f088 <BUTTON_USER_GPIO_Init+0x74>)
 800f024:	f043 0304 	orr.w	r3, r3, #4
 800f028:	6313      	str	r3, [r2, #48]	@ 0x30
 800f02a:	4b17      	ldr	r3, [pc, #92]	@ (800f088 <BUTTON_USER_GPIO_Init+0x74>)
 800f02c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f02e:	f003 0304 	and.w	r3, r3, #4
 800f032:	60bb      	str	r3, [r7, #8]
 800f034:	68bb      	ldr	r3, [r7, #8]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800f036:	f107 030c 	add.w	r3, r7, #12
 800f03a:	2200      	movs	r2, #0
 800f03c:	601a      	str	r2, [r3, #0]
 800f03e:	605a      	str	r2, [r3, #4]
 800f040:	609a      	str	r2, [r3, #8]
 800f042:	60da      	str	r2, [r3, #12]
 800f044:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800f046:	2300      	movs	r3, #0
 800f048:	607b      	str	r3, [r7, #4]
 800f04a:	4b0f      	ldr	r3, [pc, #60]	@ (800f088 <BUTTON_USER_GPIO_Init+0x74>)
 800f04c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f04e:	4a0e      	ldr	r2, [pc, #56]	@ (800f088 <BUTTON_USER_GPIO_Init+0x74>)
 800f050:	f043 0304 	orr.w	r3, r3, #4
 800f054:	6313      	str	r3, [r2, #48]	@ 0x30
 800f056:	4b0c      	ldr	r3, [pc, #48]	@ (800f088 <BUTTON_USER_GPIO_Init+0x74>)
 800f058:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f05a:	f003 0304 	and.w	r3, r3, #4
 800f05e:	607b      	str	r3, [r7, #4]
 800f060:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin : PTPIN */
  GPIO_InitStruct.Pin = BUS_BSP_BUTTON_GPIO_PIN;
 800f062:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 800f066:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800f068:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
 800f06c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f06e:	2300      	movs	r3, #0
 800f070:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(BUS_BSP_BUTTON_GPIO_PORT, &GPIO_InitStruct);
 800f072:	f107 030c 	add.w	r3, r7, #12
 800f076:	4619      	mov	r1, r3
 800f078:	4804      	ldr	r0, [pc, #16]	@ (800f08c <BUTTON_USER_GPIO_Init+0x78>)
 800f07a:	f000 fbd7 	bl	800f82c <HAL_GPIO_Init>

}
 800f07e:	bf00      	nop
 800f080:	3720      	adds	r7, #32
 800f082:	46bd      	mov	sp, r7
 800f084:	bd80      	pop	{r7, pc}
 800f086:	bf00      	nop
 800f088:	40023800 	.word	0x40023800
 800f08c:	40020800 	.word	0x40020800

0800f090 <BSP_COM_Init>:
 * @param  UART_Init: Pointer to a UART_HandleTypeDef structure that contains the
 *                    configuration information for the specified USART peripheral.
 * @retval BSP error code
 */
int32_t BSP_COM_Init(COM_TypeDef COM)
{
 800f090:	b580      	push	{r7, lr}
 800f092:	b084      	sub	sp, #16
 800f094:	af00      	add	r7, sp, #0
 800f096:	4603      	mov	r3, r0
 800f098:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 800f09a:	2300      	movs	r3, #0
 800f09c:	60fb      	str	r3, [r7, #12]

  if(COM > COMn)
 800f09e:	79fb      	ldrb	r3, [r7, #7]
 800f0a0:	2b01      	cmp	r3, #1
 800f0a2:	d903      	bls.n	800f0ac <BSP_COM_Init+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 800f0a4:	f06f 0301 	mvn.w	r3, #1
 800f0a8:	60fb      	str	r3, [r7, #12]
 800f0aa:	e025      	b.n	800f0f8 <BSP_COM_Init+0x68>
  }
  else
  {
     hcom_uart[COM].Instance = COM_USART[COM];
 800f0ac:	79fb      	ldrb	r3, [r7, #7]
 800f0ae:	79fa      	ldrb	r2, [r7, #7]
 800f0b0:	4914      	ldr	r1, [pc, #80]	@ (800f104 <BSP_COM_Init+0x74>)
 800f0b2:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 800f0b6:	4814      	ldr	r0, [pc, #80]	@ (800f108 <BSP_COM_Init+0x78>)
 800f0b8:	4613      	mov	r3, r2
 800f0ba:	00db      	lsls	r3, r3, #3
 800f0bc:	4413      	add	r3, r2
 800f0be:	00db      	lsls	r3, r3, #3
 800f0c0:	4403      	add	r3, r0
 800f0c2:	6019      	str	r1, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 0U)
    /* Init the UART Msp */
    USART2_MspInit(&hcom_uart[COM]);
 800f0c4:	79fa      	ldrb	r2, [r7, #7]
 800f0c6:	4613      	mov	r3, r2
 800f0c8:	00db      	lsls	r3, r3, #3
 800f0ca:	4413      	add	r3, r2
 800f0cc:	00db      	lsls	r3, r3, #3
 800f0ce:	4a0e      	ldr	r2, [pc, #56]	@ (800f108 <BSP_COM_Init+0x78>)
 800f0d0:	4413      	add	r3, r2
 800f0d2:	4618      	mov	r0, r3
 800f0d4:	f000 f864 	bl	800f1a0 <USART2_MspInit>
      {
        return BSP_ERROR_MSP_FAILURE;
      }
    }
#endif
    if (MX_USART2_UART_Init(&hcom_uart[COM]))
 800f0d8:	79fa      	ldrb	r2, [r7, #7]
 800f0da:	4613      	mov	r3, r2
 800f0dc:	00db      	lsls	r3, r3, #3
 800f0de:	4413      	add	r3, r2
 800f0e0:	00db      	lsls	r3, r3, #3
 800f0e2:	4a09      	ldr	r2, [pc, #36]	@ (800f108 <BSP_COM_Init+0x78>)
 800f0e4:	4413      	add	r3, r2
 800f0e6:	4618      	mov	r0, r3
 800f0e8:	f000 f810 	bl	800f10c <MX_USART2_UART_Init>
 800f0ec:	4603      	mov	r3, r0
 800f0ee:	2b00      	cmp	r3, #0
 800f0f0:	d002      	beq.n	800f0f8 <BSP_COM_Init+0x68>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
 800f0f2:	f06f 0303 	mvn.w	r3, #3
 800f0f6:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
 800f0f8:	68fb      	ldr	r3, [r7, #12]
}
 800f0fa:	4618      	mov	r0, r3
 800f0fc:	3710      	adds	r7, #16
 800f0fe:	46bd      	mov	sp, r7
 800f100:	bd80      	pop	{r7, pc}
 800f102:	bf00      	nop
 800f104:	20000348 	.word	0x20000348
 800f108:	200022c4 	.word	0x200022c4

0800f10c <MX_USART2_UART_Init>:
 */

/* USART2 init function */

__weak HAL_StatusTypeDef MX_USART2_UART_Init(UART_HandleTypeDef* huart)
{
 800f10c:	b580      	push	{r7, lr}
 800f10e:	b084      	sub	sp, #16
 800f110:	af00      	add	r7, sp, #0
 800f112:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
 800f114:	2300      	movs	r3, #0
 800f116:	73fb      	strb	r3, [r7, #15]

  huart->Instance = USART2;
 800f118:	687b      	ldr	r3, [r7, #4]
 800f11a:	4a12      	ldr	r2, [pc, #72]	@ (800f164 <MX_USART2_UART_Init+0x58>)
 800f11c:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate = 115200;
 800f11e:	687b      	ldr	r3, [r7, #4]
 800f120:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 800f124:	605a      	str	r2, [r3, #4]
  huart->Init.WordLength = UART_WORDLENGTH_8B;
 800f126:	687b      	ldr	r3, [r7, #4]
 800f128:	2200      	movs	r2, #0
 800f12a:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits = UART_STOPBITS_1;
 800f12c:	687b      	ldr	r3, [r7, #4]
 800f12e:	2200      	movs	r2, #0
 800f130:	60da      	str	r2, [r3, #12]
  huart->Init.Parity = UART_PARITY_NONE;
 800f132:	687b      	ldr	r3, [r7, #4]
 800f134:	2200      	movs	r2, #0
 800f136:	611a      	str	r2, [r3, #16]
  huart->Init.Mode = UART_MODE_TX_RX;
 800f138:	687b      	ldr	r3, [r7, #4]
 800f13a:	220c      	movs	r2, #12
 800f13c:	615a      	str	r2, [r3, #20]
  huart->Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800f13e:	687b      	ldr	r3, [r7, #4]
 800f140:	2200      	movs	r2, #0
 800f142:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_16;
 800f144:	687b      	ldr	r3, [r7, #4]
 800f146:	2200      	movs	r2, #0
 800f148:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(huart) != HAL_OK)
 800f14a:	6878      	ldr	r0, [r7, #4]
 800f14c:	f005 ffb4 	bl	80150b8 <HAL_UART_Init>
 800f150:	4603      	mov	r3, r0
 800f152:	2b00      	cmp	r3, #0
 800f154:	d001      	beq.n	800f15a <MX_USART2_UART_Init+0x4e>
  {
    ret = HAL_ERROR;
 800f156:	2301      	movs	r3, #1
 800f158:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 800f15a:	7bfb      	ldrb	r3, [r7, #15]
}
 800f15c:	4618      	mov	r0, r3
 800f15e:	3710      	adds	r7, #16
 800f160:	46bd      	mov	sp, r7
 800f162:	bd80      	pop	{r7, pc}
 800f164:	40004400 	.word	0x40004400

0800f168 <__io_putchar>:
  (void)HAL_UART_Transmit(&hcom_uart[COM_ActiveLogPort], (uint8_t *)&ch, 1, COM_POLL_TIMEOUT);
  return ch;
}
#else /* For GCC Toolchains */
int __io_putchar (int ch)
{
 800f168:	b580      	push	{r7, lr}
 800f16a:	b082      	sub	sp, #8
 800f16c:	af00      	add	r7, sp, #0
 800f16e:	6078      	str	r0, [r7, #4]
  (void)HAL_UART_Transmit(&hcom_uart[COM_ActiveLogPort], (uint8_t *)&ch, 1, COM_POLL_TIMEOUT);
 800f170:	4b09      	ldr	r3, [pc, #36]	@ (800f198 <__io_putchar+0x30>)
 800f172:	781b      	ldrb	r3, [r3, #0]
 800f174:	461a      	mov	r2, r3
 800f176:	4613      	mov	r3, r2
 800f178:	00db      	lsls	r3, r3, #3
 800f17a:	4413      	add	r3, r2
 800f17c:	00db      	lsls	r3, r3, #3
 800f17e:	4a07      	ldr	r2, [pc, #28]	@ (800f19c <__io_putchar+0x34>)
 800f180:	1898      	adds	r0, r3, r2
 800f182:	1d39      	adds	r1, r7, #4
 800f184:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800f188:	2201      	movs	r2, #1
 800f18a:	f005 ffef 	bl	801516c <HAL_UART_Transmit>
  return ch;
 800f18e:	687b      	ldr	r3, [r7, #4]
}
 800f190:	4618      	mov	r0, r3
 800f192:	3708      	adds	r7, #8
 800f194:	46bd      	mov	sp, r7
 800f196:	bd80      	pop	{r7, pc}
 800f198:	2000230c 	.word	0x2000230c
 800f19c:	200022c4 	.word	0x200022c4

0800f1a0 <USART2_MspInit>:
 * @param  huart USART2 handle
 * @retval None
 */

static void USART2_MspInit(UART_HandleTypeDef* uartHandle)
{
 800f1a0:	b580      	push	{r7, lr}
 800f1a2:	b08a      	sub	sp, #40	@ 0x28
 800f1a4:	af00      	add	r7, sp, #0
 800f1a6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Enable Peripheral clock */
    __HAL_RCC_USART2_CLK_ENABLE();
 800f1a8:	2300      	movs	r3, #0
 800f1aa:	613b      	str	r3, [r7, #16]
 800f1ac:	4b1e      	ldr	r3, [pc, #120]	@ (800f228 <USART2_MspInit+0x88>)
 800f1ae:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f1b0:	4a1d      	ldr	r2, [pc, #116]	@ (800f228 <USART2_MspInit+0x88>)
 800f1b2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800f1b6:	6413      	str	r3, [r2, #64]	@ 0x40
 800f1b8:	4b1b      	ldr	r3, [pc, #108]	@ (800f228 <USART2_MspInit+0x88>)
 800f1ba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f1bc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800f1c0:	613b      	str	r3, [r7, #16]
 800f1c2:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800f1c4:	2300      	movs	r3, #0
 800f1c6:	60fb      	str	r3, [r7, #12]
 800f1c8:	4b17      	ldr	r3, [pc, #92]	@ (800f228 <USART2_MspInit+0x88>)
 800f1ca:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f1cc:	4a16      	ldr	r2, [pc, #88]	@ (800f228 <USART2_MspInit+0x88>)
 800f1ce:	f043 0301 	orr.w	r3, r3, #1
 800f1d2:	6313      	str	r3, [r2, #48]	@ 0x30
 800f1d4:	4b14      	ldr	r3, [pc, #80]	@ (800f228 <USART2_MspInit+0x88>)
 800f1d6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f1d8:	f003 0301 	and.w	r3, r3, #1
 800f1dc:	60fb      	str	r3, [r7, #12]
 800f1de:	68fb      	ldr	r3, [r7, #12]
    /**USART2 GPIO Configuration
    PA2     ------> USART2_TX
    PA3     ------> USART2_RX
    */
    GPIO_InitStruct.Pin = BUS_USART2_TX_GPIO_PIN;
 800f1e0:	2304      	movs	r3, #4
 800f1e2:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f1e4:	2302      	movs	r3, #2
 800f1e6:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f1e8:	2300      	movs	r3, #0
 800f1ea:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800f1ec:	2303      	movs	r3, #3
 800f1ee:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = BUS_USART2_TX_GPIO_AF;
 800f1f0:	2307      	movs	r3, #7
 800f1f2:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUS_USART2_TX_GPIO_PORT, &GPIO_InitStruct);
 800f1f4:	f107 0314 	add.w	r3, r7, #20
 800f1f8:	4619      	mov	r1, r3
 800f1fa:	480c      	ldr	r0, [pc, #48]	@ (800f22c <USART2_MspInit+0x8c>)
 800f1fc:	f000 fb16 	bl	800f82c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = BUS_USART2_RX_GPIO_PIN;
 800f200:	2308      	movs	r3, #8
 800f202:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f204:	2302      	movs	r3, #2
 800f206:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f208:	2300      	movs	r3, #0
 800f20a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800f20c:	2303      	movs	r3, #3
 800f20e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = BUS_USART2_RX_GPIO_AF;
 800f210:	2307      	movs	r3, #7
 800f212:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUS_USART2_RX_GPIO_PORT, &GPIO_InitStruct);
 800f214:	f107 0314 	add.w	r3, r7, #20
 800f218:	4619      	mov	r1, r3
 800f21a:	4804      	ldr	r0, [pc, #16]	@ (800f22c <USART2_MspInit+0x8c>)
 800f21c:	f000 fb06 	bl	800f82c <HAL_GPIO_Init>

  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
}
 800f220:	bf00      	nop
 800f222:	3728      	adds	r7, #40	@ 0x28
 800f224:	46bd      	mov	sp, r7
 800f226:	bd80      	pop	{r7, pc}
 800f228:	40023800 	.word	0x40023800
 800f22c:	40020000 	.word	0x40020000

0800f230 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 800f230:	b580      	push	{r7, lr}
 800f232:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 800f234:	4b0e      	ldr	r3, [pc, #56]	@ (800f270 <HAL_Init+0x40>)
 800f236:	681b      	ldr	r3, [r3, #0]
 800f238:	4a0d      	ldr	r2, [pc, #52]	@ (800f270 <HAL_Init+0x40>)
 800f23a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800f23e:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 800f240:	4b0b      	ldr	r3, [pc, #44]	@ (800f270 <HAL_Init+0x40>)
 800f242:	681b      	ldr	r3, [r3, #0]
 800f244:	4a0a      	ldr	r2, [pc, #40]	@ (800f270 <HAL_Init+0x40>)
 800f246:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800f24a:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800f24c:	4b08      	ldr	r3, [pc, #32]	@ (800f270 <HAL_Init+0x40>)
 800f24e:	681b      	ldr	r3, [r3, #0]
 800f250:	4a07      	ldr	r2, [pc, #28]	@ (800f270 <HAL_Init+0x40>)
 800f252:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800f256:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800f258:	2003      	movs	r0, #3
 800f25a:	f000 f973 	bl	800f544 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 800f25e:	2000      	movs	r0, #0
 800f260:	f000 f808 	bl	800f274 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 800f264:	f7f6 fb16 	bl	8005894 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800f268:	2300      	movs	r3, #0
}
 800f26a:	4618      	mov	r0, r3
 800f26c:	bd80      	pop	{r7, pc}
 800f26e:	bf00      	nop
 800f270:	40023c00 	.word	0x40023c00

0800f274 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800f274:	b580      	push	{r7, lr}
 800f276:	b082      	sub	sp, #8
 800f278:	af00      	add	r7, sp, #0
 800f27a:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800f27c:	4b12      	ldr	r3, [pc, #72]	@ (800f2c8 <HAL_InitTick+0x54>)
 800f27e:	681a      	ldr	r2, [r3, #0]
 800f280:	4b12      	ldr	r3, [pc, #72]	@ (800f2cc <HAL_InitTick+0x58>)
 800f282:	781b      	ldrb	r3, [r3, #0]
 800f284:	4619      	mov	r1, r3
 800f286:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 800f28a:	fbb3 f3f1 	udiv	r3, r3, r1
 800f28e:	fbb2 f3f3 	udiv	r3, r2, r3
 800f292:	4618      	mov	r0, r3
 800f294:	f000 f999 	bl	800f5ca <HAL_SYSTICK_Config>
 800f298:	4603      	mov	r3, r0
 800f29a:	2b00      	cmp	r3, #0
 800f29c:	d001      	beq.n	800f2a2 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 800f29e:	2301      	movs	r3, #1
 800f2a0:	e00e      	b.n	800f2c0 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800f2a2:	687b      	ldr	r3, [r7, #4]
 800f2a4:	2b0f      	cmp	r3, #15
 800f2a6:	d80a      	bhi.n	800f2be <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800f2a8:	2200      	movs	r2, #0
 800f2aa:	6879      	ldr	r1, [r7, #4]
 800f2ac:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800f2b0:	f000 f953 	bl	800f55a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800f2b4:	4a06      	ldr	r2, [pc, #24]	@ (800f2d0 <HAL_InitTick+0x5c>)
 800f2b6:	687b      	ldr	r3, [r7, #4]
 800f2b8:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800f2ba:	2300      	movs	r3, #0
 800f2bc:	e000      	b.n	800f2c0 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 800f2be:	2301      	movs	r3, #1
}
 800f2c0:	4618      	mov	r0, r3
 800f2c2:	3708      	adds	r7, #8
 800f2c4:	46bd      	mov	sp, r7
 800f2c6:	bd80      	pop	{r7, pc}
 800f2c8:	20000144 	.word	0x20000144
 800f2cc:	20000350 	.word	0x20000350
 800f2d0:	2000034c 	.word	0x2000034c

0800f2d4 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800f2d4:	b480      	push	{r7}
 800f2d6:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 800f2d8:	4b06      	ldr	r3, [pc, #24]	@ (800f2f4 <HAL_IncTick+0x20>)
 800f2da:	781b      	ldrb	r3, [r3, #0]
 800f2dc:	461a      	mov	r2, r3
 800f2de:	4b06      	ldr	r3, [pc, #24]	@ (800f2f8 <HAL_IncTick+0x24>)
 800f2e0:	681b      	ldr	r3, [r3, #0]
 800f2e2:	4413      	add	r3, r2
 800f2e4:	4a04      	ldr	r2, [pc, #16]	@ (800f2f8 <HAL_IncTick+0x24>)
 800f2e6:	6013      	str	r3, [r2, #0]
}
 800f2e8:	bf00      	nop
 800f2ea:	46bd      	mov	sp, r7
 800f2ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f2f0:	4770      	bx	lr
 800f2f2:	bf00      	nop
 800f2f4:	20000350 	.word	0x20000350
 800f2f8:	20002310 	.word	0x20002310

0800f2fc <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800f2fc:	b480      	push	{r7}
 800f2fe:	af00      	add	r7, sp, #0
  return uwTick;
 800f300:	4b03      	ldr	r3, [pc, #12]	@ (800f310 <HAL_GetTick+0x14>)
 800f302:	681b      	ldr	r3, [r3, #0]
}
 800f304:	4618      	mov	r0, r3
 800f306:	46bd      	mov	sp, r7
 800f308:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f30c:	4770      	bx	lr
 800f30e:	bf00      	nop
 800f310:	20002310 	.word	0x20002310

0800f314 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800f314:	b580      	push	{r7, lr}
 800f316:	b084      	sub	sp, #16
 800f318:	af00      	add	r7, sp, #0
 800f31a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 800f31c:	f7ff ffee 	bl	800f2fc <HAL_GetTick>
 800f320:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 800f322:	687b      	ldr	r3, [r7, #4]
 800f324:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800f326:	68fb      	ldr	r3, [r7, #12]
 800f328:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 800f32c:	d005      	beq.n	800f33a <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 800f32e:	4b0a      	ldr	r3, [pc, #40]	@ (800f358 <HAL_Delay+0x44>)
 800f330:	781b      	ldrb	r3, [r3, #0]
 800f332:	461a      	mov	r2, r3
 800f334:	68fb      	ldr	r3, [r7, #12]
 800f336:	4413      	add	r3, r2
 800f338:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 800f33a:	bf00      	nop
 800f33c:	f7ff ffde 	bl	800f2fc <HAL_GetTick>
 800f340:	4602      	mov	r2, r0
 800f342:	68bb      	ldr	r3, [r7, #8]
 800f344:	1ad3      	subs	r3, r2, r3
 800f346:	68fa      	ldr	r2, [r7, #12]
 800f348:	429a      	cmp	r2, r3
 800f34a:	d8f7      	bhi.n	800f33c <HAL_Delay+0x28>
  {
  }
}
 800f34c:	bf00      	nop
 800f34e:	bf00      	nop
 800f350:	3710      	adds	r7, #16
 800f352:	46bd      	mov	sp, r7
 800f354:	bd80      	pop	{r7, pc}
 800f356:	bf00      	nop
 800f358:	20000350 	.word	0x20000350

0800f35c <__NVIC_SetPriorityGrouping>:
{
 800f35c:	b480      	push	{r7}
 800f35e:	b085      	sub	sp, #20
 800f360:	af00      	add	r7, sp, #0
 800f362:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800f364:	687b      	ldr	r3, [r7, #4]
 800f366:	f003 0307 	and.w	r3, r3, #7
 800f36a:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800f36c:	4b0c      	ldr	r3, [pc, #48]	@ (800f3a0 <__NVIC_SetPriorityGrouping+0x44>)
 800f36e:	68db      	ldr	r3, [r3, #12]
 800f370:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800f372:	68ba      	ldr	r2, [r7, #8]
 800f374:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 800f378:	4013      	ands	r3, r2
 800f37a:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800f37c:	68fb      	ldr	r3, [r7, #12]
 800f37e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800f380:	68bb      	ldr	r3, [r7, #8]
 800f382:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800f384:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800f388:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800f38c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 800f38e:	4a04      	ldr	r2, [pc, #16]	@ (800f3a0 <__NVIC_SetPriorityGrouping+0x44>)
 800f390:	68bb      	ldr	r3, [r7, #8]
 800f392:	60d3      	str	r3, [r2, #12]
}
 800f394:	bf00      	nop
 800f396:	3714      	adds	r7, #20
 800f398:	46bd      	mov	sp, r7
 800f39a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f39e:	4770      	bx	lr
 800f3a0:	e000ed00 	.word	0xe000ed00

0800f3a4 <__NVIC_GetPriorityGrouping>:
{
 800f3a4:	b480      	push	{r7}
 800f3a6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800f3a8:	4b04      	ldr	r3, [pc, #16]	@ (800f3bc <__NVIC_GetPriorityGrouping+0x18>)
 800f3aa:	68db      	ldr	r3, [r3, #12]
 800f3ac:	0a1b      	lsrs	r3, r3, #8
 800f3ae:	f003 0307 	and.w	r3, r3, #7
}
 800f3b2:	4618      	mov	r0, r3
 800f3b4:	46bd      	mov	sp, r7
 800f3b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3ba:	4770      	bx	lr
 800f3bc:	e000ed00 	.word	0xe000ed00

0800f3c0 <__NVIC_EnableIRQ>:
{
 800f3c0:	b480      	push	{r7}
 800f3c2:	b083      	sub	sp, #12
 800f3c4:	af00      	add	r7, sp, #0
 800f3c6:	4603      	mov	r3, r0
 800f3c8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f3ca:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f3ce:	2b00      	cmp	r3, #0
 800f3d0:	db0b      	blt.n	800f3ea <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f3d2:	79fb      	ldrb	r3, [r7, #7]
 800f3d4:	f003 021f 	and.w	r2, r3, #31
 800f3d8:	4907      	ldr	r1, [pc, #28]	@ (800f3f8 <__NVIC_EnableIRQ+0x38>)
 800f3da:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f3de:	095b      	lsrs	r3, r3, #5
 800f3e0:	2001      	movs	r0, #1
 800f3e2:	fa00 f202 	lsl.w	r2, r0, r2
 800f3e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 800f3ea:	bf00      	nop
 800f3ec:	370c      	adds	r7, #12
 800f3ee:	46bd      	mov	sp, r7
 800f3f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3f4:	4770      	bx	lr
 800f3f6:	bf00      	nop
 800f3f8:	e000e100 	.word	0xe000e100

0800f3fc <__NVIC_DisableIRQ>:
{
 800f3fc:	b480      	push	{r7}
 800f3fe:	b083      	sub	sp, #12
 800f400:	af00      	add	r7, sp, #0
 800f402:	4603      	mov	r3, r0
 800f404:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f406:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f40a:	2b00      	cmp	r3, #0
 800f40c:	db12      	blt.n	800f434 <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800f40e:	79fb      	ldrb	r3, [r7, #7]
 800f410:	f003 021f 	and.w	r2, r3, #31
 800f414:	490a      	ldr	r1, [pc, #40]	@ (800f440 <__NVIC_DisableIRQ+0x44>)
 800f416:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f41a:	095b      	lsrs	r3, r3, #5
 800f41c:	2001      	movs	r0, #1
 800f41e:	fa00 f202 	lsl.w	r2, r0, r2
 800f422:	3320      	adds	r3, #32
 800f424:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 800f428:	f3bf 8f4f 	dsb	sy
}
 800f42c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 800f42e:	f3bf 8f6f 	isb	sy
}
 800f432:	bf00      	nop
}
 800f434:	bf00      	nop
 800f436:	370c      	adds	r7, #12
 800f438:	46bd      	mov	sp, r7
 800f43a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f43e:	4770      	bx	lr
 800f440:	e000e100 	.word	0xe000e100

0800f444 <__NVIC_SetPriority>:
{
 800f444:	b480      	push	{r7}
 800f446:	b083      	sub	sp, #12
 800f448:	af00      	add	r7, sp, #0
 800f44a:	4603      	mov	r3, r0
 800f44c:	6039      	str	r1, [r7, #0]
 800f44e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 800f450:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f454:	2b00      	cmp	r3, #0
 800f456:	db0a      	blt.n	800f46e <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f458:	683b      	ldr	r3, [r7, #0]
 800f45a:	b2da      	uxtb	r2, r3
 800f45c:	490c      	ldr	r1, [pc, #48]	@ (800f490 <__NVIC_SetPriority+0x4c>)
 800f45e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f462:	0112      	lsls	r2, r2, #4
 800f464:	b2d2      	uxtb	r2, r2
 800f466:	440b      	add	r3, r1
 800f468:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 800f46c:	e00a      	b.n	800f484 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800f46e:	683b      	ldr	r3, [r7, #0]
 800f470:	b2da      	uxtb	r2, r3
 800f472:	4908      	ldr	r1, [pc, #32]	@ (800f494 <__NVIC_SetPriority+0x50>)
 800f474:	79fb      	ldrb	r3, [r7, #7]
 800f476:	f003 030f 	and.w	r3, r3, #15
 800f47a:	3b04      	subs	r3, #4
 800f47c:	0112      	lsls	r2, r2, #4
 800f47e:	b2d2      	uxtb	r2, r2
 800f480:	440b      	add	r3, r1
 800f482:	761a      	strb	r2, [r3, #24]
}
 800f484:	bf00      	nop
 800f486:	370c      	adds	r7, #12
 800f488:	46bd      	mov	sp, r7
 800f48a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f48e:	4770      	bx	lr
 800f490:	e000e100 	.word	0xe000e100
 800f494:	e000ed00 	.word	0xe000ed00

0800f498 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800f498:	b480      	push	{r7}
 800f49a:	b089      	sub	sp, #36	@ 0x24
 800f49c:	af00      	add	r7, sp, #0
 800f49e:	60f8      	str	r0, [r7, #12]
 800f4a0:	60b9      	str	r1, [r7, #8]
 800f4a2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800f4a4:	68fb      	ldr	r3, [r7, #12]
 800f4a6:	f003 0307 	and.w	r3, r3, #7
 800f4aa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800f4ac:	69fb      	ldr	r3, [r7, #28]
 800f4ae:	f1c3 0307 	rsb	r3, r3, #7
 800f4b2:	2b04      	cmp	r3, #4
 800f4b4:	bf28      	it	cs
 800f4b6:	2304      	movcs	r3, #4
 800f4b8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800f4ba:	69fb      	ldr	r3, [r7, #28]
 800f4bc:	3304      	adds	r3, #4
 800f4be:	2b06      	cmp	r3, #6
 800f4c0:	d902      	bls.n	800f4c8 <NVIC_EncodePriority+0x30>
 800f4c2:	69fb      	ldr	r3, [r7, #28]
 800f4c4:	3b03      	subs	r3, #3
 800f4c6:	e000      	b.n	800f4ca <NVIC_EncodePriority+0x32>
 800f4c8:	2300      	movs	r3, #0
 800f4ca:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800f4cc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 800f4d0:	69bb      	ldr	r3, [r7, #24]
 800f4d2:	fa02 f303 	lsl.w	r3, r2, r3
 800f4d6:	43da      	mvns	r2, r3
 800f4d8:	68bb      	ldr	r3, [r7, #8]
 800f4da:	401a      	ands	r2, r3
 800f4dc:	697b      	ldr	r3, [r7, #20]
 800f4de:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800f4e0:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 800f4e4:	697b      	ldr	r3, [r7, #20]
 800f4e6:	fa01 f303 	lsl.w	r3, r1, r3
 800f4ea:	43d9      	mvns	r1, r3
 800f4ec:	687b      	ldr	r3, [r7, #4]
 800f4ee:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800f4f0:	4313      	orrs	r3, r2
         );
}
 800f4f2:	4618      	mov	r0, r3
 800f4f4:	3724      	adds	r7, #36	@ 0x24
 800f4f6:	46bd      	mov	sp, r7
 800f4f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4fc:	4770      	bx	lr
	...

0800f500 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 800f500:	b580      	push	{r7, lr}
 800f502:	b082      	sub	sp, #8
 800f504:	af00      	add	r7, sp, #0
 800f506:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800f508:	687b      	ldr	r3, [r7, #4]
 800f50a:	3b01      	subs	r3, #1
 800f50c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800f510:	d301      	bcc.n	800f516 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800f512:	2301      	movs	r3, #1
 800f514:	e00f      	b.n	800f536 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800f516:	4a0a      	ldr	r2, [pc, #40]	@ (800f540 <SysTick_Config+0x40>)
 800f518:	687b      	ldr	r3, [r7, #4]
 800f51a:	3b01      	subs	r3, #1
 800f51c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800f51e:	210f      	movs	r1, #15
 800f520:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 800f524:	f7ff ff8e 	bl	800f444 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800f528:	4b05      	ldr	r3, [pc, #20]	@ (800f540 <SysTick_Config+0x40>)
 800f52a:	2200      	movs	r2, #0
 800f52c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800f52e:	4b04      	ldr	r3, [pc, #16]	@ (800f540 <SysTick_Config+0x40>)
 800f530:	2207      	movs	r2, #7
 800f532:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800f534:	2300      	movs	r3, #0
}
 800f536:	4618      	mov	r0, r3
 800f538:	3708      	adds	r7, #8
 800f53a:	46bd      	mov	sp, r7
 800f53c:	bd80      	pop	{r7, pc}
 800f53e:	bf00      	nop
 800f540:	e000e010 	.word	0xe000e010

0800f544 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800f544:	b580      	push	{r7, lr}
 800f546:	b082      	sub	sp, #8
 800f548:	af00      	add	r7, sp, #0
 800f54a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800f54c:	6878      	ldr	r0, [r7, #4]
 800f54e:	f7ff ff05 	bl	800f35c <__NVIC_SetPriorityGrouping>
}
 800f552:	bf00      	nop
 800f554:	3708      	adds	r7, #8
 800f556:	46bd      	mov	sp, r7
 800f558:	bd80      	pop	{r7, pc}

0800f55a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800f55a:	b580      	push	{r7, lr}
 800f55c:	b086      	sub	sp, #24
 800f55e:	af00      	add	r7, sp, #0
 800f560:	4603      	mov	r3, r0
 800f562:	60b9      	str	r1, [r7, #8]
 800f564:	607a      	str	r2, [r7, #4]
 800f566:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 800f568:	2300      	movs	r3, #0
 800f56a:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800f56c:	f7ff ff1a 	bl	800f3a4 <__NVIC_GetPriorityGrouping>
 800f570:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800f572:	687a      	ldr	r2, [r7, #4]
 800f574:	68b9      	ldr	r1, [r7, #8]
 800f576:	6978      	ldr	r0, [r7, #20]
 800f578:	f7ff ff8e 	bl	800f498 <NVIC_EncodePriority>
 800f57c:	4602      	mov	r2, r0
 800f57e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800f582:	4611      	mov	r1, r2
 800f584:	4618      	mov	r0, r3
 800f586:	f7ff ff5d 	bl	800f444 <__NVIC_SetPriority>
}
 800f58a:	bf00      	nop
 800f58c:	3718      	adds	r7, #24
 800f58e:	46bd      	mov	sp, r7
 800f590:	bd80      	pop	{r7, pc}

0800f592 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800f592:	b580      	push	{r7, lr}
 800f594:	b082      	sub	sp, #8
 800f596:	af00      	add	r7, sp, #0
 800f598:	4603      	mov	r3, r0
 800f59a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 800f59c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f5a0:	4618      	mov	r0, r3
 800f5a2:	f7ff ff0d 	bl	800f3c0 <__NVIC_EnableIRQ>
}
 800f5a6:	bf00      	nop
 800f5a8:	3708      	adds	r7, #8
 800f5aa:	46bd      	mov	sp, r7
 800f5ac:	bd80      	pop	{r7, pc}

0800f5ae <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 800f5ae:	b580      	push	{r7, lr}
 800f5b0:	b082      	sub	sp, #8
 800f5b2:	af00      	add	r7, sp, #0
 800f5b4:	4603      	mov	r3, r0
 800f5b6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 800f5b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800f5bc:	4618      	mov	r0, r3
 800f5be:	f7ff ff1d 	bl	800f3fc <__NVIC_DisableIRQ>
}
 800f5c2:	bf00      	nop
 800f5c4:	3708      	adds	r7, #8
 800f5c6:	46bd      	mov	sp, r7
 800f5c8:	bd80      	pop	{r7, pc}

0800f5ca <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800f5ca:	b580      	push	{r7, lr}
 800f5cc:	b082      	sub	sp, #8
 800f5ce:	af00      	add	r7, sp, #0
 800f5d0:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 800f5d2:	6878      	ldr	r0, [r7, #4]
 800f5d4:	f7ff ff94 	bl	800f500 <SysTick_Config>
 800f5d8:	4603      	mov	r3, r0
}
 800f5da:	4618      	mov	r0, r3
 800f5dc:	3708      	adds	r7, #8
 800f5de:	46bd      	mov	sp, r7
 800f5e0:	bd80      	pop	{r7, pc}

0800f5e2 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 800f5e2:	b580      	push	{r7, lr}
 800f5e4:	b082      	sub	sp, #8
 800f5e6:	af00      	add	r7, sp, #0
 800f5e8:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 800f5ea:	687b      	ldr	r3, [r7, #4]
 800f5ec:	2b00      	cmp	r3, #0
 800f5ee:	d101      	bne.n	800f5f4 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 800f5f0:	2301      	movs	r3, #1
 800f5f2:	e00e      	b.n	800f612 <HAL_CRC_Init+0x30>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 800f5f4:	687b      	ldr	r3, [r7, #4]
 800f5f6:	795b      	ldrb	r3, [r3, #5]
 800f5f8:	b2db      	uxtb	r3, r3
 800f5fa:	2b00      	cmp	r3, #0
 800f5fc:	d105      	bne.n	800f60a <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 800f5fe:	687b      	ldr	r3, [r7, #4]
 800f600:	2200      	movs	r2, #0
 800f602:	711a      	strb	r2, [r3, #4]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 800f604:	6878      	ldr	r0, [r7, #4]
 800f606:	f7f6 f96d 	bl	80058e4 <HAL_CRC_MspInit>
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 800f60a:	687b      	ldr	r3, [r7, #4]
 800f60c:	2201      	movs	r2, #1
 800f60e:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 800f610:	2300      	movs	r3, #0
}
 800f612:	4618      	mov	r0, r3
 800f614:	3708      	adds	r7, #8
 800f616:	46bd      	mov	sp, r7
 800f618:	bd80      	pop	{r7, pc}

0800f61a <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 800f61a:	b580      	push	{r7, lr}
 800f61c:	b086      	sub	sp, #24
 800f61e:	af00      	add	r7, sp, #0
 800f620:	60f8      	str	r0, [r7, #12]
 800f622:	60b9      	str	r1, [r7, #8]
 800f624:	607a      	str	r2, [r7, #4]
 800f626:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800f628:	2300      	movs	r3, #0
 800f62a:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800f62c:	68fb      	ldr	r3, [r7, #12]
 800f62e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800f630:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 800f632:	68fb      	ldr	r3, [r7, #12]
 800f634:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800f638:	2b01      	cmp	r3, #1
 800f63a:	d101      	bne.n	800f640 <HAL_DMA_Start_IT+0x26>
 800f63c:	2302      	movs	r3, #2
 800f63e:	e040      	b.n	800f6c2 <HAL_DMA_Start_IT+0xa8>
 800f640:	68fb      	ldr	r3, [r7, #12]
 800f642:	2201      	movs	r2, #1
 800f644:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 800f648:	68fb      	ldr	r3, [r7, #12]
 800f64a:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800f64e:	b2db      	uxtb	r3, r3
 800f650:	2b01      	cmp	r3, #1
 800f652:	d12f      	bne.n	800f6b4 <HAL_DMA_Start_IT+0x9a>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 800f654:	68fb      	ldr	r3, [r7, #12]
 800f656:	2202      	movs	r2, #2
 800f658:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800f65c:	68fb      	ldr	r3, [r7, #12]
 800f65e:	2200      	movs	r2, #0
 800f660:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 800f662:	683b      	ldr	r3, [r7, #0]
 800f664:	687a      	ldr	r2, [r7, #4]
 800f666:	68b9      	ldr	r1, [r7, #8]
 800f668:	68f8      	ldr	r0, [r7, #12]
 800f66a:	f000 f85e 	bl	800f72a <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800f66e:	68fb      	ldr	r3, [r7, #12]
 800f670:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f672:	223f      	movs	r2, #63	@ 0x3f
 800f674:	409a      	lsls	r2, r3
 800f676:	693b      	ldr	r3, [r7, #16]
 800f678:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 800f67a:	68fb      	ldr	r3, [r7, #12]
 800f67c:	681b      	ldr	r3, [r3, #0]
 800f67e:	681a      	ldr	r2, [r3, #0]
 800f680:	68fb      	ldr	r3, [r7, #12]
 800f682:	681b      	ldr	r3, [r3, #0]
 800f684:	f042 0216 	orr.w	r2, r2, #22
 800f688:	601a      	str	r2, [r3, #0]
    
    if(hdma->XferHalfCpltCallback != NULL)
 800f68a:	68fb      	ldr	r3, [r7, #12]
 800f68c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f68e:	2b00      	cmp	r3, #0
 800f690:	d007      	beq.n	800f6a2 <HAL_DMA_Start_IT+0x88>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
 800f692:	68fb      	ldr	r3, [r7, #12]
 800f694:	681b      	ldr	r3, [r3, #0]
 800f696:	681a      	ldr	r2, [r3, #0]
 800f698:	68fb      	ldr	r3, [r7, #12]
 800f69a:	681b      	ldr	r3, [r3, #0]
 800f69c:	f042 0208 	orr.w	r2, r2, #8
 800f6a0:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 800f6a2:	68fb      	ldr	r3, [r7, #12]
 800f6a4:	681b      	ldr	r3, [r3, #0]
 800f6a6:	681a      	ldr	r2, [r3, #0]
 800f6a8:	68fb      	ldr	r3, [r7, #12]
 800f6aa:	681b      	ldr	r3, [r3, #0]
 800f6ac:	f042 0201 	orr.w	r2, r2, #1
 800f6b0:	601a      	str	r2, [r3, #0]
 800f6b2:	e005      	b.n	800f6c0 <HAL_DMA_Start_IT+0xa6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 800f6b4:	68fb      	ldr	r3, [r7, #12]
 800f6b6:	2200      	movs	r2, #0
 800f6b8:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 800f6bc:	2302      	movs	r3, #2
 800f6be:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 800f6c0:	7dfb      	ldrb	r3, [r7, #23]
}
 800f6c2:	4618      	mov	r0, r3
 800f6c4:	3718      	adds	r7, #24
 800f6c6:	46bd      	mov	sp, r7
 800f6c8:	bd80      	pop	{r7, pc}

0800f6ca <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 800f6ca:	b480      	push	{r7}
 800f6cc:	b083      	sub	sp, #12
 800f6ce:	af00      	add	r7, sp, #0
 800f6d0:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800f6d2:	687b      	ldr	r3, [r7, #4]
 800f6d4:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800f6d8:	b2db      	uxtb	r3, r3
 800f6da:	2b02      	cmp	r3, #2
 800f6dc:	d004      	beq.n	800f6e8 <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800f6de:	687b      	ldr	r3, [r7, #4]
 800f6e0:	2280      	movs	r2, #128	@ 0x80
 800f6e2:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 800f6e4:	2301      	movs	r3, #1
 800f6e6:	e00c      	b.n	800f702 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 800f6e8:	687b      	ldr	r3, [r7, #4]
 800f6ea:	2205      	movs	r2, #5
 800f6ec:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 800f6f0:	687b      	ldr	r3, [r7, #4]
 800f6f2:	681b      	ldr	r3, [r3, #0]
 800f6f4:	681a      	ldr	r2, [r3, #0]
 800f6f6:	687b      	ldr	r3, [r7, #4]
 800f6f8:	681b      	ldr	r3, [r3, #0]
 800f6fa:	f022 0201 	bic.w	r2, r2, #1
 800f6fe:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 800f700:	2300      	movs	r3, #0
}
 800f702:	4618      	mov	r0, r3
 800f704:	370c      	adds	r7, #12
 800f706:	46bd      	mov	sp, r7
 800f708:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f70c:	4770      	bx	lr

0800f70e <HAL_DMA_GetState>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
 800f70e:	b480      	push	{r7}
 800f710:	b083      	sub	sp, #12
 800f712:	af00      	add	r7, sp, #0
 800f714:	6078      	str	r0, [r7, #4]
  return hdma->State;
 800f716:	687b      	ldr	r3, [r7, #4]
 800f718:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800f71c:	b2db      	uxtb	r3, r3
}
 800f71e:	4618      	mov	r0, r3
 800f720:	370c      	adds	r7, #12
 800f722:	46bd      	mov	sp, r7
 800f724:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f728:	4770      	bx	lr

0800f72a <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 800f72a:	b480      	push	{r7}
 800f72c:	b085      	sub	sp, #20
 800f72e:	af00      	add	r7, sp, #0
 800f730:	60f8      	str	r0, [r7, #12]
 800f732:	60b9      	str	r1, [r7, #8]
 800f734:	607a      	str	r2, [r7, #4]
 800f736:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800f738:	68fb      	ldr	r3, [r7, #12]
 800f73a:	681b      	ldr	r3, [r3, #0]
 800f73c:	681a      	ldr	r2, [r3, #0]
 800f73e:	68fb      	ldr	r3, [r7, #12]
 800f740:	681b      	ldr	r3, [r3, #0]
 800f742:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 800f746:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 800f748:	68fb      	ldr	r3, [r7, #12]
 800f74a:	681b      	ldr	r3, [r3, #0]
 800f74c:	683a      	ldr	r2, [r7, #0]
 800f74e:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800f750:	68fb      	ldr	r3, [r7, #12]
 800f752:	689b      	ldr	r3, [r3, #8]
 800f754:	2b40      	cmp	r3, #64	@ 0x40
 800f756:	d108      	bne.n	800f76a <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 800f758:	68fb      	ldr	r3, [r7, #12]
 800f75a:	681b      	ldr	r3, [r3, #0]
 800f75c:	687a      	ldr	r2, [r7, #4]
 800f75e:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 800f760:	68fb      	ldr	r3, [r7, #12]
 800f762:	681b      	ldr	r3, [r3, #0]
 800f764:	68ba      	ldr	r2, [r7, #8]
 800f766:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 800f768:	e007      	b.n	800f77a <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 800f76a:	68fb      	ldr	r3, [r7, #12]
 800f76c:	681b      	ldr	r3, [r3, #0]
 800f76e:	68ba      	ldr	r2, [r7, #8]
 800f770:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 800f772:	68fb      	ldr	r3, [r7, #12]
 800f774:	681b      	ldr	r3, [r3, #0]
 800f776:	687a      	ldr	r2, [r7, #4]
 800f778:	60da      	str	r2, [r3, #12]
}
 800f77a:	bf00      	nop
 800f77c:	3714      	adds	r7, #20
 800f77e:	46bd      	mov	sp, r7
 800f780:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f784:	4770      	bx	lr

0800f786 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 800f786:	b480      	push	{r7}
 800f788:	b087      	sub	sp, #28
 800f78a:	af00      	add	r7, sp, #0
 800f78c:	60f8      	str	r0, [r7, #12]
 800f78e:	460b      	mov	r3, r1
 800f790:	607a      	str	r2, [r7, #4]
 800f792:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
 800f794:	2300      	movs	r3, #0
 800f796:	75fb      	strb	r3, [r7, #23]

  switch (CallbackID)
 800f798:	7afb      	ldrb	r3, [r7, #11]
 800f79a:	2b00      	cmp	r3, #0
 800f79c:	d103      	bne.n	800f7a6 <HAL_EXTI_RegisterCallback+0x20>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 800f79e:	68fb      	ldr	r3, [r7, #12]
 800f7a0:	687a      	ldr	r2, [r7, #4]
 800f7a2:	605a      	str	r2, [r3, #4]
      break;
 800f7a4:	e002      	b.n	800f7ac <HAL_EXTI_RegisterCallback+0x26>

    default:
      status = HAL_ERROR;
 800f7a6:	2301      	movs	r3, #1
 800f7a8:	75fb      	strb	r3, [r7, #23]
      break;
 800f7aa:	bf00      	nop
  }

  return status;
 800f7ac:	7dfb      	ldrb	r3, [r7, #23]
}
 800f7ae:	4618      	mov	r0, r3
 800f7b0:	371c      	adds	r7, #28
 800f7b2:	46bd      	mov	sp, r7
 800f7b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7b8:	4770      	bx	lr

0800f7ba <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
 800f7ba:	b480      	push	{r7}
 800f7bc:	b083      	sub	sp, #12
 800f7be:	af00      	add	r7, sp, #0
 800f7c0:	6078      	str	r0, [r7, #4]
 800f7c2:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 800f7c4:	687b      	ldr	r3, [r7, #4]
 800f7c6:	2b00      	cmp	r3, #0
 800f7c8:	d101      	bne.n	800f7ce <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
 800f7ca:	2301      	movs	r3, #1
 800f7cc:	e003      	b.n	800f7d6 <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 800f7ce:	687b      	ldr	r3, [r7, #4]
 800f7d0:	683a      	ldr	r2, [r7, #0]
 800f7d2:	601a      	str	r2, [r3, #0]

    return HAL_OK;
 800f7d4:	2300      	movs	r3, #0
  }
}
 800f7d6:	4618      	mov	r0, r3
 800f7d8:	370c      	adds	r7, #12
 800f7da:	46bd      	mov	sp, r7
 800f7dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7e0:	4770      	bx	lr
	...

0800f7e4 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
 800f7e4:	b580      	push	{r7, lr}
 800f7e6:	b084      	sub	sp, #16
 800f7e8:	af00      	add	r7, sp, #0
 800f7ea:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;

  /* Compute line mask */
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
 800f7ec:	687b      	ldr	r3, [r7, #4]
 800f7ee:	681b      	ldr	r3, [r3, #0]
 800f7f0:	f003 031f 	and.w	r3, r3, #31
 800f7f4:	2201      	movs	r2, #1
 800f7f6:	fa02 f303 	lsl.w	r3, r2, r3
 800f7fa:	60fb      	str	r3, [r7, #12]

  /* Get pending bit  */
  regval = (EXTI->PR & maskline);
 800f7fc:	4b0a      	ldr	r3, [pc, #40]	@ (800f828 <HAL_EXTI_IRQHandler+0x44>)
 800f7fe:	695b      	ldr	r3, [r3, #20]
 800f800:	68fa      	ldr	r2, [r7, #12]
 800f802:	4013      	ands	r3, r2
 800f804:	60bb      	str	r3, [r7, #8]
  if (regval != 0x00u)
 800f806:	68bb      	ldr	r3, [r7, #8]
 800f808:	2b00      	cmp	r3, #0
 800f80a:	d009      	beq.n	800f820 <HAL_EXTI_IRQHandler+0x3c>
  {
    /* Clear pending bit */
    EXTI->PR = maskline;
 800f80c:	4a06      	ldr	r2, [pc, #24]	@ (800f828 <HAL_EXTI_IRQHandler+0x44>)
 800f80e:	68fb      	ldr	r3, [r7, #12]
 800f810:	6153      	str	r3, [r2, #20]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
 800f812:	687b      	ldr	r3, [r7, #4]
 800f814:	685b      	ldr	r3, [r3, #4]
 800f816:	2b00      	cmp	r3, #0
 800f818:	d002      	beq.n	800f820 <HAL_EXTI_IRQHandler+0x3c>
    {
      hexti->PendingCallback();
 800f81a:	687b      	ldr	r3, [r7, #4]
 800f81c:	685b      	ldr	r3, [r3, #4]
 800f81e:	4798      	blx	r3
    }
  }
}
 800f820:	bf00      	nop
 800f822:	3710      	adds	r7, #16
 800f824:	46bd      	mov	sp, r7
 800f826:	bd80      	pop	{r7, pc}
 800f828:	40013c00 	.word	0x40013c00

0800f82c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800f82c:	b480      	push	{r7}
 800f82e:	b089      	sub	sp, #36	@ 0x24
 800f830:	af00      	add	r7, sp, #0
 800f832:	6078      	str	r0, [r7, #4]
 800f834:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 800f836:	2300      	movs	r3, #0
 800f838:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 800f83a:	2300      	movs	r3, #0
 800f83c:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 800f83e:	2300      	movs	r3, #0
 800f840:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800f842:	2300      	movs	r3, #0
 800f844:	61fb      	str	r3, [r7, #28]
 800f846:	e159      	b.n	800fafc <HAL_GPIO_Init+0x2d0>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800f848:	2201      	movs	r2, #1
 800f84a:	69fb      	ldr	r3, [r7, #28]
 800f84c:	fa02 f303 	lsl.w	r3, r2, r3
 800f850:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800f852:	683b      	ldr	r3, [r7, #0]
 800f854:	681b      	ldr	r3, [r3, #0]
 800f856:	697a      	ldr	r2, [r7, #20]
 800f858:	4013      	ands	r3, r2
 800f85a:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 800f85c:	693a      	ldr	r2, [r7, #16]
 800f85e:	697b      	ldr	r3, [r7, #20]
 800f860:	429a      	cmp	r2, r3
 800f862:	f040 8148 	bne.w	800faf6 <HAL_GPIO_Init+0x2ca>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800f866:	683b      	ldr	r3, [r7, #0]
 800f868:	685b      	ldr	r3, [r3, #4]
 800f86a:	f003 0303 	and.w	r3, r3, #3
 800f86e:	2b01      	cmp	r3, #1
 800f870:	d005      	beq.n	800f87e <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800f872:	683b      	ldr	r3, [r7, #0]
 800f874:	685b      	ldr	r3, [r3, #4]
 800f876:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 800f87a:	2b02      	cmp	r3, #2
 800f87c:	d130      	bne.n	800f8e0 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 800f87e:	687b      	ldr	r3, [r7, #4]
 800f880:	689b      	ldr	r3, [r3, #8]
 800f882:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800f884:	69fb      	ldr	r3, [r7, #28]
 800f886:	005b      	lsls	r3, r3, #1
 800f888:	2203      	movs	r2, #3
 800f88a:	fa02 f303 	lsl.w	r3, r2, r3
 800f88e:	43db      	mvns	r3, r3
 800f890:	69ba      	ldr	r2, [r7, #24]
 800f892:	4013      	ands	r3, r2
 800f894:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800f896:	683b      	ldr	r3, [r7, #0]
 800f898:	68da      	ldr	r2, [r3, #12]
 800f89a:	69fb      	ldr	r3, [r7, #28]
 800f89c:	005b      	lsls	r3, r3, #1
 800f89e:	fa02 f303 	lsl.w	r3, r2, r3
 800f8a2:	69ba      	ldr	r2, [r7, #24]
 800f8a4:	4313      	orrs	r3, r2
 800f8a6:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 800f8a8:	687b      	ldr	r3, [r7, #4]
 800f8aa:	69ba      	ldr	r2, [r7, #24]
 800f8ac:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800f8ae:	687b      	ldr	r3, [r7, #4]
 800f8b0:	685b      	ldr	r3, [r3, #4]
 800f8b2:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800f8b4:	2201      	movs	r2, #1
 800f8b6:	69fb      	ldr	r3, [r7, #28]
 800f8b8:	fa02 f303 	lsl.w	r3, r2, r3
 800f8bc:	43db      	mvns	r3, r3
 800f8be:	69ba      	ldr	r2, [r7, #24]
 800f8c0:	4013      	ands	r3, r2
 800f8c2:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800f8c4:	683b      	ldr	r3, [r7, #0]
 800f8c6:	685b      	ldr	r3, [r3, #4]
 800f8c8:	091b      	lsrs	r3, r3, #4
 800f8ca:	f003 0201 	and.w	r2, r3, #1
 800f8ce:	69fb      	ldr	r3, [r7, #28]
 800f8d0:	fa02 f303 	lsl.w	r3, r2, r3
 800f8d4:	69ba      	ldr	r2, [r7, #24]
 800f8d6:	4313      	orrs	r3, r2
 800f8d8:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 800f8da:	687b      	ldr	r3, [r7, #4]
 800f8dc:	69ba      	ldr	r2, [r7, #24]
 800f8de:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 800f8e0:	683b      	ldr	r3, [r7, #0]
 800f8e2:	685b      	ldr	r3, [r3, #4]
 800f8e4:	f003 0303 	and.w	r3, r3, #3
 800f8e8:	2b03      	cmp	r3, #3
 800f8ea:	d017      	beq.n	800f91c <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 800f8ec:	687b      	ldr	r3, [r7, #4]
 800f8ee:	68db      	ldr	r3, [r3, #12]
 800f8f0:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800f8f2:	69fb      	ldr	r3, [r7, #28]
 800f8f4:	005b      	lsls	r3, r3, #1
 800f8f6:	2203      	movs	r2, #3
 800f8f8:	fa02 f303 	lsl.w	r3, r2, r3
 800f8fc:	43db      	mvns	r3, r3
 800f8fe:	69ba      	ldr	r2, [r7, #24]
 800f900:	4013      	ands	r3, r2
 800f902:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 800f904:	683b      	ldr	r3, [r7, #0]
 800f906:	689a      	ldr	r2, [r3, #8]
 800f908:	69fb      	ldr	r3, [r7, #28]
 800f90a:	005b      	lsls	r3, r3, #1
 800f90c:	fa02 f303 	lsl.w	r3, r2, r3
 800f910:	69ba      	ldr	r2, [r7, #24]
 800f912:	4313      	orrs	r3, r2
 800f914:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 800f916:	687b      	ldr	r3, [r7, #4]
 800f918:	69ba      	ldr	r2, [r7, #24]
 800f91a:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800f91c:	683b      	ldr	r3, [r7, #0]
 800f91e:	685b      	ldr	r3, [r3, #4]
 800f920:	f003 0303 	and.w	r3, r3, #3
 800f924:	2b02      	cmp	r3, #2
 800f926:	d123      	bne.n	800f970 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800f928:	69fb      	ldr	r3, [r7, #28]
 800f92a:	08da      	lsrs	r2, r3, #3
 800f92c:	687b      	ldr	r3, [r7, #4]
 800f92e:	3208      	adds	r2, #8
 800f930:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f934:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800f936:	69fb      	ldr	r3, [r7, #28]
 800f938:	f003 0307 	and.w	r3, r3, #7
 800f93c:	009b      	lsls	r3, r3, #2
 800f93e:	220f      	movs	r2, #15
 800f940:	fa02 f303 	lsl.w	r3, r2, r3
 800f944:	43db      	mvns	r3, r3
 800f946:	69ba      	ldr	r2, [r7, #24]
 800f948:	4013      	ands	r3, r2
 800f94a:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 800f94c:	683b      	ldr	r3, [r7, #0]
 800f94e:	691a      	ldr	r2, [r3, #16]
 800f950:	69fb      	ldr	r3, [r7, #28]
 800f952:	f003 0307 	and.w	r3, r3, #7
 800f956:	009b      	lsls	r3, r3, #2
 800f958:	fa02 f303 	lsl.w	r3, r2, r3
 800f95c:	69ba      	ldr	r2, [r7, #24]
 800f95e:	4313      	orrs	r3, r2
 800f960:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 800f962:	69fb      	ldr	r3, [r7, #28]
 800f964:	08da      	lsrs	r2, r3, #3
 800f966:	687b      	ldr	r3, [r7, #4]
 800f968:	3208      	adds	r2, #8
 800f96a:	69b9      	ldr	r1, [r7, #24]
 800f96c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800f970:	687b      	ldr	r3, [r7, #4]
 800f972:	681b      	ldr	r3, [r3, #0]
 800f974:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800f976:	69fb      	ldr	r3, [r7, #28]
 800f978:	005b      	lsls	r3, r3, #1
 800f97a:	2203      	movs	r2, #3
 800f97c:	fa02 f303 	lsl.w	r3, r2, r3
 800f980:	43db      	mvns	r3, r3
 800f982:	69ba      	ldr	r2, [r7, #24]
 800f984:	4013      	ands	r3, r2
 800f986:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800f988:	683b      	ldr	r3, [r7, #0]
 800f98a:	685b      	ldr	r3, [r3, #4]
 800f98c:	f003 0203 	and.w	r2, r3, #3
 800f990:	69fb      	ldr	r3, [r7, #28]
 800f992:	005b      	lsls	r3, r3, #1
 800f994:	fa02 f303 	lsl.w	r3, r2, r3
 800f998:	69ba      	ldr	r2, [r7, #24]
 800f99a:	4313      	orrs	r3, r2
 800f99c:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 800f99e:	687b      	ldr	r3, [r7, #4]
 800f9a0:	69ba      	ldr	r2, [r7, #24]
 800f9a2:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800f9a4:	683b      	ldr	r3, [r7, #0]
 800f9a6:	685b      	ldr	r3, [r3, #4]
 800f9a8:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 800f9ac:	2b00      	cmp	r3, #0
 800f9ae:	f000 80a2 	beq.w	800faf6 <HAL_GPIO_Init+0x2ca>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800f9b2:	2300      	movs	r3, #0
 800f9b4:	60fb      	str	r3, [r7, #12]
 800f9b6:	4b57      	ldr	r3, [pc, #348]	@ (800fb14 <HAL_GPIO_Init+0x2e8>)
 800f9b8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f9ba:	4a56      	ldr	r2, [pc, #344]	@ (800fb14 <HAL_GPIO_Init+0x2e8>)
 800f9bc:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 800f9c0:	6453      	str	r3, [r2, #68]	@ 0x44
 800f9c2:	4b54      	ldr	r3, [pc, #336]	@ (800fb14 <HAL_GPIO_Init+0x2e8>)
 800f9c4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800f9c6:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800f9ca:	60fb      	str	r3, [r7, #12]
 800f9cc:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 800f9ce:	4a52      	ldr	r2, [pc, #328]	@ (800fb18 <HAL_GPIO_Init+0x2ec>)
 800f9d0:	69fb      	ldr	r3, [r7, #28]
 800f9d2:	089b      	lsrs	r3, r3, #2
 800f9d4:	3302      	adds	r3, #2
 800f9d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800f9da:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 800f9dc:	69fb      	ldr	r3, [r7, #28]
 800f9de:	f003 0303 	and.w	r3, r3, #3
 800f9e2:	009b      	lsls	r3, r3, #2
 800f9e4:	220f      	movs	r2, #15
 800f9e6:	fa02 f303 	lsl.w	r3, r2, r3
 800f9ea:	43db      	mvns	r3, r3
 800f9ec:	69ba      	ldr	r2, [r7, #24]
 800f9ee:	4013      	ands	r3, r2
 800f9f0:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800f9f2:	687b      	ldr	r3, [r7, #4]
 800f9f4:	4a49      	ldr	r2, [pc, #292]	@ (800fb1c <HAL_GPIO_Init+0x2f0>)
 800f9f6:	4293      	cmp	r3, r2
 800f9f8:	d019      	beq.n	800fa2e <HAL_GPIO_Init+0x202>
 800f9fa:	687b      	ldr	r3, [r7, #4]
 800f9fc:	4a48      	ldr	r2, [pc, #288]	@ (800fb20 <HAL_GPIO_Init+0x2f4>)
 800f9fe:	4293      	cmp	r3, r2
 800fa00:	d013      	beq.n	800fa2a <HAL_GPIO_Init+0x1fe>
 800fa02:	687b      	ldr	r3, [r7, #4]
 800fa04:	4a47      	ldr	r2, [pc, #284]	@ (800fb24 <HAL_GPIO_Init+0x2f8>)
 800fa06:	4293      	cmp	r3, r2
 800fa08:	d00d      	beq.n	800fa26 <HAL_GPIO_Init+0x1fa>
 800fa0a:	687b      	ldr	r3, [r7, #4]
 800fa0c:	4a46      	ldr	r2, [pc, #280]	@ (800fb28 <HAL_GPIO_Init+0x2fc>)
 800fa0e:	4293      	cmp	r3, r2
 800fa10:	d007      	beq.n	800fa22 <HAL_GPIO_Init+0x1f6>
 800fa12:	687b      	ldr	r3, [r7, #4]
 800fa14:	4a45      	ldr	r2, [pc, #276]	@ (800fb2c <HAL_GPIO_Init+0x300>)
 800fa16:	4293      	cmp	r3, r2
 800fa18:	d101      	bne.n	800fa1e <HAL_GPIO_Init+0x1f2>
 800fa1a:	2304      	movs	r3, #4
 800fa1c:	e008      	b.n	800fa30 <HAL_GPIO_Init+0x204>
 800fa1e:	2307      	movs	r3, #7
 800fa20:	e006      	b.n	800fa30 <HAL_GPIO_Init+0x204>
 800fa22:	2303      	movs	r3, #3
 800fa24:	e004      	b.n	800fa30 <HAL_GPIO_Init+0x204>
 800fa26:	2302      	movs	r3, #2
 800fa28:	e002      	b.n	800fa30 <HAL_GPIO_Init+0x204>
 800fa2a:	2301      	movs	r3, #1
 800fa2c:	e000      	b.n	800fa30 <HAL_GPIO_Init+0x204>
 800fa2e:	2300      	movs	r3, #0
 800fa30:	69fa      	ldr	r2, [r7, #28]
 800fa32:	f002 0203 	and.w	r2, r2, #3
 800fa36:	0092      	lsls	r2, r2, #2
 800fa38:	4093      	lsls	r3, r2
 800fa3a:	69ba      	ldr	r2, [r7, #24]
 800fa3c:	4313      	orrs	r3, r2
 800fa3e:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800fa40:	4935      	ldr	r1, [pc, #212]	@ (800fb18 <HAL_GPIO_Init+0x2ec>)
 800fa42:	69fb      	ldr	r3, [r7, #28]
 800fa44:	089b      	lsrs	r3, r3, #2
 800fa46:	3302      	adds	r3, #2
 800fa48:	69ba      	ldr	r2, [r7, #24]
 800fa4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800fa4e:	4b38      	ldr	r3, [pc, #224]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800fa50:	689b      	ldr	r3, [r3, #8]
 800fa52:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800fa54:	693b      	ldr	r3, [r7, #16]
 800fa56:	43db      	mvns	r3, r3
 800fa58:	69ba      	ldr	r2, [r7, #24]
 800fa5a:	4013      	ands	r3, r2
 800fa5c:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800fa5e:	683b      	ldr	r3, [r7, #0]
 800fa60:	685b      	ldr	r3, [r3, #4]
 800fa62:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800fa66:	2b00      	cmp	r3, #0
 800fa68:	d003      	beq.n	800fa72 <HAL_GPIO_Init+0x246>
        {
          temp |= iocurrent;
 800fa6a:	69ba      	ldr	r2, [r7, #24]
 800fa6c:	693b      	ldr	r3, [r7, #16]
 800fa6e:	4313      	orrs	r3, r2
 800fa70:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800fa72:	4a2f      	ldr	r2, [pc, #188]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800fa74:	69bb      	ldr	r3, [r7, #24]
 800fa76:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800fa78:	4b2d      	ldr	r3, [pc, #180]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800fa7a:	68db      	ldr	r3, [r3, #12]
 800fa7c:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800fa7e:	693b      	ldr	r3, [r7, #16]
 800fa80:	43db      	mvns	r3, r3
 800fa82:	69ba      	ldr	r2, [r7, #24]
 800fa84:	4013      	ands	r3, r2
 800fa86:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800fa88:	683b      	ldr	r3, [r7, #0]
 800fa8a:	685b      	ldr	r3, [r3, #4]
 800fa8c:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800fa90:	2b00      	cmp	r3, #0
 800fa92:	d003      	beq.n	800fa9c <HAL_GPIO_Init+0x270>
        {
          temp |= iocurrent;
 800fa94:	69ba      	ldr	r2, [r7, #24]
 800fa96:	693b      	ldr	r3, [r7, #16]
 800fa98:	4313      	orrs	r3, r2
 800fa9a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 800fa9c:	4a24      	ldr	r2, [pc, #144]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800fa9e:	69bb      	ldr	r3, [r7, #24]
 800faa0:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800faa2:	4b23      	ldr	r3, [pc, #140]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800faa4:	685b      	ldr	r3, [r3, #4]
 800faa6:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800faa8:	693b      	ldr	r3, [r7, #16]
 800faaa:	43db      	mvns	r3, r3
 800faac:	69ba      	ldr	r2, [r7, #24]
 800faae:	4013      	ands	r3, r2
 800fab0:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800fab2:	683b      	ldr	r3, [r7, #0]
 800fab4:	685b      	ldr	r3, [r3, #4]
 800fab6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800faba:	2b00      	cmp	r3, #0
 800fabc:	d003      	beq.n	800fac6 <HAL_GPIO_Init+0x29a>
        {
          temp |= iocurrent;
 800fabe:	69ba      	ldr	r2, [r7, #24]
 800fac0:	693b      	ldr	r3, [r7, #16]
 800fac2:	4313      	orrs	r3, r2
 800fac4:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800fac6:	4a1a      	ldr	r2, [pc, #104]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800fac8:	69bb      	ldr	r3, [r7, #24]
 800faca:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800facc:	4b18      	ldr	r3, [pc, #96]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800face:	681b      	ldr	r3, [r3, #0]
 800fad0:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800fad2:	693b      	ldr	r3, [r7, #16]
 800fad4:	43db      	mvns	r3, r3
 800fad6:	69ba      	ldr	r2, [r7, #24]
 800fad8:	4013      	ands	r3, r2
 800fada:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800fadc:	683b      	ldr	r3, [r7, #0]
 800fade:	685b      	ldr	r3, [r3, #4]
 800fae0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800fae4:	2b00      	cmp	r3, #0
 800fae6:	d003      	beq.n	800faf0 <HAL_GPIO_Init+0x2c4>
        {
          temp |= iocurrent;
 800fae8:	69ba      	ldr	r2, [r7, #24]
 800faea:	693b      	ldr	r3, [r7, #16]
 800faec:	4313      	orrs	r3, r2
 800faee:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800faf0:	4a0f      	ldr	r2, [pc, #60]	@ (800fb30 <HAL_GPIO_Init+0x304>)
 800faf2:	69bb      	ldr	r3, [r7, #24]
 800faf4:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800faf6:	69fb      	ldr	r3, [r7, #28]
 800faf8:	3301      	adds	r3, #1
 800fafa:	61fb      	str	r3, [r7, #28]
 800fafc:	69fb      	ldr	r3, [r7, #28]
 800fafe:	2b0f      	cmp	r3, #15
 800fb00:	f67f aea2 	bls.w	800f848 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 800fb04:	bf00      	nop
 800fb06:	bf00      	nop
 800fb08:	3724      	adds	r7, #36	@ 0x24
 800fb0a:	46bd      	mov	sp, r7
 800fb0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb10:	4770      	bx	lr
 800fb12:	bf00      	nop
 800fb14:	40023800 	.word	0x40023800
 800fb18:	40013800 	.word	0x40013800
 800fb1c:	40020000 	.word	0x40020000
 800fb20:	40020400 	.word	0x40020400
 800fb24:	40020800 	.word	0x40020800
 800fb28:	40020c00 	.word	0x40020c00
 800fb2c:	40021000 	.word	0x40021000
 800fb30:	40013c00 	.word	0x40013c00

0800fb34 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 800fb34:	b480      	push	{r7}
 800fb36:	b087      	sub	sp, #28
 800fb38:	af00      	add	r7, sp, #0
 800fb3a:	6078      	str	r0, [r7, #4]
 800fb3c:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 800fb3e:	2300      	movs	r3, #0
 800fb40:	613b      	str	r3, [r7, #16]
  uint32_t iocurrent = 0x00U;
 800fb42:	2300      	movs	r3, #0
 800fb44:	60fb      	str	r3, [r7, #12]
  uint32_t tmp = 0x00U;
 800fb46:	2300      	movs	r3, #0
 800fb48:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800fb4a:	2300      	movs	r3, #0
 800fb4c:	617b      	str	r3, [r7, #20]
 800fb4e:	e0bb      	b.n	800fcc8 <HAL_GPIO_DeInit+0x194>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800fb50:	2201      	movs	r2, #1
 800fb52:	697b      	ldr	r3, [r7, #20]
 800fb54:	fa02 f303 	lsl.w	r3, r2, r3
 800fb58:	613b      	str	r3, [r7, #16]
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;
 800fb5a:	683a      	ldr	r2, [r7, #0]
 800fb5c:	693b      	ldr	r3, [r7, #16]
 800fb5e:	4013      	ands	r3, r2
 800fb60:	60fb      	str	r3, [r7, #12]

    if(iocurrent == ioposition)
 800fb62:	68fa      	ldr	r2, [r7, #12]
 800fb64:	693b      	ldr	r3, [r7, #16]
 800fb66:	429a      	cmp	r2, r3
 800fb68:	f040 80ab 	bne.w	800fcc2 <HAL_GPIO_DeInit+0x18e>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2U];
 800fb6c:	4a5c      	ldr	r2, [pc, #368]	@ (800fce0 <HAL_GPIO_DeInit+0x1ac>)
 800fb6e:	697b      	ldr	r3, [r7, #20]
 800fb70:	089b      	lsrs	r3, r3, #2
 800fb72:	3302      	adds	r3, #2
 800fb74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800fb78:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FU << (4U * (position & 0x03U)));
 800fb7a:	697b      	ldr	r3, [r7, #20]
 800fb7c:	f003 0303 	and.w	r3, r3, #3
 800fb80:	009b      	lsls	r3, r3, #2
 800fb82:	220f      	movs	r2, #15
 800fb84:	fa02 f303 	lsl.w	r3, r2, r3
 800fb88:	68ba      	ldr	r2, [r7, #8]
 800fb8a:	4013      	ands	r3, r2
 800fb8c:	60bb      	str	r3, [r7, #8]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 800fb8e:	687b      	ldr	r3, [r7, #4]
 800fb90:	4a54      	ldr	r2, [pc, #336]	@ (800fce4 <HAL_GPIO_DeInit+0x1b0>)
 800fb92:	4293      	cmp	r3, r2
 800fb94:	d019      	beq.n	800fbca <HAL_GPIO_DeInit+0x96>
 800fb96:	687b      	ldr	r3, [r7, #4]
 800fb98:	4a53      	ldr	r2, [pc, #332]	@ (800fce8 <HAL_GPIO_DeInit+0x1b4>)
 800fb9a:	4293      	cmp	r3, r2
 800fb9c:	d013      	beq.n	800fbc6 <HAL_GPIO_DeInit+0x92>
 800fb9e:	687b      	ldr	r3, [r7, #4]
 800fba0:	4a52      	ldr	r2, [pc, #328]	@ (800fcec <HAL_GPIO_DeInit+0x1b8>)
 800fba2:	4293      	cmp	r3, r2
 800fba4:	d00d      	beq.n	800fbc2 <HAL_GPIO_DeInit+0x8e>
 800fba6:	687b      	ldr	r3, [r7, #4]
 800fba8:	4a51      	ldr	r2, [pc, #324]	@ (800fcf0 <HAL_GPIO_DeInit+0x1bc>)
 800fbaa:	4293      	cmp	r3, r2
 800fbac:	d007      	beq.n	800fbbe <HAL_GPIO_DeInit+0x8a>
 800fbae:	687b      	ldr	r3, [r7, #4]
 800fbb0:	4a50      	ldr	r2, [pc, #320]	@ (800fcf4 <HAL_GPIO_DeInit+0x1c0>)
 800fbb2:	4293      	cmp	r3, r2
 800fbb4:	d101      	bne.n	800fbba <HAL_GPIO_DeInit+0x86>
 800fbb6:	2304      	movs	r3, #4
 800fbb8:	e008      	b.n	800fbcc <HAL_GPIO_DeInit+0x98>
 800fbba:	2307      	movs	r3, #7
 800fbbc:	e006      	b.n	800fbcc <HAL_GPIO_DeInit+0x98>
 800fbbe:	2303      	movs	r3, #3
 800fbc0:	e004      	b.n	800fbcc <HAL_GPIO_DeInit+0x98>
 800fbc2:	2302      	movs	r3, #2
 800fbc4:	e002      	b.n	800fbcc <HAL_GPIO_DeInit+0x98>
 800fbc6:	2301      	movs	r3, #1
 800fbc8:	e000      	b.n	800fbcc <HAL_GPIO_DeInit+0x98>
 800fbca:	2300      	movs	r3, #0
 800fbcc:	697a      	ldr	r2, [r7, #20]
 800fbce:	f002 0203 	and.w	r2, r2, #3
 800fbd2:	0092      	lsls	r2, r2, #2
 800fbd4:	4093      	lsls	r3, r2
 800fbd6:	68ba      	ldr	r2, [r7, #8]
 800fbd8:	429a      	cmp	r2, r3
 800fbda:	d132      	bne.n	800fc42 <HAL_GPIO_DeInit+0x10e>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 800fbdc:	4b46      	ldr	r3, [pc, #280]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fbde:	681a      	ldr	r2, [r3, #0]
 800fbe0:	68fb      	ldr	r3, [r7, #12]
 800fbe2:	43db      	mvns	r3, r3
 800fbe4:	4944      	ldr	r1, [pc, #272]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fbe6:	4013      	ands	r3, r2
 800fbe8:	600b      	str	r3, [r1, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 800fbea:	4b43      	ldr	r3, [pc, #268]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fbec:	685a      	ldr	r2, [r3, #4]
 800fbee:	68fb      	ldr	r3, [r7, #12]
 800fbf0:	43db      	mvns	r3, r3
 800fbf2:	4941      	ldr	r1, [pc, #260]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fbf4:	4013      	ands	r3, r2
 800fbf6:	604b      	str	r3, [r1, #4]
        
        /* Clear Rising Falling edge configuration */
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 800fbf8:	4b3f      	ldr	r3, [pc, #252]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fbfa:	68da      	ldr	r2, [r3, #12]
 800fbfc:	68fb      	ldr	r3, [r7, #12]
 800fbfe:	43db      	mvns	r3, r3
 800fc00:	493d      	ldr	r1, [pc, #244]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fc02:	4013      	ands	r3, r2
 800fc04:	60cb      	str	r3, [r1, #12]
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 800fc06:	4b3c      	ldr	r3, [pc, #240]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fc08:	689a      	ldr	r2, [r3, #8]
 800fc0a:	68fb      	ldr	r3, [r7, #12]
 800fc0c:	43db      	mvns	r3, r3
 800fc0e:	493a      	ldr	r1, [pc, #232]	@ (800fcf8 <HAL_GPIO_DeInit+0x1c4>)
 800fc10:	4013      	ands	r3, r2
 800fc12:	608b      	str	r3, [r1, #8]

        /* Configure the External Interrupt or event for the current IO */
        tmp = 0x0FU << (4U * (position & 0x03U));
 800fc14:	697b      	ldr	r3, [r7, #20]
 800fc16:	f003 0303 	and.w	r3, r3, #3
 800fc1a:	009b      	lsls	r3, r3, #2
 800fc1c:	220f      	movs	r2, #15
 800fc1e:	fa02 f303 	lsl.w	r3, r2, r3
 800fc22:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 800fc24:	4a2e      	ldr	r2, [pc, #184]	@ (800fce0 <HAL_GPIO_DeInit+0x1ac>)
 800fc26:	697b      	ldr	r3, [r7, #20]
 800fc28:	089b      	lsrs	r3, r3, #2
 800fc2a:	3302      	adds	r3, #2
 800fc2c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800fc30:	68bb      	ldr	r3, [r7, #8]
 800fc32:	43da      	mvns	r2, r3
 800fc34:	482a      	ldr	r0, [pc, #168]	@ (800fce0 <HAL_GPIO_DeInit+0x1ac>)
 800fc36:	697b      	ldr	r3, [r7, #20]
 800fc38:	089b      	lsrs	r3, r3, #2
 800fc3a:	400a      	ands	r2, r1
 800fc3c:	3302      	adds	r3, #2
 800fc3e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800fc42:	687b      	ldr	r3, [r7, #4]
 800fc44:	681a      	ldr	r2, [r3, #0]
 800fc46:	697b      	ldr	r3, [r7, #20]
 800fc48:	005b      	lsls	r3, r3, #1
 800fc4a:	2103      	movs	r1, #3
 800fc4c:	fa01 f303 	lsl.w	r3, r1, r3
 800fc50:	43db      	mvns	r3, r3
 800fc52:	401a      	ands	r2, r3
 800fc54:	687b      	ldr	r3, [r7, #4]
 800fc56:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800fc58:	697b      	ldr	r3, [r7, #20]
 800fc5a:	08da      	lsrs	r2, r3, #3
 800fc5c:	687b      	ldr	r3, [r7, #4]
 800fc5e:	3208      	adds	r2, #8
 800fc60:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800fc64:	697b      	ldr	r3, [r7, #20]
 800fc66:	f003 0307 	and.w	r3, r3, #7
 800fc6a:	009b      	lsls	r3, r3, #2
 800fc6c:	220f      	movs	r2, #15
 800fc6e:	fa02 f303 	lsl.w	r3, r2, r3
 800fc72:	43db      	mvns	r3, r3
 800fc74:	697a      	ldr	r2, [r7, #20]
 800fc76:	08d2      	lsrs	r2, r2, #3
 800fc78:	4019      	ands	r1, r3
 800fc7a:	687b      	ldr	r3, [r7, #4]
 800fc7c:	3208      	adds	r2, #8
 800fc7e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800fc82:	687b      	ldr	r3, [r7, #4]
 800fc84:	68da      	ldr	r2, [r3, #12]
 800fc86:	697b      	ldr	r3, [r7, #20]
 800fc88:	005b      	lsls	r3, r3, #1
 800fc8a:	2103      	movs	r1, #3
 800fc8c:	fa01 f303 	lsl.w	r3, r1, r3
 800fc90:	43db      	mvns	r3, r3
 800fc92:	401a      	ands	r2, r3
 800fc94:	687b      	ldr	r3, [r7, #4]
 800fc96:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 800fc98:	687b      	ldr	r3, [r7, #4]
 800fc9a:	685a      	ldr	r2, [r3, #4]
 800fc9c:	2101      	movs	r1, #1
 800fc9e:	697b      	ldr	r3, [r7, #20]
 800fca0:	fa01 f303 	lsl.w	r3, r1, r3
 800fca4:	43db      	mvns	r3, r3
 800fca6:	401a      	ands	r2, r3
 800fca8:	687b      	ldr	r3, [r7, #4]
 800fcaa:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800fcac:	687b      	ldr	r3, [r7, #4]
 800fcae:	689a      	ldr	r2, [r3, #8]
 800fcb0:	697b      	ldr	r3, [r7, #20]
 800fcb2:	005b      	lsls	r3, r3, #1
 800fcb4:	2103      	movs	r1, #3
 800fcb6:	fa01 f303 	lsl.w	r3, r1, r3
 800fcba:	43db      	mvns	r3, r3
 800fcbc:	401a      	ands	r2, r3
 800fcbe:	687b      	ldr	r3, [r7, #4]
 800fcc0:	609a      	str	r2, [r3, #8]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800fcc2:	697b      	ldr	r3, [r7, #20]
 800fcc4:	3301      	adds	r3, #1
 800fcc6:	617b      	str	r3, [r7, #20]
 800fcc8:	697b      	ldr	r3, [r7, #20]
 800fcca:	2b0f      	cmp	r3, #15
 800fccc:	f67f af40 	bls.w	800fb50 <HAL_GPIO_DeInit+0x1c>
    }
  }
}
 800fcd0:	bf00      	nop
 800fcd2:	bf00      	nop
 800fcd4:	371c      	adds	r7, #28
 800fcd6:	46bd      	mov	sp, r7
 800fcd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fcdc:	4770      	bx	lr
 800fcde:	bf00      	nop
 800fce0:	40013800 	.word	0x40013800
 800fce4:	40020000 	.word	0x40020000
 800fce8:	40020400 	.word	0x40020400
 800fcec:	40020800 	.word	0x40020800
 800fcf0:	40020c00 	.word	0x40020c00
 800fcf4:	40021000 	.word	0x40021000
 800fcf8:	40013c00 	.word	0x40013c00

0800fcfc <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800fcfc:	b480      	push	{r7}
 800fcfe:	b085      	sub	sp, #20
 800fd00:	af00      	add	r7, sp, #0
 800fd02:	6078      	str	r0, [r7, #4]
 800fd04:	460b      	mov	r3, r1
 800fd06:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 800fd08:	687b      	ldr	r3, [r7, #4]
 800fd0a:	691a      	ldr	r2, [r3, #16]
 800fd0c:	887b      	ldrh	r3, [r7, #2]
 800fd0e:	4013      	ands	r3, r2
 800fd10:	2b00      	cmp	r3, #0
 800fd12:	d002      	beq.n	800fd1a <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 800fd14:	2301      	movs	r3, #1
 800fd16:	73fb      	strb	r3, [r7, #15]
 800fd18:	e001      	b.n	800fd1e <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 800fd1a:	2300      	movs	r3, #0
 800fd1c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800fd1e:	7bfb      	ldrb	r3, [r7, #15]
}
 800fd20:	4618      	mov	r0, r3
 800fd22:	3714      	adds	r7, #20
 800fd24:	46bd      	mov	sp, r7
 800fd26:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd2a:	4770      	bx	lr

0800fd2c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800fd2c:	b480      	push	{r7}
 800fd2e:	b083      	sub	sp, #12
 800fd30:	af00      	add	r7, sp, #0
 800fd32:	6078      	str	r0, [r7, #4]
 800fd34:	460b      	mov	r3, r1
 800fd36:	807b      	strh	r3, [r7, #2]
 800fd38:	4613      	mov	r3, r2
 800fd3a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800fd3c:	787b      	ldrb	r3, [r7, #1]
 800fd3e:	2b00      	cmp	r3, #0
 800fd40:	d003      	beq.n	800fd4a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800fd42:	887a      	ldrh	r2, [r7, #2]
 800fd44:	687b      	ldr	r3, [r7, #4]
 800fd46:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 800fd48:	e003      	b.n	800fd52 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 800fd4a:	887b      	ldrh	r3, [r7, #2]
 800fd4c:	041a      	lsls	r2, r3, #16
 800fd4e:	687b      	ldr	r3, [r7, #4]
 800fd50:	619a      	str	r2, [r3, #24]
}
 800fd52:	bf00      	nop
 800fd54:	370c      	adds	r7, #12
 800fd56:	46bd      	mov	sp, r7
 800fd58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fd5c:	4770      	bx	lr
	...

0800fd60 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800fd60:	b580      	push	{r7, lr}
 800fd62:	b084      	sub	sp, #16
 800fd64:	af00      	add	r7, sp, #0
 800fd66:	6078      	str	r0, [r7, #4]
  uint32_t freqrange;
  uint32_t pclk1;

  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800fd68:	687b      	ldr	r3, [r7, #4]
 800fd6a:	2b00      	cmp	r3, #0
 800fd6c:	d101      	bne.n	800fd72 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800fd6e:	2301      	movs	r3, #1
 800fd70:	e12b      	b.n	800ffca <HAL_I2C_Init+0x26a>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800fd72:	687b      	ldr	r3, [r7, #4]
 800fd74:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800fd78:	b2db      	uxtb	r3, r3
 800fd7a:	2b00      	cmp	r3, #0
 800fd7c:	d106      	bne.n	800fd8c <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800fd7e:	687b      	ldr	r3, [r7, #4]
 800fd80:	2200      	movs	r2, #0
 800fd82:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 800fd86:	6878      	ldr	r0, [r7, #4]
 800fd88:	f000 f95d 	bl	8010046 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800fd8c:	687b      	ldr	r3, [r7, #4]
 800fd8e:	2224      	movs	r2, #36	@ 0x24
 800fd90:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800fd94:	687b      	ldr	r3, [r7, #4]
 800fd96:	681b      	ldr	r3, [r3, #0]
 800fd98:	681a      	ldr	r2, [r3, #0]
 800fd9a:	687b      	ldr	r3, [r7, #4]
 800fd9c:	681b      	ldr	r3, [r3, #0]
 800fd9e:	f022 0201 	bic.w	r2, r2, #1
 800fda2:	601a      	str	r2, [r3, #0]

  /*Reset I2C*/
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 800fda4:	687b      	ldr	r3, [r7, #4]
 800fda6:	681b      	ldr	r3, [r3, #0]
 800fda8:	681a      	ldr	r2, [r3, #0]
 800fdaa:	687b      	ldr	r3, [r7, #4]
 800fdac:	681b      	ldr	r3, [r3, #0]
 800fdae:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800fdb2:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 800fdb4:	687b      	ldr	r3, [r7, #4]
 800fdb6:	681b      	ldr	r3, [r3, #0]
 800fdb8:	681a      	ldr	r2, [r3, #0]
 800fdba:	687b      	ldr	r3, [r7, #4]
 800fdbc:	681b      	ldr	r3, [r3, #0]
 800fdbe:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800fdc2:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 800fdc4:	f003 fe26 	bl	8013a14 <HAL_RCC_GetPCLK1Freq>
 800fdc8:	60f8      	str	r0, [r7, #12]

  /* Check the minimum allowed PCLK1 frequency */
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 800fdca:	687b      	ldr	r3, [r7, #4]
 800fdcc:	685b      	ldr	r3, [r3, #4]
 800fdce:	4a81      	ldr	r2, [pc, #516]	@ (800ffd4 <HAL_I2C_Init+0x274>)
 800fdd0:	4293      	cmp	r3, r2
 800fdd2:	d807      	bhi.n	800fde4 <HAL_I2C_Init+0x84>
 800fdd4:	68fb      	ldr	r3, [r7, #12]
 800fdd6:	4a80      	ldr	r2, [pc, #512]	@ (800ffd8 <HAL_I2C_Init+0x278>)
 800fdd8:	4293      	cmp	r3, r2
 800fdda:	bf94      	ite	ls
 800fddc:	2301      	movls	r3, #1
 800fdde:	2300      	movhi	r3, #0
 800fde0:	b2db      	uxtb	r3, r3
 800fde2:	e006      	b.n	800fdf2 <HAL_I2C_Init+0x92>
 800fde4:	68fb      	ldr	r3, [r7, #12]
 800fde6:	4a7d      	ldr	r2, [pc, #500]	@ (800ffdc <HAL_I2C_Init+0x27c>)
 800fde8:	4293      	cmp	r3, r2
 800fdea:	bf94      	ite	ls
 800fdec:	2301      	movls	r3, #1
 800fdee:	2300      	movhi	r3, #0
 800fdf0:	b2db      	uxtb	r3, r3
 800fdf2:	2b00      	cmp	r3, #0
 800fdf4:	d001      	beq.n	800fdfa <HAL_I2C_Init+0x9a>
  {
    return HAL_ERROR;
 800fdf6:	2301      	movs	r3, #1
 800fdf8:	e0e7      	b.n	800ffca <HAL_I2C_Init+0x26a>
  }

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 800fdfa:	68fb      	ldr	r3, [r7, #12]
 800fdfc:	4a78      	ldr	r2, [pc, #480]	@ (800ffe0 <HAL_I2C_Init+0x280>)
 800fdfe:	fba2 2303 	umull	r2, r3, r2, r3
 800fe02:	0c9b      	lsrs	r3, r3, #18
 800fe04:	60bb      	str	r3, [r7, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 800fe06:	687b      	ldr	r3, [r7, #4]
 800fe08:	681b      	ldr	r3, [r3, #0]
 800fe0a:	685b      	ldr	r3, [r3, #4]
 800fe0c:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 800fe10:	687b      	ldr	r3, [r7, #4]
 800fe12:	681b      	ldr	r3, [r3, #0]
 800fe14:	68ba      	ldr	r2, [r7, #8]
 800fe16:	430a      	orrs	r2, r1
 800fe18:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 800fe1a:	687b      	ldr	r3, [r7, #4]
 800fe1c:	681b      	ldr	r3, [r3, #0]
 800fe1e:	6a1b      	ldr	r3, [r3, #32]
 800fe20:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 800fe24:	687b      	ldr	r3, [r7, #4]
 800fe26:	685b      	ldr	r3, [r3, #4]
 800fe28:	4a6a      	ldr	r2, [pc, #424]	@ (800ffd4 <HAL_I2C_Init+0x274>)
 800fe2a:	4293      	cmp	r3, r2
 800fe2c:	d802      	bhi.n	800fe34 <HAL_I2C_Init+0xd4>
 800fe2e:	68bb      	ldr	r3, [r7, #8]
 800fe30:	3301      	adds	r3, #1
 800fe32:	e009      	b.n	800fe48 <HAL_I2C_Init+0xe8>
 800fe34:	68bb      	ldr	r3, [r7, #8]
 800fe36:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 800fe3a:	fb02 f303 	mul.w	r3, r2, r3
 800fe3e:	4a69      	ldr	r2, [pc, #420]	@ (800ffe4 <HAL_I2C_Init+0x284>)
 800fe40:	fba2 2303 	umull	r2, r3, r2, r3
 800fe44:	099b      	lsrs	r3, r3, #6
 800fe46:	3301      	adds	r3, #1
 800fe48:	687a      	ldr	r2, [r7, #4]
 800fe4a:	6812      	ldr	r2, [r2, #0]
 800fe4c:	430b      	orrs	r3, r1
 800fe4e:	6213      	str	r3, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 800fe50:	687b      	ldr	r3, [r7, #4]
 800fe52:	681b      	ldr	r3, [r3, #0]
 800fe54:	69db      	ldr	r3, [r3, #28]
 800fe56:	f423 424f 	bic.w	r2, r3, #52992	@ 0xcf00
 800fe5a:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 800fe5e:	687b      	ldr	r3, [r7, #4]
 800fe60:	685b      	ldr	r3, [r3, #4]
 800fe62:	495c      	ldr	r1, [pc, #368]	@ (800ffd4 <HAL_I2C_Init+0x274>)
 800fe64:	428b      	cmp	r3, r1
 800fe66:	d819      	bhi.n	800fe9c <HAL_I2C_Init+0x13c>
 800fe68:	68fb      	ldr	r3, [r7, #12]
 800fe6a:	1e59      	subs	r1, r3, #1
 800fe6c:	687b      	ldr	r3, [r7, #4]
 800fe6e:	685b      	ldr	r3, [r3, #4]
 800fe70:	005b      	lsls	r3, r3, #1
 800fe72:	fbb1 f3f3 	udiv	r3, r1, r3
 800fe76:	1c59      	adds	r1, r3, #1
 800fe78:	f640 73fc 	movw	r3, #4092	@ 0xffc
 800fe7c:	400b      	ands	r3, r1
 800fe7e:	2b00      	cmp	r3, #0
 800fe80:	d00a      	beq.n	800fe98 <HAL_I2C_Init+0x138>
 800fe82:	68fb      	ldr	r3, [r7, #12]
 800fe84:	1e59      	subs	r1, r3, #1
 800fe86:	687b      	ldr	r3, [r7, #4]
 800fe88:	685b      	ldr	r3, [r3, #4]
 800fe8a:	005b      	lsls	r3, r3, #1
 800fe8c:	fbb1 f3f3 	udiv	r3, r1, r3
 800fe90:	3301      	adds	r3, #1
 800fe92:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800fe96:	e051      	b.n	800ff3c <HAL_I2C_Init+0x1dc>
 800fe98:	2304      	movs	r3, #4
 800fe9a:	e04f      	b.n	800ff3c <HAL_I2C_Init+0x1dc>
 800fe9c:	687b      	ldr	r3, [r7, #4]
 800fe9e:	689b      	ldr	r3, [r3, #8]
 800fea0:	2b00      	cmp	r3, #0
 800fea2:	d111      	bne.n	800fec8 <HAL_I2C_Init+0x168>
 800fea4:	68fb      	ldr	r3, [r7, #12]
 800fea6:	1e58      	subs	r0, r3, #1
 800fea8:	687b      	ldr	r3, [r7, #4]
 800feaa:	6859      	ldr	r1, [r3, #4]
 800feac:	460b      	mov	r3, r1
 800feae:	005b      	lsls	r3, r3, #1
 800feb0:	440b      	add	r3, r1
 800feb2:	fbb0 f3f3 	udiv	r3, r0, r3
 800feb6:	3301      	adds	r3, #1
 800feb8:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800febc:	2b00      	cmp	r3, #0
 800febe:	bf0c      	ite	eq
 800fec0:	2301      	moveq	r3, #1
 800fec2:	2300      	movne	r3, #0
 800fec4:	b2db      	uxtb	r3, r3
 800fec6:	e012      	b.n	800feee <HAL_I2C_Init+0x18e>
 800fec8:	68fb      	ldr	r3, [r7, #12]
 800feca:	1e58      	subs	r0, r3, #1
 800fecc:	687b      	ldr	r3, [r7, #4]
 800fece:	6859      	ldr	r1, [r3, #4]
 800fed0:	460b      	mov	r3, r1
 800fed2:	009b      	lsls	r3, r3, #2
 800fed4:	440b      	add	r3, r1
 800fed6:	0099      	lsls	r1, r3, #2
 800fed8:	440b      	add	r3, r1
 800feda:	fbb0 f3f3 	udiv	r3, r0, r3
 800fede:	3301      	adds	r3, #1
 800fee0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800fee4:	2b00      	cmp	r3, #0
 800fee6:	bf0c      	ite	eq
 800fee8:	2301      	moveq	r3, #1
 800feea:	2300      	movne	r3, #0
 800feec:	b2db      	uxtb	r3, r3
 800feee:	2b00      	cmp	r3, #0
 800fef0:	d001      	beq.n	800fef6 <HAL_I2C_Init+0x196>
 800fef2:	2301      	movs	r3, #1
 800fef4:	e022      	b.n	800ff3c <HAL_I2C_Init+0x1dc>
 800fef6:	687b      	ldr	r3, [r7, #4]
 800fef8:	689b      	ldr	r3, [r3, #8]
 800fefa:	2b00      	cmp	r3, #0
 800fefc:	d10e      	bne.n	800ff1c <HAL_I2C_Init+0x1bc>
 800fefe:	68fb      	ldr	r3, [r7, #12]
 800ff00:	1e58      	subs	r0, r3, #1
 800ff02:	687b      	ldr	r3, [r7, #4]
 800ff04:	6859      	ldr	r1, [r3, #4]
 800ff06:	460b      	mov	r3, r1
 800ff08:	005b      	lsls	r3, r3, #1
 800ff0a:	440b      	add	r3, r1
 800ff0c:	fbb0 f3f3 	udiv	r3, r0, r3
 800ff10:	3301      	adds	r3, #1
 800ff12:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800ff16:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800ff1a:	e00f      	b.n	800ff3c <HAL_I2C_Init+0x1dc>
 800ff1c:	68fb      	ldr	r3, [r7, #12]
 800ff1e:	1e58      	subs	r0, r3, #1
 800ff20:	687b      	ldr	r3, [r7, #4]
 800ff22:	6859      	ldr	r1, [r3, #4]
 800ff24:	460b      	mov	r3, r1
 800ff26:	009b      	lsls	r3, r3, #2
 800ff28:	440b      	add	r3, r1
 800ff2a:	0099      	lsls	r1, r3, #2
 800ff2c:	440b      	add	r3, r1
 800ff2e:	fbb0 f3f3 	udiv	r3, r0, r3
 800ff32:	3301      	adds	r3, #1
 800ff34:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800ff38:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 800ff3c:	6879      	ldr	r1, [r7, #4]
 800ff3e:	6809      	ldr	r1, [r1, #0]
 800ff40:	4313      	orrs	r3, r2
 800ff42:	61cb      	str	r3, [r1, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 800ff44:	687b      	ldr	r3, [r7, #4]
 800ff46:	681b      	ldr	r3, [r3, #0]
 800ff48:	681b      	ldr	r3, [r3, #0]
 800ff4a:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 800ff4e:	687b      	ldr	r3, [r7, #4]
 800ff50:	69da      	ldr	r2, [r3, #28]
 800ff52:	687b      	ldr	r3, [r7, #4]
 800ff54:	6a1b      	ldr	r3, [r3, #32]
 800ff56:	431a      	orrs	r2, r3
 800ff58:	687b      	ldr	r3, [r7, #4]
 800ff5a:	681b      	ldr	r3, [r3, #0]
 800ff5c:	430a      	orrs	r2, r1
 800ff5e:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 800ff60:	687b      	ldr	r3, [r7, #4]
 800ff62:	681b      	ldr	r3, [r3, #0]
 800ff64:	689b      	ldr	r3, [r3, #8]
 800ff66:	f423 4303 	bic.w	r3, r3, #33536	@ 0x8300
 800ff6a:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800ff6e:	687a      	ldr	r2, [r7, #4]
 800ff70:	6911      	ldr	r1, [r2, #16]
 800ff72:	687a      	ldr	r2, [r7, #4]
 800ff74:	68d2      	ldr	r2, [r2, #12]
 800ff76:	4311      	orrs	r1, r2
 800ff78:	687a      	ldr	r2, [r7, #4]
 800ff7a:	6812      	ldr	r2, [r2, #0]
 800ff7c:	430b      	orrs	r3, r1
 800ff7e:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 800ff80:	687b      	ldr	r3, [r7, #4]
 800ff82:	681b      	ldr	r3, [r3, #0]
 800ff84:	68db      	ldr	r3, [r3, #12]
 800ff86:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
 800ff8a:	687b      	ldr	r3, [r7, #4]
 800ff8c:	695a      	ldr	r2, [r3, #20]
 800ff8e:	687b      	ldr	r3, [r7, #4]
 800ff90:	699b      	ldr	r3, [r3, #24]
 800ff92:	431a      	orrs	r2, r3
 800ff94:	687b      	ldr	r3, [r7, #4]
 800ff96:	681b      	ldr	r3, [r3, #0]
 800ff98:	430a      	orrs	r2, r1
 800ff9a:	60da      	str	r2, [r3, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800ff9c:	687b      	ldr	r3, [r7, #4]
 800ff9e:	681b      	ldr	r3, [r3, #0]
 800ffa0:	681a      	ldr	r2, [r3, #0]
 800ffa2:	687b      	ldr	r3, [r7, #4]
 800ffa4:	681b      	ldr	r3, [r3, #0]
 800ffa6:	f042 0201 	orr.w	r2, r2, #1
 800ffaa:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800ffac:	687b      	ldr	r3, [r7, #4]
 800ffae:	2200      	movs	r2, #0
 800ffb0:	641a      	str	r2, [r3, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 800ffb2:	687b      	ldr	r3, [r7, #4]
 800ffb4:	2220      	movs	r2, #32
 800ffb6:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 800ffba:	687b      	ldr	r3, [r7, #4]
 800ffbc:	2200      	movs	r2, #0
 800ffbe:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800ffc0:	687b      	ldr	r3, [r7, #4]
 800ffc2:	2200      	movs	r2, #0
 800ffc4:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

  return HAL_OK;
 800ffc8:	2300      	movs	r3, #0
}
 800ffca:	4618      	mov	r0, r3
 800ffcc:	3710      	adds	r7, #16
 800ffce:	46bd      	mov	sp, r7
 800ffd0:	bd80      	pop	{r7, pc}
 800ffd2:	bf00      	nop
 800ffd4:	000186a0 	.word	0x000186a0
 800ffd8:	001e847f 	.word	0x001e847f
 800ffdc:	003d08ff 	.word	0x003d08ff
 800ffe0:	431bde83 	.word	0x431bde83
 800ffe4:	10624dd3 	.word	0x10624dd3

0800ffe8 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 800ffe8:	b580      	push	{r7, lr}
 800ffea:	b082      	sub	sp, #8
 800ffec:	af00      	add	r7, sp, #0
 800ffee:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800fff0:	687b      	ldr	r3, [r7, #4]
 800fff2:	2b00      	cmp	r3, #0
 800fff4:	d101      	bne.n	800fffa <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
 800fff6:	2301      	movs	r3, #1
 800fff8:	e021      	b.n	801003e <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
 800fffa:	687b      	ldr	r3, [r7, #4]
 800fffc:	2224      	movs	r2, #36	@ 0x24
 800fffe:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 8010002:	687b      	ldr	r3, [r7, #4]
 8010004:	681b      	ldr	r3, [r3, #0]
 8010006:	681a      	ldr	r2, [r3, #0]
 8010008:	687b      	ldr	r3, [r7, #4]
 801000a:	681b      	ldr	r3, [r3, #0]
 801000c:	f022 0201 	bic.w	r2, r2, #1
 8010010:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 8010012:	6878      	ldr	r0, [r7, #4]
 8010014:	f000 f821 	bl	801005a <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 8010018:	687b      	ldr	r3, [r7, #4]
 801001a:	2200      	movs	r2, #0
 801001c:	641a      	str	r2, [r3, #64]	@ 0x40
  hi2c->State         = HAL_I2C_STATE_RESET;
 801001e:	687b      	ldr	r3, [r7, #4]
 8010020:	2200      	movs	r2, #0
 8010022:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8010026:	687b      	ldr	r3, [r7, #4]
 8010028:	2200      	movs	r2, #0
 801002a:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 801002c:	687b      	ldr	r3, [r7, #4]
 801002e:	2200      	movs	r2, #0
 8010030:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 8010034:	687b      	ldr	r3, [r7, #4]
 8010036:	2200      	movs	r2, #0
 8010038:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 801003c:	2300      	movs	r3, #0
}
 801003e:	4618      	mov	r0, r3
 8010040:	3708      	adds	r7, #8
 8010042:	46bd      	mov	sp, r7
 8010044:	bd80      	pop	{r7, pc}

08010046 <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
 8010046:	b480      	push	{r7}
 8010048:	b083      	sub	sp, #12
 801004a:	af00      	add	r7, sp, #0
 801004c:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
 801004e:	bf00      	nop
 8010050:	370c      	adds	r7, #12
 8010052:	46bd      	mov	sp, r7
 8010054:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010058:	4770      	bx	lr

0801005a <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 801005a:	b480      	push	{r7}
 801005c:	b083      	sub	sp, #12
 801005e:	af00      	add	r7, sp, #0
 8010060:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
 8010062:	bf00      	nop
 8010064:	370c      	adds	r7, #12
 8010066:	46bd      	mov	sp, r7
 8010068:	f85d 7b04 	ldr.w	r7, [sp], #4
 801006c:	4770      	bx	lr

0801006e <I2C_Flush_DR>:
  * @brief  I2C data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_DR(I2C_HandleTypeDef *hi2c)
{
 801006e:	b480      	push	{r7}
 8010070:	b083      	sub	sp, #12
 8010072:	af00      	add	r7, sp, #0
 8010074:	6078      	str	r0, [r7, #4]
  /* Write a dummy data in DR to clear TXE flag */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) != RESET)
 8010076:	687b      	ldr	r3, [r7, #4]
 8010078:	681b      	ldr	r3, [r3, #0]
 801007a:	695b      	ldr	r3, [r3, #20]
 801007c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8010080:	2b80      	cmp	r3, #128	@ 0x80
 8010082:	d103      	bne.n	801008c <I2C_Flush_DR+0x1e>
  {
    hi2c->Instance->DR = 0x00U;
 8010084:	687b      	ldr	r3, [r7, #4]
 8010086:	681b      	ldr	r3, [r3, #0]
 8010088:	2200      	movs	r2, #0
 801008a:	611a      	str	r2, [r3, #16]
  }
}
 801008c:	bf00      	nop
 801008e:	370c      	adds	r7, #12
 8010090:	46bd      	mov	sp, r7
 8010092:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010096:	4770      	bx	lr

08010098 <HAL_I2C_Master_Transmit>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8010098:	b580      	push	{r7, lr}
 801009a:	b088      	sub	sp, #32
 801009c:	af02      	add	r7, sp, #8
 801009e:	60f8      	str	r0, [r7, #12]
 80100a0:	607a      	str	r2, [r7, #4]
 80100a2:	461a      	mov	r2, r3
 80100a4:	460b      	mov	r3, r1
 80100a6:	817b      	strh	r3, [r7, #10]
 80100a8:	4613      	mov	r3, r2
 80100aa:	813b      	strh	r3, [r7, #8]
  /* Init tickstart for timeout management*/
  uint32_t tickstart = HAL_GetTick();
 80100ac:	f7ff f926 	bl	800f2fc <HAL_GetTick>
 80100b0:	6178      	str	r0, [r7, #20]

  if (hi2c->State == HAL_I2C_STATE_READY)
 80100b2:	68fb      	ldr	r3, [r7, #12]
 80100b4:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 80100b8:	b2db      	uxtb	r3, r3
 80100ba:	2b20      	cmp	r3, #32
 80100bc:	f040 80e0 	bne.w	8010280 <HAL_I2C_Master_Transmit+0x1e8>
  {
    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 80100c0:	697b      	ldr	r3, [r7, #20]
 80100c2:	9300      	str	r3, [sp, #0]
 80100c4:	2319      	movs	r3, #25
 80100c6:	2201      	movs	r2, #1
 80100c8:	4970      	ldr	r1, [pc, #448]	@ (801028c <HAL_I2C_Master_Transmit+0x1f4>)
 80100ca:	68f8      	ldr	r0, [r7, #12]
 80100cc:	f002 fdae 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 80100d0:	4603      	mov	r3, r0
 80100d2:	2b00      	cmp	r3, #0
 80100d4:	d001      	beq.n	80100da <HAL_I2C_Master_Transmit+0x42>
    {
      return HAL_BUSY;
 80100d6:	2302      	movs	r3, #2
 80100d8:	e0d3      	b.n	8010282 <HAL_I2C_Master_Transmit+0x1ea>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80100da:	68fb      	ldr	r3, [r7, #12]
 80100dc:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 80100e0:	2b01      	cmp	r3, #1
 80100e2:	d101      	bne.n	80100e8 <HAL_I2C_Master_Transmit+0x50>
 80100e4:	2302      	movs	r3, #2
 80100e6:	e0cc      	b.n	8010282 <HAL_I2C_Master_Transmit+0x1ea>
 80100e8:	68fb      	ldr	r3, [r7, #12]
 80100ea:	2201      	movs	r2, #1
 80100ec:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Check if the I2C is already enabled */
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 80100f0:	68fb      	ldr	r3, [r7, #12]
 80100f2:	681b      	ldr	r3, [r3, #0]
 80100f4:	681b      	ldr	r3, [r3, #0]
 80100f6:	f003 0301 	and.w	r3, r3, #1
 80100fa:	2b01      	cmp	r3, #1
 80100fc:	d007      	beq.n	801010e <HAL_I2C_Master_Transmit+0x76>
    {
      /* Enable I2C peripheral */
      __HAL_I2C_ENABLE(hi2c);
 80100fe:	68fb      	ldr	r3, [r7, #12]
 8010100:	681b      	ldr	r3, [r3, #0]
 8010102:	681a      	ldr	r2, [r3, #0]
 8010104:	68fb      	ldr	r3, [r7, #12]
 8010106:	681b      	ldr	r3, [r3, #0]
 8010108:	f042 0201 	orr.w	r2, r2, #1
 801010c:	601a      	str	r2, [r3, #0]
    }

    /* Disable Pos */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 801010e:	68fb      	ldr	r3, [r7, #12]
 8010110:	681b      	ldr	r3, [r3, #0]
 8010112:	681a      	ldr	r2, [r3, #0]
 8010114:	68fb      	ldr	r3, [r7, #12]
 8010116:	681b      	ldr	r3, [r3, #0]
 8010118:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 801011c:	601a      	str	r2, [r3, #0]

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
 801011e:	68fb      	ldr	r3, [r7, #12]
 8010120:	2221      	movs	r2, #33	@ 0x21
 8010122:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
 8010126:	68fb      	ldr	r3, [r7, #12]
 8010128:	2210      	movs	r2, #16
 801012a:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 801012e:	68fb      	ldr	r3, [r7, #12]
 8010130:	2200      	movs	r2, #0
 8010132:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
 8010134:	68fb      	ldr	r3, [r7, #12]
 8010136:	687a      	ldr	r2, [r7, #4]
 8010138:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
 801013a:	68fb      	ldr	r3, [r7, #12]
 801013c:	893a      	ldrh	r2, [r7, #8]
 801013e:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
 8010140:	68fb      	ldr	r3, [r7, #12]
 8010142:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010144:	b29a      	uxth	r2, r3
 8010146:	68fb      	ldr	r3, [r7, #12]
 8010148:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 801014a:	68fb      	ldr	r3, [r7, #12]
 801014c:	4a50      	ldr	r2, [pc, #320]	@ (8010290 <HAL_I2C_Master_Transmit+0x1f8>)
 801014e:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Send Slave Address */
    if (I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
 8010150:	8979      	ldrh	r1, [r7, #10]
 8010152:	697b      	ldr	r3, [r7, #20]
 8010154:	6a3a      	ldr	r2, [r7, #32]
 8010156:	68f8      	ldr	r0, [r7, #12]
 8010158:	f002 f9f2 	bl	8012540 <I2C_MasterRequestWrite>
 801015c:	4603      	mov	r3, r0
 801015e:	2b00      	cmp	r3, #0
 8010160:	d001      	beq.n	8010166 <HAL_I2C_Master_Transmit+0xce>
    {
      return HAL_ERROR;
 8010162:	2301      	movs	r3, #1
 8010164:	e08d      	b.n	8010282 <HAL_I2C_Master_Transmit+0x1ea>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8010166:	2300      	movs	r3, #0
 8010168:	613b      	str	r3, [r7, #16]
 801016a:	68fb      	ldr	r3, [r7, #12]
 801016c:	681b      	ldr	r3, [r3, #0]
 801016e:	695b      	ldr	r3, [r3, #20]
 8010170:	613b      	str	r3, [r7, #16]
 8010172:	68fb      	ldr	r3, [r7, #12]
 8010174:	681b      	ldr	r3, [r3, #0]
 8010176:	699b      	ldr	r3, [r3, #24]
 8010178:	613b      	str	r3, [r7, #16]
 801017a:	693b      	ldr	r3, [r7, #16]

    while (hi2c->XferSize > 0U)
 801017c:	e066      	b.n	801024c <HAL_I2C_Master_Transmit+0x1b4>
    {
      /* Wait until TXE flag is set */
      if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 801017e:	697a      	ldr	r2, [r7, #20]
 8010180:	6a39      	ldr	r1, [r7, #32]
 8010182:	68f8      	ldr	r0, [r7, #12]
 8010184:	f002 fe6c 	bl	8012e60 <I2C_WaitOnTXEFlagUntilTimeout>
 8010188:	4603      	mov	r3, r0
 801018a:	2b00      	cmp	r3, #0
 801018c:	d00d      	beq.n	80101aa <HAL_I2C_Master_Transmit+0x112>
      {
        if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 801018e:	68fb      	ldr	r3, [r7, #12]
 8010190:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8010192:	2b04      	cmp	r3, #4
 8010194:	d107      	bne.n	80101a6 <HAL_I2C_Master_Transmit+0x10e>
        {
          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010196:	68fb      	ldr	r3, [r7, #12]
 8010198:	681b      	ldr	r3, [r3, #0]
 801019a:	681a      	ldr	r2, [r3, #0]
 801019c:	68fb      	ldr	r3, [r7, #12]
 801019e:	681b      	ldr	r3, [r3, #0]
 80101a0:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80101a4:	601a      	str	r2, [r3, #0]
        }
        return HAL_ERROR;
 80101a6:	2301      	movs	r3, #1
 80101a8:	e06b      	b.n	8010282 <HAL_I2C_Master_Transmit+0x1ea>
      }

      /* Write data to DR */
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 80101aa:	68fb      	ldr	r3, [r7, #12]
 80101ac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80101ae:	781a      	ldrb	r2, [r3, #0]
 80101b0:	68fb      	ldr	r3, [r7, #12]
 80101b2:	681b      	ldr	r3, [r3, #0]
 80101b4:	611a      	str	r2, [r3, #16]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80101b6:	68fb      	ldr	r3, [r7, #12]
 80101b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80101ba:	1c5a      	adds	r2, r3, #1
 80101bc:	68fb      	ldr	r3, [r7, #12]
 80101be:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 80101c0:	68fb      	ldr	r3, [r7, #12]
 80101c2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80101c4:	b29b      	uxth	r3, r3
 80101c6:	3b01      	subs	r3, #1
 80101c8:	b29a      	uxth	r2, r3
 80101ca:	68fb      	ldr	r3, [r7, #12]
 80101cc:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
 80101ce:	68fb      	ldr	r3, [r7, #12]
 80101d0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80101d2:	3b01      	subs	r3, #1
 80101d4:	b29a      	uxth	r2, r3
 80101d6:	68fb      	ldr	r3, [r7, #12]
 80101d8:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
 80101da:	68fb      	ldr	r3, [r7, #12]
 80101dc:	681b      	ldr	r3, [r3, #0]
 80101de:	695b      	ldr	r3, [r3, #20]
 80101e0:	f003 0304 	and.w	r3, r3, #4
 80101e4:	2b04      	cmp	r3, #4
 80101e6:	d11b      	bne.n	8010220 <HAL_I2C_Master_Transmit+0x188>
 80101e8:	68fb      	ldr	r3, [r7, #12]
 80101ea:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80101ec:	2b00      	cmp	r3, #0
 80101ee:	d017      	beq.n	8010220 <HAL_I2C_Master_Transmit+0x188>
      {
        /* Write data to DR */
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 80101f0:	68fb      	ldr	r3, [r7, #12]
 80101f2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80101f4:	781a      	ldrb	r2, [r3, #0]
 80101f6:	68fb      	ldr	r3, [r7, #12]
 80101f8:	681b      	ldr	r3, [r3, #0]
 80101fa:	611a      	str	r2, [r3, #16]

        /* Increment Buffer pointer */
        hi2c->pBuffPtr++;
 80101fc:	68fb      	ldr	r3, [r7, #12]
 80101fe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010200:	1c5a      	adds	r2, r3, #1
 8010202:	68fb      	ldr	r3, [r7, #12]
 8010204:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Update counter */
        hi2c->XferCount--;
 8010206:	68fb      	ldr	r3, [r7, #12]
 8010208:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801020a:	b29b      	uxth	r3, r3
 801020c:	3b01      	subs	r3, #1
 801020e:	b29a      	uxth	r2, r3
 8010210:	68fb      	ldr	r3, [r7, #12]
 8010212:	855a      	strh	r2, [r3, #42]	@ 0x2a
        hi2c->XferSize--;
 8010214:	68fb      	ldr	r3, [r7, #12]
 8010216:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010218:	3b01      	subs	r3, #1
 801021a:	b29a      	uxth	r2, r3
 801021c:	68fb      	ldr	r3, [r7, #12]
 801021e:	851a      	strh	r2, [r3, #40]	@ 0x28
      }

      /* Wait until BTF flag is set */
      if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010220:	697a      	ldr	r2, [r7, #20]
 8010222:	6a39      	ldr	r1, [r7, #32]
 8010224:	68f8      	ldr	r0, [r7, #12]
 8010226:	f002 fe63 	bl	8012ef0 <I2C_WaitOnBTFFlagUntilTimeout>
 801022a:	4603      	mov	r3, r0
 801022c:	2b00      	cmp	r3, #0
 801022e:	d00d      	beq.n	801024c <HAL_I2C_Master_Transmit+0x1b4>
      {
        if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8010230:	68fb      	ldr	r3, [r7, #12]
 8010232:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8010234:	2b04      	cmp	r3, #4
 8010236:	d107      	bne.n	8010248 <HAL_I2C_Master_Transmit+0x1b0>
        {
          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010238:	68fb      	ldr	r3, [r7, #12]
 801023a:	681b      	ldr	r3, [r3, #0]
 801023c:	681a      	ldr	r2, [r3, #0]
 801023e:	68fb      	ldr	r3, [r7, #12]
 8010240:	681b      	ldr	r3, [r3, #0]
 8010242:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8010246:	601a      	str	r2, [r3, #0]
        }
        return HAL_ERROR;
 8010248:	2301      	movs	r3, #1
 801024a:	e01a      	b.n	8010282 <HAL_I2C_Master_Transmit+0x1ea>
    while (hi2c->XferSize > 0U)
 801024c:	68fb      	ldr	r3, [r7, #12]
 801024e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010250:	2b00      	cmp	r3, #0
 8010252:	d194      	bne.n	801017e <HAL_I2C_Master_Transmit+0xe6>
      }
    }

    /* Generate Stop */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010254:	68fb      	ldr	r3, [r7, #12]
 8010256:	681b      	ldr	r3, [r3, #0]
 8010258:	681a      	ldr	r2, [r3, #0]
 801025a:	68fb      	ldr	r3, [r7, #12]
 801025c:	681b      	ldr	r3, [r3, #0]
 801025e:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8010262:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8010264:	68fb      	ldr	r3, [r7, #12]
 8010266:	2220      	movs	r2, #32
 8010268:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 801026c:	68fb      	ldr	r3, [r7, #12]
 801026e:	2200      	movs	r2, #0
 8010270:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8010274:	68fb      	ldr	r3, [r7, #12]
 8010276:	2200      	movs	r2, #0
 8010278:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 801027c:	2300      	movs	r3, #0
 801027e:	e000      	b.n	8010282 <HAL_I2C_Master_Transmit+0x1ea>
  }
  else
  {
    return HAL_BUSY;
 8010280:	2302      	movs	r3, #2
  }
}
 8010282:	4618      	mov	r0, r3
 8010284:	3718      	adds	r7, #24
 8010286:	46bd      	mov	sp, r7
 8010288:	bd80      	pop	{r7, pc}
 801028a:	bf00      	nop
 801028c:	00100002 	.word	0x00100002
 8010290:	ffff0000 	.word	0xffff0000

08010294 <HAL_I2C_Master_Receive>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8010294:	b580      	push	{r7, lr}
 8010296:	b08c      	sub	sp, #48	@ 0x30
 8010298:	af02      	add	r7, sp, #8
 801029a:	60f8      	str	r0, [r7, #12]
 801029c:	607a      	str	r2, [r7, #4]
 801029e:	461a      	mov	r2, r3
 80102a0:	460b      	mov	r3, r1
 80102a2:	817b      	strh	r3, [r7, #10]
 80102a4:	4613      	mov	r3, r2
 80102a6:	813b      	strh	r3, [r7, #8]
  /* Init tickstart for timeout management*/
  uint32_t tickstart = HAL_GetTick();
 80102a8:	f7ff f828 	bl	800f2fc <HAL_GetTick>
 80102ac:	6278      	str	r0, [r7, #36]	@ 0x24

  if (hi2c->State == HAL_I2C_STATE_READY)
 80102ae:	68fb      	ldr	r3, [r7, #12]
 80102b0:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 80102b4:	b2db      	uxtb	r3, r3
 80102b6:	2b20      	cmp	r3, #32
 80102b8:	f040 8217 	bne.w	80106ea <HAL_I2C_Master_Receive+0x456>
  {
    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 80102bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102be:	9300      	str	r3, [sp, #0]
 80102c0:	2319      	movs	r3, #25
 80102c2:	2201      	movs	r2, #1
 80102c4:	497c      	ldr	r1, [pc, #496]	@ (80104b8 <HAL_I2C_Master_Receive+0x224>)
 80102c6:	68f8      	ldr	r0, [r7, #12]
 80102c8:	f002 fcb0 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 80102cc:	4603      	mov	r3, r0
 80102ce:	2b00      	cmp	r3, #0
 80102d0:	d001      	beq.n	80102d6 <HAL_I2C_Master_Receive+0x42>
    {
      return HAL_BUSY;
 80102d2:	2302      	movs	r3, #2
 80102d4:	e20a      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80102d6:	68fb      	ldr	r3, [r7, #12]
 80102d8:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 80102dc:	2b01      	cmp	r3, #1
 80102de:	d101      	bne.n	80102e4 <HAL_I2C_Master_Receive+0x50>
 80102e0:	2302      	movs	r3, #2
 80102e2:	e203      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
 80102e4:	68fb      	ldr	r3, [r7, #12]
 80102e6:	2201      	movs	r2, #1
 80102e8:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Check if the I2C is already enabled */
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 80102ec:	68fb      	ldr	r3, [r7, #12]
 80102ee:	681b      	ldr	r3, [r3, #0]
 80102f0:	681b      	ldr	r3, [r3, #0]
 80102f2:	f003 0301 	and.w	r3, r3, #1
 80102f6:	2b01      	cmp	r3, #1
 80102f8:	d007      	beq.n	801030a <HAL_I2C_Master_Receive+0x76>
    {
      /* Enable I2C peripheral */
      __HAL_I2C_ENABLE(hi2c);
 80102fa:	68fb      	ldr	r3, [r7, #12]
 80102fc:	681b      	ldr	r3, [r3, #0]
 80102fe:	681a      	ldr	r2, [r3, #0]
 8010300:	68fb      	ldr	r3, [r7, #12]
 8010302:	681b      	ldr	r3, [r3, #0]
 8010304:	f042 0201 	orr.w	r2, r2, #1
 8010308:	601a      	str	r2, [r3, #0]
    }

    /* Disable Pos */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 801030a:	68fb      	ldr	r3, [r7, #12]
 801030c:	681b      	ldr	r3, [r3, #0]
 801030e:	681a      	ldr	r2, [r3, #0]
 8010310:	68fb      	ldr	r3, [r7, #12]
 8010312:	681b      	ldr	r3, [r3, #0]
 8010314:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8010318:	601a      	str	r2, [r3, #0]

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
 801031a:	68fb      	ldr	r3, [r7, #12]
 801031c:	2222      	movs	r2, #34	@ 0x22
 801031e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
 8010322:	68fb      	ldr	r3, [r7, #12]
 8010324:	2210      	movs	r2, #16
 8010326:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 801032a:	68fb      	ldr	r3, [r7, #12]
 801032c:	2200      	movs	r2, #0
 801032e:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
 8010330:	68fb      	ldr	r3, [r7, #12]
 8010332:	687a      	ldr	r2, [r7, #4]
 8010334:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
 8010336:	68fb      	ldr	r3, [r7, #12]
 8010338:	893a      	ldrh	r2, [r7, #8]
 801033a:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
 801033c:	68fb      	ldr	r3, [r7, #12]
 801033e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010340:	b29a      	uxth	r2, r3
 8010342:	68fb      	ldr	r3, [r7, #12]
 8010344:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8010346:	68fb      	ldr	r3, [r7, #12]
 8010348:	4a5c      	ldr	r2, [pc, #368]	@ (80104bc <HAL_I2C_Master_Receive+0x228>)
 801034a:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Send Slave Address */
    if (I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
 801034c:	8979      	ldrh	r1, [r7, #10]
 801034e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010350:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8010352:	68f8      	ldr	r0, [r7, #12]
 8010354:	f002 f976 	bl	8012644 <I2C_MasterRequestRead>
 8010358:	4603      	mov	r3, r0
 801035a:	2b00      	cmp	r3, #0
 801035c:	d001      	beq.n	8010362 <HAL_I2C_Master_Receive+0xce>
    {
      return HAL_ERROR;
 801035e:	2301      	movs	r3, #1
 8010360:	e1c4      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
    }

    if (hi2c->XferSize == 0U)
 8010362:	68fb      	ldr	r3, [r7, #12]
 8010364:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010366:	2b00      	cmp	r3, #0
 8010368:	d113      	bne.n	8010392 <HAL_I2C_Master_Receive+0xfe>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 801036a:	2300      	movs	r3, #0
 801036c:	623b      	str	r3, [r7, #32]
 801036e:	68fb      	ldr	r3, [r7, #12]
 8010370:	681b      	ldr	r3, [r3, #0]
 8010372:	695b      	ldr	r3, [r3, #20]
 8010374:	623b      	str	r3, [r7, #32]
 8010376:	68fb      	ldr	r3, [r7, #12]
 8010378:	681b      	ldr	r3, [r3, #0]
 801037a:	699b      	ldr	r3, [r3, #24]
 801037c:	623b      	str	r3, [r7, #32]
 801037e:	6a3b      	ldr	r3, [r7, #32]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010380:	68fb      	ldr	r3, [r7, #12]
 8010382:	681b      	ldr	r3, [r3, #0]
 8010384:	681a      	ldr	r2, [r3, #0]
 8010386:	68fb      	ldr	r3, [r7, #12]
 8010388:	681b      	ldr	r3, [r3, #0]
 801038a:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 801038e:	601a      	str	r2, [r3, #0]
 8010390:	e198      	b.n	80106c4 <HAL_I2C_Master_Receive+0x430>
    }
    else if (hi2c->XferSize == 1U)
 8010392:	68fb      	ldr	r3, [r7, #12]
 8010394:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010396:	2b01      	cmp	r3, #1
 8010398:	d11b      	bne.n	80103d2 <HAL_I2C_Master_Receive+0x13e>
    {
      /* Disable Acknowledge */
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 801039a:	68fb      	ldr	r3, [r7, #12]
 801039c:	681b      	ldr	r3, [r3, #0]
 801039e:	681a      	ldr	r2, [r3, #0]
 80103a0:	68fb      	ldr	r3, [r7, #12]
 80103a2:	681b      	ldr	r3, [r3, #0]
 80103a4:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80103a8:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80103aa:	2300      	movs	r3, #0
 80103ac:	61fb      	str	r3, [r7, #28]
 80103ae:	68fb      	ldr	r3, [r7, #12]
 80103b0:	681b      	ldr	r3, [r3, #0]
 80103b2:	695b      	ldr	r3, [r3, #20]
 80103b4:	61fb      	str	r3, [r7, #28]
 80103b6:	68fb      	ldr	r3, [r7, #12]
 80103b8:	681b      	ldr	r3, [r3, #0]
 80103ba:	699b      	ldr	r3, [r3, #24]
 80103bc:	61fb      	str	r3, [r7, #28]
 80103be:	69fb      	ldr	r3, [r7, #28]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80103c0:	68fb      	ldr	r3, [r7, #12]
 80103c2:	681b      	ldr	r3, [r3, #0]
 80103c4:	681a      	ldr	r2, [r3, #0]
 80103c6:	68fb      	ldr	r3, [r7, #12]
 80103c8:	681b      	ldr	r3, [r3, #0]
 80103ca:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80103ce:	601a      	str	r2, [r3, #0]
 80103d0:	e178      	b.n	80106c4 <HAL_I2C_Master_Receive+0x430>
    }
    else if (hi2c->XferSize == 2U)
 80103d2:	68fb      	ldr	r3, [r7, #12]
 80103d4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80103d6:	2b02      	cmp	r3, #2
 80103d8:	d11b      	bne.n	8010412 <HAL_I2C_Master_Receive+0x17e>
    {
      /* Disable Acknowledge */
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80103da:	68fb      	ldr	r3, [r7, #12]
 80103dc:	681b      	ldr	r3, [r3, #0]
 80103de:	681a      	ldr	r2, [r3, #0]
 80103e0:	68fb      	ldr	r3, [r7, #12]
 80103e2:	681b      	ldr	r3, [r3, #0]
 80103e4:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80103e8:	601a      	str	r2, [r3, #0]

      /* Enable Pos */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 80103ea:	68fb      	ldr	r3, [r7, #12]
 80103ec:	681b      	ldr	r3, [r3, #0]
 80103ee:	681a      	ldr	r2, [r3, #0]
 80103f0:	68fb      	ldr	r3, [r7, #12]
 80103f2:	681b      	ldr	r3, [r3, #0]
 80103f4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80103f8:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80103fa:	2300      	movs	r3, #0
 80103fc:	61bb      	str	r3, [r7, #24]
 80103fe:	68fb      	ldr	r3, [r7, #12]
 8010400:	681b      	ldr	r3, [r3, #0]
 8010402:	695b      	ldr	r3, [r3, #20]
 8010404:	61bb      	str	r3, [r7, #24]
 8010406:	68fb      	ldr	r3, [r7, #12]
 8010408:	681b      	ldr	r3, [r3, #0]
 801040a:	699b      	ldr	r3, [r3, #24]
 801040c:	61bb      	str	r3, [r7, #24]
 801040e:	69bb      	ldr	r3, [r7, #24]
 8010410:	e158      	b.n	80106c4 <HAL_I2C_Master_Receive+0x430>
    }
    else
    {
      /* Enable Acknowledge */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8010412:	68fb      	ldr	r3, [r7, #12]
 8010414:	681b      	ldr	r3, [r3, #0]
 8010416:	681a      	ldr	r2, [r3, #0]
 8010418:	68fb      	ldr	r3, [r7, #12]
 801041a:	681b      	ldr	r3, [r3, #0]
 801041c:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8010420:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8010422:	2300      	movs	r3, #0
 8010424:	617b      	str	r3, [r7, #20]
 8010426:	68fb      	ldr	r3, [r7, #12]
 8010428:	681b      	ldr	r3, [r3, #0]
 801042a:	695b      	ldr	r3, [r3, #20]
 801042c:	617b      	str	r3, [r7, #20]
 801042e:	68fb      	ldr	r3, [r7, #12]
 8010430:	681b      	ldr	r3, [r3, #0]
 8010432:	699b      	ldr	r3, [r3, #24]
 8010434:	617b      	str	r3, [r7, #20]
 8010436:	697b      	ldr	r3, [r7, #20]
    }

    while (hi2c->XferSize > 0U)
 8010438:	e144      	b.n	80106c4 <HAL_I2C_Master_Receive+0x430>
    {
      if (hi2c->XferSize <= 3U)
 801043a:	68fb      	ldr	r3, [r7, #12]
 801043c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801043e:	2b03      	cmp	r3, #3
 8010440:	f200 80f1 	bhi.w	8010626 <HAL_I2C_Master_Receive+0x392>
      {
        /* One byte */
        if (hi2c->XferSize == 1U)
 8010444:	68fb      	ldr	r3, [r7, #12]
 8010446:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010448:	2b01      	cmp	r3, #1
 801044a:	d123      	bne.n	8010494 <HAL_I2C_Master_Receive+0x200>
        {
          /* Wait until RXNE flag is set */
          if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 801044c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801044e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8010450:	68f8      	ldr	r0, [r7, #12]
 8010452:	f002 fdc7 	bl	8012fe4 <I2C_WaitOnRXNEFlagUntilTimeout>
 8010456:	4603      	mov	r3, r0
 8010458:	2b00      	cmp	r3, #0
 801045a:	d001      	beq.n	8010460 <HAL_I2C_Master_Receive+0x1cc>
          {
            return HAL_ERROR;
 801045c:	2301      	movs	r3, #1
 801045e:	e145      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
          }

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010460:	68fb      	ldr	r3, [r7, #12]
 8010462:	681b      	ldr	r3, [r3, #0]
 8010464:	691a      	ldr	r2, [r3, #16]
 8010466:	68fb      	ldr	r3, [r7, #12]
 8010468:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801046a:	b2d2      	uxtb	r2, r2
 801046c:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 801046e:	68fb      	ldr	r3, [r7, #12]
 8010470:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010472:	1c5a      	adds	r2, r3, #1
 8010474:	68fb      	ldr	r3, [r7, #12]
 8010476:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010478:	68fb      	ldr	r3, [r7, #12]
 801047a:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801047c:	3b01      	subs	r3, #1
 801047e:	b29a      	uxth	r2, r3
 8010480:	68fb      	ldr	r3, [r7, #12]
 8010482:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010484:	68fb      	ldr	r3, [r7, #12]
 8010486:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010488:	b29b      	uxth	r3, r3
 801048a:	3b01      	subs	r3, #1
 801048c:	b29a      	uxth	r2, r3
 801048e:	68fb      	ldr	r3, [r7, #12]
 8010490:	855a      	strh	r2, [r3, #42]	@ 0x2a
 8010492:	e117      	b.n	80106c4 <HAL_I2C_Master_Receive+0x430>
        }
        /* Two bytes */
        else if (hi2c->XferSize == 2U)
 8010494:	68fb      	ldr	r3, [r7, #12]
 8010496:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010498:	2b02      	cmp	r3, #2
 801049a:	d14e      	bne.n	801053a <HAL_I2C_Master_Receive+0x2a6>
        {
          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 801049c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801049e:	9300      	str	r3, [sp, #0]
 80104a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80104a2:	2200      	movs	r2, #0
 80104a4:	4906      	ldr	r1, [pc, #24]	@ (80104c0 <HAL_I2C_Master_Receive+0x22c>)
 80104a6:	68f8      	ldr	r0, [r7, #12]
 80104a8:	f002 fbc0 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 80104ac:	4603      	mov	r3, r0
 80104ae:	2b00      	cmp	r3, #0
 80104b0:	d008      	beq.n	80104c4 <HAL_I2C_Master_Receive+0x230>
          {
            return HAL_ERROR;
 80104b2:	2301      	movs	r3, #1
 80104b4:	e11a      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
 80104b6:	bf00      	nop
 80104b8:	00100002 	.word	0x00100002
 80104bc:	ffff0000 	.word	0xffff0000
 80104c0:	00010004 	.word	0x00010004
          }

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80104c4:	68fb      	ldr	r3, [r7, #12]
 80104c6:	681b      	ldr	r3, [r3, #0]
 80104c8:	681a      	ldr	r2, [r3, #0]
 80104ca:	68fb      	ldr	r3, [r7, #12]
 80104cc:	681b      	ldr	r3, [r3, #0]
 80104ce:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80104d2:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80104d4:	68fb      	ldr	r3, [r7, #12]
 80104d6:	681b      	ldr	r3, [r3, #0]
 80104d8:	691a      	ldr	r2, [r3, #16]
 80104da:	68fb      	ldr	r3, [r7, #12]
 80104dc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80104de:	b2d2      	uxtb	r2, r2
 80104e0:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 80104e2:	68fb      	ldr	r3, [r7, #12]
 80104e4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80104e6:	1c5a      	adds	r2, r3, #1
 80104e8:	68fb      	ldr	r3, [r7, #12]
 80104ea:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 80104ec:	68fb      	ldr	r3, [r7, #12]
 80104ee:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80104f0:	3b01      	subs	r3, #1
 80104f2:	b29a      	uxth	r2, r3
 80104f4:	68fb      	ldr	r3, [r7, #12]
 80104f6:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 80104f8:	68fb      	ldr	r3, [r7, #12]
 80104fa:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80104fc:	b29b      	uxth	r3, r3
 80104fe:	3b01      	subs	r3, #1
 8010500:	b29a      	uxth	r2, r3
 8010502:	68fb      	ldr	r3, [r7, #12]
 8010504:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010506:	68fb      	ldr	r3, [r7, #12]
 8010508:	681b      	ldr	r3, [r3, #0]
 801050a:	691a      	ldr	r2, [r3, #16]
 801050c:	68fb      	ldr	r3, [r7, #12]
 801050e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010510:	b2d2      	uxtb	r2, r2
 8010512:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010514:	68fb      	ldr	r3, [r7, #12]
 8010516:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010518:	1c5a      	adds	r2, r3, #1
 801051a:	68fb      	ldr	r3, [r7, #12]
 801051c:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 801051e:	68fb      	ldr	r3, [r7, #12]
 8010520:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010522:	3b01      	subs	r3, #1
 8010524:	b29a      	uxth	r2, r3
 8010526:	68fb      	ldr	r3, [r7, #12]
 8010528:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 801052a:	68fb      	ldr	r3, [r7, #12]
 801052c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801052e:	b29b      	uxth	r3, r3
 8010530:	3b01      	subs	r3, #1
 8010532:	b29a      	uxth	r2, r3
 8010534:	68fb      	ldr	r3, [r7, #12]
 8010536:	855a      	strh	r2, [r3, #42]	@ 0x2a
 8010538:	e0c4      	b.n	80106c4 <HAL_I2C_Master_Receive+0x430>
        }
        /* 3 Last bytes */
        else
        {
          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 801053a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801053c:	9300      	str	r3, [sp, #0]
 801053e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010540:	2200      	movs	r2, #0
 8010542:	496c      	ldr	r1, [pc, #432]	@ (80106f4 <HAL_I2C_Master_Receive+0x460>)
 8010544:	68f8      	ldr	r0, [r7, #12]
 8010546:	f002 fb71 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 801054a:	4603      	mov	r3, r0
 801054c:	2b00      	cmp	r3, #0
 801054e:	d001      	beq.n	8010554 <HAL_I2C_Master_Receive+0x2c0>
          {
            return HAL_ERROR;
 8010550:	2301      	movs	r3, #1
 8010552:	e0cb      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
          }

          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8010554:	68fb      	ldr	r3, [r7, #12]
 8010556:	681b      	ldr	r3, [r3, #0]
 8010558:	681a      	ldr	r2, [r3, #0]
 801055a:	68fb      	ldr	r3, [r7, #12]
 801055c:	681b      	ldr	r3, [r3, #0]
 801055e:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8010562:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010564:	68fb      	ldr	r3, [r7, #12]
 8010566:	681b      	ldr	r3, [r3, #0]
 8010568:	691a      	ldr	r2, [r3, #16]
 801056a:	68fb      	ldr	r3, [r7, #12]
 801056c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801056e:	b2d2      	uxtb	r2, r2
 8010570:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010572:	68fb      	ldr	r3, [r7, #12]
 8010574:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010576:	1c5a      	adds	r2, r3, #1
 8010578:	68fb      	ldr	r3, [r7, #12]
 801057a:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 801057c:	68fb      	ldr	r3, [r7, #12]
 801057e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010580:	3b01      	subs	r3, #1
 8010582:	b29a      	uxth	r2, r3
 8010584:	68fb      	ldr	r3, [r7, #12]
 8010586:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010588:	68fb      	ldr	r3, [r7, #12]
 801058a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801058c:	b29b      	uxth	r3, r3
 801058e:	3b01      	subs	r3, #1
 8010590:	b29a      	uxth	r2, r3
 8010592:	68fb      	ldr	r3, [r7, #12]
 8010594:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 8010596:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010598:	9300      	str	r3, [sp, #0]
 801059a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801059c:	2200      	movs	r2, #0
 801059e:	4955      	ldr	r1, [pc, #340]	@ (80106f4 <HAL_I2C_Master_Receive+0x460>)
 80105a0:	68f8      	ldr	r0, [r7, #12]
 80105a2:	f002 fb43 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 80105a6:	4603      	mov	r3, r0
 80105a8:	2b00      	cmp	r3, #0
 80105aa:	d001      	beq.n	80105b0 <HAL_I2C_Master_Receive+0x31c>
          {
            return HAL_ERROR;
 80105ac:	2301      	movs	r3, #1
 80105ae:	e09d      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
          }

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80105b0:	68fb      	ldr	r3, [r7, #12]
 80105b2:	681b      	ldr	r3, [r3, #0]
 80105b4:	681a      	ldr	r2, [r3, #0]
 80105b6:	68fb      	ldr	r3, [r7, #12]
 80105b8:	681b      	ldr	r3, [r3, #0]
 80105ba:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80105be:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80105c0:	68fb      	ldr	r3, [r7, #12]
 80105c2:	681b      	ldr	r3, [r3, #0]
 80105c4:	691a      	ldr	r2, [r3, #16]
 80105c6:	68fb      	ldr	r3, [r7, #12]
 80105c8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80105ca:	b2d2      	uxtb	r2, r2
 80105cc:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 80105ce:	68fb      	ldr	r3, [r7, #12]
 80105d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80105d2:	1c5a      	adds	r2, r3, #1
 80105d4:	68fb      	ldr	r3, [r7, #12]
 80105d6:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 80105d8:	68fb      	ldr	r3, [r7, #12]
 80105da:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80105dc:	3b01      	subs	r3, #1
 80105de:	b29a      	uxth	r2, r3
 80105e0:	68fb      	ldr	r3, [r7, #12]
 80105e2:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 80105e4:	68fb      	ldr	r3, [r7, #12]
 80105e6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80105e8:	b29b      	uxth	r3, r3
 80105ea:	3b01      	subs	r3, #1
 80105ec:	b29a      	uxth	r2, r3
 80105ee:	68fb      	ldr	r3, [r7, #12]
 80105f0:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80105f2:	68fb      	ldr	r3, [r7, #12]
 80105f4:	681b      	ldr	r3, [r3, #0]
 80105f6:	691a      	ldr	r2, [r3, #16]
 80105f8:	68fb      	ldr	r3, [r7, #12]
 80105fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80105fc:	b2d2      	uxtb	r2, r2
 80105fe:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010600:	68fb      	ldr	r3, [r7, #12]
 8010602:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010604:	1c5a      	adds	r2, r3, #1
 8010606:	68fb      	ldr	r3, [r7, #12]
 8010608:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 801060a:	68fb      	ldr	r3, [r7, #12]
 801060c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801060e:	3b01      	subs	r3, #1
 8010610:	b29a      	uxth	r2, r3
 8010612:	68fb      	ldr	r3, [r7, #12]
 8010614:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010616:	68fb      	ldr	r3, [r7, #12]
 8010618:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801061a:	b29b      	uxth	r3, r3
 801061c:	3b01      	subs	r3, #1
 801061e:	b29a      	uxth	r2, r3
 8010620:	68fb      	ldr	r3, [r7, #12]
 8010622:	855a      	strh	r2, [r3, #42]	@ 0x2a
 8010624:	e04e      	b.n	80106c4 <HAL_I2C_Master_Receive+0x430>
        }
      }
      else
      {
        /* Wait until RXNE flag is set */
        if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010626:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010628:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801062a:	68f8      	ldr	r0, [r7, #12]
 801062c:	f002 fcda 	bl	8012fe4 <I2C_WaitOnRXNEFlagUntilTimeout>
 8010630:	4603      	mov	r3, r0
 8010632:	2b00      	cmp	r3, #0
 8010634:	d001      	beq.n	801063a <HAL_I2C_Master_Receive+0x3a6>
        {
          return HAL_ERROR;
 8010636:	2301      	movs	r3, #1
 8010638:	e058      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
        }

        /* Read data from DR */
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 801063a:	68fb      	ldr	r3, [r7, #12]
 801063c:	681b      	ldr	r3, [r3, #0]
 801063e:	691a      	ldr	r2, [r3, #16]
 8010640:	68fb      	ldr	r3, [r7, #12]
 8010642:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010644:	b2d2      	uxtb	r2, r2
 8010646:	701a      	strb	r2, [r3, #0]

        /* Increment Buffer pointer */
        hi2c->pBuffPtr++;
 8010648:	68fb      	ldr	r3, [r7, #12]
 801064a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801064c:	1c5a      	adds	r2, r3, #1
 801064e:	68fb      	ldr	r3, [r7, #12]
 8010650:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Update counter */
        hi2c->XferSize--;
 8010652:	68fb      	ldr	r3, [r7, #12]
 8010654:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010656:	3b01      	subs	r3, #1
 8010658:	b29a      	uxth	r2, r3
 801065a:	68fb      	ldr	r3, [r7, #12]
 801065c:	851a      	strh	r2, [r3, #40]	@ 0x28
        hi2c->XferCount--;
 801065e:	68fb      	ldr	r3, [r7, #12]
 8010660:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010662:	b29b      	uxth	r3, r3
 8010664:	3b01      	subs	r3, #1
 8010666:	b29a      	uxth	r2, r3
 8010668:	68fb      	ldr	r3, [r7, #12]
 801066a:	855a      	strh	r2, [r3, #42]	@ 0x2a

        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 801066c:	68fb      	ldr	r3, [r7, #12]
 801066e:	681b      	ldr	r3, [r3, #0]
 8010670:	695b      	ldr	r3, [r3, #20]
 8010672:	f003 0304 	and.w	r3, r3, #4
 8010676:	2b04      	cmp	r3, #4
 8010678:	d124      	bne.n	80106c4 <HAL_I2C_Master_Receive+0x430>
        {

          if (hi2c->XferSize == 3U)
 801067a:	68fb      	ldr	r3, [r7, #12]
 801067c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801067e:	2b03      	cmp	r3, #3
 8010680:	d107      	bne.n	8010692 <HAL_I2C_Master_Receive+0x3fe>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8010682:	68fb      	ldr	r3, [r7, #12]
 8010684:	681b      	ldr	r3, [r3, #0]
 8010686:	681a      	ldr	r2, [r3, #0]
 8010688:	68fb      	ldr	r3, [r7, #12]
 801068a:	681b      	ldr	r3, [r3, #0]
 801068c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8010690:	601a      	str	r2, [r3, #0]
          }

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010692:	68fb      	ldr	r3, [r7, #12]
 8010694:	681b      	ldr	r3, [r3, #0]
 8010696:	691a      	ldr	r2, [r3, #16]
 8010698:	68fb      	ldr	r3, [r7, #12]
 801069a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801069c:	b2d2      	uxtb	r2, r2
 801069e:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 80106a0:	68fb      	ldr	r3, [r7, #12]
 80106a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80106a4:	1c5a      	adds	r2, r3, #1
 80106a6:	68fb      	ldr	r3, [r7, #12]
 80106a8:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 80106aa:	68fb      	ldr	r3, [r7, #12]
 80106ac:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80106ae:	3b01      	subs	r3, #1
 80106b0:	b29a      	uxth	r2, r3
 80106b2:	68fb      	ldr	r3, [r7, #12]
 80106b4:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 80106b6:	68fb      	ldr	r3, [r7, #12]
 80106b8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80106ba:	b29b      	uxth	r3, r3
 80106bc:	3b01      	subs	r3, #1
 80106be:	b29a      	uxth	r2, r3
 80106c0:	68fb      	ldr	r3, [r7, #12]
 80106c2:	855a      	strh	r2, [r3, #42]	@ 0x2a
    while (hi2c->XferSize > 0U)
 80106c4:	68fb      	ldr	r3, [r7, #12]
 80106c6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80106c8:	2b00      	cmp	r3, #0
 80106ca:	f47f aeb6 	bne.w	801043a <HAL_I2C_Master_Receive+0x1a6>
        }
      }
    }

    hi2c->State = HAL_I2C_STATE_READY;
 80106ce:	68fb      	ldr	r3, [r7, #12]
 80106d0:	2220      	movs	r2, #32
 80106d2:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80106d6:	68fb      	ldr	r3, [r7, #12]
 80106d8:	2200      	movs	r2, #0
 80106da:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80106de:	68fb      	ldr	r3, [r7, #12]
 80106e0:	2200      	movs	r2, #0
 80106e2:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 80106e6:	2300      	movs	r3, #0
 80106e8:	e000      	b.n	80106ec <HAL_I2C_Master_Receive+0x458>
  }
  else
  {
    return HAL_BUSY;
 80106ea:	2302      	movs	r3, #2
  }
}
 80106ec:	4618      	mov	r0, r3
 80106ee:	3728      	adds	r7, #40	@ 0x28
 80106f0:	46bd      	mov	sp, r7
 80106f2:	bd80      	pop	{r7, pc}
 80106f4:	00010004 	.word	0x00010004

080106f8 <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80106f8:	b580      	push	{r7, lr}
 80106fa:	b088      	sub	sp, #32
 80106fc:	af02      	add	r7, sp, #8
 80106fe:	60f8      	str	r0, [r7, #12]
 8010700:	4608      	mov	r0, r1
 8010702:	4611      	mov	r1, r2
 8010704:	461a      	mov	r2, r3
 8010706:	4603      	mov	r3, r0
 8010708:	817b      	strh	r3, [r7, #10]
 801070a:	460b      	mov	r3, r1
 801070c:	813b      	strh	r3, [r7, #8]
 801070e:	4613      	mov	r3, r2
 8010710:	80fb      	strh	r3, [r7, #6]
  /* Init tickstart for timeout management*/
  uint32_t tickstart = HAL_GetTick();
 8010712:	f7fe fdf3 	bl	800f2fc <HAL_GetTick>
 8010716:	6178      	str	r0, [r7, #20]

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8010718:	68fb      	ldr	r3, [r7, #12]
 801071a:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801071e:	b2db      	uxtb	r3, r3
 8010720:	2b20      	cmp	r3, #32
 8010722:	f040 80d9 	bne.w	80108d8 <HAL_I2C_Mem_Write+0x1e0>
  {
    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 8010726:	697b      	ldr	r3, [r7, #20]
 8010728:	9300      	str	r3, [sp, #0]
 801072a:	2319      	movs	r3, #25
 801072c:	2201      	movs	r2, #1
 801072e:	496d      	ldr	r1, [pc, #436]	@ (80108e4 <HAL_I2C_Mem_Write+0x1ec>)
 8010730:	68f8      	ldr	r0, [r7, #12]
 8010732:	f002 fa7b 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 8010736:	4603      	mov	r3, r0
 8010738:	2b00      	cmp	r3, #0
 801073a:	d001      	beq.n	8010740 <HAL_I2C_Mem_Write+0x48>
    {
      return HAL_BUSY;
 801073c:	2302      	movs	r3, #2
 801073e:	e0cc      	b.n	80108da <HAL_I2C_Mem_Write+0x1e2>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8010740:	68fb      	ldr	r3, [r7, #12]
 8010742:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8010746:	2b01      	cmp	r3, #1
 8010748:	d101      	bne.n	801074e <HAL_I2C_Mem_Write+0x56>
 801074a:	2302      	movs	r3, #2
 801074c:	e0c5      	b.n	80108da <HAL_I2C_Mem_Write+0x1e2>
 801074e:	68fb      	ldr	r3, [r7, #12]
 8010750:	2201      	movs	r2, #1
 8010752:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Check if the I2C is already enabled */
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 8010756:	68fb      	ldr	r3, [r7, #12]
 8010758:	681b      	ldr	r3, [r3, #0]
 801075a:	681b      	ldr	r3, [r3, #0]
 801075c:	f003 0301 	and.w	r3, r3, #1
 8010760:	2b01      	cmp	r3, #1
 8010762:	d007      	beq.n	8010774 <HAL_I2C_Mem_Write+0x7c>
    {
      /* Enable I2C peripheral */
      __HAL_I2C_ENABLE(hi2c);
 8010764:	68fb      	ldr	r3, [r7, #12]
 8010766:	681b      	ldr	r3, [r3, #0]
 8010768:	681a      	ldr	r2, [r3, #0]
 801076a:	68fb      	ldr	r3, [r7, #12]
 801076c:	681b      	ldr	r3, [r3, #0]
 801076e:	f042 0201 	orr.w	r2, r2, #1
 8010772:	601a      	str	r2, [r3, #0]
    }

    /* Disable Pos */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8010774:	68fb      	ldr	r3, [r7, #12]
 8010776:	681b      	ldr	r3, [r3, #0]
 8010778:	681a      	ldr	r2, [r3, #0]
 801077a:	68fb      	ldr	r3, [r7, #12]
 801077c:	681b      	ldr	r3, [r3, #0]
 801077e:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8010782:	601a      	str	r2, [r3, #0]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8010784:	68fb      	ldr	r3, [r7, #12]
 8010786:	2221      	movs	r2, #33	@ 0x21
 8010788:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 801078c:	68fb      	ldr	r3, [r7, #12]
 801078e:	2240      	movs	r2, #64	@ 0x40
 8010790:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010794:	68fb      	ldr	r3, [r7, #12]
 8010796:	2200      	movs	r2, #0
 8010798:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
 801079a:	68fb      	ldr	r3, [r7, #12]
 801079c:	6a3a      	ldr	r2, [r7, #32]
 801079e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
 80107a0:	68fb      	ldr	r3, [r7, #12]
 80107a2:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 80107a4:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
 80107a6:	68fb      	ldr	r3, [r7, #12]
 80107a8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80107aa:	b29a      	uxth	r2, r3
 80107ac:	68fb      	ldr	r3, [r7, #12]
 80107ae:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80107b0:	68fb      	ldr	r3, [r7, #12]
 80107b2:	4a4d      	ldr	r2, [pc, #308]	@ (80108e8 <HAL_I2C_Mem_Write+0x1f0>)
 80107b4:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80107b6:	88f8      	ldrh	r0, [r7, #6]
 80107b8:	893a      	ldrh	r2, [r7, #8]
 80107ba:	8979      	ldrh	r1, [r7, #10]
 80107bc:	697b      	ldr	r3, [r7, #20]
 80107be:	9301      	str	r3, [sp, #4]
 80107c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80107c2:	9300      	str	r3, [sp, #0]
 80107c4:	4603      	mov	r3, r0
 80107c6:	68f8      	ldr	r0, [r7, #12]
 80107c8:	f002 f80a 	bl	80127e0 <I2C_RequestMemoryWrite>
 80107cc:	4603      	mov	r3, r0
 80107ce:	2b00      	cmp	r3, #0
 80107d0:	d052      	beq.n	8010878 <HAL_I2C_Mem_Write+0x180>
    {
      return HAL_ERROR;
 80107d2:	2301      	movs	r3, #1
 80107d4:	e081      	b.n	80108da <HAL_I2C_Mem_Write+0x1e2>
    }

    while (hi2c->XferSize > 0U)
    {
      /* Wait until TXE flag is set */
      if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80107d6:	697a      	ldr	r2, [r7, #20]
 80107d8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80107da:	68f8      	ldr	r0, [r7, #12]
 80107dc:	f002 fb40 	bl	8012e60 <I2C_WaitOnTXEFlagUntilTimeout>
 80107e0:	4603      	mov	r3, r0
 80107e2:	2b00      	cmp	r3, #0
 80107e4:	d00d      	beq.n	8010802 <HAL_I2C_Mem_Write+0x10a>
      {
        if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80107e6:	68fb      	ldr	r3, [r7, #12]
 80107e8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80107ea:	2b04      	cmp	r3, #4
 80107ec:	d107      	bne.n	80107fe <HAL_I2C_Mem_Write+0x106>
        {
          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80107ee:	68fb      	ldr	r3, [r7, #12]
 80107f0:	681b      	ldr	r3, [r3, #0]
 80107f2:	681a      	ldr	r2, [r3, #0]
 80107f4:	68fb      	ldr	r3, [r7, #12]
 80107f6:	681b      	ldr	r3, [r3, #0]
 80107f8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80107fc:	601a      	str	r2, [r3, #0]
        }
        return HAL_ERROR;
 80107fe:	2301      	movs	r3, #1
 8010800:	e06b      	b.n	80108da <HAL_I2C_Mem_Write+0x1e2>
      }

      /* Write data to DR */
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8010802:	68fb      	ldr	r3, [r7, #12]
 8010804:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010806:	781a      	ldrb	r2, [r3, #0]
 8010808:	68fb      	ldr	r3, [r7, #12]
 801080a:	681b      	ldr	r3, [r3, #0]
 801080c:	611a      	str	r2, [r3, #16]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 801080e:	68fb      	ldr	r3, [r7, #12]
 8010810:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010812:	1c5a      	adds	r2, r3, #1
 8010814:	68fb      	ldr	r3, [r7, #12]
 8010816:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferSize--;
 8010818:	68fb      	ldr	r3, [r7, #12]
 801081a:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801081c:	3b01      	subs	r3, #1
 801081e:	b29a      	uxth	r2, r3
 8010820:	68fb      	ldr	r3, [r7, #12]
 8010822:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 8010824:	68fb      	ldr	r3, [r7, #12]
 8010826:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010828:	b29b      	uxth	r3, r3
 801082a:	3b01      	subs	r3, #1
 801082c:	b29a      	uxth	r2, r3
 801082e:	68fb      	ldr	r3, [r7, #12]
 8010830:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
 8010832:	68fb      	ldr	r3, [r7, #12]
 8010834:	681b      	ldr	r3, [r3, #0]
 8010836:	695b      	ldr	r3, [r3, #20]
 8010838:	f003 0304 	and.w	r3, r3, #4
 801083c:	2b04      	cmp	r3, #4
 801083e:	d11b      	bne.n	8010878 <HAL_I2C_Mem_Write+0x180>
 8010840:	68fb      	ldr	r3, [r7, #12]
 8010842:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010844:	2b00      	cmp	r3, #0
 8010846:	d017      	beq.n	8010878 <HAL_I2C_Mem_Write+0x180>
      {
        /* Write data to DR */
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 8010848:	68fb      	ldr	r3, [r7, #12]
 801084a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801084c:	781a      	ldrb	r2, [r3, #0]
 801084e:	68fb      	ldr	r3, [r7, #12]
 8010850:	681b      	ldr	r3, [r3, #0]
 8010852:	611a      	str	r2, [r3, #16]

        /* Increment Buffer pointer */
        hi2c->pBuffPtr++;
 8010854:	68fb      	ldr	r3, [r7, #12]
 8010856:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010858:	1c5a      	adds	r2, r3, #1
 801085a:	68fb      	ldr	r3, [r7, #12]
 801085c:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Update counter */
        hi2c->XferSize--;
 801085e:	68fb      	ldr	r3, [r7, #12]
 8010860:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010862:	3b01      	subs	r3, #1
 8010864:	b29a      	uxth	r2, r3
 8010866:	68fb      	ldr	r3, [r7, #12]
 8010868:	851a      	strh	r2, [r3, #40]	@ 0x28
        hi2c->XferCount--;
 801086a:	68fb      	ldr	r3, [r7, #12]
 801086c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801086e:	b29b      	uxth	r3, r3
 8010870:	3b01      	subs	r3, #1
 8010872:	b29a      	uxth	r2, r3
 8010874:	68fb      	ldr	r3, [r7, #12]
 8010876:	855a      	strh	r2, [r3, #42]	@ 0x2a
    while (hi2c->XferSize > 0U)
 8010878:	68fb      	ldr	r3, [r7, #12]
 801087a:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801087c:	2b00      	cmp	r3, #0
 801087e:	d1aa      	bne.n	80107d6 <HAL_I2C_Mem_Write+0xde>
      }
    }

    /* Wait until BTF flag is set */
    if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010880:	697a      	ldr	r2, [r7, #20]
 8010882:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8010884:	68f8      	ldr	r0, [r7, #12]
 8010886:	f002 fb33 	bl	8012ef0 <I2C_WaitOnBTFFlagUntilTimeout>
 801088a:	4603      	mov	r3, r0
 801088c:	2b00      	cmp	r3, #0
 801088e:	d00d      	beq.n	80108ac <HAL_I2C_Mem_Write+0x1b4>
    {
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8010890:	68fb      	ldr	r3, [r7, #12]
 8010892:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8010894:	2b04      	cmp	r3, #4
 8010896:	d107      	bne.n	80108a8 <HAL_I2C_Mem_Write+0x1b0>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010898:	68fb      	ldr	r3, [r7, #12]
 801089a:	681b      	ldr	r3, [r3, #0]
 801089c:	681a      	ldr	r2, [r3, #0]
 801089e:	68fb      	ldr	r3, [r7, #12]
 80108a0:	681b      	ldr	r3, [r3, #0]
 80108a2:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80108a6:	601a      	str	r2, [r3, #0]
      }
      return HAL_ERROR;
 80108a8:	2301      	movs	r3, #1
 80108aa:	e016      	b.n	80108da <HAL_I2C_Mem_Write+0x1e2>
    }

    /* Generate Stop */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80108ac:	68fb      	ldr	r3, [r7, #12]
 80108ae:	681b      	ldr	r3, [r3, #0]
 80108b0:	681a      	ldr	r2, [r3, #0]
 80108b2:	68fb      	ldr	r3, [r7, #12]
 80108b4:	681b      	ldr	r3, [r3, #0]
 80108b6:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80108ba:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 80108bc:	68fb      	ldr	r3, [r7, #12]
 80108be:	2220      	movs	r2, #32
 80108c0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80108c4:	68fb      	ldr	r3, [r7, #12]
 80108c6:	2200      	movs	r2, #0
 80108c8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80108cc:	68fb      	ldr	r3, [r7, #12]
 80108ce:	2200      	movs	r2, #0
 80108d0:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 80108d4:	2300      	movs	r3, #0
 80108d6:	e000      	b.n	80108da <HAL_I2C_Mem_Write+0x1e2>
  }
  else
  {
    return HAL_BUSY;
 80108d8:	2302      	movs	r3, #2
  }
}
 80108da:	4618      	mov	r0, r3
 80108dc:	3718      	adds	r7, #24
 80108de:	46bd      	mov	sp, r7
 80108e0:	bd80      	pop	{r7, pc}
 80108e2:	bf00      	nop
 80108e4:	00100002 	.word	0x00100002
 80108e8:	ffff0000 	.word	0xffff0000

080108ec <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80108ec:	b580      	push	{r7, lr}
 80108ee:	b08c      	sub	sp, #48	@ 0x30
 80108f0:	af02      	add	r7, sp, #8
 80108f2:	60f8      	str	r0, [r7, #12]
 80108f4:	4608      	mov	r0, r1
 80108f6:	4611      	mov	r1, r2
 80108f8:	461a      	mov	r2, r3
 80108fa:	4603      	mov	r3, r0
 80108fc:	817b      	strh	r3, [r7, #10]
 80108fe:	460b      	mov	r3, r1
 8010900:	813b      	strh	r3, [r7, #8]
 8010902:	4613      	mov	r3, r2
 8010904:	80fb      	strh	r3, [r7, #6]
  /* Init tickstart for timeout management*/
  uint32_t tickstart = HAL_GetTick();
 8010906:	f7fe fcf9 	bl	800f2fc <HAL_GetTick>
 801090a:	6278      	str	r0, [r7, #36]	@ 0x24

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 801090c:	68fb      	ldr	r3, [r7, #12]
 801090e:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8010912:	b2db      	uxtb	r3, r3
 8010914:	2b20      	cmp	r3, #32
 8010916:	f040 8214 	bne.w	8010d42 <HAL_I2C_Mem_Read+0x456>
  {
    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 801091a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801091c:	9300      	str	r3, [sp, #0]
 801091e:	2319      	movs	r3, #25
 8010920:	2201      	movs	r2, #1
 8010922:	497b      	ldr	r1, [pc, #492]	@ (8010b10 <HAL_I2C_Mem_Read+0x224>)
 8010924:	68f8      	ldr	r0, [r7, #12]
 8010926:	f002 f981 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 801092a:	4603      	mov	r3, r0
 801092c:	2b00      	cmp	r3, #0
 801092e:	d001      	beq.n	8010934 <HAL_I2C_Mem_Read+0x48>
    {
      return HAL_BUSY;
 8010930:	2302      	movs	r3, #2
 8010932:	e207      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8010934:	68fb      	ldr	r3, [r7, #12]
 8010936:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 801093a:	2b01      	cmp	r3, #1
 801093c:	d101      	bne.n	8010942 <HAL_I2C_Mem_Read+0x56>
 801093e:	2302      	movs	r3, #2
 8010940:	e200      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
 8010942:	68fb      	ldr	r3, [r7, #12]
 8010944:	2201      	movs	r2, #1
 8010946:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Check if the I2C is already enabled */
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 801094a:	68fb      	ldr	r3, [r7, #12]
 801094c:	681b      	ldr	r3, [r3, #0]
 801094e:	681b      	ldr	r3, [r3, #0]
 8010950:	f003 0301 	and.w	r3, r3, #1
 8010954:	2b01      	cmp	r3, #1
 8010956:	d007      	beq.n	8010968 <HAL_I2C_Mem_Read+0x7c>
    {
      /* Enable I2C peripheral */
      __HAL_I2C_ENABLE(hi2c);
 8010958:	68fb      	ldr	r3, [r7, #12]
 801095a:	681b      	ldr	r3, [r3, #0]
 801095c:	681a      	ldr	r2, [r3, #0]
 801095e:	68fb      	ldr	r3, [r7, #12]
 8010960:	681b      	ldr	r3, [r3, #0]
 8010962:	f042 0201 	orr.w	r2, r2, #1
 8010966:	601a      	str	r2, [r3, #0]
    }

    /* Disable Pos */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8010968:	68fb      	ldr	r3, [r7, #12]
 801096a:	681b      	ldr	r3, [r3, #0]
 801096c:	681a      	ldr	r2, [r3, #0]
 801096e:	68fb      	ldr	r3, [r7, #12]
 8010970:	681b      	ldr	r3, [r3, #0]
 8010972:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8010976:	601a      	str	r2, [r3, #0]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8010978:	68fb      	ldr	r3, [r7, #12]
 801097a:	2222      	movs	r2, #34	@ 0x22
 801097c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8010980:	68fb      	ldr	r3, [r7, #12]
 8010982:	2240      	movs	r2, #64	@ 0x40
 8010984:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8010988:	68fb      	ldr	r3, [r7, #12]
 801098a:	2200      	movs	r2, #0
 801098c:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
 801098e:	68fb      	ldr	r3, [r7, #12]
 8010990:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8010992:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
 8010994:	68fb      	ldr	r3, [r7, #12]
 8010996:	8eba      	ldrh	r2, [r7, #52]	@ 0x34
 8010998:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
 801099a:	68fb      	ldr	r3, [r7, #12]
 801099c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801099e:	b29a      	uxth	r2, r3
 80109a0:	68fb      	ldr	r3, [r7, #12]
 80109a2:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80109a4:	68fb      	ldr	r3, [r7, #12]
 80109a6:	4a5b      	ldr	r2, [pc, #364]	@ (8010b14 <HAL_I2C_Mem_Read+0x228>)
 80109a8:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80109aa:	88f8      	ldrh	r0, [r7, #6]
 80109ac:	893a      	ldrh	r2, [r7, #8]
 80109ae:	8979      	ldrh	r1, [r7, #10]
 80109b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80109b2:	9301      	str	r3, [sp, #4]
 80109b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80109b6:	9300      	str	r3, [sp, #0]
 80109b8:	4603      	mov	r3, r0
 80109ba:	68f8      	ldr	r0, [r7, #12]
 80109bc:	f001 ffa6 	bl	801290c <I2C_RequestMemoryRead>
 80109c0:	4603      	mov	r3, r0
 80109c2:	2b00      	cmp	r3, #0
 80109c4:	d001      	beq.n	80109ca <HAL_I2C_Mem_Read+0xde>
    {
      return HAL_ERROR;
 80109c6:	2301      	movs	r3, #1
 80109c8:	e1bc      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
    }

    if (hi2c->XferSize == 0U)
 80109ca:	68fb      	ldr	r3, [r7, #12]
 80109cc:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80109ce:	2b00      	cmp	r3, #0
 80109d0:	d113      	bne.n	80109fa <HAL_I2C_Mem_Read+0x10e>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80109d2:	2300      	movs	r3, #0
 80109d4:	623b      	str	r3, [r7, #32]
 80109d6:	68fb      	ldr	r3, [r7, #12]
 80109d8:	681b      	ldr	r3, [r3, #0]
 80109da:	695b      	ldr	r3, [r3, #20]
 80109dc:	623b      	str	r3, [r7, #32]
 80109de:	68fb      	ldr	r3, [r7, #12]
 80109e0:	681b      	ldr	r3, [r3, #0]
 80109e2:	699b      	ldr	r3, [r3, #24]
 80109e4:	623b      	str	r3, [r7, #32]
 80109e6:	6a3b      	ldr	r3, [r7, #32]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80109e8:	68fb      	ldr	r3, [r7, #12]
 80109ea:	681b      	ldr	r3, [r3, #0]
 80109ec:	681a      	ldr	r2, [r3, #0]
 80109ee:	68fb      	ldr	r3, [r7, #12]
 80109f0:	681b      	ldr	r3, [r3, #0]
 80109f2:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80109f6:	601a      	str	r2, [r3, #0]
 80109f8:	e190      	b.n	8010d1c <HAL_I2C_Mem_Read+0x430>
    }
    else if (hi2c->XferSize == 1U)
 80109fa:	68fb      	ldr	r3, [r7, #12]
 80109fc:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80109fe:	2b01      	cmp	r3, #1
 8010a00:	d11b      	bne.n	8010a3a <HAL_I2C_Mem_Read+0x14e>
    {
      /* Disable Acknowledge */
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8010a02:	68fb      	ldr	r3, [r7, #12]
 8010a04:	681b      	ldr	r3, [r3, #0]
 8010a06:	681a      	ldr	r2, [r3, #0]
 8010a08:	68fb      	ldr	r3, [r7, #12]
 8010a0a:	681b      	ldr	r3, [r3, #0]
 8010a0c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8010a10:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8010a12:	2300      	movs	r3, #0
 8010a14:	61fb      	str	r3, [r7, #28]
 8010a16:	68fb      	ldr	r3, [r7, #12]
 8010a18:	681b      	ldr	r3, [r3, #0]
 8010a1a:	695b      	ldr	r3, [r3, #20]
 8010a1c:	61fb      	str	r3, [r7, #28]
 8010a1e:	68fb      	ldr	r3, [r7, #12]
 8010a20:	681b      	ldr	r3, [r3, #0]
 8010a22:	699b      	ldr	r3, [r3, #24]
 8010a24:	61fb      	str	r3, [r7, #28]
 8010a26:	69fb      	ldr	r3, [r7, #28]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010a28:	68fb      	ldr	r3, [r7, #12]
 8010a2a:	681b      	ldr	r3, [r3, #0]
 8010a2c:	681a      	ldr	r2, [r3, #0]
 8010a2e:	68fb      	ldr	r3, [r7, #12]
 8010a30:	681b      	ldr	r3, [r3, #0]
 8010a32:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8010a36:	601a      	str	r2, [r3, #0]
 8010a38:	e170      	b.n	8010d1c <HAL_I2C_Mem_Read+0x430>
    }
    else if (hi2c->XferSize == 2U)
 8010a3a:	68fb      	ldr	r3, [r7, #12]
 8010a3c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010a3e:	2b02      	cmp	r3, #2
 8010a40:	d11b      	bne.n	8010a7a <HAL_I2C_Mem_Read+0x18e>
    {
      /* Disable Acknowledge */
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8010a42:	68fb      	ldr	r3, [r7, #12]
 8010a44:	681b      	ldr	r3, [r3, #0]
 8010a46:	681a      	ldr	r2, [r3, #0]
 8010a48:	68fb      	ldr	r3, [r7, #12]
 8010a4a:	681b      	ldr	r3, [r3, #0]
 8010a4c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8010a50:	601a      	str	r2, [r3, #0]

      /* Enable Pos */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8010a52:	68fb      	ldr	r3, [r7, #12]
 8010a54:	681b      	ldr	r3, [r3, #0]
 8010a56:	681a      	ldr	r2, [r3, #0]
 8010a58:	68fb      	ldr	r3, [r7, #12]
 8010a5a:	681b      	ldr	r3, [r3, #0]
 8010a5c:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8010a60:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8010a62:	2300      	movs	r3, #0
 8010a64:	61bb      	str	r3, [r7, #24]
 8010a66:	68fb      	ldr	r3, [r7, #12]
 8010a68:	681b      	ldr	r3, [r3, #0]
 8010a6a:	695b      	ldr	r3, [r3, #20]
 8010a6c:	61bb      	str	r3, [r7, #24]
 8010a6e:	68fb      	ldr	r3, [r7, #12]
 8010a70:	681b      	ldr	r3, [r3, #0]
 8010a72:	699b      	ldr	r3, [r3, #24]
 8010a74:	61bb      	str	r3, [r7, #24]
 8010a76:	69bb      	ldr	r3, [r7, #24]
 8010a78:	e150      	b.n	8010d1c <HAL_I2C_Mem_Read+0x430>
    }
    else
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8010a7a:	2300      	movs	r3, #0
 8010a7c:	617b      	str	r3, [r7, #20]
 8010a7e:	68fb      	ldr	r3, [r7, #12]
 8010a80:	681b      	ldr	r3, [r3, #0]
 8010a82:	695b      	ldr	r3, [r3, #20]
 8010a84:	617b      	str	r3, [r7, #20]
 8010a86:	68fb      	ldr	r3, [r7, #12]
 8010a88:	681b      	ldr	r3, [r3, #0]
 8010a8a:	699b      	ldr	r3, [r3, #24]
 8010a8c:	617b      	str	r3, [r7, #20]
 8010a8e:	697b      	ldr	r3, [r7, #20]
    }

    while (hi2c->XferSize > 0U)
 8010a90:	e144      	b.n	8010d1c <HAL_I2C_Mem_Read+0x430>
    {
      if (hi2c->XferSize <= 3U)
 8010a92:	68fb      	ldr	r3, [r7, #12]
 8010a94:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010a96:	2b03      	cmp	r3, #3
 8010a98:	f200 80f1 	bhi.w	8010c7e <HAL_I2C_Mem_Read+0x392>
      {
        /* One byte */
        if (hi2c->XferSize == 1U)
 8010a9c:	68fb      	ldr	r3, [r7, #12]
 8010a9e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010aa0:	2b01      	cmp	r3, #1
 8010aa2:	d123      	bne.n	8010aec <HAL_I2C_Mem_Read+0x200>
        {
          /* Wait until RXNE flag is set */
          if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010aa4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010aa6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8010aa8:	68f8      	ldr	r0, [r7, #12]
 8010aaa:	f002 fa9b 	bl	8012fe4 <I2C_WaitOnRXNEFlagUntilTimeout>
 8010aae:	4603      	mov	r3, r0
 8010ab0:	2b00      	cmp	r3, #0
 8010ab2:	d001      	beq.n	8010ab8 <HAL_I2C_Mem_Read+0x1cc>
          {
            return HAL_ERROR;
 8010ab4:	2301      	movs	r3, #1
 8010ab6:	e145      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
          }

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010ab8:	68fb      	ldr	r3, [r7, #12]
 8010aba:	681b      	ldr	r3, [r3, #0]
 8010abc:	691a      	ldr	r2, [r3, #16]
 8010abe:	68fb      	ldr	r3, [r7, #12]
 8010ac0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010ac2:	b2d2      	uxtb	r2, r2
 8010ac4:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010ac6:	68fb      	ldr	r3, [r7, #12]
 8010ac8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010aca:	1c5a      	adds	r2, r3, #1
 8010acc:	68fb      	ldr	r3, [r7, #12]
 8010ace:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010ad0:	68fb      	ldr	r3, [r7, #12]
 8010ad2:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010ad4:	3b01      	subs	r3, #1
 8010ad6:	b29a      	uxth	r2, r3
 8010ad8:	68fb      	ldr	r3, [r7, #12]
 8010ada:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010adc:	68fb      	ldr	r3, [r7, #12]
 8010ade:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010ae0:	b29b      	uxth	r3, r3
 8010ae2:	3b01      	subs	r3, #1
 8010ae4:	b29a      	uxth	r2, r3
 8010ae6:	68fb      	ldr	r3, [r7, #12]
 8010ae8:	855a      	strh	r2, [r3, #42]	@ 0x2a
 8010aea:	e117      	b.n	8010d1c <HAL_I2C_Mem_Read+0x430>
        }
        /* Two bytes */
        else if (hi2c->XferSize == 2U)
 8010aec:	68fb      	ldr	r3, [r7, #12]
 8010aee:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010af0:	2b02      	cmp	r3, #2
 8010af2:	d14e      	bne.n	8010b92 <HAL_I2C_Mem_Read+0x2a6>
        {
          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 8010af4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010af6:	9300      	str	r3, [sp, #0]
 8010af8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010afa:	2200      	movs	r2, #0
 8010afc:	4906      	ldr	r1, [pc, #24]	@ (8010b18 <HAL_I2C_Mem_Read+0x22c>)
 8010afe:	68f8      	ldr	r0, [r7, #12]
 8010b00:	f002 f894 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 8010b04:	4603      	mov	r3, r0
 8010b06:	2b00      	cmp	r3, #0
 8010b08:	d008      	beq.n	8010b1c <HAL_I2C_Mem_Read+0x230>
          {
            return HAL_ERROR;
 8010b0a:	2301      	movs	r3, #1
 8010b0c:	e11a      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
 8010b0e:	bf00      	nop
 8010b10:	00100002 	.word	0x00100002
 8010b14:	ffff0000 	.word	0xffff0000
 8010b18:	00010004 	.word	0x00010004
          }

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010b1c:	68fb      	ldr	r3, [r7, #12]
 8010b1e:	681b      	ldr	r3, [r3, #0]
 8010b20:	681a      	ldr	r2, [r3, #0]
 8010b22:	68fb      	ldr	r3, [r7, #12]
 8010b24:	681b      	ldr	r3, [r3, #0]
 8010b26:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8010b2a:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010b2c:	68fb      	ldr	r3, [r7, #12]
 8010b2e:	681b      	ldr	r3, [r3, #0]
 8010b30:	691a      	ldr	r2, [r3, #16]
 8010b32:	68fb      	ldr	r3, [r7, #12]
 8010b34:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010b36:	b2d2      	uxtb	r2, r2
 8010b38:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010b3a:	68fb      	ldr	r3, [r7, #12]
 8010b3c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010b3e:	1c5a      	adds	r2, r3, #1
 8010b40:	68fb      	ldr	r3, [r7, #12]
 8010b42:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010b44:	68fb      	ldr	r3, [r7, #12]
 8010b46:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010b48:	3b01      	subs	r3, #1
 8010b4a:	b29a      	uxth	r2, r3
 8010b4c:	68fb      	ldr	r3, [r7, #12]
 8010b4e:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010b50:	68fb      	ldr	r3, [r7, #12]
 8010b52:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010b54:	b29b      	uxth	r3, r3
 8010b56:	3b01      	subs	r3, #1
 8010b58:	b29a      	uxth	r2, r3
 8010b5a:	68fb      	ldr	r3, [r7, #12]
 8010b5c:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010b5e:	68fb      	ldr	r3, [r7, #12]
 8010b60:	681b      	ldr	r3, [r3, #0]
 8010b62:	691a      	ldr	r2, [r3, #16]
 8010b64:	68fb      	ldr	r3, [r7, #12]
 8010b66:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010b68:	b2d2      	uxtb	r2, r2
 8010b6a:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010b6c:	68fb      	ldr	r3, [r7, #12]
 8010b6e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010b70:	1c5a      	adds	r2, r3, #1
 8010b72:	68fb      	ldr	r3, [r7, #12]
 8010b74:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010b76:	68fb      	ldr	r3, [r7, #12]
 8010b78:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010b7a:	3b01      	subs	r3, #1
 8010b7c:	b29a      	uxth	r2, r3
 8010b7e:	68fb      	ldr	r3, [r7, #12]
 8010b80:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010b82:	68fb      	ldr	r3, [r7, #12]
 8010b84:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010b86:	b29b      	uxth	r3, r3
 8010b88:	3b01      	subs	r3, #1
 8010b8a:	b29a      	uxth	r2, r3
 8010b8c:	68fb      	ldr	r3, [r7, #12]
 8010b8e:	855a      	strh	r2, [r3, #42]	@ 0x2a
 8010b90:	e0c4      	b.n	8010d1c <HAL_I2C_Mem_Read+0x430>
        }
        /* 3 Last bytes */
        else
        {
          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 8010b92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010b94:	9300      	str	r3, [sp, #0]
 8010b96:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010b98:	2200      	movs	r2, #0
 8010b9a:	496c      	ldr	r1, [pc, #432]	@ (8010d4c <HAL_I2C_Mem_Read+0x460>)
 8010b9c:	68f8      	ldr	r0, [r7, #12]
 8010b9e:	f002 f845 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 8010ba2:	4603      	mov	r3, r0
 8010ba4:	2b00      	cmp	r3, #0
 8010ba6:	d001      	beq.n	8010bac <HAL_I2C_Mem_Read+0x2c0>
          {
            return HAL_ERROR;
 8010ba8:	2301      	movs	r3, #1
 8010baa:	e0cb      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
          }

          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8010bac:	68fb      	ldr	r3, [r7, #12]
 8010bae:	681b      	ldr	r3, [r3, #0]
 8010bb0:	681a      	ldr	r2, [r3, #0]
 8010bb2:	68fb      	ldr	r3, [r7, #12]
 8010bb4:	681b      	ldr	r3, [r3, #0]
 8010bb6:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8010bba:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010bbc:	68fb      	ldr	r3, [r7, #12]
 8010bbe:	681b      	ldr	r3, [r3, #0]
 8010bc0:	691a      	ldr	r2, [r3, #16]
 8010bc2:	68fb      	ldr	r3, [r7, #12]
 8010bc4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010bc6:	b2d2      	uxtb	r2, r2
 8010bc8:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010bca:	68fb      	ldr	r3, [r7, #12]
 8010bcc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010bce:	1c5a      	adds	r2, r3, #1
 8010bd0:	68fb      	ldr	r3, [r7, #12]
 8010bd2:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010bd4:	68fb      	ldr	r3, [r7, #12]
 8010bd6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010bd8:	3b01      	subs	r3, #1
 8010bda:	b29a      	uxth	r2, r3
 8010bdc:	68fb      	ldr	r3, [r7, #12]
 8010bde:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010be0:	68fb      	ldr	r3, [r7, #12]
 8010be2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010be4:	b29b      	uxth	r3, r3
 8010be6:	3b01      	subs	r3, #1
 8010be8:	b29a      	uxth	r2, r3
 8010bea:	68fb      	ldr	r3, [r7, #12]
 8010bec:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 8010bee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010bf0:	9300      	str	r3, [sp, #0]
 8010bf2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010bf4:	2200      	movs	r2, #0
 8010bf6:	4955      	ldr	r1, [pc, #340]	@ (8010d4c <HAL_I2C_Mem_Read+0x460>)
 8010bf8:	68f8      	ldr	r0, [r7, #12]
 8010bfa:	f002 f817 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 8010bfe:	4603      	mov	r3, r0
 8010c00:	2b00      	cmp	r3, #0
 8010c02:	d001      	beq.n	8010c08 <HAL_I2C_Mem_Read+0x31c>
          {
            return HAL_ERROR;
 8010c04:	2301      	movs	r3, #1
 8010c06:	e09d      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
          }

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8010c08:	68fb      	ldr	r3, [r7, #12]
 8010c0a:	681b      	ldr	r3, [r3, #0]
 8010c0c:	681a      	ldr	r2, [r3, #0]
 8010c0e:	68fb      	ldr	r3, [r7, #12]
 8010c10:	681b      	ldr	r3, [r3, #0]
 8010c12:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8010c16:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010c18:	68fb      	ldr	r3, [r7, #12]
 8010c1a:	681b      	ldr	r3, [r3, #0]
 8010c1c:	691a      	ldr	r2, [r3, #16]
 8010c1e:	68fb      	ldr	r3, [r7, #12]
 8010c20:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010c22:	b2d2      	uxtb	r2, r2
 8010c24:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010c26:	68fb      	ldr	r3, [r7, #12]
 8010c28:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010c2a:	1c5a      	adds	r2, r3, #1
 8010c2c:	68fb      	ldr	r3, [r7, #12]
 8010c2e:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010c30:	68fb      	ldr	r3, [r7, #12]
 8010c32:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010c34:	3b01      	subs	r3, #1
 8010c36:	b29a      	uxth	r2, r3
 8010c38:	68fb      	ldr	r3, [r7, #12]
 8010c3a:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010c3c:	68fb      	ldr	r3, [r7, #12]
 8010c3e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010c40:	b29b      	uxth	r3, r3
 8010c42:	3b01      	subs	r3, #1
 8010c44:	b29a      	uxth	r2, r3
 8010c46:	68fb      	ldr	r3, [r7, #12]
 8010c48:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010c4a:	68fb      	ldr	r3, [r7, #12]
 8010c4c:	681b      	ldr	r3, [r3, #0]
 8010c4e:	691a      	ldr	r2, [r3, #16]
 8010c50:	68fb      	ldr	r3, [r7, #12]
 8010c52:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010c54:	b2d2      	uxtb	r2, r2
 8010c56:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010c58:	68fb      	ldr	r3, [r7, #12]
 8010c5a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010c5c:	1c5a      	adds	r2, r3, #1
 8010c5e:	68fb      	ldr	r3, [r7, #12]
 8010c60:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010c62:	68fb      	ldr	r3, [r7, #12]
 8010c64:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010c66:	3b01      	subs	r3, #1
 8010c68:	b29a      	uxth	r2, r3
 8010c6a:	68fb      	ldr	r3, [r7, #12]
 8010c6c:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010c6e:	68fb      	ldr	r3, [r7, #12]
 8010c70:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010c72:	b29b      	uxth	r3, r3
 8010c74:	3b01      	subs	r3, #1
 8010c76:	b29a      	uxth	r2, r3
 8010c78:	68fb      	ldr	r3, [r7, #12]
 8010c7a:	855a      	strh	r2, [r3, #42]	@ 0x2a
 8010c7c:	e04e      	b.n	8010d1c <HAL_I2C_Mem_Read+0x430>
        }
      }
      else
      {
        /* Wait until RXNE flag is set */
        if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8010c7e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8010c80:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8010c82:	68f8      	ldr	r0, [r7, #12]
 8010c84:	f002 f9ae 	bl	8012fe4 <I2C_WaitOnRXNEFlagUntilTimeout>
 8010c88:	4603      	mov	r3, r0
 8010c8a:	2b00      	cmp	r3, #0
 8010c8c:	d001      	beq.n	8010c92 <HAL_I2C_Mem_Read+0x3a6>
        {
          return HAL_ERROR;
 8010c8e:	2301      	movs	r3, #1
 8010c90:	e058      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
        }

        /* Read data from DR */
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010c92:	68fb      	ldr	r3, [r7, #12]
 8010c94:	681b      	ldr	r3, [r3, #0]
 8010c96:	691a      	ldr	r2, [r3, #16]
 8010c98:	68fb      	ldr	r3, [r7, #12]
 8010c9a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010c9c:	b2d2      	uxtb	r2, r2
 8010c9e:	701a      	strb	r2, [r3, #0]

        /* Increment Buffer pointer */
        hi2c->pBuffPtr++;
 8010ca0:	68fb      	ldr	r3, [r7, #12]
 8010ca2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010ca4:	1c5a      	adds	r2, r3, #1
 8010ca6:	68fb      	ldr	r3, [r7, #12]
 8010ca8:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Update counter */
        hi2c->XferSize--;
 8010caa:	68fb      	ldr	r3, [r7, #12]
 8010cac:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010cae:	3b01      	subs	r3, #1
 8010cb0:	b29a      	uxth	r2, r3
 8010cb2:	68fb      	ldr	r3, [r7, #12]
 8010cb4:	851a      	strh	r2, [r3, #40]	@ 0x28
        hi2c->XferCount--;
 8010cb6:	68fb      	ldr	r3, [r7, #12]
 8010cb8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010cba:	b29b      	uxth	r3, r3
 8010cbc:	3b01      	subs	r3, #1
 8010cbe:	b29a      	uxth	r2, r3
 8010cc0:	68fb      	ldr	r3, [r7, #12]
 8010cc2:	855a      	strh	r2, [r3, #42]	@ 0x2a

        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 8010cc4:	68fb      	ldr	r3, [r7, #12]
 8010cc6:	681b      	ldr	r3, [r3, #0]
 8010cc8:	695b      	ldr	r3, [r3, #20]
 8010cca:	f003 0304 	and.w	r3, r3, #4
 8010cce:	2b04      	cmp	r3, #4
 8010cd0:	d124      	bne.n	8010d1c <HAL_I2C_Mem_Read+0x430>
        {
          if (hi2c->XferSize == 3U)
 8010cd2:	68fb      	ldr	r3, [r7, #12]
 8010cd4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010cd6:	2b03      	cmp	r3, #3
 8010cd8:	d107      	bne.n	8010cea <HAL_I2C_Mem_Read+0x3fe>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8010cda:	68fb      	ldr	r3, [r7, #12]
 8010cdc:	681b      	ldr	r3, [r3, #0]
 8010cde:	681a      	ldr	r2, [r3, #0]
 8010ce0:	68fb      	ldr	r3, [r7, #12]
 8010ce2:	681b      	ldr	r3, [r3, #0]
 8010ce4:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8010ce8:	601a      	str	r2, [r3, #0]
          }
          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8010cea:	68fb      	ldr	r3, [r7, #12]
 8010cec:	681b      	ldr	r3, [r3, #0]
 8010cee:	691a      	ldr	r2, [r3, #16]
 8010cf0:	68fb      	ldr	r3, [r7, #12]
 8010cf2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010cf4:	b2d2      	uxtb	r2, r2
 8010cf6:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8010cf8:	68fb      	ldr	r3, [r7, #12]
 8010cfa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8010cfc:	1c5a      	adds	r2, r3, #1
 8010cfe:	68fb      	ldr	r3, [r7, #12]
 8010d00:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 8010d02:	68fb      	ldr	r3, [r7, #12]
 8010d04:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010d06:	3b01      	subs	r3, #1
 8010d08:	b29a      	uxth	r2, r3
 8010d0a:	68fb      	ldr	r3, [r7, #12]
 8010d0c:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 8010d0e:	68fb      	ldr	r3, [r7, #12]
 8010d10:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8010d12:	b29b      	uxth	r3, r3
 8010d14:	3b01      	subs	r3, #1
 8010d16:	b29a      	uxth	r2, r3
 8010d18:	68fb      	ldr	r3, [r7, #12]
 8010d1a:	855a      	strh	r2, [r3, #42]	@ 0x2a
    while (hi2c->XferSize > 0U)
 8010d1c:	68fb      	ldr	r3, [r7, #12]
 8010d1e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8010d20:	2b00      	cmp	r3, #0
 8010d22:	f47f aeb6 	bne.w	8010a92 <HAL_I2C_Mem_Read+0x1a6>
        }
      }
    }

    hi2c->State = HAL_I2C_STATE_READY;
 8010d26:	68fb      	ldr	r3, [r7, #12]
 8010d28:	2220      	movs	r2, #32
 8010d2a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8010d2e:	68fb      	ldr	r3, [r7, #12]
 8010d30:	2200      	movs	r2, #0
 8010d32:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8010d36:	68fb      	ldr	r3, [r7, #12]
 8010d38:	2200      	movs	r2, #0
 8010d3a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 8010d3e:	2300      	movs	r3, #0
 8010d40:	e000      	b.n	8010d44 <HAL_I2C_Mem_Read+0x458>
  }
  else
  {
    return HAL_BUSY;
 8010d42:	2302      	movs	r3, #2
  }
}
 8010d44:	4618      	mov	r0, r3
 8010d46:	3728      	adds	r7, #40	@ 0x28
 8010d48:	46bd      	mov	sp, r7
 8010d4a:	bd80      	pop	{r7, pc}
 8010d4c:	00010004 	.word	0x00010004

08010d50 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 8010d50:	b580      	push	{r7, lr}
 8010d52:	b088      	sub	sp, #32
 8010d54:	af00      	add	r7, sp, #0
 8010d56:	6078      	str	r0, [r7, #4]
  uint32_t sr1itflags;
  uint32_t sr2itflags               = 0U;
 8010d58:	2300      	movs	r3, #0
 8010d5a:	61bb      	str	r3, [r7, #24]
  uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
 8010d5c:	687b      	ldr	r3, [r7, #4]
 8010d5e:	681b      	ldr	r3, [r3, #0]
 8010d60:	685b      	ldr	r3, [r3, #4]
 8010d62:	617b      	str	r3, [r7, #20]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8010d64:	687b      	ldr	r3, [r7, #4]
 8010d66:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8010d68:	613b      	str	r3, [r7, #16]
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8010d6a:	687b      	ldr	r3, [r7, #4]
 8010d6c:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8010d70:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8010d72:	687b      	ldr	r3, [r7, #4]
 8010d74:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8010d78:	73bb      	strb	r3, [r7, #14]

  /* Master or Memory mode selected */
  if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 8010d7a:	7bfb      	ldrb	r3, [r7, #15]
 8010d7c:	2b10      	cmp	r3, #16
 8010d7e:	d003      	beq.n	8010d88 <HAL_I2C_EV_IRQHandler+0x38>
 8010d80:	7bfb      	ldrb	r3, [r7, #15]
 8010d82:	2b40      	cmp	r3, #64	@ 0x40
 8010d84:	f040 80b1 	bne.w	8010eea <HAL_I2C_EV_IRQHandler+0x19a>
  {
    sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8010d88:	687b      	ldr	r3, [r7, #4]
 8010d8a:	681b      	ldr	r3, [r3, #0]
 8010d8c:	699b      	ldr	r3, [r3, #24]
 8010d8e:	61bb      	str	r3, [r7, #24]
    sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8010d90:	687b      	ldr	r3, [r7, #4]
 8010d92:	681b      	ldr	r3, [r3, #0]
 8010d94:	695b      	ldr	r3, [r3, #20]
 8010d96:	61fb      	str	r3, [r7, #28]

    /* Exit IRQ event until Start Bit detected in case of Other frame requested */
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
 8010d98:	69fb      	ldr	r3, [r7, #28]
 8010d9a:	f003 0301 	and.w	r3, r3, #1
 8010d9e:	2b00      	cmp	r3, #0
 8010da0:	d10d      	bne.n	8010dbe <HAL_I2C_EV_IRQHandler+0x6e>
 8010da2:	693b      	ldr	r3, [r7, #16]
 8010da4:	f5b3 0f2a 	cmp.w	r3, #11141120	@ 0xaa0000
 8010da8:	d003      	beq.n	8010db2 <HAL_I2C_EV_IRQHandler+0x62>
 8010daa:	693b      	ldr	r3, [r7, #16]
 8010dac:	f1b3 4f2a 	cmp.w	r3, #2852126720	@ 0xaa000000
 8010db0:	d101      	bne.n	8010db6 <HAL_I2C_EV_IRQHandler+0x66>
 8010db2:	2301      	movs	r3, #1
 8010db4:	e000      	b.n	8010db8 <HAL_I2C_EV_IRQHandler+0x68>
 8010db6:	2300      	movs	r3, #0
 8010db8:	2b01      	cmp	r3, #1
 8010dba:	f000 8114 	beq.w	8010fe6 <HAL_I2C_EV_IRQHandler+0x296>
    {
      return;
    }

    /* SB Set ----------------------------------------------------------------*/
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010dbe:	69fb      	ldr	r3, [r7, #28]
 8010dc0:	f003 0301 	and.w	r3, r3, #1
 8010dc4:	2b00      	cmp	r3, #0
 8010dc6:	d00b      	beq.n	8010de0 <HAL_I2C_EV_IRQHandler+0x90>
 8010dc8:	697b      	ldr	r3, [r7, #20]
 8010dca:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010dce:	2b00      	cmp	r3, #0
 8010dd0:	d006      	beq.n	8010de0 <HAL_I2C_EV_IRQHandler+0x90>
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
 8010dd2:	6878      	ldr	r0, [r7, #4]
 8010dd4:	f002 f992 	bl	80130fc <I2C_ConvertOtherXferOptions>

      I2C_Master_SB(hi2c);
 8010dd8:	6878      	ldr	r0, [r7, #4]
 8010dda:	f000 fd94 	bl	8011906 <I2C_Master_SB>
 8010dde:	e083      	b.n	8010ee8 <HAL_I2C_EV_IRQHandler+0x198>
    }
    /* ADD10 Set -------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010de0:	69fb      	ldr	r3, [r7, #28]
 8010de2:	f003 0308 	and.w	r3, r3, #8
 8010de6:	2b00      	cmp	r3, #0
 8010de8:	d008      	beq.n	8010dfc <HAL_I2C_EV_IRQHandler+0xac>
 8010dea:	697b      	ldr	r3, [r7, #20]
 8010dec:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010df0:	2b00      	cmp	r3, #0
 8010df2:	d003      	beq.n	8010dfc <HAL_I2C_EV_IRQHandler+0xac>
    {
      I2C_Master_ADD10(hi2c);
 8010df4:	6878      	ldr	r0, [r7, #4]
 8010df6:	f000 fe0c 	bl	8011a12 <I2C_Master_ADD10>
 8010dfa:	e075      	b.n	8010ee8 <HAL_I2C_EV_IRQHandler+0x198>
    }
    /* ADDR Set --------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010dfc:	69fb      	ldr	r3, [r7, #28]
 8010dfe:	f003 0302 	and.w	r3, r3, #2
 8010e02:	2b00      	cmp	r3, #0
 8010e04:	d008      	beq.n	8010e18 <HAL_I2C_EV_IRQHandler+0xc8>
 8010e06:	697b      	ldr	r3, [r7, #20]
 8010e08:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010e0c:	2b00      	cmp	r3, #0
 8010e0e:	d003      	beq.n	8010e18 <HAL_I2C_EV_IRQHandler+0xc8>
    {
      I2C_Master_ADDR(hi2c);
 8010e10:	6878      	ldr	r0, [r7, #4]
 8010e12:	f000 fe28 	bl	8011a66 <I2C_Master_ADDR>
 8010e16:	e067      	b.n	8010ee8 <HAL_I2C_EV_IRQHandler+0x198>
    }
    /* I2C in mode Transmitter -----------------------------------------------*/
    else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
 8010e18:	69bb      	ldr	r3, [r7, #24]
 8010e1a:	f003 0304 	and.w	r3, r3, #4
 8010e1e:	2b00      	cmp	r3, #0
 8010e20:	d036      	beq.n	8010e90 <HAL_I2C_EV_IRQHandler+0x140>
    {
      /* Do not check buffer and BTF flag if a Xfer DMA is on going */
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8010e22:	687b      	ldr	r3, [r7, #4]
 8010e24:	681b      	ldr	r3, [r3, #0]
 8010e26:	685b      	ldr	r3, [r3, #4]
 8010e28:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8010e2c:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8010e30:	f000 80db 	beq.w	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
      {
        /* TXE set and BTF reset -----------------------------------------------*/
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8010e34:	69fb      	ldr	r3, [r7, #28]
 8010e36:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8010e3a:	2b00      	cmp	r3, #0
 8010e3c:	d00d      	beq.n	8010e5a <HAL_I2C_EV_IRQHandler+0x10a>
 8010e3e:	697b      	ldr	r3, [r7, #20]
 8010e40:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8010e44:	2b00      	cmp	r3, #0
 8010e46:	d008      	beq.n	8010e5a <HAL_I2C_EV_IRQHandler+0x10a>
 8010e48:	69fb      	ldr	r3, [r7, #28]
 8010e4a:	f003 0304 	and.w	r3, r3, #4
 8010e4e:	2b00      	cmp	r3, #0
 8010e50:	d103      	bne.n	8010e5a <HAL_I2C_EV_IRQHandler+0x10a>
        {
          I2C_MasterTransmit_TXE(hi2c);
 8010e52:	6878      	ldr	r0, [r7, #4]
 8010e54:	f000 f9f0 	bl	8011238 <I2C_MasterTransmit_TXE>
 8010e58:	e046      	b.n	8010ee8 <HAL_I2C_EV_IRQHandler+0x198>
        }
        /* BTF set -------------------------------------------------------------*/
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010e5a:	69fb      	ldr	r3, [r7, #28]
 8010e5c:	f003 0304 	and.w	r3, r3, #4
 8010e60:	2b00      	cmp	r3, #0
 8010e62:	f000 80c2 	beq.w	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
 8010e66:	697b      	ldr	r3, [r7, #20]
 8010e68:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010e6c:	2b00      	cmp	r3, #0
 8010e6e:	f000 80bc 	beq.w	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
        {
          if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 8010e72:	7bbb      	ldrb	r3, [r7, #14]
 8010e74:	2b21      	cmp	r3, #33	@ 0x21
 8010e76:	d103      	bne.n	8010e80 <HAL_I2C_EV_IRQHandler+0x130>
          {
            I2C_MasterTransmit_BTF(hi2c);
 8010e78:	6878      	ldr	r0, [r7, #4]
 8010e7a:	f000 fa79 	bl	8011370 <I2C_MasterTransmit_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010e7e:	e0b4      	b.n	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
          }
          else /* HAL_I2C_MODE_MEM */
          {
            if (CurrentMode == HAL_I2C_MODE_MEM)
 8010e80:	7bfb      	ldrb	r3, [r7, #15]
 8010e82:	2b40      	cmp	r3, #64	@ 0x40
 8010e84:	f040 80b1 	bne.w	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
            {
              I2C_MemoryTransmit_TXE_BTF(hi2c);
 8010e88:	6878      	ldr	r0, [r7, #4]
 8010e8a:	f000 fae7 	bl	801145c <I2C_MemoryTransmit_TXE_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010e8e:	e0ac      	b.n	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
    }
    /* I2C in mode Receiver --------------------------------------------------*/
    else
    {
      /* Do not check buffer and BTF flag if a Xfer DMA is on going */
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8010e90:	687b      	ldr	r3, [r7, #4]
 8010e92:	681b      	ldr	r3, [r3, #0]
 8010e94:	685b      	ldr	r3, [r3, #4]
 8010e96:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8010e9a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8010e9e:	f000 80a4 	beq.w	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
      {
        /* RXNE set and BTF reset -----------------------------------------------*/
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8010ea2:	69fb      	ldr	r3, [r7, #28]
 8010ea4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8010ea8:	2b00      	cmp	r3, #0
 8010eaa:	d00d      	beq.n	8010ec8 <HAL_I2C_EV_IRQHandler+0x178>
 8010eac:	697b      	ldr	r3, [r7, #20]
 8010eae:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8010eb2:	2b00      	cmp	r3, #0
 8010eb4:	d008      	beq.n	8010ec8 <HAL_I2C_EV_IRQHandler+0x178>
 8010eb6:	69fb      	ldr	r3, [r7, #28]
 8010eb8:	f003 0304 	and.w	r3, r3, #4
 8010ebc:	2b00      	cmp	r3, #0
 8010ebe:	d103      	bne.n	8010ec8 <HAL_I2C_EV_IRQHandler+0x178>
        {
          I2C_MasterReceive_RXNE(hi2c);
 8010ec0:	6878      	ldr	r0, [r7, #4]
 8010ec2:	f000 fb63 	bl	801158c <I2C_MasterReceive_RXNE>
 8010ec6:	e00f      	b.n	8010ee8 <HAL_I2C_EV_IRQHandler+0x198>
        }
        /* BTF set -------------------------------------------------------------*/
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010ec8:	69fb      	ldr	r3, [r7, #28]
 8010eca:	f003 0304 	and.w	r3, r3, #4
 8010ece:	2b00      	cmp	r3, #0
 8010ed0:	f000 808b 	beq.w	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
 8010ed4:	697b      	ldr	r3, [r7, #20]
 8010ed6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010eda:	2b00      	cmp	r3, #0
 8010edc:	f000 8085 	beq.w	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
        {
          I2C_MasterReceive_BTF(hi2c);
 8010ee0:	6878      	ldr	r0, [r7, #4]
 8010ee2:	f000 fc1b 	bl	801171c <I2C_MasterReceive_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010ee6:	e080      	b.n	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
 8010ee8:	e07f      	b.n	8010fea <HAL_I2C_EV_IRQHandler+0x29a>
  /* Slave mode selected */
  else
  {
    /* If an error is detected, read only SR1 register to prevent */
    /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
    if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8010eea:	687b      	ldr	r3, [r7, #4]
 8010eec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8010eee:	2b00      	cmp	r3, #0
 8010ef0:	d004      	beq.n	8010efc <HAL_I2C_EV_IRQHandler+0x1ac>
    {
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8010ef2:	687b      	ldr	r3, [r7, #4]
 8010ef4:	681b      	ldr	r3, [r3, #0]
 8010ef6:	695b      	ldr	r3, [r3, #20]
 8010ef8:	61fb      	str	r3, [r7, #28]
 8010efa:	e007      	b.n	8010f0c <HAL_I2C_EV_IRQHandler+0x1bc>
    }
    else
    {
      sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8010efc:	687b      	ldr	r3, [r7, #4]
 8010efe:	681b      	ldr	r3, [r3, #0]
 8010f00:	699b      	ldr	r3, [r3, #24]
 8010f02:	61bb      	str	r3, [r7, #24]
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8010f04:	687b      	ldr	r3, [r7, #4]
 8010f06:	681b      	ldr	r3, [r3, #0]
 8010f08:	695b      	ldr	r3, [r3, #20]
 8010f0a:	61fb      	str	r3, [r7, #28]
    }

    /* ADDR set --------------------------------------------------------------*/
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010f0c:	69fb      	ldr	r3, [r7, #28]
 8010f0e:	f003 0302 	and.w	r3, r3, #2
 8010f12:	2b00      	cmp	r3, #0
 8010f14:	d011      	beq.n	8010f3a <HAL_I2C_EV_IRQHandler+0x1ea>
 8010f16:	697b      	ldr	r3, [r7, #20]
 8010f18:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010f1c:	2b00      	cmp	r3, #0
 8010f1e:	d00c      	beq.n	8010f3a <HAL_I2C_EV_IRQHandler+0x1ea>
    {
      /* Now time to read SR2, this will clear ADDR flag automatically */
      if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8010f20:	687b      	ldr	r3, [r7, #4]
 8010f22:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8010f24:	2b00      	cmp	r3, #0
 8010f26:	d003      	beq.n	8010f30 <HAL_I2C_EV_IRQHandler+0x1e0>
      {
        sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8010f28:	687b      	ldr	r3, [r7, #4]
 8010f2a:	681b      	ldr	r3, [r3, #0]
 8010f2c:	699b      	ldr	r3, [r3, #24]
 8010f2e:	61bb      	str	r3, [r7, #24]
      }
      I2C_Slave_ADDR(hi2c, sr2itflags);
 8010f30:	69b9      	ldr	r1, [r7, #24]
 8010f32:	6878      	ldr	r0, [r7, #4]
 8010f34:	f000 ffe6 	bl	8011f04 <I2C_Slave_ADDR>
 8010f38:	e05a      	b.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
    }
    /* STOPF set --------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010f3a:	69fb      	ldr	r3, [r7, #28]
 8010f3c:	f003 0310 	and.w	r3, r3, #16
 8010f40:	2b00      	cmp	r3, #0
 8010f42:	d008      	beq.n	8010f56 <HAL_I2C_EV_IRQHandler+0x206>
 8010f44:	697b      	ldr	r3, [r7, #20]
 8010f46:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010f4a:	2b00      	cmp	r3, #0
 8010f4c:	d003      	beq.n	8010f56 <HAL_I2C_EV_IRQHandler+0x206>
    {
      I2C_Slave_STOPF(hi2c);
 8010f4e:	6878      	ldr	r0, [r7, #4]
 8010f50:	f001 f820 	bl	8011f94 <I2C_Slave_STOPF>
 8010f54:	e04c      	b.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
    }
    /* I2C in mode Transmitter -----------------------------------------------*/
    else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8010f56:	7bbb      	ldrb	r3, [r7, #14]
 8010f58:	2b21      	cmp	r3, #33	@ 0x21
 8010f5a:	d002      	beq.n	8010f62 <HAL_I2C_EV_IRQHandler+0x212>
 8010f5c:	7bbb      	ldrb	r3, [r7, #14]
 8010f5e:	2b29      	cmp	r3, #41	@ 0x29
 8010f60:	d120      	bne.n	8010fa4 <HAL_I2C_EV_IRQHandler+0x254>
    {
      /* TXE set and BTF reset -----------------------------------------------*/
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8010f62:	69fb      	ldr	r3, [r7, #28]
 8010f64:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8010f68:	2b00      	cmp	r3, #0
 8010f6a:	d00d      	beq.n	8010f88 <HAL_I2C_EV_IRQHandler+0x238>
 8010f6c:	697b      	ldr	r3, [r7, #20]
 8010f6e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8010f72:	2b00      	cmp	r3, #0
 8010f74:	d008      	beq.n	8010f88 <HAL_I2C_EV_IRQHandler+0x238>
 8010f76:	69fb      	ldr	r3, [r7, #28]
 8010f78:	f003 0304 	and.w	r3, r3, #4
 8010f7c:	2b00      	cmp	r3, #0
 8010f7e:	d103      	bne.n	8010f88 <HAL_I2C_EV_IRQHandler+0x238>
      {
        I2C_SlaveTransmit_TXE(hi2c);
 8010f80:	6878      	ldr	r0, [r7, #4]
 8010f82:	f000 ff01 	bl	8011d88 <I2C_SlaveTransmit_TXE>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8010f86:	e032      	b.n	8010fee <HAL_I2C_EV_IRQHandler+0x29e>
      }
      /* BTF set -------------------------------------------------------------*/
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010f88:	69fb      	ldr	r3, [r7, #28]
 8010f8a:	f003 0304 	and.w	r3, r3, #4
 8010f8e:	2b00      	cmp	r3, #0
 8010f90:	d02d      	beq.n	8010fee <HAL_I2C_EV_IRQHandler+0x29e>
 8010f92:	697b      	ldr	r3, [r7, #20]
 8010f94:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010f98:	2b00      	cmp	r3, #0
 8010f9a:	d028      	beq.n	8010fee <HAL_I2C_EV_IRQHandler+0x29e>
      {
        I2C_SlaveTransmit_BTF(hi2c);
 8010f9c:	6878      	ldr	r0, [r7, #4]
 8010f9e:	f000 ff30 	bl	8011e02 <I2C_SlaveTransmit_BTF>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8010fa2:	e024      	b.n	8010fee <HAL_I2C_EV_IRQHandler+0x29e>
    }
    /* I2C in mode Receiver --------------------------------------------------*/
    else
    {
      /* RXNE set and BTF reset ----------------------------------------------*/
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8010fa4:	69fb      	ldr	r3, [r7, #28]
 8010fa6:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8010faa:	2b00      	cmp	r3, #0
 8010fac:	d00d      	beq.n	8010fca <HAL_I2C_EV_IRQHandler+0x27a>
 8010fae:	697b      	ldr	r3, [r7, #20]
 8010fb0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8010fb4:	2b00      	cmp	r3, #0
 8010fb6:	d008      	beq.n	8010fca <HAL_I2C_EV_IRQHandler+0x27a>
 8010fb8:	69fb      	ldr	r3, [r7, #28]
 8010fba:	f003 0304 	and.w	r3, r3, #4
 8010fbe:	2b00      	cmp	r3, #0
 8010fc0:	d103      	bne.n	8010fca <HAL_I2C_EV_IRQHandler+0x27a>
      {
        I2C_SlaveReceive_RXNE(hi2c);
 8010fc2:	6878      	ldr	r0, [r7, #4]
 8010fc4:	f000 ff3e 	bl	8011e44 <I2C_SlaveReceive_RXNE>
 8010fc8:	e012      	b.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
      }
      /* BTF set -------------------------------------------------------------*/
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010fca:	69fb      	ldr	r3, [r7, #28]
 8010fcc:	f003 0304 	and.w	r3, r3, #4
 8010fd0:	2b00      	cmp	r3, #0
 8010fd2:	d00d      	beq.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
 8010fd4:	697b      	ldr	r3, [r7, #20]
 8010fd6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010fda:	2b00      	cmp	r3, #0
 8010fdc:	d008      	beq.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
      {
        I2C_SlaveReceive_BTF(hi2c);
 8010fde:	6878      	ldr	r0, [r7, #4]
 8010fe0:	f000 ff6e 	bl	8011ec0 <I2C_SlaveReceive_BTF>
 8010fe4:	e004      	b.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
      return;
 8010fe6:	bf00      	nop
 8010fe8:	e002      	b.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8010fea:	bf00      	nop
 8010fec:	e000      	b.n	8010ff0 <HAL_I2C_EV_IRQHandler+0x2a0>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8010fee:	bf00      	nop
      {
        /* Do nothing */
      }
    }
  }
}
 8010ff0:	3720      	adds	r7, #32
 8010ff2:	46bd      	mov	sp, r7
 8010ff4:	bd80      	pop	{r7, pc}

08010ff6 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 8010ff6:	b580      	push	{r7, lr}
 8010ff8:	b08a      	sub	sp, #40	@ 0x28
 8010ffa:	af00      	add	r7, sp, #0
 8010ffc:	6078      	str	r0, [r7, #4]
  HAL_I2C_ModeTypeDef tmp1;
  uint32_t tmp2;
  HAL_I2C_StateTypeDef tmp3;
  uint32_t tmp4;
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8010ffe:	687b      	ldr	r3, [r7, #4]
 8011000:	681b      	ldr	r3, [r3, #0]
 8011002:	695b      	ldr	r3, [r3, #20]
 8011004:	623b      	str	r3, [r7, #32]
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 8011006:	687b      	ldr	r3, [r7, #4]
 8011008:	681b      	ldr	r3, [r3, #0]
 801100a:	685b      	ldr	r3, [r3, #4]
 801100c:	61fb      	str	r3, [r7, #28]
  uint32_t error      = HAL_I2C_ERROR_NONE;
 801100e:	2300      	movs	r3, #0
 8011010:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8011012:	687b      	ldr	r3, [r7, #4]
 8011014:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8011018:	76fb      	strb	r3, [r7, #27]

  /* I2C Bus error interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 801101a:	6a3b      	ldr	r3, [r7, #32]
 801101c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8011020:	2b00      	cmp	r3, #0
 8011022:	d00d      	beq.n	8011040 <HAL_I2C_ER_IRQHandler+0x4a>
 8011024:	69fb      	ldr	r3, [r7, #28]
 8011026:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 801102a:	2b00      	cmp	r3, #0
 801102c:	d008      	beq.n	8011040 <HAL_I2C_ER_IRQHandler+0x4a>
  {
    error |= HAL_I2C_ERROR_BERR;
 801102e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011030:	f043 0301 	orr.w	r3, r3, #1
 8011034:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8011036:	687b      	ldr	r3, [r7, #4]
 8011038:	681b      	ldr	r3, [r3, #0]
 801103a:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 801103e:	615a      	str	r2, [r3, #20]
  }

  /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8011040:	6a3b      	ldr	r3, [r7, #32]
 8011042:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8011046:	2b00      	cmp	r3, #0
 8011048:	d00d      	beq.n	8011066 <HAL_I2C_ER_IRQHandler+0x70>
 801104a:	69fb      	ldr	r3, [r7, #28]
 801104c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8011050:	2b00      	cmp	r3, #0
 8011052:	d008      	beq.n	8011066 <HAL_I2C_ER_IRQHandler+0x70>
  {
    error |= HAL_I2C_ERROR_ARLO;
 8011054:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011056:	f043 0302 	orr.w	r3, r3, #2
 801105a:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 801105c:	687b      	ldr	r3, [r7, #4]
 801105e:	681b      	ldr	r3, [r3, #0]
 8011060:	f46f 7200 	mvn.w	r2, #512	@ 0x200
 8011064:	615a      	str	r2, [r3, #20]
  }

  /* I2C Acknowledge failure error interrupt occurred ------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8011066:	6a3b      	ldr	r3, [r7, #32]
 8011068:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 801106c:	2b00      	cmp	r3, #0
 801106e:	d03e      	beq.n	80110ee <HAL_I2C_ER_IRQHandler+0xf8>
 8011070:	69fb      	ldr	r3, [r7, #28]
 8011072:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8011076:	2b00      	cmp	r3, #0
 8011078:	d039      	beq.n	80110ee <HAL_I2C_ER_IRQHandler+0xf8>
  {
    tmp1 = CurrentMode;
 801107a:	7efb      	ldrb	r3, [r7, #27]
 801107c:	76bb      	strb	r3, [r7, #26]
    tmp2 = hi2c->XferCount;
 801107e:	687b      	ldr	r3, [r7, #4]
 8011080:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011082:	b29b      	uxth	r3, r3
 8011084:	617b      	str	r3, [r7, #20]
    tmp3 = hi2c->State;
 8011086:	687b      	ldr	r3, [r7, #4]
 8011088:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801108c:	74fb      	strb	r3, [r7, #19]
    tmp4 = hi2c->PreviousState;
 801108e:	687b      	ldr	r3, [r7, #4]
 8011090:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011092:	60fb      	str	r3, [r7, #12]
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8011094:	7ebb      	ldrb	r3, [r7, #26]
 8011096:	2b20      	cmp	r3, #32
 8011098:	d112      	bne.n	80110c0 <HAL_I2C_ER_IRQHandler+0xca>
 801109a:	697b      	ldr	r3, [r7, #20]
 801109c:	2b00      	cmp	r3, #0
 801109e:	d10f      	bne.n	80110c0 <HAL_I2C_ER_IRQHandler+0xca>
 80110a0:	7cfb      	ldrb	r3, [r7, #19]
 80110a2:	2b21      	cmp	r3, #33	@ 0x21
 80110a4:	d008      	beq.n	80110b8 <HAL_I2C_ER_IRQHandler+0xc2>
        ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 80110a6:	7cfb      	ldrb	r3, [r7, #19]
 80110a8:	2b29      	cmp	r3, #41	@ 0x29
 80110aa:	d005      	beq.n	80110b8 <HAL_I2C_ER_IRQHandler+0xc2>
 80110ac:	7cfb      	ldrb	r3, [r7, #19]
 80110ae:	2b28      	cmp	r3, #40	@ 0x28
 80110b0:	d106      	bne.n	80110c0 <HAL_I2C_ER_IRQHandler+0xca>
         ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 80110b2:	68fb      	ldr	r3, [r7, #12]
 80110b4:	2b21      	cmp	r3, #33	@ 0x21
 80110b6:	d103      	bne.n	80110c0 <HAL_I2C_ER_IRQHandler+0xca>
    {
      I2C_Slave_AF(hi2c);
 80110b8:	6878      	ldr	r0, [r7, #4]
 80110ba:	f001 f89b 	bl	80121f4 <I2C_Slave_AF>
 80110be:	e016      	b.n	80110ee <HAL_I2C_ER_IRQHandler+0xf8>
    }
    else
    {
      /* Clear AF flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80110c0:	687b      	ldr	r3, [r7, #4]
 80110c2:	681b      	ldr	r3, [r3, #0]
 80110c4:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 80110c8:	615a      	str	r2, [r3, #20]

      error |= HAL_I2C_ERROR_AF;
 80110ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80110cc:	f043 0304 	orr.w	r3, r3, #4
 80110d0:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
      if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 80110d2:	7efb      	ldrb	r3, [r7, #27]
 80110d4:	2b10      	cmp	r3, #16
 80110d6:	d002      	beq.n	80110de <HAL_I2C_ER_IRQHandler+0xe8>
 80110d8:	7efb      	ldrb	r3, [r7, #27]
 80110da:	2b40      	cmp	r3, #64	@ 0x40
 80110dc:	d107      	bne.n	80110ee <HAL_I2C_ER_IRQHandler+0xf8>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80110de:	687b      	ldr	r3, [r7, #4]
 80110e0:	681b      	ldr	r3, [r3, #0]
 80110e2:	681a      	ldr	r2, [r3, #0]
 80110e4:	687b      	ldr	r3, [r7, #4]
 80110e6:	681b      	ldr	r3, [r3, #0]
 80110e8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80110ec:	601a      	str	r2, [r3, #0]
      }
    }
  }

  /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 80110ee:	6a3b      	ldr	r3, [r7, #32]
 80110f0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 80110f4:	2b00      	cmp	r3, #0
 80110f6:	d00d      	beq.n	8011114 <HAL_I2C_ER_IRQHandler+0x11e>
 80110f8:	69fb      	ldr	r3, [r7, #28]
 80110fa:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80110fe:	2b00      	cmp	r3, #0
 8011100:	d008      	beq.n	8011114 <HAL_I2C_ER_IRQHandler+0x11e>
  {
    error |= HAL_I2C_ERROR_OVR;
 8011102:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011104:	f043 0308 	orr.w	r3, r3, #8
 8011108:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 801110a:	687b      	ldr	r3, [r7, #4]
 801110c:	681b      	ldr	r3, [r3, #0]
 801110e:	f46f 6200 	mvn.w	r2, #2048	@ 0x800
 8011112:	615a      	str	r2, [r3, #20]
  }

  /* Call the Error Callback in case of Error detected -----------------------*/
  if (error != HAL_I2C_ERROR_NONE)
 8011114:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011116:	2b00      	cmp	r3, #0
 8011118:	d008      	beq.n	801112c <HAL_I2C_ER_IRQHandler+0x136>
  {
    hi2c->ErrorCode |= error;
 801111a:	687b      	ldr	r3, [r7, #4]
 801111c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801111e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011120:	431a      	orrs	r2, r3
 8011122:	687b      	ldr	r3, [r7, #4]
 8011124:	641a      	str	r2, [r3, #64]	@ 0x40
    I2C_ITError(hi2c);
 8011126:	6878      	ldr	r0, [r7, #4]
 8011128:	f001 f8d8 	bl	80122dc <I2C_ITError>
  }
}
 801112c:	bf00      	nop
 801112e:	3728      	adds	r7, #40	@ 0x28
 8011130:	46bd      	mov	sp, r7
 8011132:	bd80      	pop	{r7, pc}

08011134 <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8011134:	b480      	push	{r7}
 8011136:	b083      	sub	sp, #12
 8011138:	af00      	add	r7, sp, #0
 801113a:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
 801113c:	bf00      	nop
 801113e:	370c      	adds	r7, #12
 8011140:	46bd      	mov	sp, r7
 8011142:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011146:	4770      	bx	lr

08011148 <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8011148:	b480      	push	{r7}
 801114a:	b083      	sub	sp, #12
 801114c:	af00      	add	r7, sp, #0
 801114e:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
 8011150:	bf00      	nop
 8011152:	370c      	adds	r7, #12
 8011154:	46bd      	mov	sp, r7
 8011156:	f85d 7b04 	ldr.w	r7, [sp], #4
 801115a:	4770      	bx	lr

0801115c <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 801115c:	b480      	push	{r7}
 801115e:	b083      	sub	sp, #12
 8011160:	af00      	add	r7, sp, #0
 8011162:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
 8011164:	bf00      	nop
 8011166:	370c      	adds	r7, #12
 8011168:	46bd      	mov	sp, r7
 801116a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801116e:	4770      	bx	lr

08011170 <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 8011170:	b480      	push	{r7}
 8011172:	b083      	sub	sp, #12
 8011174:	af00      	add	r7, sp, #0
 8011176:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
 8011178:	bf00      	nop
 801117a:	370c      	adds	r7, #12
 801117c:	46bd      	mov	sp, r7
 801117e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011182:	4770      	bx	lr

08011184 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferDirection_definition
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
 8011184:	b480      	push	{r7}
 8011186:	b083      	sub	sp, #12
 8011188:	af00      	add	r7, sp, #0
 801118a:	6078      	str	r0, [r7, #4]
 801118c:	460b      	mov	r3, r1
 801118e:	70fb      	strb	r3, [r7, #3]
 8011190:	4613      	mov	r3, r2
 8011192:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
 8011194:	bf00      	nop
 8011196:	370c      	adds	r7, #12
 8011198:	46bd      	mov	sp, r7
 801119a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801119e:	4770      	bx	lr

080111a0 <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80111a0:	b480      	push	{r7}
 80111a2:	b083      	sub	sp, #12
 80111a4:	af00      	add	r7, sp, #0
 80111a6:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
  */
}
 80111a8:	bf00      	nop
 80111aa:	370c      	adds	r7, #12
 80111ac:	46bd      	mov	sp, r7
 80111ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111b2:	4770      	bx	lr

080111b4 <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80111b4:	b480      	push	{r7}
 80111b6:	b083      	sub	sp, #12
 80111b8:	af00      	add	r7, sp, #0
 80111ba:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
 80111bc:	bf00      	nop
 80111be:	370c      	adds	r7, #12
 80111c0:	46bd      	mov	sp, r7
 80111c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111c6:	4770      	bx	lr

080111c8 <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80111c8:	b480      	push	{r7}
 80111ca:	b083      	sub	sp, #12
 80111cc:	af00      	add	r7, sp, #0
 80111ce:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
 80111d0:	bf00      	nop
 80111d2:	370c      	adds	r7, #12
 80111d4:	46bd      	mov	sp, r7
 80111d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111da:	4770      	bx	lr

080111dc <HAL_I2C_ErrorCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
 80111dc:	b480      	push	{r7}
 80111de:	b083      	sub	sp, #12
 80111e0:	af00      	add	r7, sp, #0
 80111e2:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ErrorCallback could be implemented in the user file
   */
}
 80111e4:	bf00      	nop
 80111e6:	370c      	adds	r7, #12
 80111e8:	46bd      	mov	sp, r7
 80111ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111ee:	4770      	bx	lr

080111f0 <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
 80111f0:	b480      	push	{r7}
 80111f2:	b083      	sub	sp, #12
 80111f4:	af00      	add	r7, sp, #0
 80111f6:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
 80111f8:	bf00      	nop
 80111fa:	370c      	adds	r7, #12
 80111fc:	46bd      	mov	sp, r7
 80111fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011202:	4770      	bx	lr

08011204 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
 8011204:	b480      	push	{r7}
 8011206:	b083      	sub	sp, #12
 8011208:	af00      	add	r7, sp, #0
 801120a:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
 801120c:	687b      	ldr	r3, [r7, #4]
 801120e:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011212:	b2db      	uxtb	r3, r3
}
 8011214:	4618      	mov	r0, r3
 8011216:	370c      	adds	r7, #12
 8011218:	46bd      	mov	sp, r7
 801121a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801121e:	4770      	bx	lr

08011220 <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
 8011220:	b480      	push	{r7}
 8011222:	b083      	sub	sp, #12
 8011224:	af00      	add	r7, sp, #0
 8011226:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
 8011228:	687b      	ldr	r3, [r7, #4]
 801122a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
 801122c:	4618      	mov	r0, r3
 801122e:	370c      	adds	r7, #12
 8011230:	46bd      	mov	sp, r7
 8011232:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011236:	4770      	bx	lr

08011238 <I2C_MasterTransmit_TXE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
{
 8011238:	b580      	push	{r7, lr}
 801123a:	b084      	sub	sp, #16
 801123c:	af00      	add	r7, sp, #0
 801123e:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8011240:	687b      	ldr	r3, [r7, #4]
 8011242:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011246:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8011248:	687b      	ldr	r3, [r7, #4]
 801124a:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 801124e:	73bb      	strb	r3, [r7, #14]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8011250:	687b      	ldr	r3, [r7, #4]
 8011252:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011254:	60bb      	str	r3, [r7, #8]

  if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8011256:	687b      	ldr	r3, [r7, #4]
 8011258:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801125a:	2b00      	cmp	r3, #0
 801125c:	d150      	bne.n	8011300 <I2C_MasterTransmit_TXE+0xc8>
 801125e:	7bfb      	ldrb	r3, [r7, #15]
 8011260:	2b21      	cmp	r3, #33	@ 0x21
 8011262:	d14d      	bne.n	8011300 <I2C_MasterTransmit_TXE+0xc8>
  {
    /* Call TxCpltCallback() directly if no stop mode is set */
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 8011264:	68bb      	ldr	r3, [r7, #8]
 8011266:	2b08      	cmp	r3, #8
 8011268:	d01d      	beq.n	80112a6 <I2C_MasterTransmit_TXE+0x6e>
 801126a:	68bb      	ldr	r3, [r7, #8]
 801126c:	2b20      	cmp	r3, #32
 801126e:	d01a      	beq.n	80112a6 <I2C_MasterTransmit_TXE+0x6e>
 8011270:	68bb      	ldr	r3, [r7, #8]
 8011272:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 8011276:	d016      	beq.n	80112a6 <I2C_MasterTransmit_TXE+0x6e>
    {
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8011278:	687b      	ldr	r3, [r7, #4]
 801127a:	681b      	ldr	r3, [r3, #0]
 801127c:	685a      	ldr	r2, [r3, #4]
 801127e:	687b      	ldr	r3, [r7, #4]
 8011280:	681b      	ldr	r3, [r3, #0]
 8011282:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8011286:	605a      	str	r2, [r3, #4]

      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8011288:	687b      	ldr	r3, [r7, #4]
 801128a:	2211      	movs	r2, #17
 801128c:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 801128e:	687b      	ldr	r3, [r7, #4]
 8011290:	2200      	movs	r2, #0
 8011292:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->State = HAL_I2C_STATE_READY;
 8011296:	687b      	ldr	r3, [r7, #4]
 8011298:	2220      	movs	r2, #32
 801129a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->MasterTxCpltCallback(hi2c);
#else
      HAL_I2C_MasterTxCpltCallback(hi2c);
 801129e:	6878      	ldr	r0, [r7, #4]
 80112a0:	f7ff ff48 	bl	8011134 <HAL_I2C_MasterTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80112a4:	e060      	b.n	8011368 <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
    else /* Generate Stop condition then Call TxCpltCallback() */
    {
      /* Disable EVT, BUF and ERR interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80112a6:	687b      	ldr	r3, [r7, #4]
 80112a8:	681b      	ldr	r3, [r3, #0]
 80112aa:	685a      	ldr	r2, [r3, #4]
 80112ac:	687b      	ldr	r3, [r7, #4]
 80112ae:	681b      	ldr	r3, [r3, #0]
 80112b0:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 80112b4:	605a      	str	r2, [r3, #4]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80112b6:	687b      	ldr	r3, [r7, #4]
 80112b8:	681b      	ldr	r3, [r3, #0]
 80112ba:	681a      	ldr	r2, [r3, #0]
 80112bc:	687b      	ldr	r3, [r7, #4]
 80112be:	681b      	ldr	r3, [r3, #0]
 80112c0:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80112c4:	601a      	str	r2, [r3, #0]

      hi2c->PreviousState = I2C_STATE_NONE;
 80112c6:	687b      	ldr	r3, [r7, #4]
 80112c8:	2200      	movs	r2, #0
 80112ca:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 80112cc:	687b      	ldr	r3, [r7, #4]
 80112ce:	2220      	movs	r2, #32
 80112d0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80112d4:	687b      	ldr	r3, [r7, #4]
 80112d6:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 80112da:	b2db      	uxtb	r3, r3
 80112dc:	2b40      	cmp	r3, #64	@ 0x40
 80112de:	d107      	bne.n	80112f0 <I2C_MasterTransmit_TXE+0xb8>
      {
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80112e0:	687b      	ldr	r3, [r7, #4]
 80112e2:	2200      	movs	r2, #0
 80112e4:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
        hi2c->MemTxCpltCallback(hi2c);
#else
        HAL_I2C_MemTxCpltCallback(hi2c);
 80112e8:	6878      	ldr	r0, [r7, #4]
 80112ea:	f7ff ff63 	bl	80111b4 <HAL_I2C_MemTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80112ee:	e03b      	b.n	8011368 <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
      else
      {
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80112f0:	687b      	ldr	r3, [r7, #4]
 80112f2:	2200      	movs	r2, #0
 80112f4:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
        hi2c->MasterTxCpltCallback(hi2c);
#else
        HAL_I2C_MasterTxCpltCallback(hi2c);
 80112f8:	6878      	ldr	r0, [r7, #4]
 80112fa:	f7ff ff1b 	bl	8011134 <HAL_I2C_MasterTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80112fe:	e033      	b.n	8011368 <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
    }
  }
  else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 8011300:	7bfb      	ldrb	r3, [r7, #15]
 8011302:	2b21      	cmp	r3, #33	@ 0x21
 8011304:	d005      	beq.n	8011312 <I2C_MasterTransmit_TXE+0xda>
 8011306:	7bbb      	ldrb	r3, [r7, #14]
 8011308:	2b40      	cmp	r3, #64	@ 0x40
 801130a:	d12d      	bne.n	8011368 <I2C_MasterTransmit_TXE+0x130>
           ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 801130c:	7bfb      	ldrb	r3, [r7, #15]
 801130e:	2b22      	cmp	r3, #34	@ 0x22
 8011310:	d12a      	bne.n	8011368 <I2C_MasterTransmit_TXE+0x130>
  {
    if (hi2c->XferCount == 0U)
 8011312:	687b      	ldr	r3, [r7, #4]
 8011314:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011316:	b29b      	uxth	r3, r3
 8011318:	2b00      	cmp	r3, #0
 801131a:	d108      	bne.n	801132e <I2C_MasterTransmit_TXE+0xf6>
    {
      /* Disable BUF interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 801131c:	687b      	ldr	r3, [r7, #4]
 801131e:	681b      	ldr	r3, [r3, #0]
 8011320:	685a      	ldr	r2, [r3, #4]
 8011322:	687b      	ldr	r3, [r7, #4]
 8011324:	681b      	ldr	r3, [r3, #0]
 8011326:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 801132a:	605a      	str	r2, [r3, #4]
  }
  else
  {
    /* Do nothing */
  }
}
 801132c:	e01c      	b.n	8011368 <I2C_MasterTransmit_TXE+0x130>
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 801132e:	687b      	ldr	r3, [r7, #4]
 8011330:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8011334:	b2db      	uxtb	r3, r3
 8011336:	2b40      	cmp	r3, #64	@ 0x40
 8011338:	d103      	bne.n	8011342 <I2C_MasterTransmit_TXE+0x10a>
        I2C_MemoryTransmit_TXE_BTF(hi2c);
 801133a:	6878      	ldr	r0, [r7, #4]
 801133c:	f000 f88e 	bl	801145c <I2C_MemoryTransmit_TXE_BTF>
}
 8011340:	e012      	b.n	8011368 <I2C_MasterTransmit_TXE+0x130>
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 8011342:	687b      	ldr	r3, [r7, #4]
 8011344:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011346:	781a      	ldrb	r2, [r3, #0]
 8011348:	687b      	ldr	r3, [r7, #4]
 801134a:	681b      	ldr	r3, [r3, #0]
 801134c:	611a      	str	r2, [r3, #16]
        hi2c->pBuffPtr++;
 801134e:	687b      	ldr	r3, [r7, #4]
 8011350:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011352:	1c5a      	adds	r2, r3, #1
 8011354:	687b      	ldr	r3, [r7, #4]
 8011356:	625a      	str	r2, [r3, #36]	@ 0x24
        hi2c->XferCount--;
 8011358:	687b      	ldr	r3, [r7, #4]
 801135a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801135c:	b29b      	uxth	r3, r3
 801135e:	3b01      	subs	r3, #1
 8011360:	b29a      	uxth	r2, r3
 8011362:	687b      	ldr	r3, [r7, #4]
 8011364:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 8011366:	e7ff      	b.n	8011368 <I2C_MasterTransmit_TXE+0x130>
 8011368:	bf00      	nop
 801136a:	3710      	adds	r7, #16
 801136c:	46bd      	mov	sp, r7
 801136e:	bd80      	pop	{r7, pc}

08011370 <I2C_MasterTransmit_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
 8011370:	b580      	push	{r7, lr}
 8011372:	b084      	sub	sp, #16
 8011374:	af00      	add	r7, sp, #0
 8011376:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8011378:	687b      	ldr	r3, [r7, #4]
 801137a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801137c:	60fb      	str	r3, [r7, #12]

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 801137e:	687b      	ldr	r3, [r7, #4]
 8011380:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011384:	b2db      	uxtb	r3, r3
 8011386:	2b21      	cmp	r3, #33	@ 0x21
 8011388:	d164      	bne.n	8011454 <I2C_MasterTransmit_BTF+0xe4>
  {
    if (hi2c->XferCount != 0U)
 801138a:	687b      	ldr	r3, [r7, #4]
 801138c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801138e:	b29b      	uxth	r3, r3
 8011390:	2b00      	cmp	r3, #0
 8011392:	d012      	beq.n	80113ba <I2C_MasterTransmit_BTF+0x4a>
    {
      /* Write data to DR */
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 8011394:	687b      	ldr	r3, [r7, #4]
 8011396:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011398:	781a      	ldrb	r2, [r3, #0]
 801139a:	687b      	ldr	r3, [r7, #4]
 801139c:	681b      	ldr	r3, [r3, #0]
 801139e:	611a      	str	r2, [r3, #16]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80113a0:	687b      	ldr	r3, [r7, #4]
 80113a2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80113a4:	1c5a      	adds	r2, r3, #1
 80113a6:	687b      	ldr	r3, [r7, #4]
 80113a8:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 80113aa:	687b      	ldr	r3, [r7, #4]
 80113ac:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80113ae:	b29b      	uxth	r3, r3
 80113b0:	3b01      	subs	r3, #1
 80113b2:	b29a      	uxth	r2, r3
 80113b4:	687b      	ldr	r3, [r7, #4]
 80113b6:	855a      	strh	r2, [r3, #42]	@ 0x2a
  }
  else
  {
    /* Do nothing */
  }
}
 80113b8:	e04c      	b.n	8011454 <I2C_MasterTransmit_BTF+0xe4>
      if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80113ba:	68fb      	ldr	r3, [r7, #12]
 80113bc:	2b08      	cmp	r3, #8
 80113be:	d01d      	beq.n	80113fc <I2C_MasterTransmit_BTF+0x8c>
 80113c0:	68fb      	ldr	r3, [r7, #12]
 80113c2:	2b20      	cmp	r3, #32
 80113c4:	d01a      	beq.n	80113fc <I2C_MasterTransmit_BTF+0x8c>
 80113c6:	68fb      	ldr	r3, [r7, #12]
 80113c8:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 80113cc:	d016      	beq.n	80113fc <I2C_MasterTransmit_BTF+0x8c>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80113ce:	687b      	ldr	r3, [r7, #4]
 80113d0:	681b      	ldr	r3, [r3, #0]
 80113d2:	685a      	ldr	r2, [r3, #4]
 80113d4:	687b      	ldr	r3, [r7, #4]
 80113d6:	681b      	ldr	r3, [r3, #0]
 80113d8:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 80113dc:	605a      	str	r2, [r3, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80113de:	687b      	ldr	r3, [r7, #4]
 80113e0:	2211      	movs	r2, #17
 80113e2:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80113e4:	687b      	ldr	r3, [r7, #4]
 80113e6:	2200      	movs	r2, #0
 80113e8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 80113ec:	687b      	ldr	r3, [r7, #4]
 80113ee:	2220      	movs	r2, #32
 80113f0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 80113f4:	6878      	ldr	r0, [r7, #4]
 80113f6:	f7ff fe9d 	bl	8011134 <HAL_I2C_MasterTxCpltCallback>
}
 80113fa:	e02b      	b.n	8011454 <I2C_MasterTransmit_BTF+0xe4>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80113fc:	687b      	ldr	r3, [r7, #4]
 80113fe:	681b      	ldr	r3, [r3, #0]
 8011400:	685a      	ldr	r2, [r3, #4]
 8011402:	687b      	ldr	r3, [r7, #4]
 8011404:	681b      	ldr	r3, [r3, #0]
 8011406:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 801140a:	605a      	str	r2, [r3, #4]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 801140c:	687b      	ldr	r3, [r7, #4]
 801140e:	681b      	ldr	r3, [r3, #0]
 8011410:	681a      	ldr	r2, [r3, #0]
 8011412:	687b      	ldr	r3, [r7, #4]
 8011414:	681b      	ldr	r3, [r3, #0]
 8011416:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 801141a:	601a      	str	r2, [r3, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 801141c:	687b      	ldr	r3, [r7, #4]
 801141e:	2200      	movs	r2, #0
 8011420:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8011422:	687b      	ldr	r3, [r7, #4]
 8011424:	2220      	movs	r2, #32
 8011426:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 801142a:	687b      	ldr	r3, [r7, #4]
 801142c:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8011430:	b2db      	uxtb	r3, r3
 8011432:	2b40      	cmp	r3, #64	@ 0x40
 8011434:	d107      	bne.n	8011446 <I2C_MasterTransmit_BTF+0xd6>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8011436:	687b      	ldr	r3, [r7, #4]
 8011438:	2200      	movs	r2, #0
 801143a:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          HAL_I2C_MemTxCpltCallback(hi2c);
 801143e:	6878      	ldr	r0, [r7, #4]
 8011440:	f7ff feb8 	bl	80111b4 <HAL_I2C_MemTxCpltCallback>
}
 8011444:	e006      	b.n	8011454 <I2C_MasterTransmit_BTF+0xe4>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8011446:	687b      	ldr	r3, [r7, #4]
 8011448:	2200      	movs	r2, #0
 801144a:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          HAL_I2C_MasterTxCpltCallback(hi2c);
 801144e:	6878      	ldr	r0, [r7, #4]
 8011450:	f7ff fe70 	bl	8011134 <HAL_I2C_MasterTxCpltCallback>
}
 8011454:	bf00      	nop
 8011456:	3710      	adds	r7, #16
 8011458:	46bd      	mov	sp, r7
 801145a:	bd80      	pop	{r7, pc}

0801145c <I2C_MemoryTransmit_TXE_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c)
{
 801145c:	b580      	push	{r7, lr}
 801145e:	b084      	sub	sp, #16
 8011460:	af00      	add	r7, sp, #0
 8011462:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8011464:	687b      	ldr	r3, [r7, #4]
 8011466:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801146a:	73fb      	strb	r3, [r7, #15]

  if (hi2c->EventCount == 0U)
 801146c:	687b      	ldr	r3, [r7, #4]
 801146e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8011470:	2b00      	cmp	r3, #0
 8011472:	d11d      	bne.n	80114b0 <I2C_MemoryTransmit_TXE_BTF+0x54>
  {
    /* If Memory address size is 8Bit */
    if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 8011474:	687b      	ldr	r3, [r7, #4]
 8011476:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8011478:	2b01      	cmp	r3, #1
 801147a:	d10b      	bne.n	8011494 <I2C_MemoryTransmit_TXE_BTF+0x38>
    {
      /* Send Memory Address */
      hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 801147c:	687b      	ldr	r3, [r7, #4]
 801147e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8011480:	b2da      	uxtb	r2, r3
 8011482:	687b      	ldr	r3, [r7, #4]
 8011484:	681b      	ldr	r3, [r3, #0]
 8011486:	611a      	str	r2, [r3, #16]

      hi2c->EventCount += 2U;
 8011488:	687b      	ldr	r3, [r7, #4]
 801148a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 801148c:	1c9a      	adds	r2, r3, #2
 801148e:	687b      	ldr	r3, [r7, #4]
 8011490:	651a      	str	r2, [r3, #80]	@ 0x50
  else
  {
    /* Clear TXE and BTF flags */
    I2C_Flush_DR(hi2c);
  }
}
 8011492:	e077      	b.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
      hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 8011494:	687b      	ldr	r3, [r7, #4]
 8011496:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8011498:	b29b      	uxth	r3, r3
 801149a:	121b      	asrs	r3, r3, #8
 801149c:	b2da      	uxtb	r2, r3
 801149e:	687b      	ldr	r3, [r7, #4]
 80114a0:	681b      	ldr	r3, [r3, #0]
 80114a2:	611a      	str	r2, [r3, #16]
      hi2c->EventCount++;
 80114a4:	687b      	ldr	r3, [r7, #4]
 80114a6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80114a8:	1c5a      	adds	r2, r3, #1
 80114aa:	687b      	ldr	r3, [r7, #4]
 80114ac:	651a      	str	r2, [r3, #80]	@ 0x50
}
 80114ae:	e069      	b.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
  else if (hi2c->EventCount == 1U)
 80114b0:	687b      	ldr	r3, [r7, #4]
 80114b2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80114b4:	2b01      	cmp	r3, #1
 80114b6:	d10b      	bne.n	80114d0 <I2C_MemoryTransmit_TXE_BTF+0x74>
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 80114b8:	687b      	ldr	r3, [r7, #4]
 80114ba:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80114bc:	b2da      	uxtb	r2, r3
 80114be:	687b      	ldr	r3, [r7, #4]
 80114c0:	681b      	ldr	r3, [r3, #0]
 80114c2:	611a      	str	r2, [r3, #16]
    hi2c->EventCount++;
 80114c4:	687b      	ldr	r3, [r7, #4]
 80114c6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80114c8:	1c5a      	adds	r2, r3, #1
 80114ca:	687b      	ldr	r3, [r7, #4]
 80114cc:	651a      	str	r2, [r3, #80]	@ 0x50
}
 80114ce:	e059      	b.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
  else if (hi2c->EventCount == 2U)
 80114d0:	687b      	ldr	r3, [r7, #4]
 80114d2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80114d4:	2b02      	cmp	r3, #2
 80114d6:	d152      	bne.n	801157e <I2C_MemoryTransmit_TXE_BTF+0x122>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX)
 80114d8:	7bfb      	ldrb	r3, [r7, #15]
 80114da:	2b22      	cmp	r3, #34	@ 0x22
 80114dc:	d10d      	bne.n	80114fa <I2C_MemoryTransmit_TXE_BTF+0x9e>
      hi2c->Instance->CR1 |= I2C_CR1_START;
 80114de:	687b      	ldr	r3, [r7, #4]
 80114e0:	681b      	ldr	r3, [r3, #0]
 80114e2:	681a      	ldr	r2, [r3, #0]
 80114e4:	687b      	ldr	r3, [r7, #4]
 80114e6:	681b      	ldr	r3, [r3, #0]
 80114e8:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80114ec:	601a      	str	r2, [r3, #0]
      hi2c->EventCount++;
 80114ee:	687b      	ldr	r3, [r7, #4]
 80114f0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80114f2:	1c5a      	adds	r2, r3, #1
 80114f4:	687b      	ldr	r3, [r7, #4]
 80114f6:	651a      	str	r2, [r3, #80]	@ 0x50
}
 80114f8:	e044      	b.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
    else if ((hi2c->XferCount > 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 80114fa:	687b      	ldr	r3, [r7, #4]
 80114fc:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80114fe:	b29b      	uxth	r3, r3
 8011500:	2b00      	cmp	r3, #0
 8011502:	d015      	beq.n	8011530 <I2C_MemoryTransmit_TXE_BTF+0xd4>
 8011504:	7bfb      	ldrb	r3, [r7, #15]
 8011506:	2b21      	cmp	r3, #33	@ 0x21
 8011508:	d112      	bne.n	8011530 <I2C_MemoryTransmit_TXE_BTF+0xd4>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 801150a:	687b      	ldr	r3, [r7, #4]
 801150c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801150e:	781a      	ldrb	r2, [r3, #0]
 8011510:	687b      	ldr	r3, [r7, #4]
 8011512:	681b      	ldr	r3, [r3, #0]
 8011514:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 8011516:	687b      	ldr	r3, [r7, #4]
 8011518:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801151a:	1c5a      	adds	r2, r3, #1
 801151c:	687b      	ldr	r3, [r7, #4]
 801151e:	625a      	str	r2, [r3, #36]	@ 0x24
      hi2c->XferCount--;
 8011520:	687b      	ldr	r3, [r7, #4]
 8011522:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011524:	b29b      	uxth	r3, r3
 8011526:	3b01      	subs	r3, #1
 8011528:	b29a      	uxth	r2, r3
 801152a:	687b      	ldr	r3, [r7, #4]
 801152c:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 801152e:	e029      	b.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
    else if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 8011530:	687b      	ldr	r3, [r7, #4]
 8011532:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011534:	b29b      	uxth	r3, r3
 8011536:	2b00      	cmp	r3, #0
 8011538:	d124      	bne.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
 801153a:	7bfb      	ldrb	r3, [r7, #15]
 801153c:	2b21      	cmp	r3, #33	@ 0x21
 801153e:	d121      	bne.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8011540:	687b      	ldr	r3, [r7, #4]
 8011542:	681b      	ldr	r3, [r3, #0]
 8011544:	685a      	ldr	r2, [r3, #4]
 8011546:	687b      	ldr	r3, [r7, #4]
 8011548:	681b      	ldr	r3, [r3, #0]
 801154a:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 801154e:	605a      	str	r2, [r3, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8011550:	687b      	ldr	r3, [r7, #4]
 8011552:	681b      	ldr	r3, [r3, #0]
 8011554:	681a      	ldr	r2, [r3, #0]
 8011556:	687b      	ldr	r3, [r7, #4]
 8011558:	681b      	ldr	r3, [r3, #0]
 801155a:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 801155e:	601a      	str	r2, [r3, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8011560:	687b      	ldr	r3, [r7, #4]
 8011562:	2200      	movs	r2, #0
 8011564:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8011566:	687b      	ldr	r3, [r7, #4]
 8011568:	2220      	movs	r2, #32
 801156a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 801156e:	687b      	ldr	r3, [r7, #4]
 8011570:	2200      	movs	r2, #0
 8011572:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      HAL_I2C_MemTxCpltCallback(hi2c);
 8011576:	6878      	ldr	r0, [r7, #4]
 8011578:	f7ff fe1c 	bl	80111b4 <HAL_I2C_MemTxCpltCallback>
}
 801157c:	e002      	b.n	8011584 <I2C_MemoryTransmit_TXE_BTF+0x128>
    I2C_Flush_DR(hi2c);
 801157e:	6878      	ldr	r0, [r7, #4]
 8011580:	f7fe fd75 	bl	801006e <I2C_Flush_DR>
}
 8011584:	bf00      	nop
 8011586:	3710      	adds	r7, #16
 8011588:	46bd      	mov	sp, r7
 801158a:	bd80      	pop	{r7, pc}

0801158c <I2C_MasterReceive_RXNE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
{
 801158c:	b580      	push	{r7, lr}
 801158e:	b084      	sub	sp, #16
 8011590:	af00      	add	r7, sp, #0
 8011592:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8011594:	687b      	ldr	r3, [r7, #4]
 8011596:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801159a:	b2db      	uxtb	r3, r3
 801159c:	2b22      	cmp	r3, #34	@ 0x22
 801159e:	f040 80b9 	bne.w	8011714 <I2C_MasterReceive_RXNE+0x188>
  {
    uint32_t tmp;
    uint32_t CurrentXferOptions;

    CurrentXferOptions = hi2c->XferOptions;
 80115a2:	687b      	ldr	r3, [r7, #4]
 80115a4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80115a6:	60fb      	str	r3, [r7, #12]
    tmp = hi2c->XferCount;
 80115a8:	687b      	ldr	r3, [r7, #4]
 80115aa:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80115ac:	b29b      	uxth	r3, r3
 80115ae:	60bb      	str	r3, [r7, #8]
    if (tmp > 3U)
 80115b0:	68bb      	ldr	r3, [r7, #8]
 80115b2:	2b03      	cmp	r3, #3
 80115b4:	d921      	bls.n	80115fa <I2C_MasterReceive_RXNE+0x6e>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80115b6:	687b      	ldr	r3, [r7, #4]
 80115b8:	681b      	ldr	r3, [r3, #0]
 80115ba:	691a      	ldr	r2, [r3, #16]
 80115bc:	687b      	ldr	r3, [r7, #4]
 80115be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80115c0:	b2d2      	uxtb	r2, r2
 80115c2:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80115c4:	687b      	ldr	r3, [r7, #4]
 80115c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80115c8:	1c5a      	adds	r2, r3, #1
 80115ca:	687b      	ldr	r3, [r7, #4]
 80115cc:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 80115ce:	687b      	ldr	r3, [r7, #4]
 80115d0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80115d2:	b29b      	uxth	r3, r3
 80115d4:	3b01      	subs	r3, #1
 80115d6:	b29a      	uxth	r2, r3
 80115d8:	687b      	ldr	r3, [r7, #4]
 80115da:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if (hi2c->XferCount == (uint16_t)3)
 80115dc:	687b      	ldr	r3, [r7, #4]
 80115de:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80115e0:	b29b      	uxth	r3, r3
 80115e2:	2b03      	cmp	r3, #3
 80115e4:	f040 8096 	bne.w	8011714 <I2C_MasterReceive_RXNE+0x188>
      {
        /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
        on BTF subroutine */
        /* Disable BUF interrupt */
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 80115e8:	687b      	ldr	r3, [r7, #4]
 80115ea:	681b      	ldr	r3, [r3, #0]
 80115ec:	685a      	ldr	r2, [r3, #4]
 80115ee:	687b      	ldr	r3, [r7, #4]
 80115f0:	681b      	ldr	r3, [r3, #0]
 80115f2:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80115f6:	605a      	str	r2, [r3, #4]
      /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
         on BTF subroutine if there is a reception delay between N-1 and N byte */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
    }
  }
}
 80115f8:	e08c      	b.n	8011714 <I2C_MasterReceive_RXNE+0x188>
    else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
 80115fa:	687b      	ldr	r3, [r7, #4]
 80115fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80115fe:	2b02      	cmp	r3, #2
 8011600:	d07f      	beq.n	8011702 <I2C_MasterReceive_RXNE+0x176>
 8011602:	68bb      	ldr	r3, [r7, #8]
 8011604:	2b01      	cmp	r3, #1
 8011606:	d002      	beq.n	801160e <I2C_MasterReceive_RXNE+0x82>
 8011608:	68bb      	ldr	r3, [r7, #8]
 801160a:	2b00      	cmp	r3, #0
 801160c:	d179      	bne.n	8011702 <I2C_MasterReceive_RXNE+0x176>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 801160e:	6878      	ldr	r0, [r7, #4]
 8011610:	f001 fcb6 	bl	8012f80 <I2C_WaitOnSTOPRequestThroughIT>
 8011614:	4603      	mov	r3, r0
 8011616:	2b00      	cmp	r3, #0
 8011618:	d14c      	bne.n	80116b4 <I2C_MasterReceive_RXNE+0x128>
        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 801161a:	687b      	ldr	r3, [r7, #4]
 801161c:	681b      	ldr	r3, [r3, #0]
 801161e:	681a      	ldr	r2, [r3, #0]
 8011620:	687b      	ldr	r3, [r7, #4]
 8011622:	681b      	ldr	r3, [r3, #0]
 8011624:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011628:	601a      	str	r2, [r3, #0]
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 801162a:	687b      	ldr	r3, [r7, #4]
 801162c:	681b      	ldr	r3, [r3, #0]
 801162e:	685a      	ldr	r2, [r3, #4]
 8011630:	687b      	ldr	r3, [r7, #4]
 8011632:	681b      	ldr	r3, [r3, #0]
 8011634:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8011638:	605a      	str	r2, [r3, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 801163a:	687b      	ldr	r3, [r7, #4]
 801163c:	681b      	ldr	r3, [r3, #0]
 801163e:	691a      	ldr	r2, [r3, #16]
 8011640:	687b      	ldr	r3, [r7, #4]
 8011642:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011644:	b2d2      	uxtb	r2, r2
 8011646:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 8011648:	687b      	ldr	r3, [r7, #4]
 801164a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801164c:	1c5a      	adds	r2, r3, #1
 801164e:	687b      	ldr	r3, [r7, #4]
 8011650:	625a      	str	r2, [r3, #36]	@ 0x24
        hi2c->XferCount--;
 8011652:	687b      	ldr	r3, [r7, #4]
 8011654:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011656:	b29b      	uxth	r3, r3
 8011658:	3b01      	subs	r3, #1
 801165a:	b29a      	uxth	r2, r3
 801165c:	687b      	ldr	r3, [r7, #4]
 801165e:	855a      	strh	r2, [r3, #42]	@ 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 8011660:	687b      	ldr	r3, [r7, #4]
 8011662:	2220      	movs	r2, #32
 8011664:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8011668:	687b      	ldr	r3, [r7, #4]
 801166a:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 801166e:	b2db      	uxtb	r3, r3
 8011670:	2b40      	cmp	r3, #64	@ 0x40
 8011672:	d10a      	bne.n	801168a <I2C_MasterReceive_RXNE+0xfe>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8011674:	687b      	ldr	r3, [r7, #4]
 8011676:	2200      	movs	r2, #0
 8011678:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->PreviousState = I2C_STATE_NONE;
 801167c:	687b      	ldr	r3, [r7, #4]
 801167e:	2200      	movs	r2, #0
 8011680:	631a      	str	r2, [r3, #48]	@ 0x30
          HAL_I2C_MemRxCpltCallback(hi2c);
 8011682:	6878      	ldr	r0, [r7, #4]
 8011684:	f7ff fda0 	bl	80111c8 <HAL_I2C_MemRxCpltCallback>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 8011688:	e044      	b.n	8011714 <I2C_MasterReceive_RXNE+0x188>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 801168a:	687b      	ldr	r3, [r7, #4]
 801168c:	2200      	movs	r2, #0
 801168e:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
 8011692:	68fb      	ldr	r3, [r7, #12]
 8011694:	2b08      	cmp	r3, #8
 8011696:	d002      	beq.n	801169e <I2C_MasterReceive_RXNE+0x112>
 8011698:	68fb      	ldr	r3, [r7, #12]
 801169a:	2b20      	cmp	r3, #32
 801169c:	d103      	bne.n	80116a6 <I2C_MasterReceive_RXNE+0x11a>
            hi2c->PreviousState = I2C_STATE_NONE;
 801169e:	687b      	ldr	r3, [r7, #4]
 80116a0:	2200      	movs	r2, #0
 80116a2:	631a      	str	r2, [r3, #48]	@ 0x30
 80116a4:	e002      	b.n	80116ac <I2C_MasterReceive_RXNE+0x120>
            hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80116a6:	687b      	ldr	r3, [r7, #4]
 80116a8:	2212      	movs	r2, #18
 80116aa:	631a      	str	r2, [r3, #48]	@ 0x30
          HAL_I2C_MasterRxCpltCallback(hi2c);
 80116ac:	6878      	ldr	r0, [r7, #4]
 80116ae:	f7ff fd4b 	bl	8011148 <HAL_I2C_MasterRxCpltCallback>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 80116b2:	e02f      	b.n	8011714 <I2C_MasterReceive_RXNE+0x188>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80116b4:	687b      	ldr	r3, [r7, #4]
 80116b6:	681b      	ldr	r3, [r3, #0]
 80116b8:	685a      	ldr	r2, [r3, #4]
 80116ba:	687b      	ldr	r3, [r7, #4]
 80116bc:	681b      	ldr	r3, [r3, #0]
 80116be:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 80116c2:	605a      	str	r2, [r3, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80116c4:	687b      	ldr	r3, [r7, #4]
 80116c6:	681b      	ldr	r3, [r3, #0]
 80116c8:	691a      	ldr	r2, [r3, #16]
 80116ca:	687b      	ldr	r3, [r7, #4]
 80116cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80116ce:	b2d2      	uxtb	r2, r2
 80116d0:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 80116d2:	687b      	ldr	r3, [r7, #4]
 80116d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80116d6:	1c5a      	adds	r2, r3, #1
 80116d8:	687b      	ldr	r3, [r7, #4]
 80116da:	625a      	str	r2, [r3, #36]	@ 0x24
        hi2c->XferCount--;
 80116dc:	687b      	ldr	r3, [r7, #4]
 80116de:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80116e0:	b29b      	uxth	r3, r3
 80116e2:	3b01      	subs	r3, #1
 80116e4:	b29a      	uxth	r2, r3
 80116e6:	687b      	ldr	r3, [r7, #4]
 80116e8:	855a      	strh	r2, [r3, #42]	@ 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 80116ea:	687b      	ldr	r3, [r7, #4]
 80116ec:	2220      	movs	r2, #32
 80116ee:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80116f2:	687b      	ldr	r3, [r7, #4]
 80116f4:	2200      	movs	r2, #0
 80116f6:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        HAL_I2C_ErrorCallback(hi2c);
 80116fa:	6878      	ldr	r0, [r7, #4]
 80116fc:	f7ff fd6e 	bl	80111dc <HAL_I2C_ErrorCallback>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 8011700:	e008      	b.n	8011714 <I2C_MasterReceive_RXNE+0x188>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8011702:	687b      	ldr	r3, [r7, #4]
 8011704:	681b      	ldr	r3, [r3, #0]
 8011706:	685a      	ldr	r2, [r3, #4]
 8011708:	687b      	ldr	r3, [r7, #4]
 801170a:	681b      	ldr	r3, [r3, #0]
 801170c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011710:	605a      	str	r2, [r3, #4]
}
 8011712:	e7ff      	b.n	8011714 <I2C_MasterReceive_RXNE+0x188>
 8011714:	bf00      	nop
 8011716:	3710      	adds	r7, #16
 8011718:	46bd      	mov	sp, r7
 801171a:	bd80      	pop	{r7, pc}

0801171c <I2C_MasterReceive_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
{
 801171c:	b580      	push	{r7, lr}
 801171e:	b084      	sub	sp, #16
 8011720:	af00      	add	r7, sp, #0
 8011722:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8011724:	687b      	ldr	r3, [r7, #4]
 8011726:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011728:	60fb      	str	r3, [r7, #12]

  if (hi2c->XferCount == 4U)
 801172a:	687b      	ldr	r3, [r7, #4]
 801172c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801172e:	b29b      	uxth	r3, r3
 8011730:	2b04      	cmp	r3, #4
 8011732:	d11b      	bne.n	801176c <I2C_MasterReceive_BTF+0x50>
  {
    /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
       on BTF subroutine if there is a reception delay between N-1 and N byte */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8011734:	687b      	ldr	r3, [r7, #4]
 8011736:	681b      	ldr	r3, [r3, #0]
 8011738:	685a      	ldr	r2, [r3, #4]
 801173a:	687b      	ldr	r3, [r7, #4]
 801173c:	681b      	ldr	r3, [r3, #0]
 801173e:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011742:	605a      	str	r2, [r3, #4]

    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8011744:	687b      	ldr	r3, [r7, #4]
 8011746:	681b      	ldr	r3, [r3, #0]
 8011748:	691a      	ldr	r2, [r3, #16]
 801174a:	687b      	ldr	r3, [r7, #4]
 801174c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801174e:	b2d2      	uxtb	r2, r2
 8011750:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8011752:	687b      	ldr	r3, [r7, #4]
 8011754:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011756:	1c5a      	adds	r2, r3, #1
 8011758:	687b      	ldr	r3, [r7, #4]
 801175a:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 801175c:	687b      	ldr	r3, [r7, #4]
 801175e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011760:	b29b      	uxth	r3, r3
 8011762:	3b01      	subs	r3, #1
 8011764:	b29a      	uxth	r2, r3
 8011766:	687b      	ldr	r3, [r7, #4]
 8011768:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->pBuffPtr++;

    /* Update counter */
    hi2c->XferCount--;
  }
}
 801176a:	e0c8      	b.n	80118fe <I2C_MasterReceive_BTF+0x1e2>
  else if (hi2c->XferCount == 3U)
 801176c:	687b      	ldr	r3, [r7, #4]
 801176e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011770:	b29b      	uxth	r3, r3
 8011772:	2b03      	cmp	r3, #3
 8011774:	d129      	bne.n	80117ca <I2C_MasterReceive_BTF+0xae>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8011776:	687b      	ldr	r3, [r7, #4]
 8011778:	681b      	ldr	r3, [r3, #0]
 801177a:	685a      	ldr	r2, [r3, #4]
 801177c:	687b      	ldr	r3, [r7, #4]
 801177e:	681b      	ldr	r3, [r3, #0]
 8011780:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011784:	605a      	str	r2, [r3, #4]
    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
 8011786:	68fb      	ldr	r3, [r7, #12]
 8011788:	2b04      	cmp	r3, #4
 801178a:	d00a      	beq.n	80117a2 <I2C_MasterReceive_BTF+0x86>
 801178c:	68fb      	ldr	r3, [r7, #12]
 801178e:	2b02      	cmp	r3, #2
 8011790:	d007      	beq.n	80117a2 <I2C_MasterReceive_BTF+0x86>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011792:	687b      	ldr	r3, [r7, #4]
 8011794:	681b      	ldr	r3, [r3, #0]
 8011796:	681a      	ldr	r2, [r3, #0]
 8011798:	687b      	ldr	r3, [r7, #4]
 801179a:	681b      	ldr	r3, [r3, #0]
 801179c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80117a0:	601a      	str	r2, [r3, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80117a2:	687b      	ldr	r3, [r7, #4]
 80117a4:	681b      	ldr	r3, [r3, #0]
 80117a6:	691a      	ldr	r2, [r3, #16]
 80117a8:	687b      	ldr	r3, [r7, #4]
 80117aa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80117ac:	b2d2      	uxtb	r2, r2
 80117ae:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 80117b0:	687b      	ldr	r3, [r7, #4]
 80117b2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80117b4:	1c5a      	adds	r2, r3, #1
 80117b6:	687b      	ldr	r3, [r7, #4]
 80117b8:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 80117ba:	687b      	ldr	r3, [r7, #4]
 80117bc:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80117be:	b29b      	uxth	r3, r3
 80117c0:	3b01      	subs	r3, #1
 80117c2:	b29a      	uxth	r2, r3
 80117c4:	687b      	ldr	r3, [r7, #4]
 80117c6:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 80117c8:	e099      	b.n	80118fe <I2C_MasterReceive_BTF+0x1e2>
  else if (hi2c->XferCount == 2U)
 80117ca:	687b      	ldr	r3, [r7, #4]
 80117cc:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80117ce:	b29b      	uxth	r3, r3
 80117d0:	2b02      	cmp	r3, #2
 80117d2:	f040 8081 	bne.w	80118d8 <I2C_MasterReceive_BTF+0x1bc>
    if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
 80117d6:	68fb      	ldr	r3, [r7, #12]
 80117d8:	2b01      	cmp	r3, #1
 80117da:	d002      	beq.n	80117e2 <I2C_MasterReceive_BTF+0xc6>
 80117dc:	68fb      	ldr	r3, [r7, #12]
 80117de:	2b10      	cmp	r3, #16
 80117e0:	d108      	bne.n	80117f4 <I2C_MasterReceive_BTF+0xd8>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80117e2:	687b      	ldr	r3, [r7, #4]
 80117e4:	681b      	ldr	r3, [r3, #0]
 80117e6:	681a      	ldr	r2, [r3, #0]
 80117e8:	687b      	ldr	r3, [r7, #4]
 80117ea:	681b      	ldr	r3, [r3, #0]
 80117ec:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80117f0:	601a      	str	r2, [r3, #0]
 80117f2:	e019      	b.n	8011828 <I2C_MasterReceive_BTF+0x10c>
    else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
 80117f4:	68fb      	ldr	r3, [r7, #12]
 80117f6:	2b04      	cmp	r3, #4
 80117f8:	d002      	beq.n	8011800 <I2C_MasterReceive_BTF+0xe4>
 80117fa:	68fb      	ldr	r3, [r7, #12]
 80117fc:	2b02      	cmp	r3, #2
 80117fe:	d108      	bne.n	8011812 <I2C_MasterReceive_BTF+0xf6>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011800:	687b      	ldr	r3, [r7, #4]
 8011802:	681b      	ldr	r3, [r3, #0]
 8011804:	681a      	ldr	r2, [r3, #0]
 8011806:	687b      	ldr	r3, [r7, #4]
 8011808:	681b      	ldr	r3, [r3, #0]
 801180a:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 801180e:	601a      	str	r2, [r3, #0]
 8011810:	e00a      	b.n	8011828 <I2C_MasterReceive_BTF+0x10c>
    else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
 8011812:	68fb      	ldr	r3, [r7, #12]
 8011814:	2b10      	cmp	r3, #16
 8011816:	d007      	beq.n	8011828 <I2C_MasterReceive_BTF+0x10c>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8011818:	687b      	ldr	r3, [r7, #4]
 801181a:	681b      	ldr	r3, [r3, #0]
 801181c:	681a      	ldr	r2, [r3, #0]
 801181e:	687b      	ldr	r3, [r7, #4]
 8011820:	681b      	ldr	r3, [r3, #0]
 8011822:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8011826:	601a      	str	r2, [r3, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8011828:	687b      	ldr	r3, [r7, #4]
 801182a:	681b      	ldr	r3, [r3, #0]
 801182c:	691a      	ldr	r2, [r3, #16]
 801182e:	687b      	ldr	r3, [r7, #4]
 8011830:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011832:	b2d2      	uxtb	r2, r2
 8011834:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8011836:	687b      	ldr	r3, [r7, #4]
 8011838:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801183a:	1c5a      	adds	r2, r3, #1
 801183c:	687b      	ldr	r3, [r7, #4]
 801183e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 8011840:	687b      	ldr	r3, [r7, #4]
 8011842:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011844:	b29b      	uxth	r3, r3
 8011846:	3b01      	subs	r3, #1
 8011848:	b29a      	uxth	r2, r3
 801184a:	687b      	ldr	r3, [r7, #4]
 801184c:	855a      	strh	r2, [r3, #42]	@ 0x2a
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 801184e:	687b      	ldr	r3, [r7, #4]
 8011850:	681b      	ldr	r3, [r3, #0]
 8011852:	691a      	ldr	r2, [r3, #16]
 8011854:	687b      	ldr	r3, [r7, #4]
 8011856:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011858:	b2d2      	uxtb	r2, r2
 801185a:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 801185c:	687b      	ldr	r3, [r7, #4]
 801185e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011860:	1c5a      	adds	r2, r3, #1
 8011862:	687b      	ldr	r3, [r7, #4]
 8011864:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 8011866:	687b      	ldr	r3, [r7, #4]
 8011868:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801186a:	b29b      	uxth	r3, r3
 801186c:	3b01      	subs	r3, #1
 801186e:	b29a      	uxth	r2, r3
 8011870:	687b      	ldr	r3, [r7, #4]
 8011872:	855a      	strh	r2, [r3, #42]	@ 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 8011874:	687b      	ldr	r3, [r7, #4]
 8011876:	681b      	ldr	r3, [r3, #0]
 8011878:	685a      	ldr	r2, [r3, #4]
 801187a:	687b      	ldr	r3, [r7, #4]
 801187c:	681b      	ldr	r3, [r3, #0]
 801187e:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8011882:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8011884:	687b      	ldr	r3, [r7, #4]
 8011886:	2220      	movs	r2, #32
 8011888:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 801188c:	687b      	ldr	r3, [r7, #4]
 801188e:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8011892:	b2db      	uxtb	r3, r3
 8011894:	2b40      	cmp	r3, #64	@ 0x40
 8011896:	d10a      	bne.n	80118ae <I2C_MasterReceive_BTF+0x192>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8011898:	687b      	ldr	r3, [r7, #4]
 801189a:	2200      	movs	r2, #0
 801189c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->PreviousState = I2C_STATE_NONE;
 80118a0:	687b      	ldr	r3, [r7, #4]
 80118a2:	2200      	movs	r2, #0
 80118a4:	631a      	str	r2, [r3, #48]	@ 0x30
      HAL_I2C_MemRxCpltCallback(hi2c);
 80118a6:	6878      	ldr	r0, [r7, #4]
 80118a8:	f7ff fc8e 	bl	80111c8 <HAL_I2C_MemRxCpltCallback>
}
 80118ac:	e027      	b.n	80118fe <I2C_MasterReceive_BTF+0x1e2>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80118ae:	687b      	ldr	r3, [r7, #4]
 80118b0:	2200      	movs	r2, #0
 80118b2:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
 80118b6:	68fb      	ldr	r3, [r7, #12]
 80118b8:	2b08      	cmp	r3, #8
 80118ba:	d002      	beq.n	80118c2 <I2C_MasterReceive_BTF+0x1a6>
 80118bc:	68fb      	ldr	r3, [r7, #12]
 80118be:	2b20      	cmp	r3, #32
 80118c0:	d103      	bne.n	80118ca <I2C_MasterReceive_BTF+0x1ae>
        hi2c->PreviousState = I2C_STATE_NONE;
 80118c2:	687b      	ldr	r3, [r7, #4]
 80118c4:	2200      	movs	r2, #0
 80118c6:	631a      	str	r2, [r3, #48]	@ 0x30
 80118c8:	e002      	b.n	80118d0 <I2C_MasterReceive_BTF+0x1b4>
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80118ca:	687b      	ldr	r3, [r7, #4]
 80118cc:	2212      	movs	r2, #18
 80118ce:	631a      	str	r2, [r3, #48]	@ 0x30
      HAL_I2C_MasterRxCpltCallback(hi2c);
 80118d0:	6878      	ldr	r0, [r7, #4]
 80118d2:	f7ff fc39 	bl	8011148 <HAL_I2C_MasterRxCpltCallback>
}
 80118d6:	e012      	b.n	80118fe <I2C_MasterReceive_BTF+0x1e2>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80118d8:	687b      	ldr	r3, [r7, #4]
 80118da:	681b      	ldr	r3, [r3, #0]
 80118dc:	691a      	ldr	r2, [r3, #16]
 80118de:	687b      	ldr	r3, [r7, #4]
 80118e0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80118e2:	b2d2      	uxtb	r2, r2
 80118e4:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 80118e6:	687b      	ldr	r3, [r7, #4]
 80118e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80118ea:	1c5a      	adds	r2, r3, #1
 80118ec:	687b      	ldr	r3, [r7, #4]
 80118ee:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 80118f0:	687b      	ldr	r3, [r7, #4]
 80118f2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80118f4:	b29b      	uxth	r3, r3
 80118f6:	3b01      	subs	r3, #1
 80118f8:	b29a      	uxth	r2, r3
 80118fa:	687b      	ldr	r3, [r7, #4]
 80118fc:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 80118fe:	bf00      	nop
 8011900:	3710      	adds	r7, #16
 8011902:	46bd      	mov	sp, r7
 8011904:	bd80      	pop	{r7, pc}

08011906 <I2C_Master_SB>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
{
 8011906:	b480      	push	{r7}
 8011908:	b083      	sub	sp, #12
 801190a:	af00      	add	r7, sp, #0
 801190c:	6078      	str	r0, [r7, #4]
  if (hi2c->Mode == HAL_I2C_MODE_MEM)
 801190e:	687b      	ldr	r3, [r7, #4]
 8011910:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8011914:	b2db      	uxtb	r3, r3
 8011916:	2b40      	cmp	r3, #64	@ 0x40
 8011918:	d117      	bne.n	801194a <I2C_Master_SB+0x44>
  {
    if (hi2c->EventCount == 0U)
 801191a:	687b      	ldr	r3, [r7, #4]
 801191c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 801191e:	2b00      	cmp	r3, #0
 8011920:	d109      	bne.n	8011936 <I2C_Master_SB+0x30>
    {
      /* Send slave address */
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8011922:	687b      	ldr	r3, [r7, #4]
 8011924:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011926:	b2db      	uxtb	r3, r3
 8011928:	461a      	mov	r2, r3
 801192a:	687b      	ldr	r3, [r7, #4]
 801192c:	681b      	ldr	r3, [r3, #0]
 801192e:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 8011932:	611a      	str	r2, [r3, #16]
      {
        /* Do nothing */
      }
    }
  }
}
 8011934:	e067      	b.n	8011a06 <I2C_Master_SB+0x100>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8011936:	687b      	ldr	r3, [r7, #4]
 8011938:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801193a:	b2db      	uxtb	r3, r3
 801193c:	f043 0301 	orr.w	r3, r3, #1
 8011940:	b2da      	uxtb	r2, r3
 8011942:	687b      	ldr	r3, [r7, #4]
 8011944:	681b      	ldr	r3, [r3, #0]
 8011946:	611a      	str	r2, [r3, #16]
}
 8011948:	e05d      	b.n	8011a06 <I2C_Master_SB+0x100>
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 801194a:	687b      	ldr	r3, [r7, #4]
 801194c:	691b      	ldr	r3, [r3, #16]
 801194e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8011952:	d133      	bne.n	80119bc <I2C_Master_SB+0xb6>
      if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8011954:	687b      	ldr	r3, [r7, #4]
 8011956:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801195a:	b2db      	uxtb	r3, r3
 801195c:	2b21      	cmp	r3, #33	@ 0x21
 801195e:	d109      	bne.n	8011974 <I2C_Master_SB+0x6e>
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8011960:	687b      	ldr	r3, [r7, #4]
 8011962:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011964:	b2db      	uxtb	r3, r3
 8011966:	461a      	mov	r2, r3
 8011968:	687b      	ldr	r3, [r7, #4]
 801196a:	681b      	ldr	r3, [r3, #0]
 801196c:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 8011970:	611a      	str	r2, [r3, #16]
 8011972:	e008      	b.n	8011986 <I2C_Master_SB+0x80>
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8011974:	687b      	ldr	r3, [r7, #4]
 8011976:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011978:	b2db      	uxtb	r3, r3
 801197a:	f043 0301 	orr.w	r3, r3, #1
 801197e:	b2da      	uxtb	r2, r3
 8011980:	687b      	ldr	r3, [r7, #4]
 8011982:	681b      	ldr	r3, [r3, #0]
 8011984:	611a      	str	r2, [r3, #16]
      if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
 8011986:	687b      	ldr	r3, [r7, #4]
 8011988:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801198a:	2b00      	cmp	r3, #0
 801198c:	d004      	beq.n	8011998 <I2C_Master_SB+0x92>
 801198e:	687b      	ldr	r3, [r7, #4]
 8011990:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011992:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011994:	2b00      	cmp	r3, #0
 8011996:	d108      	bne.n	80119aa <I2C_Master_SB+0xa4>
          || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
 8011998:	687b      	ldr	r3, [r7, #4]
 801199a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801199c:	2b00      	cmp	r3, #0
 801199e:	d032      	beq.n	8011a06 <I2C_Master_SB+0x100>
 80119a0:	687b      	ldr	r3, [r7, #4]
 80119a2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80119a4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80119a6:	2b00      	cmp	r3, #0
 80119a8:	d02d      	beq.n	8011a06 <I2C_Master_SB+0x100>
        SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 80119aa:	687b      	ldr	r3, [r7, #4]
 80119ac:	681b      	ldr	r3, [r3, #0]
 80119ae:	685a      	ldr	r2, [r3, #4]
 80119b0:	687b      	ldr	r3, [r7, #4]
 80119b2:	681b      	ldr	r3, [r3, #0]
 80119b4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80119b8:	605a      	str	r2, [r3, #4]
}
 80119ba:	e024      	b.n	8011a06 <I2C_Master_SB+0x100>
      if (hi2c->EventCount == 0U)
 80119bc:	687b      	ldr	r3, [r7, #4]
 80119be:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80119c0:	2b00      	cmp	r3, #0
 80119c2:	d10e      	bne.n	80119e2 <I2C_Master_SB+0xdc>
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 80119c4:	687b      	ldr	r3, [r7, #4]
 80119c6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80119c8:	b29b      	uxth	r3, r3
 80119ca:	11db      	asrs	r3, r3, #7
 80119cc:	b2db      	uxtb	r3, r3
 80119ce:	f003 0306 	and.w	r3, r3, #6
 80119d2:	b2db      	uxtb	r3, r3
 80119d4:	f063 030f 	orn	r3, r3, #15
 80119d8:	b2da      	uxtb	r2, r3
 80119da:	687b      	ldr	r3, [r7, #4]
 80119dc:	681b      	ldr	r3, [r3, #0]
 80119de:	611a      	str	r2, [r3, #16]
}
 80119e0:	e011      	b.n	8011a06 <I2C_Master_SB+0x100>
      else if (hi2c->EventCount == 1U)
 80119e2:	687b      	ldr	r3, [r7, #4]
 80119e4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80119e6:	2b01      	cmp	r3, #1
 80119e8:	d10d      	bne.n	8011a06 <I2C_Master_SB+0x100>
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 80119ea:	687b      	ldr	r3, [r7, #4]
 80119ec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80119ee:	b29b      	uxth	r3, r3
 80119f0:	11db      	asrs	r3, r3, #7
 80119f2:	b2db      	uxtb	r3, r3
 80119f4:	f003 0306 	and.w	r3, r3, #6
 80119f8:	b2db      	uxtb	r3, r3
 80119fa:	f063 030e 	orn	r3, r3, #14
 80119fe:	b2da      	uxtb	r2, r3
 8011a00:	687b      	ldr	r3, [r7, #4]
 8011a02:	681b      	ldr	r3, [r3, #0]
 8011a04:	611a      	str	r2, [r3, #16]
}
 8011a06:	bf00      	nop
 8011a08:	370c      	adds	r7, #12
 8011a0a:	46bd      	mov	sp, r7
 8011a0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a10:	4770      	bx	lr

08011a12 <I2C_Master_ADD10>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
{
 8011a12:	b480      	push	{r7}
 8011a14:	b083      	sub	sp, #12
 8011a16:	af00      	add	r7, sp, #0
 8011a18:	6078      	str	r0, [r7, #4]
  /* Send slave address */
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 8011a1a:	687b      	ldr	r3, [r7, #4]
 8011a1c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011a1e:	b2da      	uxtb	r2, r3
 8011a20:	687b      	ldr	r3, [r7, #4]
 8011a22:	681b      	ldr	r3, [r3, #0]
 8011a24:	611a      	str	r2, [r3, #16]

  if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
 8011a26:	687b      	ldr	r3, [r7, #4]
 8011a28:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011a2a:	2b00      	cmp	r3, #0
 8011a2c:	d004      	beq.n	8011a38 <I2C_Master_ADD10+0x26>
 8011a2e:	687b      	ldr	r3, [r7, #4]
 8011a30:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011a32:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011a34:	2b00      	cmp	r3, #0
 8011a36:	d108      	bne.n	8011a4a <I2C_Master_ADD10+0x38>
      || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
 8011a38:	687b      	ldr	r3, [r7, #4]
 8011a3a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011a3c:	2b00      	cmp	r3, #0
 8011a3e:	d00c      	beq.n	8011a5a <I2C_Master_ADD10+0x48>
 8011a40:	687b      	ldr	r3, [r7, #4]
 8011a42:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011a44:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8011a46:	2b00      	cmp	r3, #0
 8011a48:	d007      	beq.n	8011a5a <I2C_Master_ADD10+0x48>
  {
    /* Enable DMA Request */
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8011a4a:	687b      	ldr	r3, [r7, #4]
 8011a4c:	681b      	ldr	r3, [r3, #0]
 8011a4e:	685a      	ldr	r2, [r3, #4]
 8011a50:	687b      	ldr	r3, [r7, #4]
 8011a52:	681b      	ldr	r3, [r3, #0]
 8011a54:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8011a58:	605a      	str	r2, [r3, #4]
  }
}
 8011a5a:	bf00      	nop
 8011a5c:	370c      	adds	r7, #12
 8011a5e:	46bd      	mov	sp, r7
 8011a60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011a64:	4770      	bx	lr

08011a66 <I2C_Master_ADDR>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
{
 8011a66:	b480      	push	{r7}
 8011a68:	b091      	sub	sp, #68	@ 0x44
 8011a6a:	af00      	add	r7, sp, #0
 8011a6c:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
 8011a6e:	687b      	ldr	r3, [r7, #4]
 8011a70:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 8011a74:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
  uint32_t CurrentXferOptions           = hi2c->XferOptions;
 8011a78:	687b      	ldr	r3, [r7, #4]
 8011a7a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011a7c:	63bb      	str	r3, [r7, #56]	@ 0x38
  uint32_t Prev_State                   = hi2c->PreviousState;
 8011a7e:	687b      	ldr	r3, [r7, #4]
 8011a80:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011a82:	637b      	str	r3, [r7, #52]	@ 0x34

  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8011a84:	687b      	ldr	r3, [r7, #4]
 8011a86:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011a8a:	b2db      	uxtb	r3, r3
 8011a8c:	2b22      	cmp	r3, #34	@ 0x22
 8011a8e:	f040 8169 	bne.w	8011d64 <I2C_Master_ADDR+0x2fe>
  {
    if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 8011a92:	687b      	ldr	r3, [r7, #4]
 8011a94:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8011a96:	2b00      	cmp	r3, #0
 8011a98:	d10f      	bne.n	8011aba <I2C_Master_ADDR+0x54>
 8011a9a:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 8011a9e:	2b40      	cmp	r3, #64	@ 0x40
 8011aa0:	d10b      	bne.n	8011aba <I2C_Master_ADDR+0x54>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011aa2:	2300      	movs	r3, #0
 8011aa4:	633b      	str	r3, [r7, #48]	@ 0x30
 8011aa6:	687b      	ldr	r3, [r7, #4]
 8011aa8:	681b      	ldr	r3, [r3, #0]
 8011aaa:	695b      	ldr	r3, [r3, #20]
 8011aac:	633b      	str	r3, [r7, #48]	@ 0x30
 8011aae:	687b      	ldr	r3, [r7, #4]
 8011ab0:	681b      	ldr	r3, [r3, #0]
 8011ab2:	699b      	ldr	r3, [r3, #24]
 8011ab4:	633b      	str	r3, [r7, #48]	@ 0x30
 8011ab6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011ab8:	e160      	b.n	8011d7c <I2C_Master_ADDR+0x316>
    }
    else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 8011aba:	687b      	ldr	r3, [r7, #4]
 8011abc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8011abe:	2b00      	cmp	r3, #0
 8011ac0:	d11d      	bne.n	8011afe <I2C_Master_ADDR+0x98>
 8011ac2:	687b      	ldr	r3, [r7, #4]
 8011ac4:	691b      	ldr	r3, [r3, #16]
 8011ac6:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 8011aca:	d118      	bne.n	8011afe <I2C_Master_ADDR+0x98>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011acc:	2300      	movs	r3, #0
 8011ace:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011ad0:	687b      	ldr	r3, [r7, #4]
 8011ad2:	681b      	ldr	r3, [r3, #0]
 8011ad4:	695b      	ldr	r3, [r3, #20]
 8011ad6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011ad8:	687b      	ldr	r3, [r7, #4]
 8011ada:	681b      	ldr	r3, [r3, #0]
 8011adc:	699b      	ldr	r3, [r3, #24]
 8011ade:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011ae0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c

      /* Generate Restart */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8011ae2:	687b      	ldr	r3, [r7, #4]
 8011ae4:	681b      	ldr	r3, [r3, #0]
 8011ae6:	681a      	ldr	r2, [r3, #0]
 8011ae8:	687b      	ldr	r3, [r7, #4]
 8011aea:	681b      	ldr	r3, [r3, #0]
 8011aec:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8011af0:	601a      	str	r2, [r3, #0]

      hi2c->EventCount++;
 8011af2:	687b      	ldr	r3, [r7, #4]
 8011af4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8011af6:	1c5a      	adds	r2, r3, #1
 8011af8:	687b      	ldr	r3, [r7, #4]
 8011afa:	651a      	str	r2, [r3, #80]	@ 0x50
 8011afc:	e13e      	b.n	8011d7c <I2C_Master_ADDR+0x316>
    }
    else
    {
      if (hi2c->XferCount == 0U)
 8011afe:	687b      	ldr	r3, [r7, #4]
 8011b00:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011b02:	b29b      	uxth	r3, r3
 8011b04:	2b00      	cmp	r3, #0
 8011b06:	d113      	bne.n	8011b30 <I2C_Master_ADDR+0xca>
      {
        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011b08:	2300      	movs	r3, #0
 8011b0a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011b0c:	687b      	ldr	r3, [r7, #4]
 8011b0e:	681b      	ldr	r3, [r3, #0]
 8011b10:	695b      	ldr	r3, [r3, #20]
 8011b12:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011b14:	687b      	ldr	r3, [r7, #4]
 8011b16:	681b      	ldr	r3, [r3, #0]
 8011b18:	699b      	ldr	r3, [r3, #24]
 8011b1a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011b1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28

        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8011b1e:	687b      	ldr	r3, [r7, #4]
 8011b20:	681b      	ldr	r3, [r3, #0]
 8011b22:	681a      	ldr	r2, [r3, #0]
 8011b24:	687b      	ldr	r3, [r7, #4]
 8011b26:	681b      	ldr	r3, [r3, #0]
 8011b28:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8011b2c:	601a      	str	r2, [r3, #0]
 8011b2e:	e115      	b.n	8011d5c <I2C_Master_ADDR+0x2f6>
      }
      else if (hi2c->XferCount == 1U)
 8011b30:	687b      	ldr	r3, [r7, #4]
 8011b32:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011b34:	b29b      	uxth	r3, r3
 8011b36:	2b01      	cmp	r3, #1
 8011b38:	f040 808a 	bne.w	8011c50 <I2C_Master_ADDR+0x1ea>
      {
        if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
 8011b3c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011b3e:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 8011b42:	d137      	bne.n	8011bb4 <I2C_Master_ADDR+0x14e>
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011b44:	687b      	ldr	r3, [r7, #4]
 8011b46:	681b      	ldr	r3, [r3, #0]
 8011b48:	681a      	ldr	r2, [r3, #0]
 8011b4a:	687b      	ldr	r3, [r7, #4]
 8011b4c:	681b      	ldr	r3, [r3, #0]
 8011b4e:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011b52:	601a      	str	r2, [r3, #0]

          if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8011b54:	687b      	ldr	r3, [r7, #4]
 8011b56:	681b      	ldr	r3, [r3, #0]
 8011b58:	685b      	ldr	r3, [r3, #4]
 8011b5a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8011b5e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8011b62:	d113      	bne.n	8011b8c <I2C_Master_ADDR+0x126>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011b64:	687b      	ldr	r3, [r7, #4]
 8011b66:	681b      	ldr	r3, [r3, #0]
 8011b68:	681a      	ldr	r2, [r3, #0]
 8011b6a:	687b      	ldr	r3, [r7, #4]
 8011b6c:	681b      	ldr	r3, [r3, #0]
 8011b6e:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011b72:	601a      	str	r2, [r3, #0]

            /* Clear ADDR flag */
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011b74:	2300      	movs	r3, #0
 8011b76:	627b      	str	r3, [r7, #36]	@ 0x24
 8011b78:	687b      	ldr	r3, [r7, #4]
 8011b7a:	681b      	ldr	r3, [r3, #0]
 8011b7c:	695b      	ldr	r3, [r3, #20]
 8011b7e:	627b      	str	r3, [r7, #36]	@ 0x24
 8011b80:	687b      	ldr	r3, [r7, #4]
 8011b82:	681b      	ldr	r3, [r3, #0]
 8011b84:	699b      	ldr	r3, [r3, #24]
 8011b86:	627b      	str	r3, [r7, #36]	@ 0x24
 8011b88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011b8a:	e0e7      	b.n	8011d5c <I2C_Master_ADDR+0x2f6>
          }
          else
          {
            /* Clear ADDR flag */
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011b8c:	2300      	movs	r3, #0
 8011b8e:	623b      	str	r3, [r7, #32]
 8011b90:	687b      	ldr	r3, [r7, #4]
 8011b92:	681b      	ldr	r3, [r3, #0]
 8011b94:	695b      	ldr	r3, [r3, #20]
 8011b96:	623b      	str	r3, [r7, #32]
 8011b98:	687b      	ldr	r3, [r7, #4]
 8011b9a:	681b      	ldr	r3, [r3, #0]
 8011b9c:	699b      	ldr	r3, [r3, #24]
 8011b9e:	623b      	str	r3, [r7, #32]
 8011ba0:	6a3b      	ldr	r3, [r7, #32]

            /* Generate Stop */
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8011ba2:	687b      	ldr	r3, [r7, #4]
 8011ba4:	681b      	ldr	r3, [r3, #0]
 8011ba6:	681a      	ldr	r2, [r3, #0]
 8011ba8:	687b      	ldr	r3, [r7, #4]
 8011baa:	681b      	ldr	r3, [r3, #0]
 8011bac:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8011bb0:	601a      	str	r2, [r3, #0]
 8011bb2:	e0d3      	b.n	8011d5c <I2C_Master_ADDR+0x2f6>
          }
        }
        /* Prepare next transfer or stop current transfer */
        else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 8011bb4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bb6:	2b08      	cmp	r3, #8
 8011bb8:	d02e      	beq.n	8011c18 <I2C_Master_ADDR+0x1b2>
 8011bba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bbc:	2b20      	cmp	r3, #32
 8011bbe:	d02b      	beq.n	8011c18 <I2C_Master_ADDR+0x1b2>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 8011bc0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011bc2:	2b12      	cmp	r3, #18
 8011bc4:	d102      	bne.n	8011bcc <I2C_Master_ADDR+0x166>
 8011bc6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bc8:	2b01      	cmp	r3, #1
 8011bca:	d125      	bne.n	8011c18 <I2C_Master_ADDR+0x1b2>
        {
          if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 8011bcc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bce:	2b04      	cmp	r3, #4
 8011bd0:	d00e      	beq.n	8011bf0 <I2C_Master_ADDR+0x18a>
 8011bd2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bd4:	2b02      	cmp	r3, #2
 8011bd6:	d00b      	beq.n	8011bf0 <I2C_Master_ADDR+0x18a>
 8011bd8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bda:	2b10      	cmp	r3, #16
 8011bdc:	d008      	beq.n	8011bf0 <I2C_Master_ADDR+0x18a>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011bde:	687b      	ldr	r3, [r7, #4]
 8011be0:	681b      	ldr	r3, [r3, #0]
 8011be2:	681a      	ldr	r2, [r3, #0]
 8011be4:	687b      	ldr	r3, [r7, #4]
 8011be6:	681b      	ldr	r3, [r3, #0]
 8011be8:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011bec:	601a      	str	r2, [r3, #0]
 8011bee:	e007      	b.n	8011c00 <I2C_Master_ADDR+0x19a>
          }
          else
          {
            /* Enable Acknowledge */
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011bf0:	687b      	ldr	r3, [r7, #4]
 8011bf2:	681b      	ldr	r3, [r3, #0]
 8011bf4:	681a      	ldr	r2, [r3, #0]
 8011bf6:	687b      	ldr	r3, [r7, #4]
 8011bf8:	681b      	ldr	r3, [r3, #0]
 8011bfa:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8011bfe:	601a      	str	r2, [r3, #0]
          }

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011c00:	2300      	movs	r3, #0
 8011c02:	61fb      	str	r3, [r7, #28]
 8011c04:	687b      	ldr	r3, [r7, #4]
 8011c06:	681b      	ldr	r3, [r3, #0]
 8011c08:	695b      	ldr	r3, [r3, #20]
 8011c0a:	61fb      	str	r3, [r7, #28]
 8011c0c:	687b      	ldr	r3, [r7, #4]
 8011c0e:	681b      	ldr	r3, [r3, #0]
 8011c10:	699b      	ldr	r3, [r3, #24]
 8011c12:	61fb      	str	r3, [r7, #28]
 8011c14:	69fb      	ldr	r3, [r7, #28]
 8011c16:	e0a1      	b.n	8011d5c <I2C_Master_ADDR+0x2f6>
        }
        else
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011c18:	687b      	ldr	r3, [r7, #4]
 8011c1a:	681b      	ldr	r3, [r3, #0]
 8011c1c:	681a      	ldr	r2, [r3, #0]
 8011c1e:	687b      	ldr	r3, [r7, #4]
 8011c20:	681b      	ldr	r3, [r3, #0]
 8011c22:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011c26:	601a      	str	r2, [r3, #0]

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011c28:	2300      	movs	r3, #0
 8011c2a:	61bb      	str	r3, [r7, #24]
 8011c2c:	687b      	ldr	r3, [r7, #4]
 8011c2e:	681b      	ldr	r3, [r3, #0]
 8011c30:	695b      	ldr	r3, [r3, #20]
 8011c32:	61bb      	str	r3, [r7, #24]
 8011c34:	687b      	ldr	r3, [r7, #4]
 8011c36:	681b      	ldr	r3, [r3, #0]
 8011c38:	699b      	ldr	r3, [r3, #24]
 8011c3a:	61bb      	str	r3, [r7, #24]
 8011c3c:	69bb      	ldr	r3, [r7, #24]

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8011c3e:	687b      	ldr	r3, [r7, #4]
 8011c40:	681b      	ldr	r3, [r3, #0]
 8011c42:	681a      	ldr	r2, [r3, #0]
 8011c44:	687b      	ldr	r3, [r7, #4]
 8011c46:	681b      	ldr	r3, [r3, #0]
 8011c48:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8011c4c:	601a      	str	r2, [r3, #0]
 8011c4e:	e085      	b.n	8011d5c <I2C_Master_ADDR+0x2f6>
        }
      }
      else if (hi2c->XferCount == 2U)
 8011c50:	687b      	ldr	r3, [r7, #4]
 8011c52:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011c54:	b29b      	uxth	r3, r3
 8011c56:	2b02      	cmp	r3, #2
 8011c58:	d14d      	bne.n	8011cf6 <I2C_Master_ADDR+0x290>
      {
        if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 8011c5a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011c5c:	2b04      	cmp	r3, #4
 8011c5e:	d016      	beq.n	8011c8e <I2C_Master_ADDR+0x228>
 8011c60:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011c62:	2b02      	cmp	r3, #2
 8011c64:	d013      	beq.n	8011c8e <I2C_Master_ADDR+0x228>
 8011c66:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011c68:	2b10      	cmp	r3, #16
 8011c6a:	d010      	beq.n	8011c8e <I2C_Master_ADDR+0x228>
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011c6c:	687b      	ldr	r3, [r7, #4]
 8011c6e:	681b      	ldr	r3, [r3, #0]
 8011c70:	681a      	ldr	r2, [r3, #0]
 8011c72:	687b      	ldr	r3, [r7, #4]
 8011c74:	681b      	ldr	r3, [r3, #0]
 8011c76:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011c7a:	601a      	str	r2, [r3, #0]

          /* Enable Pos */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8011c7c:	687b      	ldr	r3, [r7, #4]
 8011c7e:	681b      	ldr	r3, [r3, #0]
 8011c80:	681a      	ldr	r2, [r3, #0]
 8011c82:	687b      	ldr	r3, [r7, #4]
 8011c84:	681b      	ldr	r3, [r3, #0]
 8011c86:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8011c8a:	601a      	str	r2, [r3, #0]
 8011c8c:	e007      	b.n	8011c9e <I2C_Master_ADDR+0x238>
        }
        else
        {
          /* Enable Acknowledge */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011c8e:	687b      	ldr	r3, [r7, #4]
 8011c90:	681b      	ldr	r3, [r3, #0]
 8011c92:	681a      	ldr	r2, [r3, #0]
 8011c94:	687b      	ldr	r3, [r7, #4]
 8011c96:	681b      	ldr	r3, [r3, #0]
 8011c98:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8011c9c:	601a      	str	r2, [r3, #0]
        }

        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8011c9e:	687b      	ldr	r3, [r7, #4]
 8011ca0:	681b      	ldr	r3, [r3, #0]
 8011ca2:	685b      	ldr	r3, [r3, #4]
 8011ca4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8011ca8:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8011cac:	d117      	bne.n	8011cde <I2C_Master_ADDR+0x278>
 8011cae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011cb0:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 8011cb4:	d00b      	beq.n	8011cce <I2C_Master_ADDR+0x268>
 8011cb6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011cb8:	2b01      	cmp	r3, #1
 8011cba:	d008      	beq.n	8011cce <I2C_Master_ADDR+0x268>
 8011cbc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011cbe:	2b08      	cmp	r3, #8
 8011cc0:	d005      	beq.n	8011cce <I2C_Master_ADDR+0x268>
 8011cc2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011cc4:	2b10      	cmp	r3, #16
 8011cc6:	d002      	beq.n	8011cce <I2C_Master_ADDR+0x268>
 8011cc8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011cca:	2b20      	cmp	r3, #32
 8011ccc:	d107      	bne.n	8011cde <I2C_Master_ADDR+0x278>
        {
          /* Enable Last DMA bit */
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 8011cce:	687b      	ldr	r3, [r7, #4]
 8011cd0:	681b      	ldr	r3, [r3, #0]
 8011cd2:	685a      	ldr	r2, [r3, #4]
 8011cd4:	687b      	ldr	r3, [r7, #4]
 8011cd6:	681b      	ldr	r3, [r3, #0]
 8011cd8:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8011cdc:	605a      	str	r2, [r3, #4]
        }

        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011cde:	2300      	movs	r3, #0
 8011ce0:	617b      	str	r3, [r7, #20]
 8011ce2:	687b      	ldr	r3, [r7, #4]
 8011ce4:	681b      	ldr	r3, [r3, #0]
 8011ce6:	695b      	ldr	r3, [r3, #20]
 8011ce8:	617b      	str	r3, [r7, #20]
 8011cea:	687b      	ldr	r3, [r7, #4]
 8011cec:	681b      	ldr	r3, [r3, #0]
 8011cee:	699b      	ldr	r3, [r3, #24]
 8011cf0:	617b      	str	r3, [r7, #20]
 8011cf2:	697b      	ldr	r3, [r7, #20]
 8011cf4:	e032      	b.n	8011d5c <I2C_Master_ADDR+0x2f6>
      }
      else
      {
        /* Enable Acknowledge */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011cf6:	687b      	ldr	r3, [r7, #4]
 8011cf8:	681b      	ldr	r3, [r3, #0]
 8011cfa:	681a      	ldr	r2, [r3, #0]
 8011cfc:	687b      	ldr	r3, [r7, #4]
 8011cfe:	681b      	ldr	r3, [r3, #0]
 8011d00:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8011d04:	601a      	str	r2, [r3, #0]

        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8011d06:	687b      	ldr	r3, [r7, #4]
 8011d08:	681b      	ldr	r3, [r3, #0]
 8011d0a:	685b      	ldr	r3, [r3, #4]
 8011d0c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8011d10:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8011d14:	d117      	bne.n	8011d46 <I2C_Master_ADDR+0x2e0>
 8011d16:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d18:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 8011d1c:	d00b      	beq.n	8011d36 <I2C_Master_ADDR+0x2d0>
 8011d1e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d20:	2b01      	cmp	r3, #1
 8011d22:	d008      	beq.n	8011d36 <I2C_Master_ADDR+0x2d0>
 8011d24:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d26:	2b08      	cmp	r3, #8
 8011d28:	d005      	beq.n	8011d36 <I2C_Master_ADDR+0x2d0>
 8011d2a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d2c:	2b10      	cmp	r3, #16
 8011d2e:	d002      	beq.n	8011d36 <I2C_Master_ADDR+0x2d0>
 8011d30:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d32:	2b20      	cmp	r3, #32
 8011d34:	d107      	bne.n	8011d46 <I2C_Master_ADDR+0x2e0>
        {
          /* Enable Last DMA bit */
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 8011d36:	687b      	ldr	r3, [r7, #4]
 8011d38:	681b      	ldr	r3, [r3, #0]
 8011d3a:	685a      	ldr	r2, [r3, #4]
 8011d3c:	687b      	ldr	r3, [r7, #4]
 8011d3e:	681b      	ldr	r3, [r3, #0]
 8011d40:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8011d44:	605a      	str	r2, [r3, #4]
        }

        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011d46:	2300      	movs	r3, #0
 8011d48:	613b      	str	r3, [r7, #16]
 8011d4a:	687b      	ldr	r3, [r7, #4]
 8011d4c:	681b      	ldr	r3, [r3, #0]
 8011d4e:	695b      	ldr	r3, [r3, #20]
 8011d50:	613b      	str	r3, [r7, #16]
 8011d52:	687b      	ldr	r3, [r7, #4]
 8011d54:	681b      	ldr	r3, [r3, #0]
 8011d56:	699b      	ldr	r3, [r3, #24]
 8011d58:	613b      	str	r3, [r7, #16]
 8011d5a:	693b      	ldr	r3, [r7, #16]
      }

      /* Reset Event counter  */
      hi2c->EventCount = 0U;
 8011d5c:	687b      	ldr	r3, [r7, #4]
 8011d5e:	2200      	movs	r2, #0
 8011d60:	651a      	str	r2, [r3, #80]	@ 0x50
  else
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
  }
}
 8011d62:	e00b      	b.n	8011d7c <I2C_Master_ADDR+0x316>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011d64:	2300      	movs	r3, #0
 8011d66:	60fb      	str	r3, [r7, #12]
 8011d68:	687b      	ldr	r3, [r7, #4]
 8011d6a:	681b      	ldr	r3, [r3, #0]
 8011d6c:	695b      	ldr	r3, [r3, #20]
 8011d6e:	60fb      	str	r3, [r7, #12]
 8011d70:	687b      	ldr	r3, [r7, #4]
 8011d72:	681b      	ldr	r3, [r3, #0]
 8011d74:	699b      	ldr	r3, [r3, #24]
 8011d76:	60fb      	str	r3, [r7, #12]
 8011d78:	68fb      	ldr	r3, [r7, #12]
}
 8011d7a:	e7ff      	b.n	8011d7c <I2C_Master_ADDR+0x316>
 8011d7c:	bf00      	nop
 8011d7e:	3744      	adds	r7, #68	@ 0x44
 8011d80:	46bd      	mov	sp, r7
 8011d82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d86:	4770      	bx	lr

08011d88 <I2C_SlaveTransmit_TXE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
{
 8011d88:	b580      	push	{r7, lr}
 8011d8a:	b084      	sub	sp, #16
 8011d8c:	af00      	add	r7, sp, #0
 8011d8e:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8011d90:	687b      	ldr	r3, [r7, #4]
 8011d92:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011d96:	73fb      	strb	r3, [r7, #15]

  if (hi2c->XferCount != 0U)
 8011d98:	687b      	ldr	r3, [r7, #4]
 8011d9a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011d9c:	b29b      	uxth	r3, r3
 8011d9e:	2b00      	cmp	r3, #0
 8011da0:	d02b      	beq.n	8011dfa <I2C_SlaveTransmit_TXE+0x72>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 8011da2:	687b      	ldr	r3, [r7, #4]
 8011da4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011da6:	781a      	ldrb	r2, [r3, #0]
 8011da8:	687b      	ldr	r3, [r7, #4]
 8011daa:	681b      	ldr	r3, [r3, #0]
 8011dac:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8011dae:	687b      	ldr	r3, [r7, #4]
 8011db0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011db2:	1c5a      	adds	r2, r3, #1
 8011db4:	687b      	ldr	r3, [r7, #4]
 8011db6:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 8011db8:	687b      	ldr	r3, [r7, #4]
 8011dba:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011dbc:	b29b      	uxth	r3, r3
 8011dbe:	3b01      	subs	r3, #1
 8011dc0:	b29a      	uxth	r2, r3
 8011dc2:	687b      	ldr	r3, [r7, #4]
 8011dc4:	855a      	strh	r2, [r3, #42]	@ 0x2a

    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8011dc6:	687b      	ldr	r3, [r7, #4]
 8011dc8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011dca:	b29b      	uxth	r3, r3
 8011dcc:	2b00      	cmp	r3, #0
 8011dce:	d114      	bne.n	8011dfa <I2C_SlaveTransmit_TXE+0x72>
 8011dd0:	7bfb      	ldrb	r3, [r7, #15]
 8011dd2:	2b29      	cmp	r3, #41	@ 0x29
 8011dd4:	d111      	bne.n	8011dfa <I2C_SlaveTransmit_TXE+0x72>
    {
      /* Last Byte is received, disable Interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8011dd6:	687b      	ldr	r3, [r7, #4]
 8011dd8:	681b      	ldr	r3, [r3, #0]
 8011dda:	685a      	ldr	r2, [r3, #4]
 8011ddc:	687b      	ldr	r3, [r7, #4]
 8011dde:	681b      	ldr	r3, [r3, #0]
 8011de0:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011de4:	605a      	str	r2, [r3, #4]

      /* Set state at HAL_I2C_STATE_LISTEN */
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8011de6:	687b      	ldr	r3, [r7, #4]
 8011de8:	2221      	movs	r2, #33	@ 0x21
 8011dea:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8011dec:	687b      	ldr	r3, [r7, #4]
 8011dee:	2228      	movs	r2, #40	@ 0x28
 8011df0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

      /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->SlaveTxCpltCallback(hi2c);
#else
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 8011df4:	6878      	ldr	r0, [r7, #4]
 8011df6:	f7ff f9b1 	bl	801115c <HAL_I2C_SlaveTxCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
  }
}
 8011dfa:	bf00      	nop
 8011dfc:	3710      	adds	r7, #16
 8011dfe:	46bd      	mov	sp, r7
 8011e00:	bd80      	pop	{r7, pc}

08011e02 <I2C_SlaveTransmit_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
 8011e02:	b480      	push	{r7}
 8011e04:	b083      	sub	sp, #12
 8011e06:	af00      	add	r7, sp, #0
 8011e08:	6078      	str	r0, [r7, #4]
  if (hi2c->XferCount != 0U)
 8011e0a:	687b      	ldr	r3, [r7, #4]
 8011e0c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011e0e:	b29b      	uxth	r3, r3
 8011e10:	2b00      	cmp	r3, #0
 8011e12:	d011      	beq.n	8011e38 <I2C_SlaveTransmit_BTF+0x36>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 8011e14:	687b      	ldr	r3, [r7, #4]
 8011e16:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011e18:	781a      	ldrb	r2, [r3, #0]
 8011e1a:	687b      	ldr	r3, [r7, #4]
 8011e1c:	681b      	ldr	r3, [r3, #0]
 8011e1e:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8011e20:	687b      	ldr	r3, [r7, #4]
 8011e22:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011e24:	1c5a      	adds	r2, r3, #1
 8011e26:	687b      	ldr	r3, [r7, #4]
 8011e28:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 8011e2a:	687b      	ldr	r3, [r7, #4]
 8011e2c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011e2e:	b29b      	uxth	r3, r3
 8011e30:	3b01      	subs	r3, #1
 8011e32:	b29a      	uxth	r2, r3
 8011e34:	687b      	ldr	r3, [r7, #4]
 8011e36:	855a      	strh	r2, [r3, #42]	@ 0x2a
  }
}
 8011e38:	bf00      	nop
 8011e3a:	370c      	adds	r7, #12
 8011e3c:	46bd      	mov	sp, r7
 8011e3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e42:	4770      	bx	lr

08011e44 <I2C_SlaveReceive_RXNE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
{
 8011e44:	b580      	push	{r7, lr}
 8011e46:	b084      	sub	sp, #16
 8011e48:	af00      	add	r7, sp, #0
 8011e4a:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8011e4c:	687b      	ldr	r3, [r7, #4]
 8011e4e:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011e52:	73fb      	strb	r3, [r7, #15]

  if (hi2c->XferCount != 0U)
 8011e54:	687b      	ldr	r3, [r7, #4]
 8011e56:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011e58:	b29b      	uxth	r3, r3
 8011e5a:	2b00      	cmp	r3, #0
 8011e5c:	d02c      	beq.n	8011eb8 <I2C_SlaveReceive_RXNE+0x74>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8011e5e:	687b      	ldr	r3, [r7, #4]
 8011e60:	681b      	ldr	r3, [r3, #0]
 8011e62:	691a      	ldr	r2, [r3, #16]
 8011e64:	687b      	ldr	r3, [r7, #4]
 8011e66:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011e68:	b2d2      	uxtb	r2, r2
 8011e6a:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8011e6c:	687b      	ldr	r3, [r7, #4]
 8011e6e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011e70:	1c5a      	adds	r2, r3, #1
 8011e72:	687b      	ldr	r3, [r7, #4]
 8011e74:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 8011e76:	687b      	ldr	r3, [r7, #4]
 8011e78:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011e7a:	b29b      	uxth	r3, r3
 8011e7c:	3b01      	subs	r3, #1
 8011e7e:	b29a      	uxth	r2, r3
 8011e80:	687b      	ldr	r3, [r7, #4]
 8011e82:	855a      	strh	r2, [r3, #42]	@ 0x2a

    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8011e84:	687b      	ldr	r3, [r7, #4]
 8011e86:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011e88:	b29b      	uxth	r3, r3
 8011e8a:	2b00      	cmp	r3, #0
 8011e8c:	d114      	bne.n	8011eb8 <I2C_SlaveReceive_RXNE+0x74>
 8011e8e:	7bfb      	ldrb	r3, [r7, #15]
 8011e90:	2b2a      	cmp	r3, #42	@ 0x2a
 8011e92:	d111      	bne.n	8011eb8 <I2C_SlaveReceive_RXNE+0x74>
    {
      /* Last Byte is received, disable Interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8011e94:	687b      	ldr	r3, [r7, #4]
 8011e96:	681b      	ldr	r3, [r3, #0]
 8011e98:	685a      	ldr	r2, [r3, #4]
 8011e9a:	687b      	ldr	r3, [r7, #4]
 8011e9c:	681b      	ldr	r3, [r3, #0]
 8011e9e:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011ea2:	605a      	str	r2, [r3, #4]

      /* Set state at HAL_I2C_STATE_LISTEN */
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8011ea4:	687b      	ldr	r3, [r7, #4]
 8011ea6:	2222      	movs	r2, #34	@ 0x22
 8011ea8:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8011eaa:	687b      	ldr	r3, [r7, #4]
 8011eac:	2228      	movs	r2, #40	@ 0x28
 8011eae:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

      /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->SlaveRxCpltCallback(hi2c);
#else
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 8011eb2:	6878      	ldr	r0, [r7, #4]
 8011eb4:	f7ff f95c 	bl	8011170 <HAL_I2C_SlaveRxCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
  }
}
 8011eb8:	bf00      	nop
 8011eba:	3710      	adds	r7, #16
 8011ebc:	46bd      	mov	sp, r7
 8011ebe:	bd80      	pop	{r7, pc}

08011ec0 <I2C_SlaveReceive_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
{
 8011ec0:	b480      	push	{r7}
 8011ec2:	b083      	sub	sp, #12
 8011ec4:	af00      	add	r7, sp, #0
 8011ec6:	6078      	str	r0, [r7, #4]
  if (hi2c->XferCount != 0U)
 8011ec8:	687b      	ldr	r3, [r7, #4]
 8011eca:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011ecc:	b29b      	uxth	r3, r3
 8011ece:	2b00      	cmp	r3, #0
 8011ed0:	d012      	beq.n	8011ef8 <I2C_SlaveReceive_BTF+0x38>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8011ed2:	687b      	ldr	r3, [r7, #4]
 8011ed4:	681b      	ldr	r3, [r3, #0]
 8011ed6:	691a      	ldr	r2, [r3, #16]
 8011ed8:	687b      	ldr	r3, [r7, #4]
 8011eda:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011edc:	b2d2      	uxtb	r2, r2
 8011ede:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8011ee0:	687b      	ldr	r3, [r7, #4]
 8011ee2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011ee4:	1c5a      	adds	r2, r3, #1
 8011ee6:	687b      	ldr	r3, [r7, #4]
 8011ee8:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 8011eea:	687b      	ldr	r3, [r7, #4]
 8011eec:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8011eee:	b29b      	uxth	r3, r3
 8011ef0:	3b01      	subs	r3, #1
 8011ef2:	b29a      	uxth	r2, r3
 8011ef4:	687b      	ldr	r3, [r7, #4]
 8011ef6:	855a      	strh	r2, [r3, #42]	@ 0x2a
  }
}
 8011ef8:	bf00      	nop
 8011efa:	370c      	adds	r7, #12
 8011efc:	46bd      	mov	sp, r7
 8011efe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f02:	4770      	bx	lr

08011f04 <I2C_Slave_ADDR>:
  *         the configuration information for I2C module
  * @param  IT2Flags Interrupt2 flags to handle.
  * @retval None
  */
static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
{
 8011f04:	b580      	push	{r7, lr}
 8011f06:	b084      	sub	sp, #16
 8011f08:	af00      	add	r7, sp, #0
 8011f0a:	6078      	str	r0, [r7, #4]
 8011f0c:	6039      	str	r1, [r7, #0]
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 8011f0e:	2300      	movs	r3, #0
 8011f10:	73fb      	strb	r3, [r7, #15]
  uint16_t SlaveAddrCode;

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8011f12:	687b      	ldr	r3, [r7, #4]
 8011f14:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011f18:	b2db      	uxtb	r3, r3
 8011f1a:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 8011f1e:	2b28      	cmp	r3, #40	@ 0x28
 8011f20:	d125      	bne.n	8011f6e <I2C_Slave_ADDR+0x6a>
  {
    /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
    __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
 8011f22:	687b      	ldr	r3, [r7, #4]
 8011f24:	681b      	ldr	r3, [r3, #0]
 8011f26:	685a      	ldr	r2, [r3, #4]
 8011f28:	687b      	ldr	r3, [r7, #4]
 8011f2a:	681b      	ldr	r3, [r3, #0]
 8011f2c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011f30:	605a      	str	r2, [r3, #4]

    /* Transfer Direction requested by Master */
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
 8011f32:	683b      	ldr	r3, [r7, #0]
 8011f34:	f003 0304 	and.w	r3, r3, #4
 8011f38:	2b00      	cmp	r3, #0
 8011f3a:	d101      	bne.n	8011f40 <I2C_Slave_ADDR+0x3c>
    {
      TransferDirection = I2C_DIRECTION_TRANSMIT;
 8011f3c:	2301      	movs	r3, #1
 8011f3e:	73fb      	strb	r3, [r7, #15]
    }

    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
 8011f40:	683b      	ldr	r3, [r7, #0]
 8011f42:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8011f46:	2b00      	cmp	r3, #0
 8011f48:	d103      	bne.n	8011f52 <I2C_Slave_ADDR+0x4e>
    {
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
 8011f4a:	687b      	ldr	r3, [r7, #4]
 8011f4c:	68db      	ldr	r3, [r3, #12]
 8011f4e:	81bb      	strh	r3, [r7, #12]
 8011f50:	e002      	b.n	8011f58 <I2C_Slave_ADDR+0x54>
    }
    else
    {
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
 8011f52:	687b      	ldr	r3, [r7, #4]
 8011f54:	699b      	ldr	r3, [r3, #24]
 8011f56:	81bb      	strh	r3, [r7, #12]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8011f58:	687b      	ldr	r3, [r7, #4]
 8011f5a:	2200      	movs	r2, #0
 8011f5c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
#else
    HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 8011f60:	89ba      	ldrh	r2, [r7, #12]
 8011f62:	7bfb      	ldrb	r3, [r7, #15]
 8011f64:	4619      	mov	r1, r3
 8011f66:	6878      	ldr	r0, [r7, #4]
 8011f68:	f7ff f90c 	bl	8011184 <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
 8011f6c:	e00e      	b.n	8011f8c <I2C_Slave_ADDR+0x88>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8011f6e:	2300      	movs	r3, #0
 8011f70:	60bb      	str	r3, [r7, #8]
 8011f72:	687b      	ldr	r3, [r7, #4]
 8011f74:	681b      	ldr	r3, [r3, #0]
 8011f76:	695b      	ldr	r3, [r3, #20]
 8011f78:	60bb      	str	r3, [r7, #8]
 8011f7a:	687b      	ldr	r3, [r7, #4]
 8011f7c:	681b      	ldr	r3, [r3, #0]
 8011f7e:	699b      	ldr	r3, [r3, #24]
 8011f80:	60bb      	str	r3, [r7, #8]
 8011f82:	68bb      	ldr	r3, [r7, #8]
    __HAL_UNLOCK(hi2c);
 8011f84:	687b      	ldr	r3, [r7, #4]
 8011f86:	2200      	movs	r2, #0
 8011f88:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
}
 8011f8c:	bf00      	nop
 8011f8e:	3710      	adds	r7, #16
 8011f90:	46bd      	mov	sp, r7
 8011f92:	bd80      	pop	{r7, pc}

08011f94 <I2C_Slave_STOPF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
{
 8011f94:	b580      	push	{r7, lr}
 8011f96:	b084      	sub	sp, #16
 8011f98:	af00      	add	r7, sp, #0
 8011f9a:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8011f9c:	687b      	ldr	r3, [r7, #4]
 8011f9e:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8011fa2:	73fb      	strb	r3, [r7, #15]

  /* Disable EVT, BUF and ERR interrupt */
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8011fa4:	687b      	ldr	r3, [r7, #4]
 8011fa6:	681b      	ldr	r3, [r3, #0]
 8011fa8:	685a      	ldr	r2, [r3, #4]
 8011faa:	687b      	ldr	r3, [r7, #4]
 8011fac:	681b      	ldr	r3, [r3, #0]
 8011fae:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8011fb2:	605a      	str	r2, [r3, #4]

  /* Clear STOPF flag */
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 8011fb4:	2300      	movs	r3, #0
 8011fb6:	60bb      	str	r3, [r7, #8]
 8011fb8:	687b      	ldr	r3, [r7, #4]
 8011fba:	681b      	ldr	r3, [r3, #0]
 8011fbc:	695b      	ldr	r3, [r3, #20]
 8011fbe:	60bb      	str	r3, [r7, #8]
 8011fc0:	687b      	ldr	r3, [r7, #4]
 8011fc2:	681b      	ldr	r3, [r3, #0]
 8011fc4:	681a      	ldr	r2, [r3, #0]
 8011fc6:	687b      	ldr	r3, [r7, #4]
 8011fc8:	681b      	ldr	r3, [r3, #0]
 8011fca:	f042 0201 	orr.w	r2, r2, #1
 8011fce:	601a      	str	r2, [r3, #0]
 8011fd0:	68bb      	ldr	r3, [r7, #8]

  /* Disable Acknowledge */
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8011fd2:	687b      	ldr	r3, [r7, #4]
 8011fd4:	681b      	ldr	r3, [r3, #0]
 8011fd6:	681a      	ldr	r2, [r3, #0]
 8011fd8:	687b      	ldr	r3, [r7, #4]
 8011fda:	681b      	ldr	r3, [r3, #0]
 8011fdc:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8011fe0:	601a      	str	r2, [r3, #0]

  /* If a DMA is ongoing, Update handle size context */
  if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8011fe2:	687b      	ldr	r3, [r7, #4]
 8011fe4:	681b      	ldr	r3, [r3, #0]
 8011fe6:	685b      	ldr	r3, [r3, #4]
 8011fe8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8011fec:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8011ff0:	d172      	bne.n	80120d8 <I2C_Slave_STOPF+0x144>
  {
    if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8011ff2:	7bfb      	ldrb	r3, [r7, #15]
 8011ff4:	2b22      	cmp	r3, #34	@ 0x22
 8011ff6:	d002      	beq.n	8011ffe <I2C_Slave_STOPF+0x6a>
 8011ff8:	7bfb      	ldrb	r3, [r7, #15]
 8011ffa:	2b2a      	cmp	r3, #42	@ 0x2a
 8011ffc:	d135      	bne.n	801206a <I2C_Slave_STOPF+0xd6>
    {
      hi2c->XferCount = (uint16_t)(I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx));
 8011ffe:	687b      	ldr	r3, [r7, #4]
 8012000:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012002:	681b      	ldr	r3, [r3, #0]
 8012004:	685b      	ldr	r3, [r3, #4]
 8012006:	b29a      	uxth	r2, r3
 8012008:	687b      	ldr	r3, [r7, #4]
 801200a:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if (hi2c->XferCount != 0U)
 801200c:	687b      	ldr	r3, [r7, #4]
 801200e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8012010:	b29b      	uxth	r3, r3
 8012012:	2b00      	cmp	r3, #0
 8012014:	d005      	beq.n	8012022 <I2C_Slave_STOPF+0x8e>
      {
        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8012016:	687b      	ldr	r3, [r7, #4]
 8012018:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801201a:	f043 0204 	orr.w	r2, r3, #4
 801201e:	687b      	ldr	r3, [r7, #4]
 8012020:	641a      	str	r2, [r3, #64]	@ 0x40
      }

      /* Disable, stop the current DMA */
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8012022:	687b      	ldr	r3, [r7, #4]
 8012024:	681b      	ldr	r3, [r3, #0]
 8012026:	685a      	ldr	r2, [r3, #4]
 8012028:	687b      	ldr	r3, [r7, #4]
 801202a:	681b      	ldr	r3, [r3, #0]
 801202c:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8012030:	605a      	str	r2, [r3, #4]

      /* Abort DMA Xfer if any */
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8012032:	687b      	ldr	r3, [r7, #4]
 8012034:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012036:	4618      	mov	r0, r3
 8012038:	f7fd fb69 	bl	800f70e <HAL_DMA_GetState>
 801203c:	4603      	mov	r3, r0
 801203e:	2b01      	cmp	r3, #1
 8012040:	d049      	beq.n	80120d6 <I2C_Slave_STOPF+0x142>
      {
        /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
        hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8012042:	687b      	ldr	r3, [r7, #4]
 8012044:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012046:	4a69      	ldr	r2, [pc, #420]	@ (80121ec <I2C_Slave_STOPF+0x258>)
 8012048:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Abort DMA RX */
        if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 801204a:	687b      	ldr	r3, [r7, #4]
 801204c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801204e:	4618      	mov	r0, r3
 8012050:	f7fd fb3b 	bl	800f6ca <HAL_DMA_Abort_IT>
 8012054:	4603      	mov	r3, r0
 8012056:	2b00      	cmp	r3, #0
 8012058:	d03d      	beq.n	80120d6 <I2C_Slave_STOPF+0x142>
        {
          /* Call Directly XferAbortCallback function in case of error */
          hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 801205a:	687b      	ldr	r3, [r7, #4]
 801205c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801205e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012060:	687a      	ldr	r2, [r7, #4]
 8012062:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 8012064:	4610      	mov	r0, r2
 8012066:	4798      	blx	r3
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8012068:	e035      	b.n	80120d6 <I2C_Slave_STOPF+0x142>
        }
      }
    }
    else
    {
      hi2c->XferCount = (uint16_t)(I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx));
 801206a:	687b      	ldr	r3, [r7, #4]
 801206c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801206e:	681b      	ldr	r3, [r3, #0]
 8012070:	685b      	ldr	r3, [r3, #4]
 8012072:	b29a      	uxth	r2, r3
 8012074:	687b      	ldr	r3, [r7, #4]
 8012076:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if (hi2c->XferCount != 0U)
 8012078:	687b      	ldr	r3, [r7, #4]
 801207a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801207c:	b29b      	uxth	r3, r3
 801207e:	2b00      	cmp	r3, #0
 8012080:	d005      	beq.n	801208e <I2C_Slave_STOPF+0xfa>
      {
        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8012082:	687b      	ldr	r3, [r7, #4]
 8012084:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012086:	f043 0204 	orr.w	r2, r3, #4
 801208a:	687b      	ldr	r3, [r7, #4]
 801208c:	641a      	str	r2, [r3, #64]	@ 0x40
      }

      /* Disable, stop the current DMA */
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 801208e:	687b      	ldr	r3, [r7, #4]
 8012090:	681b      	ldr	r3, [r3, #0]
 8012092:	685a      	ldr	r2, [r3, #4]
 8012094:	687b      	ldr	r3, [r7, #4]
 8012096:	681b      	ldr	r3, [r3, #0]
 8012098:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 801209c:	605a      	str	r2, [r3, #4]

      /* Abort DMA Xfer if any */
      if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 801209e:	687b      	ldr	r3, [r7, #4]
 80120a0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80120a2:	4618      	mov	r0, r3
 80120a4:	f7fd fb33 	bl	800f70e <HAL_DMA_GetState>
 80120a8:	4603      	mov	r3, r0
 80120aa:	2b01      	cmp	r3, #1
 80120ac:	d014      	beq.n	80120d8 <I2C_Slave_STOPF+0x144>
      {
        /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
        hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 80120ae:	687b      	ldr	r3, [r7, #4]
 80120b0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80120b2:	4a4e      	ldr	r2, [pc, #312]	@ (80121ec <I2C_Slave_STOPF+0x258>)
 80120b4:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Abort DMA TX */
        if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 80120b6:	687b      	ldr	r3, [r7, #4]
 80120b8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80120ba:	4618      	mov	r0, r3
 80120bc:	f7fd fb05 	bl	800f6ca <HAL_DMA_Abort_IT>
 80120c0:	4603      	mov	r3, r0
 80120c2:	2b00      	cmp	r3, #0
 80120c4:	d008      	beq.n	80120d8 <I2C_Slave_STOPF+0x144>
        {
          /* Call Directly XferAbortCallback function in case of error */
          hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 80120c6:	687b      	ldr	r3, [r7, #4]
 80120c8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80120ca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80120cc:	687a      	ldr	r2, [r7, #4]
 80120ce:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 80120d0:	4610      	mov	r0, r2
 80120d2:	4798      	blx	r3
 80120d4:	e000      	b.n	80120d8 <I2C_Slave_STOPF+0x144>
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 80120d6:	bf00      	nop
      }
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
 80120d8:	687b      	ldr	r3, [r7, #4]
 80120da:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80120dc:	b29b      	uxth	r3, r3
 80120de:	2b00      	cmp	r3, #0
 80120e0:	d03e      	beq.n	8012160 <I2C_Slave_STOPF+0x1cc>
  {
    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 80120e2:	687b      	ldr	r3, [r7, #4]
 80120e4:	681b      	ldr	r3, [r3, #0]
 80120e6:	695b      	ldr	r3, [r3, #20]
 80120e8:	f003 0304 	and.w	r3, r3, #4
 80120ec:	2b04      	cmp	r3, #4
 80120ee:	d112      	bne.n	8012116 <I2C_Slave_STOPF+0x182>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80120f0:	687b      	ldr	r3, [r7, #4]
 80120f2:	681b      	ldr	r3, [r3, #0]
 80120f4:	691a      	ldr	r2, [r3, #16]
 80120f6:	687b      	ldr	r3, [r7, #4]
 80120f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80120fa:	b2d2      	uxtb	r2, r2
 80120fc:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80120fe:	687b      	ldr	r3, [r7, #4]
 8012100:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012102:	1c5a      	adds	r2, r3, #1
 8012104:	687b      	ldr	r3, [r7, #4]
 8012106:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 8012108:	687b      	ldr	r3, [r7, #4]
 801210a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801210c:	b29b      	uxth	r3, r3
 801210e:	3b01      	subs	r3, #1
 8012110:	b29a      	uxth	r2, r3
 8012112:	687b      	ldr	r3, [r7, #4]
 8012114:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }

    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8012116:	687b      	ldr	r3, [r7, #4]
 8012118:	681b      	ldr	r3, [r3, #0]
 801211a:	695b      	ldr	r3, [r3, #20]
 801211c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8012120:	2b40      	cmp	r3, #64	@ 0x40
 8012122:	d112      	bne.n	801214a <I2C_Slave_STOPF+0x1b6>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8012124:	687b      	ldr	r3, [r7, #4]
 8012126:	681b      	ldr	r3, [r3, #0]
 8012128:	691a      	ldr	r2, [r3, #16]
 801212a:	687b      	ldr	r3, [r7, #4]
 801212c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801212e:	b2d2      	uxtb	r2, r2
 8012130:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8012132:	687b      	ldr	r3, [r7, #4]
 8012134:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012136:	1c5a      	adds	r2, r3, #1
 8012138:	687b      	ldr	r3, [r7, #4]
 801213a:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 801213c:	687b      	ldr	r3, [r7, #4]
 801213e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8012140:	b29b      	uxth	r3, r3
 8012142:	3b01      	subs	r3, #1
 8012144:	b29a      	uxth	r2, r3
 8012146:	687b      	ldr	r3, [r7, #4]
 8012148:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }

    if (hi2c->XferCount != 0U)
 801214a:	687b      	ldr	r3, [r7, #4]
 801214c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 801214e:	b29b      	uxth	r3, r3
 8012150:	2b00      	cmp	r3, #0
 8012152:	d005      	beq.n	8012160 <I2C_Slave_STOPF+0x1cc>
    {
      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8012154:	687b      	ldr	r3, [r7, #4]
 8012156:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012158:	f043 0204 	orr.w	r2, r3, #4
 801215c:	687b      	ldr	r3, [r7, #4]
 801215e:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8012160:	687b      	ldr	r3, [r7, #4]
 8012162:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012164:	2b00      	cmp	r3, #0
 8012166:	d003      	beq.n	8012170 <I2C_Slave_STOPF+0x1dc>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c);
 8012168:	6878      	ldr	r0, [r7, #4]
 801216a:	f000 f8b7 	bl	80122dc <I2C_ITError>
        HAL_I2C_SlaveRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
    }
  }
}
 801216e:	e039      	b.n	80121e4 <I2C_Slave_STOPF+0x250>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8012170:	7bfb      	ldrb	r3, [r7, #15]
 8012172:	2b2a      	cmp	r3, #42	@ 0x2a
 8012174:	d109      	bne.n	801218a <I2C_Slave_STOPF+0x1f6>
      hi2c->PreviousState = I2C_STATE_NONE;
 8012176:	687b      	ldr	r3, [r7, #4]
 8012178:	2200      	movs	r2, #0
 801217a:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 801217c:	687b      	ldr	r3, [r7, #4]
 801217e:	2228      	movs	r2, #40	@ 0x28
 8012180:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 8012184:	6878      	ldr	r0, [r7, #4]
 8012186:	f7fe fff3 	bl	8011170 <HAL_I2C_SlaveRxCpltCallback>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 801218a:	687b      	ldr	r3, [r7, #4]
 801218c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8012190:	b2db      	uxtb	r3, r3
 8012192:	2b28      	cmp	r3, #40	@ 0x28
 8012194:	d111      	bne.n	80121ba <I2C_Slave_STOPF+0x226>
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8012196:	687b      	ldr	r3, [r7, #4]
 8012198:	4a15      	ldr	r2, [pc, #84]	@ (80121f0 <I2C_Slave_STOPF+0x25c>)
 801219a:	62da      	str	r2, [r3, #44]	@ 0x2c
      hi2c->PreviousState = I2C_STATE_NONE;
 801219c:	687b      	ldr	r3, [r7, #4]
 801219e:	2200      	movs	r2, #0
 80121a0:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 80121a2:	687b      	ldr	r3, [r7, #4]
 80121a4:	2220      	movs	r2, #32
 80121a6:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80121aa:	687b      	ldr	r3, [r7, #4]
 80121ac:	2200      	movs	r2, #0
 80121ae:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 80121b2:	6878      	ldr	r0, [r7, #4]
 80121b4:	f7fe fff4 	bl	80111a0 <HAL_I2C_ListenCpltCallback>
}
 80121b8:	e014      	b.n	80121e4 <I2C_Slave_STOPF+0x250>
      if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 80121ba:	687b      	ldr	r3, [r7, #4]
 80121bc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80121be:	2b22      	cmp	r3, #34	@ 0x22
 80121c0:	d002      	beq.n	80121c8 <I2C_Slave_STOPF+0x234>
 80121c2:	7bfb      	ldrb	r3, [r7, #15]
 80121c4:	2b22      	cmp	r3, #34	@ 0x22
 80121c6:	d10d      	bne.n	80121e4 <I2C_Slave_STOPF+0x250>
        hi2c->PreviousState = I2C_STATE_NONE;
 80121c8:	687b      	ldr	r3, [r7, #4]
 80121ca:	2200      	movs	r2, #0
 80121cc:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 80121ce:	687b      	ldr	r3, [r7, #4]
 80121d0:	2220      	movs	r2, #32
 80121d2:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80121d6:	687b      	ldr	r3, [r7, #4]
 80121d8:	2200      	movs	r2, #0
 80121da:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        HAL_I2C_SlaveRxCpltCallback(hi2c);
 80121de:	6878      	ldr	r0, [r7, #4]
 80121e0:	f7fe ffc6 	bl	8011170 <HAL_I2C_SlaveRxCpltCallback>
}
 80121e4:	bf00      	nop
 80121e6:	3710      	adds	r7, #16
 80121e8:	46bd      	mov	sp, r7
 80121ea:	bd80      	pop	{r7, pc}
 80121ec:	08012add 	.word	0x08012add
 80121f0:	ffff0000 	.word	0xffff0000

080121f4 <I2C_Slave_AF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
{
 80121f4:	b580      	push	{r7, lr}
 80121f6:	b084      	sub	sp, #16
 80121f8:	af00      	add	r7, sp, #0
 80121fa:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80121fc:	687b      	ldr	r3, [r7, #4]
 80121fe:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8012202:	73fb      	strb	r3, [r7, #15]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8012204:	687b      	ldr	r3, [r7, #4]
 8012206:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8012208:	60bb      	str	r3, [r7, #8]

  if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 801220a:	68bb      	ldr	r3, [r7, #8]
 801220c:	2b08      	cmp	r3, #8
 801220e:	d002      	beq.n	8012216 <I2C_Slave_AF+0x22>
 8012210:	68bb      	ldr	r3, [r7, #8]
 8012212:	2b20      	cmp	r3, #32
 8012214:	d129      	bne.n	801226a <I2C_Slave_AF+0x76>
 8012216:	7bfb      	ldrb	r3, [r7, #15]
 8012218:	2b28      	cmp	r3, #40	@ 0x28
 801221a:	d126      	bne.n	801226a <I2C_Slave_AF+0x76>
      (CurrentState == HAL_I2C_STATE_LISTEN))
  {
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 801221c:	687b      	ldr	r3, [r7, #4]
 801221e:	4a2e      	ldr	r2, [pc, #184]	@ (80122d8 <I2C_Slave_AF+0xe4>)
 8012220:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Disable EVT, BUF and ERR interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8012222:	687b      	ldr	r3, [r7, #4]
 8012224:	681b      	ldr	r3, [r3, #0]
 8012226:	685a      	ldr	r2, [r3, #4]
 8012228:	687b      	ldr	r3, [r7, #4]
 801222a:	681b      	ldr	r3, [r3, #0]
 801222c:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8012230:	605a      	str	r2, [r3, #4]

    /* Clear AF flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8012232:	687b      	ldr	r3, [r7, #4]
 8012234:	681b      	ldr	r3, [r3, #0]
 8012236:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 801223a:	615a      	str	r2, [r3, #20]

    /* Disable Acknowledge */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 801223c:	687b      	ldr	r3, [r7, #4]
 801223e:	681b      	ldr	r3, [r3, #0]
 8012240:	681a      	ldr	r2, [r3, #0]
 8012242:	687b      	ldr	r3, [r7, #4]
 8012244:	681b      	ldr	r3, [r3, #0]
 8012246:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 801224a:	601a      	str	r2, [r3, #0]

    hi2c->PreviousState = I2C_STATE_NONE;
 801224c:	687b      	ldr	r3, [r7, #4]
 801224e:	2200      	movs	r2, #0
 8012250:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8012252:	687b      	ldr	r3, [r7, #4]
 8012254:	2220      	movs	r2, #32
 8012256:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 801225a:	687b      	ldr	r3, [r7, #4]
 801225c:	2200      	movs	r2, #0
 801225e:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ListenCpltCallback(hi2c);
#else
    HAL_I2C_ListenCpltCallback(hi2c);
 8012262:	6878      	ldr	r0, [r7, #4]
 8012264:	f7fe ff9c 	bl	80111a0 <HAL_I2C_ListenCpltCallback>
  {
    /* Clear AF flag only */
    /* State Listen, but XferOptions == FIRST or NEXT */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
  }
}
 8012268:	e031      	b.n	80122ce <I2C_Slave_AF+0xda>
  else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 801226a:	7bfb      	ldrb	r3, [r7, #15]
 801226c:	2b21      	cmp	r3, #33	@ 0x21
 801226e:	d129      	bne.n	80122c4 <I2C_Slave_AF+0xd0>
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8012270:	687b      	ldr	r3, [r7, #4]
 8012272:	4a19      	ldr	r2, [pc, #100]	@ (80122d8 <I2C_Slave_AF+0xe4>)
 8012274:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8012276:	687b      	ldr	r3, [r7, #4]
 8012278:	2221      	movs	r2, #33	@ 0x21
 801227a:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 801227c:	687b      	ldr	r3, [r7, #4]
 801227e:	2220      	movs	r2, #32
 8012280:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8012284:	687b      	ldr	r3, [r7, #4]
 8012286:	2200      	movs	r2, #0
 8012288:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 801228c:	687b      	ldr	r3, [r7, #4]
 801228e:	681b      	ldr	r3, [r3, #0]
 8012290:	685a      	ldr	r2, [r3, #4]
 8012292:	687b      	ldr	r3, [r7, #4]
 8012294:	681b      	ldr	r3, [r3, #0]
 8012296:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 801229a:	605a      	str	r2, [r3, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 801229c:	687b      	ldr	r3, [r7, #4]
 801229e:	681b      	ldr	r3, [r3, #0]
 80122a0:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 80122a4:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80122a6:	687b      	ldr	r3, [r7, #4]
 80122a8:	681b      	ldr	r3, [r3, #0]
 80122aa:	681a      	ldr	r2, [r3, #0]
 80122ac:	687b      	ldr	r3, [r7, #4]
 80122ae:	681b      	ldr	r3, [r3, #0]
 80122b0:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80122b4:	601a      	str	r2, [r3, #0]
    I2C_Flush_DR(hi2c);
 80122b6:	6878      	ldr	r0, [r7, #4]
 80122b8:	f7fd fed9 	bl	801006e <I2C_Flush_DR>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 80122bc:	6878      	ldr	r0, [r7, #4]
 80122be:	f7fe ff4d 	bl	801115c <HAL_I2C_SlaveTxCpltCallback>
}
 80122c2:	e004      	b.n	80122ce <I2C_Slave_AF+0xda>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80122c4:	687b      	ldr	r3, [r7, #4]
 80122c6:	681b      	ldr	r3, [r3, #0]
 80122c8:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 80122cc:	615a      	str	r2, [r3, #20]
}
 80122ce:	bf00      	nop
 80122d0:	3710      	adds	r7, #16
 80122d2:	46bd      	mov	sp, r7
 80122d4:	bd80      	pop	{r7, pc}
 80122d6:	bf00      	nop
 80122d8:	ffff0000 	.word	0xffff0000

080122dc <I2C_ITError>:
  * @brief  I2C interrupts error process
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c)
{
 80122dc:	b580      	push	{r7, lr}
 80122de:	b084      	sub	sp, #16
 80122e0:	af00      	add	r7, sp, #0
 80122e2:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80122e4:	687b      	ldr	r3, [r7, #4]
 80122e6:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 80122ea:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_ModeTypeDef CurrentMode = hi2c->Mode;
 80122ec:	687b      	ldr	r3, [r7, #4]
 80122ee:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 80122f2:	73bb      	strb	r3, [r7, #14]
  uint32_t CurrentError;

  if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 80122f4:	7bbb      	ldrb	r3, [r7, #14]
 80122f6:	2b10      	cmp	r3, #16
 80122f8:	d002      	beq.n	8012300 <I2C_ITError+0x24>
 80122fa:	7bbb      	ldrb	r3, [r7, #14]
 80122fc:	2b40      	cmp	r3, #64	@ 0x40
 80122fe:	d10a      	bne.n	8012316 <I2C_ITError+0x3a>
 8012300:	7bfb      	ldrb	r3, [r7, #15]
 8012302:	2b22      	cmp	r3, #34	@ 0x22
 8012304:	d107      	bne.n	8012316 <I2C_ITError+0x3a>
  {
    /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 8012306:	687b      	ldr	r3, [r7, #4]
 8012308:	681b      	ldr	r3, [r3, #0]
 801230a:	681a      	ldr	r2, [r3, #0]
 801230c:	687b      	ldr	r3, [r7, #4]
 801230e:	681b      	ldr	r3, [r3, #0]
 8012310:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 8012314:	601a      	str	r2, [r3, #0]
  }

  if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8012316:	7bfb      	ldrb	r3, [r7, #15]
 8012318:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 801231c:	2b28      	cmp	r3, #40	@ 0x28
 801231e:	d107      	bne.n	8012330 <I2C_ITError+0x54>
  {
    /* keep HAL_I2C_STATE_LISTEN */
    hi2c->PreviousState = I2C_STATE_NONE;
 8012320:	687b      	ldr	r3, [r7, #4]
 8012322:	2200      	movs	r2, #0
 8012324:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8012326:	687b      	ldr	r3, [r7, #4]
 8012328:	2228      	movs	r2, #40	@ 0x28
 801232a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
 801232e:	e015      	b.n	801235c <I2C_ITError+0x80>
  }
  else
  {
    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
 8012330:	687b      	ldr	r3, [r7, #4]
 8012332:	681b      	ldr	r3, [r3, #0]
 8012334:	685b      	ldr	r3, [r3, #4]
 8012336:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 801233a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801233e:	d00a      	beq.n	8012356 <I2C_ITError+0x7a>
 8012340:	7bfb      	ldrb	r3, [r7, #15]
 8012342:	2b60      	cmp	r3, #96	@ 0x60
 8012344:	d007      	beq.n	8012356 <I2C_ITError+0x7a>
    {
      hi2c->State = HAL_I2C_STATE_READY;
 8012346:	687b      	ldr	r3, [r7, #4]
 8012348:	2220      	movs	r2, #32
 801234a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 801234e:	687b      	ldr	r3, [r7, #4]
 8012350:	2200      	movs	r2, #0
 8012352:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    }
    hi2c->PreviousState = I2C_STATE_NONE;
 8012356:	687b      	ldr	r3, [r7, #4]
 8012358:	2200      	movs	r2, #0
 801235a:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Abort DMA transfer */
  if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 801235c:	687b      	ldr	r3, [r7, #4]
 801235e:	681b      	ldr	r3, [r3, #0]
 8012360:	685b      	ldr	r3, [r3, #4]
 8012362:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8012366:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801236a:	d162      	bne.n	8012432 <I2C_ITError+0x156>
  {
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 801236c:	687b      	ldr	r3, [r7, #4]
 801236e:	681b      	ldr	r3, [r3, #0]
 8012370:	685a      	ldr	r2, [r3, #4]
 8012372:	687b      	ldr	r3, [r7, #4]
 8012374:	681b      	ldr	r3, [r3, #0]
 8012376:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 801237a:	605a      	str	r2, [r3, #4]

    if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 801237c:	687b      	ldr	r3, [r7, #4]
 801237e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012380:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8012384:	b2db      	uxtb	r3, r3
 8012386:	2b01      	cmp	r3, #1
 8012388:	d020      	beq.n	80123cc <I2C_ITError+0xf0>
    {
      /* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 801238a:	687b      	ldr	r3, [r7, #4]
 801238c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801238e:	4a6a      	ldr	r2, [pc, #424]	@ (8012538 <I2C_ITError+0x25c>)
 8012390:	651a      	str	r2, [r3, #80]	@ 0x50

      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8012392:	687b      	ldr	r3, [r7, #4]
 8012394:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012396:	4618      	mov	r0, r3
 8012398:	f7fd f997 	bl	800f6ca <HAL_DMA_Abort_IT>
 801239c:	4603      	mov	r3, r0
 801239e:	2b00      	cmp	r3, #0
 80123a0:	f000 8089 	beq.w	80124b6 <I2C_ITError+0x1da>
      {
        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);
 80123a4:	687b      	ldr	r3, [r7, #4]
 80123a6:	681b      	ldr	r3, [r3, #0]
 80123a8:	681a      	ldr	r2, [r3, #0]
 80123aa:	687b      	ldr	r3, [r7, #4]
 80123ac:	681b      	ldr	r3, [r3, #0]
 80123ae:	f022 0201 	bic.w	r2, r2, #1
 80123b2:	601a      	str	r2, [r3, #0]

        hi2c->State = HAL_I2C_STATE_READY;
 80123b4:	687b      	ldr	r3, [r7, #4]
 80123b6:	2220      	movs	r2, #32
 80123b8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 80123bc:	687b      	ldr	r3, [r7, #4]
 80123be:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80123c0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80123c2:	687a      	ldr	r2, [r7, #4]
 80123c4:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 80123c6:	4610      	mov	r0, r2
 80123c8:	4798      	blx	r3
 80123ca:	e074      	b.n	80124b6 <I2C_ITError+0x1da>
    }
    else
    {
      /* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 80123cc:	687b      	ldr	r3, [r7, #4]
 80123ce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80123d0:	4a59      	ldr	r2, [pc, #356]	@ (8012538 <I2C_ITError+0x25c>)
 80123d2:	651a      	str	r2, [r3, #80]	@ 0x50

      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 80123d4:	687b      	ldr	r3, [r7, #4]
 80123d6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80123d8:	4618      	mov	r0, r3
 80123da:	f7fd f976 	bl	800f6ca <HAL_DMA_Abort_IT>
 80123de:	4603      	mov	r3, r0
 80123e0:	2b00      	cmp	r3, #0
 80123e2:	d068      	beq.n	80124b6 <I2C_ITError+0x1da>
      {
        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80123e4:	687b      	ldr	r3, [r7, #4]
 80123e6:	681b      	ldr	r3, [r3, #0]
 80123e8:	695b      	ldr	r3, [r3, #20]
 80123ea:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80123ee:	2b40      	cmp	r3, #64	@ 0x40
 80123f0:	d10b      	bne.n	801240a <I2C_ITError+0x12e>
        {
          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80123f2:	687b      	ldr	r3, [r7, #4]
 80123f4:	681b      	ldr	r3, [r3, #0]
 80123f6:	691a      	ldr	r2, [r3, #16]
 80123f8:	687b      	ldr	r3, [r7, #4]
 80123fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80123fc:	b2d2      	uxtb	r2, r2
 80123fe:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 8012400:	687b      	ldr	r3, [r7, #4]
 8012402:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012404:	1c5a      	adds	r2, r3, #1
 8012406:	687b      	ldr	r3, [r7, #4]
 8012408:	625a      	str	r2, [r3, #36]	@ 0x24
        }

        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);
 801240a:	687b      	ldr	r3, [r7, #4]
 801240c:	681b      	ldr	r3, [r3, #0]
 801240e:	681a      	ldr	r2, [r3, #0]
 8012410:	687b      	ldr	r3, [r7, #4]
 8012412:	681b      	ldr	r3, [r3, #0]
 8012414:	f022 0201 	bic.w	r2, r2, #1
 8012418:	601a      	str	r2, [r3, #0]

        hi2c->State = HAL_I2C_STATE_READY;
 801241a:	687b      	ldr	r3, [r7, #4]
 801241c:	2220      	movs	r2, #32
 801241e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8012422:	687b      	ldr	r3, [r7, #4]
 8012424:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012426:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012428:	687a      	ldr	r2, [r7, #4]
 801242a:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 801242c:	4610      	mov	r0, r2
 801242e:	4798      	blx	r3
 8012430:	e041      	b.n	80124b6 <I2C_ITError+0x1da>
      }
    }
  }
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 8012432:	687b      	ldr	r3, [r7, #4]
 8012434:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8012438:	b2db      	uxtb	r3, r3
 801243a:	2b60      	cmp	r3, #96	@ 0x60
 801243c:	d125      	bne.n	801248a <I2C_ITError+0x1ae>
  {
    hi2c->State = HAL_I2C_STATE_READY;
 801243e:	687b      	ldr	r3, [r7, #4]
 8012440:	2220      	movs	r2, #32
 8012442:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8012446:	687b      	ldr	r3, [r7, #4]
 8012448:	2200      	movs	r2, #0
 801244a:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 801244c:	687b      	ldr	r3, [r7, #4]
 801244e:	681b      	ldr	r3, [r3, #0]
 8012450:	695b      	ldr	r3, [r3, #20]
 8012452:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8012456:	2b40      	cmp	r3, #64	@ 0x40
 8012458:	d10b      	bne.n	8012472 <I2C_ITError+0x196>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 801245a:	687b      	ldr	r3, [r7, #4]
 801245c:	681b      	ldr	r3, [r3, #0]
 801245e:	691a      	ldr	r2, [r3, #16]
 8012460:	687b      	ldr	r3, [r7, #4]
 8012462:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012464:	b2d2      	uxtb	r2, r2
 8012466:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8012468:	687b      	ldr	r3, [r7, #4]
 801246a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801246c:	1c5a      	adds	r2, r3, #1
 801246e:	687b      	ldr	r3, [r7, #4]
 8012470:	625a      	str	r2, [r3, #36]	@ 0x24
    }

    /* Disable I2C peripheral to prevent dummy data in buffer */
    __HAL_I2C_DISABLE(hi2c);
 8012472:	687b      	ldr	r3, [r7, #4]
 8012474:	681b      	ldr	r3, [r3, #0]
 8012476:	681a      	ldr	r2, [r3, #0]
 8012478:	687b      	ldr	r3, [r7, #4]
 801247a:	681b      	ldr	r3, [r3, #0]
 801247c:	f022 0201 	bic.w	r2, r2, #1
 8012480:	601a      	str	r2, [r3, #0]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
 8012482:	6878      	ldr	r0, [r7, #4]
 8012484:	f7fe feb4 	bl	80111f0 <HAL_I2C_AbortCpltCallback>
 8012488:	e015      	b.n	80124b6 <I2C_ITError+0x1da>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
  else
  {
    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 801248a:	687b      	ldr	r3, [r7, #4]
 801248c:	681b      	ldr	r3, [r3, #0]
 801248e:	695b      	ldr	r3, [r3, #20]
 8012490:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8012494:	2b40      	cmp	r3, #64	@ 0x40
 8012496:	d10b      	bne.n	80124b0 <I2C_ITError+0x1d4>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8012498:	687b      	ldr	r3, [r7, #4]
 801249a:	681b      	ldr	r3, [r3, #0]
 801249c:	691a      	ldr	r2, [r3, #16]
 801249e:	687b      	ldr	r3, [r7, #4]
 80124a0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80124a2:	b2d2      	uxtb	r2, r2
 80124a4:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80124a6:	687b      	ldr	r3, [r7, #4]
 80124a8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80124aa:	1c5a      	adds	r2, r3, #1
 80124ac:	687b      	ldr	r3, [r7, #4]
 80124ae:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Call user error callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
 80124b0:	6878      	ldr	r0, [r7, #4]
 80124b2:	f7fe fe93 	bl	80111dc <HAL_I2C_ErrorCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  /* STOP Flag is not set after a NACK reception, BusError, ArbitrationLost, OverRun */
  CurrentError = hi2c->ErrorCode;
 80124b6:	687b      	ldr	r3, [r7, #4]
 80124b8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80124ba:	60bb      	str	r3, [r7, #8]

  if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
 80124bc:	68bb      	ldr	r3, [r7, #8]
 80124be:	f003 0301 	and.w	r3, r3, #1
 80124c2:	2b00      	cmp	r3, #0
 80124c4:	d10e      	bne.n	80124e4 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
 80124c6:	68bb      	ldr	r3, [r7, #8]
 80124c8:	f003 0302 	and.w	r3, r3, #2
  if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
 80124cc:	2b00      	cmp	r3, #0
 80124ce:	d109      	bne.n	80124e4 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
 80124d0:	68bb      	ldr	r3, [r7, #8]
 80124d2:	f003 0304 	and.w	r3, r3, #4
      ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
 80124d6:	2b00      	cmp	r3, #0
 80124d8:	d104      	bne.n	80124e4 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_OVR) == HAL_I2C_ERROR_OVR))
 80124da:	68bb      	ldr	r3, [r7, #8]
 80124dc:	f003 0308 	and.w	r3, r3, #8
      ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
 80124e0:	2b00      	cmp	r3, #0
 80124e2:	d007      	beq.n	80124f4 <I2C_ITError+0x218>
  {
    /* Disable EVT, BUF and ERR interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80124e4:	687b      	ldr	r3, [r7, #4]
 80124e6:	681b      	ldr	r3, [r3, #0]
 80124e8:	685a      	ldr	r2, [r3, #4]
 80124ea:	687b      	ldr	r3, [r7, #4]
 80124ec:	681b      	ldr	r3, [r3, #0]
 80124ee:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 80124f2:	605a      	str	r2, [r3, #4]
  }

  /* So may inform upper layer that listen phase is stopped */
  /* during NACK error treatment */
  CurrentState = hi2c->State;
 80124f4:	687b      	ldr	r3, [r7, #4]
 80124f6:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 80124fa:	73fb      	strb	r3, [r7, #15]
  if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
 80124fc:	687b      	ldr	r3, [r7, #4]
 80124fe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012500:	f003 0304 	and.w	r3, r3, #4
 8012504:	2b04      	cmp	r3, #4
 8012506:	d113      	bne.n	8012530 <I2C_ITError+0x254>
 8012508:	7bfb      	ldrb	r3, [r7, #15]
 801250a:	2b28      	cmp	r3, #40	@ 0x28
 801250c:	d110      	bne.n	8012530 <I2C_ITError+0x254>
  {
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 801250e:	687b      	ldr	r3, [r7, #4]
 8012510:	4a0a      	ldr	r2, [pc, #40]	@ (801253c <I2C_ITError+0x260>)
 8012512:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
 8012514:	687b      	ldr	r3, [r7, #4]
 8012516:	2200      	movs	r2, #0
 8012518:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 801251a:	687b      	ldr	r3, [r7, #4]
 801251c:	2220      	movs	r2, #32
 801251e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8012522:	687b      	ldr	r3, [r7, #4]
 8012524:	2200      	movs	r2, #0
 8012526:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ListenCpltCallback(hi2c);
#else
    HAL_I2C_ListenCpltCallback(hi2c);
 801252a:	6878      	ldr	r0, [r7, #4]
 801252c:	f7fe fe38 	bl	80111a0 <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 8012530:	bf00      	nop
 8012532:	3710      	adds	r7, #16
 8012534:	46bd      	mov	sp, r7
 8012536:	bd80      	pop	{r7, pc}
 8012538:	08012add 	.word	0x08012add
 801253c:	ffff0000 	.word	0xffff0000

08012540 <I2C_MasterRequestWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
{
 8012540:	b580      	push	{r7, lr}
 8012542:	b088      	sub	sp, #32
 8012544:	af02      	add	r7, sp, #8
 8012546:	60f8      	str	r0, [r7, #12]
 8012548:	607a      	str	r2, [r7, #4]
 801254a:	603b      	str	r3, [r7, #0]
 801254c:	460b      	mov	r3, r1
 801254e:	817b      	strh	r3, [r7, #10]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8012550:	68fb      	ldr	r3, [r7, #12]
 8012552:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8012554:	617b      	str	r3, [r7, #20]

  /* Generate Start condition if first transfer */
  if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
 8012556:	697b      	ldr	r3, [r7, #20]
 8012558:	2b08      	cmp	r3, #8
 801255a:	d006      	beq.n	801256a <I2C_MasterRequestWrite+0x2a>
 801255c:	697b      	ldr	r3, [r7, #20]
 801255e:	2b01      	cmp	r3, #1
 8012560:	d003      	beq.n	801256a <I2C_MasterRequestWrite+0x2a>
 8012562:	697b      	ldr	r3, [r7, #20]
 8012564:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 8012568:	d108      	bne.n	801257c <I2C_MasterRequestWrite+0x3c>
  {
    /* Generate Start */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 801256a:	68fb      	ldr	r3, [r7, #12]
 801256c:	681b      	ldr	r3, [r3, #0]
 801256e:	681a      	ldr	r2, [r3, #0]
 8012570:	68fb      	ldr	r3, [r7, #12]
 8012572:	681b      	ldr	r3, [r3, #0]
 8012574:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8012578:	601a      	str	r2, [r3, #0]
 801257a:	e00b      	b.n	8012594 <I2C_MasterRequestWrite+0x54>
  }
  else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
 801257c:	68fb      	ldr	r3, [r7, #12]
 801257e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012580:	2b12      	cmp	r3, #18
 8012582:	d107      	bne.n	8012594 <I2C_MasterRequestWrite+0x54>
  {
    /* Generate ReStart */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8012584:	68fb      	ldr	r3, [r7, #12]
 8012586:	681b      	ldr	r3, [r3, #0]
 8012588:	681a      	ldr	r2, [r3, #0]
 801258a:	68fb      	ldr	r3, [r7, #12]
 801258c:	681b      	ldr	r3, [r3, #0]
 801258e:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8012592:	601a      	str	r2, [r3, #0]
  {
    /* Do nothing */
  }

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 8012594:	683b      	ldr	r3, [r7, #0]
 8012596:	9300      	str	r3, [sp, #0]
 8012598:	687b      	ldr	r3, [r7, #4]
 801259a:	2200      	movs	r2, #0
 801259c:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 80125a0:	68f8      	ldr	r0, [r7, #12]
 80125a2:	f000 fb43 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 80125a6:	4603      	mov	r3, r0
 80125a8:	2b00      	cmp	r3, #0
 80125aa:	d00d      	beq.n	80125c8 <I2C_MasterRequestWrite+0x88>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 80125ac:	68fb      	ldr	r3, [r7, #12]
 80125ae:	681b      	ldr	r3, [r3, #0]
 80125b0:	681b      	ldr	r3, [r3, #0]
 80125b2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80125b6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80125ba:	d103      	bne.n	80125c4 <I2C_MasterRequestWrite+0x84>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 80125bc:	68fb      	ldr	r3, [r7, #12]
 80125be:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80125c2:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 80125c4:	2303      	movs	r3, #3
 80125c6:	e035      	b.n	8012634 <I2C_MasterRequestWrite+0xf4>
  }

  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80125c8:	68fb      	ldr	r3, [r7, #12]
 80125ca:	691b      	ldr	r3, [r3, #16]
 80125cc:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80125d0:	d108      	bne.n	80125e4 <I2C_MasterRequestWrite+0xa4>
  {
    /* Send slave address */
    hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 80125d2:	897b      	ldrh	r3, [r7, #10]
 80125d4:	b2db      	uxtb	r3, r3
 80125d6:	461a      	mov	r2, r3
 80125d8:	68fb      	ldr	r3, [r7, #12]
 80125da:	681b      	ldr	r3, [r3, #0]
 80125dc:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 80125e0:	611a      	str	r2, [r3, #16]
 80125e2:	e01b      	b.n	801261c <I2C_MasterRequestWrite+0xdc>
  }
  else
  {
    /* Send header of slave address */
    hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
 80125e4:	897b      	ldrh	r3, [r7, #10]
 80125e6:	11db      	asrs	r3, r3, #7
 80125e8:	b2db      	uxtb	r3, r3
 80125ea:	f003 0306 	and.w	r3, r3, #6
 80125ee:	b2db      	uxtb	r3, r3
 80125f0:	f063 030f 	orn	r3, r3, #15
 80125f4:	b2da      	uxtb	r2, r3
 80125f6:	68fb      	ldr	r3, [r7, #12]
 80125f8:	681b      	ldr	r3, [r3, #0]
 80125fa:	611a      	str	r2, [r3, #16]

    /* Wait until ADD10 flag is set */
    if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
 80125fc:	683b      	ldr	r3, [r7, #0]
 80125fe:	687a      	ldr	r2, [r7, #4]
 8012600:	490e      	ldr	r1, [pc, #56]	@ (801263c <I2C_MasterRequestWrite+0xfc>)
 8012602:	68f8      	ldr	r0, [r7, #12]
 8012604:	f000 fb8c 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8012608:	4603      	mov	r3, r0
 801260a:	2b00      	cmp	r3, #0
 801260c:	d001      	beq.n	8012612 <I2C_MasterRequestWrite+0xd2>
    {
      return HAL_ERROR;
 801260e:	2301      	movs	r3, #1
 8012610:	e010      	b.n	8012634 <I2C_MasterRequestWrite+0xf4>
    }

    /* Send slave address */
    hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
 8012612:	897b      	ldrh	r3, [r7, #10]
 8012614:	b2da      	uxtb	r2, r3
 8012616:	68fb      	ldr	r3, [r7, #12]
 8012618:	681b      	ldr	r3, [r3, #0]
 801261a:	611a      	str	r2, [r3, #16]
  }

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 801261c:	683b      	ldr	r3, [r7, #0]
 801261e:	687a      	ldr	r2, [r7, #4]
 8012620:	4907      	ldr	r1, [pc, #28]	@ (8012640 <I2C_MasterRequestWrite+0x100>)
 8012622:	68f8      	ldr	r0, [r7, #12]
 8012624:	f000 fb7c 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8012628:	4603      	mov	r3, r0
 801262a:	2b00      	cmp	r3, #0
 801262c:	d001      	beq.n	8012632 <I2C_MasterRequestWrite+0xf2>
  {
    return HAL_ERROR;
 801262e:	2301      	movs	r3, #1
 8012630:	e000      	b.n	8012634 <I2C_MasterRequestWrite+0xf4>
  }

  return HAL_OK;
 8012632:	2300      	movs	r3, #0
}
 8012634:	4618      	mov	r0, r3
 8012636:	3718      	adds	r7, #24
 8012638:	46bd      	mov	sp, r7
 801263a:	bd80      	pop	{r7, pc}
 801263c:	00010008 	.word	0x00010008
 8012640:	00010002 	.word	0x00010002

08012644 <I2C_MasterRequestRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
{
 8012644:	b580      	push	{r7, lr}
 8012646:	b088      	sub	sp, #32
 8012648:	af02      	add	r7, sp, #8
 801264a:	60f8      	str	r0, [r7, #12]
 801264c:	607a      	str	r2, [r7, #4]
 801264e:	603b      	str	r3, [r7, #0]
 8012650:	460b      	mov	r3, r1
 8012652:	817b      	strh	r3, [r7, #10]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 8012654:	68fb      	ldr	r3, [r7, #12]
 8012656:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8012658:	617b      	str	r3, [r7, #20]

  /* Enable Acknowledge */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 801265a:	68fb      	ldr	r3, [r7, #12]
 801265c:	681b      	ldr	r3, [r3, #0]
 801265e:	681a      	ldr	r2, [r3, #0]
 8012660:	68fb      	ldr	r3, [r7, #12]
 8012662:	681b      	ldr	r3, [r3, #0]
 8012664:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8012668:	601a      	str	r2, [r3, #0]

  /* Generate Start condition if first transfer */
  if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
 801266a:	697b      	ldr	r3, [r7, #20]
 801266c:	2b08      	cmp	r3, #8
 801266e:	d006      	beq.n	801267e <I2C_MasterRequestRead+0x3a>
 8012670:	697b      	ldr	r3, [r7, #20]
 8012672:	2b01      	cmp	r3, #1
 8012674:	d003      	beq.n	801267e <I2C_MasterRequestRead+0x3a>
 8012676:	697b      	ldr	r3, [r7, #20]
 8012678:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 801267c:	d108      	bne.n	8012690 <I2C_MasterRequestRead+0x4c>
  {
    /* Generate Start */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 801267e:	68fb      	ldr	r3, [r7, #12]
 8012680:	681b      	ldr	r3, [r3, #0]
 8012682:	681a      	ldr	r2, [r3, #0]
 8012684:	68fb      	ldr	r3, [r7, #12]
 8012686:	681b      	ldr	r3, [r3, #0]
 8012688:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 801268c:	601a      	str	r2, [r3, #0]
 801268e:	e00b      	b.n	80126a8 <I2C_MasterRequestRead+0x64>
  }
  else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
 8012690:	68fb      	ldr	r3, [r7, #12]
 8012692:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012694:	2b11      	cmp	r3, #17
 8012696:	d107      	bne.n	80126a8 <I2C_MasterRequestRead+0x64>
  {
    /* Generate ReStart */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8012698:	68fb      	ldr	r3, [r7, #12]
 801269a:	681b      	ldr	r3, [r3, #0]
 801269c:	681a      	ldr	r2, [r3, #0]
 801269e:	68fb      	ldr	r3, [r7, #12]
 80126a0:	681b      	ldr	r3, [r3, #0]
 80126a2:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80126a6:	601a      	str	r2, [r3, #0]
  {
    /* Do nothing */
  }

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 80126a8:	683b      	ldr	r3, [r7, #0]
 80126aa:	9300      	str	r3, [sp, #0]
 80126ac:	687b      	ldr	r3, [r7, #4]
 80126ae:	2200      	movs	r2, #0
 80126b0:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 80126b4:	68f8      	ldr	r0, [r7, #12]
 80126b6:	f000 fab9 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 80126ba:	4603      	mov	r3, r0
 80126bc:	2b00      	cmp	r3, #0
 80126be:	d00d      	beq.n	80126dc <I2C_MasterRequestRead+0x98>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 80126c0:	68fb      	ldr	r3, [r7, #12]
 80126c2:	681b      	ldr	r3, [r3, #0]
 80126c4:	681b      	ldr	r3, [r3, #0]
 80126c6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80126ca:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80126ce:	d103      	bne.n	80126d8 <I2C_MasterRequestRead+0x94>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 80126d0:	68fb      	ldr	r3, [r7, #12]
 80126d2:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80126d6:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 80126d8:	2303      	movs	r3, #3
 80126da:	e079      	b.n	80127d0 <I2C_MasterRequestRead+0x18c>
  }

  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80126dc:	68fb      	ldr	r3, [r7, #12]
 80126de:	691b      	ldr	r3, [r3, #16]
 80126e0:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80126e4:	d108      	bne.n	80126f8 <I2C_MasterRequestRead+0xb4>
  {
    /* Send slave address */
    hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
 80126e6:	897b      	ldrh	r3, [r7, #10]
 80126e8:	b2db      	uxtb	r3, r3
 80126ea:	f043 0301 	orr.w	r3, r3, #1
 80126ee:	b2da      	uxtb	r2, r3
 80126f0:	68fb      	ldr	r3, [r7, #12]
 80126f2:	681b      	ldr	r3, [r3, #0]
 80126f4:	611a      	str	r2, [r3, #16]
 80126f6:	e05f      	b.n	80127b8 <I2C_MasterRequestRead+0x174>
  }
  else
  {
    /* Send header of slave address */
    hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
 80126f8:	897b      	ldrh	r3, [r7, #10]
 80126fa:	11db      	asrs	r3, r3, #7
 80126fc:	b2db      	uxtb	r3, r3
 80126fe:	f003 0306 	and.w	r3, r3, #6
 8012702:	b2db      	uxtb	r3, r3
 8012704:	f063 030f 	orn	r3, r3, #15
 8012708:	b2da      	uxtb	r2, r3
 801270a:	68fb      	ldr	r3, [r7, #12]
 801270c:	681b      	ldr	r3, [r3, #0]
 801270e:	611a      	str	r2, [r3, #16]

    /* Wait until ADD10 flag is set */
    if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
 8012710:	683b      	ldr	r3, [r7, #0]
 8012712:	687a      	ldr	r2, [r7, #4]
 8012714:	4930      	ldr	r1, [pc, #192]	@ (80127d8 <I2C_MasterRequestRead+0x194>)
 8012716:	68f8      	ldr	r0, [r7, #12]
 8012718:	f000 fb02 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 801271c:	4603      	mov	r3, r0
 801271e:	2b00      	cmp	r3, #0
 8012720:	d001      	beq.n	8012726 <I2C_MasterRequestRead+0xe2>
    {
      return HAL_ERROR;
 8012722:	2301      	movs	r3, #1
 8012724:	e054      	b.n	80127d0 <I2C_MasterRequestRead+0x18c>
    }

    /* Send slave address */
    hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
 8012726:	897b      	ldrh	r3, [r7, #10]
 8012728:	b2da      	uxtb	r2, r3
 801272a:	68fb      	ldr	r3, [r7, #12]
 801272c:	681b      	ldr	r3, [r3, #0]
 801272e:	611a      	str	r2, [r3, #16]

    /* Wait until ADDR flag is set */
    if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 8012730:	683b      	ldr	r3, [r7, #0]
 8012732:	687a      	ldr	r2, [r7, #4]
 8012734:	4929      	ldr	r1, [pc, #164]	@ (80127dc <I2C_MasterRequestRead+0x198>)
 8012736:	68f8      	ldr	r0, [r7, #12]
 8012738:	f000 faf2 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 801273c:	4603      	mov	r3, r0
 801273e:	2b00      	cmp	r3, #0
 8012740:	d001      	beq.n	8012746 <I2C_MasterRequestRead+0x102>
    {
      return HAL_ERROR;
 8012742:	2301      	movs	r3, #1
 8012744:	e044      	b.n	80127d0 <I2C_MasterRequestRead+0x18c>
    }

    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8012746:	2300      	movs	r3, #0
 8012748:	613b      	str	r3, [r7, #16]
 801274a:	68fb      	ldr	r3, [r7, #12]
 801274c:	681b      	ldr	r3, [r3, #0]
 801274e:	695b      	ldr	r3, [r3, #20]
 8012750:	613b      	str	r3, [r7, #16]
 8012752:	68fb      	ldr	r3, [r7, #12]
 8012754:	681b      	ldr	r3, [r3, #0]
 8012756:	699b      	ldr	r3, [r3, #24]
 8012758:	613b      	str	r3, [r7, #16]
 801275a:	693b      	ldr	r3, [r7, #16]

    /* Generate Restart */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 801275c:	68fb      	ldr	r3, [r7, #12]
 801275e:	681b      	ldr	r3, [r3, #0]
 8012760:	681a      	ldr	r2, [r3, #0]
 8012762:	68fb      	ldr	r3, [r7, #12]
 8012764:	681b      	ldr	r3, [r3, #0]
 8012766:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 801276a:	601a      	str	r2, [r3, #0]

    /* Wait until SB flag is set */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 801276c:	683b      	ldr	r3, [r7, #0]
 801276e:	9300      	str	r3, [sp, #0]
 8012770:	687b      	ldr	r3, [r7, #4]
 8012772:	2200      	movs	r2, #0
 8012774:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 8012778:	68f8      	ldr	r0, [r7, #12]
 801277a:	f000 fa57 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 801277e:	4603      	mov	r3, r0
 8012780:	2b00      	cmp	r3, #0
 8012782:	d00d      	beq.n	80127a0 <I2C_MasterRequestRead+0x15c>
    {
      if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 8012784:	68fb      	ldr	r3, [r7, #12]
 8012786:	681b      	ldr	r3, [r3, #0]
 8012788:	681b      	ldr	r3, [r3, #0]
 801278a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 801278e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8012792:	d103      	bne.n	801279c <I2C_MasterRequestRead+0x158>
      {
        hi2c->ErrorCode = HAL_I2C_WRONG_START;
 8012794:	68fb      	ldr	r3, [r7, #12]
 8012796:	f44f 7200 	mov.w	r2, #512	@ 0x200
 801279a:	641a      	str	r2, [r3, #64]	@ 0x40
      }
      return HAL_TIMEOUT;
 801279c:	2303      	movs	r3, #3
 801279e:	e017      	b.n	80127d0 <I2C_MasterRequestRead+0x18c>
    }

    /* Send header of slave address */
    hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
 80127a0:	897b      	ldrh	r3, [r7, #10]
 80127a2:	11db      	asrs	r3, r3, #7
 80127a4:	b2db      	uxtb	r3, r3
 80127a6:	f003 0306 	and.w	r3, r3, #6
 80127aa:	b2db      	uxtb	r3, r3
 80127ac:	f063 030e 	orn	r3, r3, #14
 80127b0:	b2da      	uxtb	r2, r3
 80127b2:	68fb      	ldr	r3, [r7, #12]
 80127b4:	681b      	ldr	r3, [r3, #0]
 80127b6:	611a      	str	r2, [r3, #16]
  }

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 80127b8:	683b      	ldr	r3, [r7, #0]
 80127ba:	687a      	ldr	r2, [r7, #4]
 80127bc:	4907      	ldr	r1, [pc, #28]	@ (80127dc <I2C_MasterRequestRead+0x198>)
 80127be:	68f8      	ldr	r0, [r7, #12]
 80127c0:	f000 faae 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 80127c4:	4603      	mov	r3, r0
 80127c6:	2b00      	cmp	r3, #0
 80127c8:	d001      	beq.n	80127ce <I2C_MasterRequestRead+0x18a>
  {
    return HAL_ERROR;
 80127ca:	2301      	movs	r3, #1
 80127cc:	e000      	b.n	80127d0 <I2C_MasterRequestRead+0x18c>
  }

  return HAL_OK;
 80127ce:	2300      	movs	r3, #0
}
 80127d0:	4618      	mov	r0, r3
 80127d2:	3718      	adds	r7, #24
 80127d4:	46bd      	mov	sp, r7
 80127d6:	bd80      	pop	{r7, pc}
 80127d8:	00010008 	.word	0x00010008
 80127dc:	00010002 	.word	0x00010002

080127e0 <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 80127e0:	b580      	push	{r7, lr}
 80127e2:	b088      	sub	sp, #32
 80127e4:	af02      	add	r7, sp, #8
 80127e6:	60f8      	str	r0, [r7, #12]
 80127e8:	4608      	mov	r0, r1
 80127ea:	4611      	mov	r1, r2
 80127ec:	461a      	mov	r2, r3
 80127ee:	4603      	mov	r3, r0
 80127f0:	817b      	strh	r3, [r7, #10]
 80127f2:	460b      	mov	r3, r1
 80127f4:	813b      	strh	r3, [r7, #8]
 80127f6:	4613      	mov	r3, r2
 80127f8:	80fb      	strh	r3, [r7, #6]
  /* Generate Start */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 80127fa:	68fb      	ldr	r3, [r7, #12]
 80127fc:	681b      	ldr	r3, [r3, #0]
 80127fe:	681a      	ldr	r2, [r3, #0]
 8012800:	68fb      	ldr	r3, [r7, #12]
 8012802:	681b      	ldr	r3, [r3, #0]
 8012804:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8012808:	601a      	str	r2, [r3, #0]

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 801280a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801280c:	9300      	str	r3, [sp, #0]
 801280e:	6a3b      	ldr	r3, [r7, #32]
 8012810:	2200      	movs	r2, #0
 8012812:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 8012816:	68f8      	ldr	r0, [r7, #12]
 8012818:	f000 fa08 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 801281c:	4603      	mov	r3, r0
 801281e:	2b00      	cmp	r3, #0
 8012820:	d00d      	beq.n	801283e <I2C_RequestMemoryWrite+0x5e>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 8012822:	68fb      	ldr	r3, [r7, #12]
 8012824:	681b      	ldr	r3, [r3, #0]
 8012826:	681b      	ldr	r3, [r3, #0]
 8012828:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 801282c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8012830:	d103      	bne.n	801283a <I2C_RequestMemoryWrite+0x5a>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 8012832:	68fb      	ldr	r3, [r7, #12]
 8012834:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8012838:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 801283a:	2303      	movs	r3, #3
 801283c:	e05f      	b.n	80128fe <I2C_RequestMemoryWrite+0x11e>
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 801283e:	897b      	ldrh	r3, [r7, #10]
 8012840:	b2db      	uxtb	r3, r3
 8012842:	461a      	mov	r2, r3
 8012844:	68fb      	ldr	r3, [r7, #12]
 8012846:	681b      	ldr	r3, [r3, #0]
 8012848:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 801284c:	611a      	str	r2, [r3, #16]

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 801284e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012850:	6a3a      	ldr	r2, [r7, #32]
 8012852:	492d      	ldr	r1, [pc, #180]	@ (8012908 <I2C_RequestMemoryWrite+0x128>)
 8012854:	68f8      	ldr	r0, [r7, #12]
 8012856:	f000 fa63 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 801285a:	4603      	mov	r3, r0
 801285c:	2b00      	cmp	r3, #0
 801285e:	d001      	beq.n	8012864 <I2C_RequestMemoryWrite+0x84>
  {
    return HAL_ERROR;
 8012860:	2301      	movs	r3, #1
 8012862:	e04c      	b.n	80128fe <I2C_RequestMemoryWrite+0x11e>
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8012864:	2300      	movs	r3, #0
 8012866:	617b      	str	r3, [r7, #20]
 8012868:	68fb      	ldr	r3, [r7, #12]
 801286a:	681b      	ldr	r3, [r3, #0]
 801286c:	695b      	ldr	r3, [r3, #20]
 801286e:	617b      	str	r3, [r7, #20]
 8012870:	68fb      	ldr	r3, [r7, #12]
 8012872:	681b      	ldr	r3, [r3, #0]
 8012874:	699b      	ldr	r3, [r3, #24]
 8012876:	617b      	str	r3, [r7, #20]
 8012878:	697b      	ldr	r3, [r7, #20]

  /* Wait until TXE flag is set */
  if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 801287a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801287c:	6a39      	ldr	r1, [r7, #32]
 801287e:	68f8      	ldr	r0, [r7, #12]
 8012880:	f000 faee 	bl	8012e60 <I2C_WaitOnTXEFlagUntilTimeout>
 8012884:	4603      	mov	r3, r0
 8012886:	2b00      	cmp	r3, #0
 8012888:	d00d      	beq.n	80128a6 <I2C_RequestMemoryWrite+0xc6>
  {
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 801288a:	68fb      	ldr	r3, [r7, #12]
 801288c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801288e:	2b04      	cmp	r3, #4
 8012890:	d107      	bne.n	80128a2 <I2C_RequestMemoryWrite+0xc2>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8012892:	68fb      	ldr	r3, [r7, #12]
 8012894:	681b      	ldr	r3, [r3, #0]
 8012896:	681a      	ldr	r2, [r3, #0]
 8012898:	68fb      	ldr	r3, [r7, #12]
 801289a:	681b      	ldr	r3, [r3, #0]
 801289c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80128a0:	601a      	str	r2, [r3, #0]
    }
    return HAL_ERROR;
 80128a2:	2301      	movs	r3, #1
 80128a4:	e02b      	b.n	80128fe <I2C_RequestMemoryWrite+0x11e>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80128a6:	88fb      	ldrh	r3, [r7, #6]
 80128a8:	2b01      	cmp	r3, #1
 80128aa:	d105      	bne.n	80128b8 <I2C_RequestMemoryWrite+0xd8>
  {
    /* Send Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 80128ac:	893b      	ldrh	r3, [r7, #8]
 80128ae:	b2da      	uxtb	r2, r3
 80128b0:	68fb      	ldr	r3, [r7, #12]
 80128b2:	681b      	ldr	r3, [r3, #0]
 80128b4:	611a      	str	r2, [r3, #16]
 80128b6:	e021      	b.n	80128fc <I2C_RequestMemoryWrite+0x11c>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 80128b8:	893b      	ldrh	r3, [r7, #8]
 80128ba:	0a1b      	lsrs	r3, r3, #8
 80128bc:	b29b      	uxth	r3, r3
 80128be:	b2da      	uxtb	r2, r3
 80128c0:	68fb      	ldr	r3, [r7, #12]
 80128c2:	681b      	ldr	r3, [r3, #0]
 80128c4:	611a      	str	r2, [r3, #16]

    /* Wait until TXE flag is set */
    if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80128c6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80128c8:	6a39      	ldr	r1, [r7, #32]
 80128ca:	68f8      	ldr	r0, [r7, #12]
 80128cc:	f000 fac8 	bl	8012e60 <I2C_WaitOnTXEFlagUntilTimeout>
 80128d0:	4603      	mov	r3, r0
 80128d2:	2b00      	cmp	r3, #0
 80128d4:	d00d      	beq.n	80128f2 <I2C_RequestMemoryWrite+0x112>
    {
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80128d6:	68fb      	ldr	r3, [r7, #12]
 80128d8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80128da:	2b04      	cmp	r3, #4
 80128dc:	d107      	bne.n	80128ee <I2C_RequestMemoryWrite+0x10e>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80128de:	68fb      	ldr	r3, [r7, #12]
 80128e0:	681b      	ldr	r3, [r3, #0]
 80128e2:	681a      	ldr	r2, [r3, #0]
 80128e4:	68fb      	ldr	r3, [r7, #12]
 80128e6:	681b      	ldr	r3, [r3, #0]
 80128e8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80128ec:	601a      	str	r2, [r3, #0]
      }
      return HAL_ERROR;
 80128ee:	2301      	movs	r3, #1
 80128f0:	e005      	b.n	80128fe <I2C_RequestMemoryWrite+0x11e>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 80128f2:	893b      	ldrh	r3, [r7, #8]
 80128f4:	b2da      	uxtb	r2, r3
 80128f6:	68fb      	ldr	r3, [r7, #12]
 80128f8:	681b      	ldr	r3, [r3, #0]
 80128fa:	611a      	str	r2, [r3, #16]
  }

  return HAL_OK;
 80128fc:	2300      	movs	r3, #0
}
 80128fe:	4618      	mov	r0, r3
 8012900:	3718      	adds	r7, #24
 8012902:	46bd      	mov	sp, r7
 8012904:	bd80      	pop	{r7, pc}
 8012906:	bf00      	nop
 8012908:	00010002 	.word	0x00010002

0801290c <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 801290c:	b580      	push	{r7, lr}
 801290e:	b088      	sub	sp, #32
 8012910:	af02      	add	r7, sp, #8
 8012912:	60f8      	str	r0, [r7, #12]
 8012914:	4608      	mov	r0, r1
 8012916:	4611      	mov	r1, r2
 8012918:	461a      	mov	r2, r3
 801291a:	4603      	mov	r3, r0
 801291c:	817b      	strh	r3, [r7, #10]
 801291e:	460b      	mov	r3, r1
 8012920:	813b      	strh	r3, [r7, #8]
 8012922:	4613      	mov	r3, r2
 8012924:	80fb      	strh	r3, [r7, #6]
  /* Enable Acknowledge */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8012926:	68fb      	ldr	r3, [r7, #12]
 8012928:	681b      	ldr	r3, [r3, #0]
 801292a:	681a      	ldr	r2, [r3, #0]
 801292c:	68fb      	ldr	r3, [r7, #12]
 801292e:	681b      	ldr	r3, [r3, #0]
 8012930:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8012934:	601a      	str	r2, [r3, #0]

  /* Generate Start */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8012936:	68fb      	ldr	r3, [r7, #12]
 8012938:	681b      	ldr	r3, [r3, #0]
 801293a:	681a      	ldr	r2, [r3, #0]
 801293c:	68fb      	ldr	r3, [r7, #12]
 801293e:	681b      	ldr	r3, [r3, #0]
 8012940:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8012944:	601a      	str	r2, [r3, #0]

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 8012946:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012948:	9300      	str	r3, [sp, #0]
 801294a:	6a3b      	ldr	r3, [r7, #32]
 801294c:	2200      	movs	r2, #0
 801294e:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 8012952:	68f8      	ldr	r0, [r7, #12]
 8012954:	f000 f96a 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 8012958:	4603      	mov	r3, r0
 801295a:	2b00      	cmp	r3, #0
 801295c:	d00d      	beq.n	801297a <I2C_RequestMemoryRead+0x6e>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 801295e:	68fb      	ldr	r3, [r7, #12]
 8012960:	681b      	ldr	r3, [r3, #0]
 8012962:	681b      	ldr	r3, [r3, #0]
 8012964:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8012968:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801296c:	d103      	bne.n	8012976 <I2C_RequestMemoryRead+0x6a>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 801296e:	68fb      	ldr	r3, [r7, #12]
 8012970:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8012974:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 8012976:	2303      	movs	r3, #3
 8012978:	e0aa      	b.n	8012ad0 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 801297a:	897b      	ldrh	r3, [r7, #10]
 801297c:	b2db      	uxtb	r3, r3
 801297e:	461a      	mov	r2, r3
 8012980:	68fb      	ldr	r3, [r7, #12]
 8012982:	681b      	ldr	r3, [r3, #0]
 8012984:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 8012988:	611a      	str	r2, [r3, #16]

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 801298a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801298c:	6a3a      	ldr	r2, [r7, #32]
 801298e:	4952      	ldr	r1, [pc, #328]	@ (8012ad8 <I2C_RequestMemoryRead+0x1cc>)
 8012990:	68f8      	ldr	r0, [r7, #12]
 8012992:	f000 f9c5 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8012996:	4603      	mov	r3, r0
 8012998:	2b00      	cmp	r3, #0
 801299a:	d001      	beq.n	80129a0 <I2C_RequestMemoryRead+0x94>
  {
    return HAL_ERROR;
 801299c:	2301      	movs	r3, #1
 801299e:	e097      	b.n	8012ad0 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80129a0:	2300      	movs	r3, #0
 80129a2:	617b      	str	r3, [r7, #20]
 80129a4:	68fb      	ldr	r3, [r7, #12]
 80129a6:	681b      	ldr	r3, [r3, #0]
 80129a8:	695b      	ldr	r3, [r3, #20]
 80129aa:	617b      	str	r3, [r7, #20]
 80129ac:	68fb      	ldr	r3, [r7, #12]
 80129ae:	681b      	ldr	r3, [r3, #0]
 80129b0:	699b      	ldr	r3, [r3, #24]
 80129b2:	617b      	str	r3, [r7, #20]
 80129b4:	697b      	ldr	r3, [r7, #20]

  /* Wait until TXE flag is set */
  if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80129b6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80129b8:	6a39      	ldr	r1, [r7, #32]
 80129ba:	68f8      	ldr	r0, [r7, #12]
 80129bc:	f000 fa50 	bl	8012e60 <I2C_WaitOnTXEFlagUntilTimeout>
 80129c0:	4603      	mov	r3, r0
 80129c2:	2b00      	cmp	r3, #0
 80129c4:	d00d      	beq.n	80129e2 <I2C_RequestMemoryRead+0xd6>
  {
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80129c6:	68fb      	ldr	r3, [r7, #12]
 80129c8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80129ca:	2b04      	cmp	r3, #4
 80129cc:	d107      	bne.n	80129de <I2C_RequestMemoryRead+0xd2>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80129ce:	68fb      	ldr	r3, [r7, #12]
 80129d0:	681b      	ldr	r3, [r3, #0]
 80129d2:	681a      	ldr	r2, [r3, #0]
 80129d4:	68fb      	ldr	r3, [r7, #12]
 80129d6:	681b      	ldr	r3, [r3, #0]
 80129d8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80129dc:	601a      	str	r2, [r3, #0]
    }
    return HAL_ERROR;
 80129de:	2301      	movs	r3, #1
 80129e0:	e076      	b.n	8012ad0 <I2C_RequestMemoryRead+0x1c4>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 80129e2:	88fb      	ldrh	r3, [r7, #6]
 80129e4:	2b01      	cmp	r3, #1
 80129e6:	d105      	bne.n	80129f4 <I2C_RequestMemoryRead+0xe8>
  {
    /* Send Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 80129e8:	893b      	ldrh	r3, [r7, #8]
 80129ea:	b2da      	uxtb	r2, r3
 80129ec:	68fb      	ldr	r3, [r7, #12]
 80129ee:	681b      	ldr	r3, [r3, #0]
 80129f0:	611a      	str	r2, [r3, #16]
 80129f2:	e021      	b.n	8012a38 <I2C_RequestMemoryRead+0x12c>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 80129f4:	893b      	ldrh	r3, [r7, #8]
 80129f6:	0a1b      	lsrs	r3, r3, #8
 80129f8:	b29b      	uxth	r3, r3
 80129fa:	b2da      	uxtb	r2, r3
 80129fc:	68fb      	ldr	r3, [r7, #12]
 80129fe:	681b      	ldr	r3, [r3, #0]
 8012a00:	611a      	str	r2, [r3, #16]

    /* Wait until TXE flag is set */
    if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8012a02:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a04:	6a39      	ldr	r1, [r7, #32]
 8012a06:	68f8      	ldr	r0, [r7, #12]
 8012a08:	f000 fa2a 	bl	8012e60 <I2C_WaitOnTXEFlagUntilTimeout>
 8012a0c:	4603      	mov	r3, r0
 8012a0e:	2b00      	cmp	r3, #0
 8012a10:	d00d      	beq.n	8012a2e <I2C_RequestMemoryRead+0x122>
    {
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8012a12:	68fb      	ldr	r3, [r7, #12]
 8012a14:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012a16:	2b04      	cmp	r3, #4
 8012a18:	d107      	bne.n	8012a2a <I2C_RequestMemoryRead+0x11e>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8012a1a:	68fb      	ldr	r3, [r7, #12]
 8012a1c:	681b      	ldr	r3, [r3, #0]
 8012a1e:	681a      	ldr	r2, [r3, #0]
 8012a20:	68fb      	ldr	r3, [r7, #12]
 8012a22:	681b      	ldr	r3, [r3, #0]
 8012a24:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8012a28:	601a      	str	r2, [r3, #0]
      }
      return HAL_ERROR;
 8012a2a:	2301      	movs	r3, #1
 8012a2c:	e050      	b.n	8012ad0 <I2C_RequestMemoryRead+0x1c4>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 8012a2e:	893b      	ldrh	r3, [r7, #8]
 8012a30:	b2da      	uxtb	r2, r3
 8012a32:	68fb      	ldr	r3, [r7, #12]
 8012a34:	681b      	ldr	r3, [r3, #0]
 8012a36:	611a      	str	r2, [r3, #16]
  }

  /* Wait until TXE flag is set */
  if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8012a38:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012a3a:	6a39      	ldr	r1, [r7, #32]
 8012a3c:	68f8      	ldr	r0, [r7, #12]
 8012a3e:	f000 fa0f 	bl	8012e60 <I2C_WaitOnTXEFlagUntilTimeout>
 8012a42:	4603      	mov	r3, r0
 8012a44:	2b00      	cmp	r3, #0
 8012a46:	d00d      	beq.n	8012a64 <I2C_RequestMemoryRead+0x158>
  {
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8012a48:	68fb      	ldr	r3, [r7, #12]
 8012a4a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012a4c:	2b04      	cmp	r3, #4
 8012a4e:	d107      	bne.n	8012a60 <I2C_RequestMemoryRead+0x154>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8012a50:	68fb      	ldr	r3, [r7, #12]
 8012a52:	681b      	ldr	r3, [r3, #0]
 8012a54:	681a      	ldr	r2, [r3, #0]
 8012a56:	68fb      	ldr	r3, [r7, #12]
 8012a58:	681b      	ldr	r3, [r3, #0]
 8012a5a:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8012a5e:	601a      	str	r2, [r3, #0]
    }
    return HAL_ERROR;
 8012a60:	2301      	movs	r3, #1
 8012a62:	e035      	b.n	8012ad0 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Generate Restart */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8012a64:	68fb      	ldr	r3, [r7, #12]
 8012a66:	681b      	ldr	r3, [r3, #0]
 8012a68:	681a      	ldr	r2, [r3, #0]
 8012a6a:	68fb      	ldr	r3, [r7, #12]
 8012a6c:	681b      	ldr	r3, [r3, #0]
 8012a6e:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8012a72:	601a      	str	r2, [r3, #0]

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 8012a74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012a76:	9300      	str	r3, [sp, #0]
 8012a78:	6a3b      	ldr	r3, [r7, #32]
 8012a7a:	2200      	movs	r2, #0
 8012a7c:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 8012a80:	68f8      	ldr	r0, [r7, #12]
 8012a82:	f000 f8d3 	bl	8012c2c <I2C_WaitOnFlagUntilTimeout>
 8012a86:	4603      	mov	r3, r0
 8012a88:	2b00      	cmp	r3, #0
 8012a8a:	d00d      	beq.n	8012aa8 <I2C_RequestMemoryRead+0x19c>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 8012a8c:	68fb      	ldr	r3, [r7, #12]
 8012a8e:	681b      	ldr	r3, [r3, #0]
 8012a90:	681b      	ldr	r3, [r3, #0]
 8012a92:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8012a96:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8012a9a:	d103      	bne.n	8012aa4 <I2C_RequestMemoryRead+0x198>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 8012a9c:	68fb      	ldr	r3, [r7, #12]
 8012a9e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8012aa2:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 8012aa4:	2303      	movs	r3, #3
 8012aa6:	e013      	b.n	8012ad0 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
 8012aa8:	897b      	ldrh	r3, [r7, #10]
 8012aaa:	b2db      	uxtb	r3, r3
 8012aac:	f043 0301 	orr.w	r3, r3, #1
 8012ab0:	b2da      	uxtb	r2, r3
 8012ab2:	68fb      	ldr	r3, [r7, #12]
 8012ab4:	681b      	ldr	r3, [r3, #0]
 8012ab6:	611a      	str	r2, [r3, #16]

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 8012ab8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012aba:	6a3a      	ldr	r2, [r7, #32]
 8012abc:	4906      	ldr	r1, [pc, #24]	@ (8012ad8 <I2C_RequestMemoryRead+0x1cc>)
 8012abe:	68f8      	ldr	r0, [r7, #12]
 8012ac0:	f000 f92e 	bl	8012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8012ac4:	4603      	mov	r3, r0
 8012ac6:	2b00      	cmp	r3, #0
 8012ac8:	d001      	beq.n	8012ace <I2C_RequestMemoryRead+0x1c2>
  {
    return HAL_ERROR;
 8012aca:	2301      	movs	r3, #1
 8012acc:	e000      	b.n	8012ad0 <I2C_RequestMemoryRead+0x1c4>
  }

  return HAL_OK;
 8012ace:	2300      	movs	r3, #0
}
 8012ad0:	4618      	mov	r0, r3
 8012ad2:	3718      	adds	r7, #24
 8012ad4:	46bd      	mov	sp, r7
 8012ad6:	bd80      	pop	{r7, pc}
 8012ad8:	00010002 	.word	0x00010002

08012adc <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
 8012adc:	b580      	push	{r7, lr}
 8012ade:	b086      	sub	sp, #24
 8012ae0:	af00      	add	r7, sp, #0
 8012ae2:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8012ae4:	2300      	movs	r3, #0
 8012ae6:	60fb      	str	r3, [r7, #12]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 8012ae8:	687b      	ldr	r3, [r7, #4]
 8012aea:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012aec:	617b      	str	r3, [r7, #20]

  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8012aee:	697b      	ldr	r3, [r7, #20]
 8012af0:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8012af4:	74fb      	strb	r3, [r7, #19]

  /* During abort treatment, check that there is no pending STOP request */
  /* Wait until STOP flag is reset */
  count = I2C_TIMEOUT_FLAG * (SystemCoreClock / 25U / 1000U);
 8012af6:	4b4b      	ldr	r3, [pc, #300]	@ (8012c24 <I2C_DMAAbort+0x148>)
 8012af8:	681b      	ldr	r3, [r3, #0]
 8012afa:	08db      	lsrs	r3, r3, #3
 8012afc:	4a4a      	ldr	r2, [pc, #296]	@ (8012c28 <I2C_DMAAbort+0x14c>)
 8012afe:	fba2 2303 	umull	r2, r3, r2, r3
 8012b02:	0a1a      	lsrs	r2, r3, #8
 8012b04:	4613      	mov	r3, r2
 8012b06:	009b      	lsls	r3, r3, #2
 8012b08:	4413      	add	r3, r2
 8012b0a:	00da      	lsls	r2, r3, #3
 8012b0c:	1ad3      	subs	r3, r2, r3
 8012b0e:	60fb      	str	r3, [r7, #12]
  do
  {
    if (count == 0U)
 8012b10:	68fb      	ldr	r3, [r7, #12]
 8012b12:	2b00      	cmp	r3, #0
 8012b14:	d106      	bne.n	8012b24 <I2C_DMAAbort+0x48>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8012b16:	697b      	ldr	r3, [r7, #20]
 8012b18:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012b1a:	f043 0220 	orr.w	r2, r3, #32
 8012b1e:	697b      	ldr	r3, [r7, #20]
 8012b20:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
 8012b22:	e00a      	b.n	8012b3a <I2C_DMAAbort+0x5e>
    }
    count--;
 8012b24:	68fb      	ldr	r3, [r7, #12]
 8012b26:	3b01      	subs	r3, #1
 8012b28:	60fb      	str	r3, [r7, #12]
  }
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 8012b2a:	697b      	ldr	r3, [r7, #20]
 8012b2c:	681b      	ldr	r3, [r3, #0]
 8012b2e:	681b      	ldr	r3, [r3, #0]
 8012b30:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012b34:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012b38:	d0ea      	beq.n	8012b10 <I2C_DMAAbort+0x34>

  /* Clear Complete callback */
  if (hi2c->hdmatx != NULL)
 8012b3a:	697b      	ldr	r3, [r7, #20]
 8012b3c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012b3e:	2b00      	cmp	r3, #0
 8012b40:	d003      	beq.n	8012b4a <I2C_DMAAbort+0x6e>
  {
    hi2c->hdmatx->XferCpltCallback = NULL;
 8012b42:	697b      	ldr	r3, [r7, #20]
 8012b44:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012b46:	2200      	movs	r2, #0
 8012b48:	63da      	str	r2, [r3, #60]	@ 0x3c
  }
  if (hi2c->hdmarx != NULL)
 8012b4a:	697b      	ldr	r3, [r7, #20]
 8012b4c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012b4e:	2b00      	cmp	r3, #0
 8012b50:	d003      	beq.n	8012b5a <I2C_DMAAbort+0x7e>
  {
    hi2c->hdmarx->XferCpltCallback = NULL;
 8012b52:	697b      	ldr	r3, [r7, #20]
 8012b54:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012b56:	2200      	movs	r2, #0
 8012b58:	63da      	str	r2, [r3, #60]	@ 0x3c
  }

  /* Disable Acknowledge */
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8012b5a:	697b      	ldr	r3, [r7, #20]
 8012b5c:	681b      	ldr	r3, [r3, #0]
 8012b5e:	681a      	ldr	r2, [r3, #0]
 8012b60:	697b      	ldr	r3, [r7, #20]
 8012b62:	681b      	ldr	r3, [r3, #0]
 8012b64:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8012b68:	601a      	str	r2, [r3, #0]

  hi2c->XferCount = 0U;
 8012b6a:	697b      	ldr	r3, [r7, #20]
 8012b6c:	2200      	movs	r2, #0
 8012b6e:	855a      	strh	r2, [r3, #42]	@ 0x2a

  /* Reset XferAbortCallback */
  if (hi2c->hdmatx != NULL)
 8012b70:	697b      	ldr	r3, [r7, #20]
 8012b72:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012b74:	2b00      	cmp	r3, #0
 8012b76:	d003      	beq.n	8012b80 <I2C_DMAAbort+0xa4>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
 8012b78:	697b      	ldr	r3, [r7, #20]
 8012b7a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8012b7c:	2200      	movs	r2, #0
 8012b7e:	651a      	str	r2, [r3, #80]	@ 0x50
  }
  if (hi2c->hdmarx != NULL)
 8012b80:	697b      	ldr	r3, [r7, #20]
 8012b82:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012b84:	2b00      	cmp	r3, #0
 8012b86:	d003      	beq.n	8012b90 <I2C_DMAAbort+0xb4>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
 8012b88:	697b      	ldr	r3, [r7, #20]
 8012b8a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012b8c:	2200      	movs	r2, #0
 8012b8e:	651a      	str	r2, [r3, #80]	@ 0x50
  }

  /* Disable I2C peripheral to prevent dummy data in buffer */
  __HAL_I2C_DISABLE(hi2c);
 8012b90:	697b      	ldr	r3, [r7, #20]
 8012b92:	681b      	ldr	r3, [r3, #0]
 8012b94:	681a      	ldr	r2, [r3, #0]
 8012b96:	697b      	ldr	r3, [r7, #20]
 8012b98:	681b      	ldr	r3, [r3, #0]
 8012b9a:	f022 0201 	bic.w	r2, r2, #1
 8012b9e:	601a      	str	r2, [r3, #0]

  /* Check if come from abort from user */
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8012ba0:	697b      	ldr	r3, [r7, #20]
 8012ba2:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8012ba6:	b2db      	uxtb	r3, r3
 8012ba8:	2b60      	cmp	r3, #96	@ 0x60
 8012baa:	d10e      	bne.n	8012bca <I2C_DMAAbort+0xee>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
 8012bac:	697b      	ldr	r3, [r7, #20]
 8012bae:	2220      	movs	r2, #32
 8012bb0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8012bb4:	697b      	ldr	r3, [r7, #20]
 8012bb6:	2200      	movs	r2, #0
 8012bb8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 8012bbc:	697b      	ldr	r3, [r7, #20]
 8012bbe:	2200      	movs	r2, #0
 8012bc0:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
 8012bc2:	6978      	ldr	r0, [r7, #20]
 8012bc4:	f7fe fb14 	bl	80111f0 <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 8012bc8:	e027      	b.n	8012c1a <I2C_DMAAbort+0x13e>
    if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8012bca:	7cfb      	ldrb	r3, [r7, #19]
 8012bcc:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 8012bd0:	2b28      	cmp	r3, #40	@ 0x28
 8012bd2:	d117      	bne.n	8012c04 <I2C_DMAAbort+0x128>
      __HAL_I2C_ENABLE(hi2c);
 8012bd4:	697b      	ldr	r3, [r7, #20]
 8012bd6:	681b      	ldr	r3, [r3, #0]
 8012bd8:	681a      	ldr	r2, [r3, #0]
 8012bda:	697b      	ldr	r3, [r7, #20]
 8012bdc:	681b      	ldr	r3, [r3, #0]
 8012bde:	f042 0201 	orr.w	r2, r2, #1
 8012be2:	601a      	str	r2, [r3, #0]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8012be4:	697b      	ldr	r3, [r7, #20]
 8012be6:	681b      	ldr	r3, [r3, #0]
 8012be8:	681a      	ldr	r2, [r3, #0]
 8012bea:	697b      	ldr	r3, [r7, #20]
 8012bec:	681b      	ldr	r3, [r3, #0]
 8012bee:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8012bf2:	601a      	str	r2, [r3, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 8012bf4:	697b      	ldr	r3, [r7, #20]
 8012bf6:	2200      	movs	r2, #0
 8012bf8:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8012bfa:	697b      	ldr	r3, [r7, #20]
 8012bfc:	2228      	movs	r2, #40	@ 0x28
 8012bfe:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
 8012c02:	e007      	b.n	8012c14 <I2C_DMAAbort+0x138>
      hi2c->State = HAL_I2C_STATE_READY;
 8012c04:	697b      	ldr	r3, [r7, #20]
 8012c06:	2220      	movs	r2, #32
 8012c08:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8012c0c:	697b      	ldr	r3, [r7, #20]
 8012c0e:	2200      	movs	r2, #0
 8012c10:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    HAL_I2C_ErrorCallback(hi2c);
 8012c14:	6978      	ldr	r0, [r7, #20]
 8012c16:	f7fe fae1 	bl	80111dc <HAL_I2C_ErrorCallback>
}
 8012c1a:	bf00      	nop
 8012c1c:	3718      	adds	r7, #24
 8012c1e:	46bd      	mov	sp, r7
 8012c20:	bd80      	pop	{r7, pc}
 8012c22:	bf00      	nop
 8012c24:	20000144 	.word	0x20000144
 8012c28:	14f8b589 	.word	0x14f8b589

08012c2c <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
 8012c2c:	b580      	push	{r7, lr}
 8012c2e:	b084      	sub	sp, #16
 8012c30:	af00      	add	r7, sp, #0
 8012c32:	60f8      	str	r0, [r7, #12]
 8012c34:	60b9      	str	r1, [r7, #8]
 8012c36:	603b      	str	r3, [r7, #0]
 8012c38:	4613      	mov	r3, r2
 8012c3a:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8012c3c:	e048      	b.n	8012cd0 <I2C_WaitOnFlagUntilTimeout+0xa4>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8012c3e:	683b      	ldr	r3, [r7, #0]
 8012c40:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8012c44:	d044      	beq.n	8012cd0 <I2C_WaitOnFlagUntilTimeout+0xa4>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012c46:	f7fc fb59 	bl	800f2fc <HAL_GetTick>
 8012c4a:	4602      	mov	r2, r0
 8012c4c:	69bb      	ldr	r3, [r7, #24]
 8012c4e:	1ad3      	subs	r3, r2, r3
 8012c50:	683a      	ldr	r2, [r7, #0]
 8012c52:	429a      	cmp	r2, r3
 8012c54:	d302      	bcc.n	8012c5c <I2C_WaitOnFlagUntilTimeout+0x30>
 8012c56:	683b      	ldr	r3, [r7, #0]
 8012c58:	2b00      	cmp	r3, #0
 8012c5a:	d139      	bne.n	8012cd0 <I2C_WaitOnFlagUntilTimeout+0xa4>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 8012c5c:	68bb      	ldr	r3, [r7, #8]
 8012c5e:	0c1b      	lsrs	r3, r3, #16
 8012c60:	b2db      	uxtb	r3, r3
 8012c62:	2b01      	cmp	r3, #1
 8012c64:	d10d      	bne.n	8012c82 <I2C_WaitOnFlagUntilTimeout+0x56>
 8012c66:	68fb      	ldr	r3, [r7, #12]
 8012c68:	681b      	ldr	r3, [r3, #0]
 8012c6a:	695b      	ldr	r3, [r3, #20]
 8012c6c:	43da      	mvns	r2, r3
 8012c6e:	68bb      	ldr	r3, [r7, #8]
 8012c70:	4013      	ands	r3, r2
 8012c72:	b29b      	uxth	r3, r3
 8012c74:	2b00      	cmp	r3, #0
 8012c76:	bf0c      	ite	eq
 8012c78:	2301      	moveq	r3, #1
 8012c7a:	2300      	movne	r3, #0
 8012c7c:	b2db      	uxtb	r3, r3
 8012c7e:	461a      	mov	r2, r3
 8012c80:	e00c      	b.n	8012c9c <I2C_WaitOnFlagUntilTimeout+0x70>
 8012c82:	68fb      	ldr	r3, [r7, #12]
 8012c84:	681b      	ldr	r3, [r3, #0]
 8012c86:	699b      	ldr	r3, [r3, #24]
 8012c88:	43da      	mvns	r2, r3
 8012c8a:	68bb      	ldr	r3, [r7, #8]
 8012c8c:	4013      	ands	r3, r2
 8012c8e:	b29b      	uxth	r3, r3
 8012c90:	2b00      	cmp	r3, #0
 8012c92:	bf0c      	ite	eq
 8012c94:	2301      	moveq	r3, #1
 8012c96:	2300      	movne	r3, #0
 8012c98:	b2db      	uxtb	r3, r3
 8012c9a:	461a      	mov	r2, r3
 8012c9c:	79fb      	ldrb	r3, [r7, #7]
 8012c9e:	429a      	cmp	r2, r3
 8012ca0:	d116      	bne.n	8012cd0 <I2C_WaitOnFlagUntilTimeout+0xa4>
        {
          hi2c->PreviousState     = I2C_STATE_NONE;
 8012ca2:	68fb      	ldr	r3, [r7, #12]
 8012ca4:	2200      	movs	r2, #0
 8012ca6:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State             = HAL_I2C_STATE_READY;
 8012ca8:	68fb      	ldr	r3, [r7, #12]
 8012caa:	2220      	movs	r2, #32
 8012cac:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode              = HAL_I2C_MODE_NONE;
 8012cb0:	68fb      	ldr	r3, [r7, #12]
 8012cb2:	2200      	movs	r2, #0
 8012cb4:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode         |= HAL_I2C_ERROR_TIMEOUT;
 8012cb8:	68fb      	ldr	r3, [r7, #12]
 8012cba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012cbc:	f043 0220 	orr.w	r2, r3, #32
 8012cc0:	68fb      	ldr	r3, [r7, #12]
 8012cc2:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8012cc4:	68fb      	ldr	r3, [r7, #12]
 8012cc6:	2200      	movs	r2, #0
 8012cc8:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 8012ccc:	2301      	movs	r3, #1
 8012cce:	e023      	b.n	8012d18 <I2C_WaitOnFlagUntilTimeout+0xec>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8012cd0:	68bb      	ldr	r3, [r7, #8]
 8012cd2:	0c1b      	lsrs	r3, r3, #16
 8012cd4:	b2db      	uxtb	r3, r3
 8012cd6:	2b01      	cmp	r3, #1
 8012cd8:	d10d      	bne.n	8012cf6 <I2C_WaitOnFlagUntilTimeout+0xca>
 8012cda:	68fb      	ldr	r3, [r7, #12]
 8012cdc:	681b      	ldr	r3, [r3, #0]
 8012cde:	695b      	ldr	r3, [r3, #20]
 8012ce0:	43da      	mvns	r2, r3
 8012ce2:	68bb      	ldr	r3, [r7, #8]
 8012ce4:	4013      	ands	r3, r2
 8012ce6:	b29b      	uxth	r3, r3
 8012ce8:	2b00      	cmp	r3, #0
 8012cea:	bf0c      	ite	eq
 8012cec:	2301      	moveq	r3, #1
 8012cee:	2300      	movne	r3, #0
 8012cf0:	b2db      	uxtb	r3, r3
 8012cf2:	461a      	mov	r2, r3
 8012cf4:	e00c      	b.n	8012d10 <I2C_WaitOnFlagUntilTimeout+0xe4>
 8012cf6:	68fb      	ldr	r3, [r7, #12]
 8012cf8:	681b      	ldr	r3, [r3, #0]
 8012cfa:	699b      	ldr	r3, [r3, #24]
 8012cfc:	43da      	mvns	r2, r3
 8012cfe:	68bb      	ldr	r3, [r7, #8]
 8012d00:	4013      	ands	r3, r2
 8012d02:	b29b      	uxth	r3, r3
 8012d04:	2b00      	cmp	r3, #0
 8012d06:	bf0c      	ite	eq
 8012d08:	2301      	moveq	r3, #1
 8012d0a:	2300      	movne	r3, #0
 8012d0c:	b2db      	uxtb	r3, r3
 8012d0e:	461a      	mov	r2, r3
 8012d10:	79fb      	ldrb	r3, [r7, #7]
 8012d12:	429a      	cmp	r2, r3
 8012d14:	d093      	beq.n	8012c3e <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8012d16:	2300      	movs	r3, #0
}
 8012d18:	4618      	mov	r0, r3
 8012d1a:	3710      	adds	r7, #16
 8012d1c:	46bd      	mov	sp, r7
 8012d1e:	bd80      	pop	{r7, pc}

08012d20 <I2C_WaitOnMasterAddressFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
{
 8012d20:	b580      	push	{r7, lr}
 8012d22:	b084      	sub	sp, #16
 8012d24:	af00      	add	r7, sp, #0
 8012d26:	60f8      	str	r0, [r7, #12]
 8012d28:	60b9      	str	r1, [r7, #8]
 8012d2a:	607a      	str	r2, [r7, #4]
 8012d2c:	603b      	str	r3, [r7, #0]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8012d2e:	e071      	b.n	8012e14 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8012d30:	68fb      	ldr	r3, [r7, #12]
 8012d32:	681b      	ldr	r3, [r3, #0]
 8012d34:	695b      	ldr	r3, [r3, #20]
 8012d36:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8012d3a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8012d3e:	d123      	bne.n	8012d88 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x68>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8012d40:	68fb      	ldr	r3, [r7, #12]
 8012d42:	681b      	ldr	r3, [r3, #0]
 8012d44:	681a      	ldr	r2, [r3, #0]
 8012d46:	68fb      	ldr	r3, [r7, #12]
 8012d48:	681b      	ldr	r3, [r3, #0]
 8012d4a:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8012d4e:	601a      	str	r2, [r3, #0]

      /* Clear AF Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8012d50:	68fb      	ldr	r3, [r7, #12]
 8012d52:	681b      	ldr	r3, [r3, #0]
 8012d54:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 8012d58:	615a      	str	r2, [r3, #20]

      hi2c->PreviousState       = I2C_STATE_NONE;
 8012d5a:	68fb      	ldr	r3, [r7, #12]
 8012d5c:	2200      	movs	r2, #0
 8012d5e:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State               = HAL_I2C_STATE_READY;
 8012d60:	68fb      	ldr	r3, [r7, #12]
 8012d62:	2220      	movs	r2, #32
 8012d64:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode                = HAL_I2C_MODE_NONE;
 8012d68:	68fb      	ldr	r3, [r7, #12]
 8012d6a:	2200      	movs	r2, #0
 8012d6c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
 8012d70:	68fb      	ldr	r3, [r7, #12]
 8012d72:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012d74:	f043 0204 	orr.w	r2, r3, #4
 8012d78:	68fb      	ldr	r3, [r7, #12]
 8012d7a:	641a      	str	r2, [r3, #64]	@ 0x40

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8012d7c:	68fb      	ldr	r3, [r7, #12]
 8012d7e:	2200      	movs	r2, #0
 8012d80:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

      return HAL_ERROR;
 8012d84:	2301      	movs	r3, #1
 8012d86:	e067      	b.n	8012e58 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x138>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8012d88:	687b      	ldr	r3, [r7, #4]
 8012d8a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8012d8e:	d041      	beq.n	8012e14 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012d90:	f7fc fab4 	bl	800f2fc <HAL_GetTick>
 8012d94:	4602      	mov	r2, r0
 8012d96:	683b      	ldr	r3, [r7, #0]
 8012d98:	1ad3      	subs	r3, r2, r3
 8012d9a:	687a      	ldr	r2, [r7, #4]
 8012d9c:	429a      	cmp	r2, r3
 8012d9e:	d302      	bcc.n	8012da6 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x86>
 8012da0:	687b      	ldr	r3, [r7, #4]
 8012da2:	2b00      	cmp	r3, #0
 8012da4:	d136      	bne.n	8012e14 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET))
 8012da6:	68bb      	ldr	r3, [r7, #8]
 8012da8:	0c1b      	lsrs	r3, r3, #16
 8012daa:	b2db      	uxtb	r3, r3
 8012dac:	2b01      	cmp	r3, #1
 8012dae:	d10c      	bne.n	8012dca <I2C_WaitOnMasterAddressFlagUntilTimeout+0xaa>
 8012db0:	68fb      	ldr	r3, [r7, #12]
 8012db2:	681b      	ldr	r3, [r3, #0]
 8012db4:	695b      	ldr	r3, [r3, #20]
 8012db6:	43da      	mvns	r2, r3
 8012db8:	68bb      	ldr	r3, [r7, #8]
 8012dba:	4013      	ands	r3, r2
 8012dbc:	b29b      	uxth	r3, r3
 8012dbe:	2b00      	cmp	r3, #0
 8012dc0:	bf14      	ite	ne
 8012dc2:	2301      	movne	r3, #1
 8012dc4:	2300      	moveq	r3, #0
 8012dc6:	b2db      	uxtb	r3, r3
 8012dc8:	e00b      	b.n	8012de2 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xc2>
 8012dca:	68fb      	ldr	r3, [r7, #12]
 8012dcc:	681b      	ldr	r3, [r3, #0]
 8012dce:	699b      	ldr	r3, [r3, #24]
 8012dd0:	43da      	mvns	r2, r3
 8012dd2:	68bb      	ldr	r3, [r7, #8]
 8012dd4:	4013      	ands	r3, r2
 8012dd6:	b29b      	uxth	r3, r3
 8012dd8:	2b00      	cmp	r3, #0
 8012dda:	bf14      	ite	ne
 8012ddc:	2301      	movne	r3, #1
 8012dde:	2300      	moveq	r3, #0
 8012de0:	b2db      	uxtb	r3, r3
 8012de2:	2b00      	cmp	r3, #0
 8012de4:	d016      	beq.n	8012e14 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
        {
          hi2c->PreviousState       = I2C_STATE_NONE;
 8012de6:	68fb      	ldr	r3, [r7, #12]
 8012de8:	2200      	movs	r2, #0
 8012dea:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State               = HAL_I2C_STATE_READY;
 8012dec:	68fb      	ldr	r3, [r7, #12]
 8012dee:	2220      	movs	r2, #32
 8012df0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode                = HAL_I2C_MODE_NONE;
 8012df4:	68fb      	ldr	r3, [r7, #12]
 8012df6:	2200      	movs	r2, #0
 8012df8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8012dfc:	68fb      	ldr	r3, [r7, #12]
 8012dfe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012e00:	f043 0220 	orr.w	r2, r3, #32
 8012e04:	68fb      	ldr	r3, [r7, #12]
 8012e06:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8012e08:	68fb      	ldr	r3, [r7, #12]
 8012e0a:	2200      	movs	r2, #0
 8012e0c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 8012e10:	2301      	movs	r3, #1
 8012e12:	e021      	b.n	8012e58 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x138>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8012e14:	68bb      	ldr	r3, [r7, #8]
 8012e16:	0c1b      	lsrs	r3, r3, #16
 8012e18:	b2db      	uxtb	r3, r3
 8012e1a:	2b01      	cmp	r3, #1
 8012e1c:	d10c      	bne.n	8012e38 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x118>
 8012e1e:	68fb      	ldr	r3, [r7, #12]
 8012e20:	681b      	ldr	r3, [r3, #0]
 8012e22:	695b      	ldr	r3, [r3, #20]
 8012e24:	43da      	mvns	r2, r3
 8012e26:	68bb      	ldr	r3, [r7, #8]
 8012e28:	4013      	ands	r3, r2
 8012e2a:	b29b      	uxth	r3, r3
 8012e2c:	2b00      	cmp	r3, #0
 8012e2e:	bf14      	ite	ne
 8012e30:	2301      	movne	r3, #1
 8012e32:	2300      	moveq	r3, #0
 8012e34:	b2db      	uxtb	r3, r3
 8012e36:	e00b      	b.n	8012e50 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x130>
 8012e38:	68fb      	ldr	r3, [r7, #12]
 8012e3a:	681b      	ldr	r3, [r3, #0]
 8012e3c:	699b      	ldr	r3, [r3, #24]
 8012e3e:	43da      	mvns	r2, r3
 8012e40:	68bb      	ldr	r3, [r7, #8]
 8012e42:	4013      	ands	r3, r2
 8012e44:	b29b      	uxth	r3, r3
 8012e46:	2b00      	cmp	r3, #0
 8012e48:	bf14      	ite	ne
 8012e4a:	2301      	movne	r3, #1
 8012e4c:	2300      	moveq	r3, #0
 8012e4e:	b2db      	uxtb	r3, r3
 8012e50:	2b00      	cmp	r3, #0
 8012e52:	f47f af6d 	bne.w	8012d30 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x10>
        }
      }
    }
  }
  return HAL_OK;
 8012e56:	2300      	movs	r3, #0
}
 8012e58:	4618      	mov	r0, r3
 8012e5a:	3710      	adds	r7, #16
 8012e5c:	46bd      	mov	sp, r7
 8012e5e:	bd80      	pop	{r7, pc}

08012e60 <I2C_WaitOnTXEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8012e60:	b580      	push	{r7, lr}
 8012e62:	b084      	sub	sp, #16
 8012e64:	af00      	add	r7, sp, #0
 8012e66:	60f8      	str	r0, [r7, #12]
 8012e68:	60b9      	str	r1, [r7, #8]
 8012e6a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8012e6c:	e034      	b.n	8012ed8 <I2C_WaitOnTXEFlagUntilTimeout+0x78>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 8012e6e:	68f8      	ldr	r0, [r7, #12]
 8012e70:	f000 f915 	bl	801309e <I2C_IsAcknowledgeFailed>
 8012e74:	4603      	mov	r3, r0
 8012e76:	2b00      	cmp	r3, #0
 8012e78:	d001      	beq.n	8012e7e <I2C_WaitOnTXEFlagUntilTimeout+0x1e>
    {
      return HAL_ERROR;
 8012e7a:	2301      	movs	r3, #1
 8012e7c:	e034      	b.n	8012ee8 <I2C_WaitOnTXEFlagUntilTimeout+0x88>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8012e7e:	68bb      	ldr	r3, [r7, #8]
 8012e80:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8012e84:	d028      	beq.n	8012ed8 <I2C_WaitOnTXEFlagUntilTimeout+0x78>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012e86:	f7fc fa39 	bl	800f2fc <HAL_GetTick>
 8012e8a:	4602      	mov	r2, r0
 8012e8c:	687b      	ldr	r3, [r7, #4]
 8012e8e:	1ad3      	subs	r3, r2, r3
 8012e90:	68ba      	ldr	r2, [r7, #8]
 8012e92:	429a      	cmp	r2, r3
 8012e94:	d302      	bcc.n	8012e9c <I2C_WaitOnTXEFlagUntilTimeout+0x3c>
 8012e96:	68bb      	ldr	r3, [r7, #8]
 8012e98:	2b00      	cmp	r3, #0
 8012e9a:	d11d      	bne.n	8012ed8 <I2C_WaitOnTXEFlagUntilTimeout+0x78>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET))
 8012e9c:	68fb      	ldr	r3, [r7, #12]
 8012e9e:	681b      	ldr	r3, [r3, #0]
 8012ea0:	695b      	ldr	r3, [r3, #20]
 8012ea2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012ea6:	2b80      	cmp	r3, #128	@ 0x80
 8012ea8:	d016      	beq.n	8012ed8 <I2C_WaitOnTXEFlagUntilTimeout+0x78>
        {
          hi2c->PreviousState       = I2C_STATE_NONE;
 8012eaa:	68fb      	ldr	r3, [r7, #12]
 8012eac:	2200      	movs	r2, #0
 8012eae:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State               = HAL_I2C_STATE_READY;
 8012eb0:	68fb      	ldr	r3, [r7, #12]
 8012eb2:	2220      	movs	r2, #32
 8012eb4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode                = HAL_I2C_MODE_NONE;
 8012eb8:	68fb      	ldr	r3, [r7, #12]
 8012eba:	2200      	movs	r2, #0
 8012ebc:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8012ec0:	68fb      	ldr	r3, [r7, #12]
 8012ec2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012ec4:	f043 0220 	orr.w	r2, r3, #32
 8012ec8:	68fb      	ldr	r3, [r7, #12]
 8012eca:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8012ecc:	68fb      	ldr	r3, [r7, #12]
 8012ece:	2200      	movs	r2, #0
 8012ed0:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 8012ed4:	2301      	movs	r3, #1
 8012ed6:	e007      	b.n	8012ee8 <I2C_WaitOnTXEFlagUntilTimeout+0x88>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8012ed8:	68fb      	ldr	r3, [r7, #12]
 8012eda:	681b      	ldr	r3, [r3, #0]
 8012edc:	695b      	ldr	r3, [r3, #20]
 8012ede:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012ee2:	2b80      	cmp	r3, #128	@ 0x80
 8012ee4:	d1c3      	bne.n	8012e6e <I2C_WaitOnTXEFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
 8012ee6:	2300      	movs	r3, #0
}
 8012ee8:	4618      	mov	r0, r3
 8012eea:	3710      	adds	r7, #16
 8012eec:	46bd      	mov	sp, r7
 8012eee:	bd80      	pop	{r7, pc}

08012ef0 <I2C_WaitOnBTFFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8012ef0:	b580      	push	{r7, lr}
 8012ef2:	b084      	sub	sp, #16
 8012ef4:	af00      	add	r7, sp, #0
 8012ef6:	60f8      	str	r0, [r7, #12]
 8012ef8:	60b9      	str	r1, [r7, #8]
 8012efa:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 8012efc:	e034      	b.n	8012f68 <I2C_WaitOnBTFFlagUntilTimeout+0x78>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 8012efe:	68f8      	ldr	r0, [r7, #12]
 8012f00:	f000 f8cd 	bl	801309e <I2C_IsAcknowledgeFailed>
 8012f04:	4603      	mov	r3, r0
 8012f06:	2b00      	cmp	r3, #0
 8012f08:	d001      	beq.n	8012f0e <I2C_WaitOnBTFFlagUntilTimeout+0x1e>
    {
      return HAL_ERROR;
 8012f0a:	2301      	movs	r3, #1
 8012f0c:	e034      	b.n	8012f78 <I2C_WaitOnBTFFlagUntilTimeout+0x88>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8012f0e:	68bb      	ldr	r3, [r7, #8]
 8012f10:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8012f14:	d028      	beq.n	8012f68 <I2C_WaitOnBTFFlagUntilTimeout+0x78>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8012f16:	f7fc f9f1 	bl	800f2fc <HAL_GetTick>
 8012f1a:	4602      	mov	r2, r0
 8012f1c:	687b      	ldr	r3, [r7, #4]
 8012f1e:	1ad3      	subs	r3, r2, r3
 8012f20:	68ba      	ldr	r2, [r7, #8]
 8012f22:	429a      	cmp	r2, r3
 8012f24:	d302      	bcc.n	8012f2c <I2C_WaitOnBTFFlagUntilTimeout+0x3c>
 8012f26:	68bb      	ldr	r3, [r7, #8]
 8012f28:	2b00      	cmp	r3, #0
 8012f2a:	d11d      	bne.n	8012f68 <I2C_WaitOnBTFFlagUntilTimeout+0x78>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET))
 8012f2c:	68fb      	ldr	r3, [r7, #12]
 8012f2e:	681b      	ldr	r3, [r3, #0]
 8012f30:	695b      	ldr	r3, [r3, #20]
 8012f32:	f003 0304 	and.w	r3, r3, #4
 8012f36:	2b04      	cmp	r3, #4
 8012f38:	d016      	beq.n	8012f68 <I2C_WaitOnBTFFlagUntilTimeout+0x78>
        {
          hi2c->PreviousState       = I2C_STATE_NONE;
 8012f3a:	68fb      	ldr	r3, [r7, #12]
 8012f3c:	2200      	movs	r2, #0
 8012f3e:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State               = HAL_I2C_STATE_READY;
 8012f40:	68fb      	ldr	r3, [r7, #12]
 8012f42:	2220      	movs	r2, #32
 8012f44:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode                = HAL_I2C_MODE_NONE;
 8012f48:	68fb      	ldr	r3, [r7, #12]
 8012f4a:	2200      	movs	r2, #0
 8012f4c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8012f50:	68fb      	ldr	r3, [r7, #12]
 8012f52:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012f54:	f043 0220 	orr.w	r2, r3, #32
 8012f58:	68fb      	ldr	r3, [r7, #12]
 8012f5a:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8012f5c:	68fb      	ldr	r3, [r7, #12]
 8012f5e:	2200      	movs	r2, #0
 8012f60:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 8012f64:	2301      	movs	r3, #1
 8012f66:	e007      	b.n	8012f78 <I2C_WaitOnBTFFlagUntilTimeout+0x88>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 8012f68:	68fb      	ldr	r3, [r7, #12]
 8012f6a:	681b      	ldr	r3, [r3, #0]
 8012f6c:	695b      	ldr	r3, [r3, #20]
 8012f6e:	f003 0304 	and.w	r3, r3, #4
 8012f72:	2b04      	cmp	r3, #4
 8012f74:	d1c3      	bne.n	8012efe <I2C_WaitOnBTFFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
 8012f76:	2300      	movs	r3, #0
}
 8012f78:	4618      	mov	r0, r3
 8012f7a:	3710      	adds	r7, #16
 8012f7c:	46bd      	mov	sp, r7
 8012f7e:	bd80      	pop	{r7, pc}

08012f80 <I2C_WaitOnSTOPRequestThroughIT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c)
{
 8012f80:	b480      	push	{r7}
 8012f82:	b085      	sub	sp, #20
 8012f84:	af00      	add	r7, sp, #0
 8012f86:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8012f88:	2300      	movs	r3, #0
 8012f8a:	60fb      	str	r3, [r7, #12]

  /* Wait until STOP flag is reset */
  count = I2C_TIMEOUT_STOP_FLAG * (SystemCoreClock / 25U / 1000U);
 8012f8c:	4b13      	ldr	r3, [pc, #76]	@ (8012fdc <I2C_WaitOnSTOPRequestThroughIT+0x5c>)
 8012f8e:	681b      	ldr	r3, [r3, #0]
 8012f90:	08db      	lsrs	r3, r3, #3
 8012f92:	4a13      	ldr	r2, [pc, #76]	@ (8012fe0 <I2C_WaitOnSTOPRequestThroughIT+0x60>)
 8012f94:	fba2 2303 	umull	r2, r3, r2, r3
 8012f98:	0a1a      	lsrs	r2, r3, #8
 8012f9a:	4613      	mov	r3, r2
 8012f9c:	009b      	lsls	r3, r3, #2
 8012f9e:	4413      	add	r3, r2
 8012fa0:	60fb      	str	r3, [r7, #12]
  do
  {
    count--;
 8012fa2:	68fb      	ldr	r3, [r7, #12]
 8012fa4:	3b01      	subs	r3, #1
 8012fa6:	60fb      	str	r3, [r7, #12]
    if (count == 0U)
 8012fa8:	68fb      	ldr	r3, [r7, #12]
 8012faa:	2b00      	cmp	r3, #0
 8012fac:	d107      	bne.n	8012fbe <I2C_WaitOnSTOPRequestThroughIT+0x3e>
    {
      hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 8012fae:	687b      	ldr	r3, [r7, #4]
 8012fb0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8012fb2:	f043 0220 	orr.w	r2, r3, #32
 8012fb6:	687b      	ldr	r3, [r7, #4]
 8012fb8:	641a      	str	r2, [r3, #64]	@ 0x40

      return HAL_ERROR;
 8012fba:	2301      	movs	r3, #1
 8012fbc:	e008      	b.n	8012fd0 <I2C_WaitOnSTOPRequestThroughIT+0x50>
    }
  }
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 8012fbe:	687b      	ldr	r3, [r7, #4]
 8012fc0:	681b      	ldr	r3, [r3, #0]
 8012fc2:	681b      	ldr	r3, [r3, #0]
 8012fc4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8012fc8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012fcc:	d0e9      	beq.n	8012fa2 <I2C_WaitOnSTOPRequestThroughIT+0x22>

  return HAL_OK;
 8012fce:	2300      	movs	r3, #0
}
 8012fd0:	4618      	mov	r0, r3
 8012fd2:	3714      	adds	r7, #20
 8012fd4:	46bd      	mov	sp, r7
 8012fd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012fda:	4770      	bx	lr
 8012fdc:	20000144 	.word	0x20000144
 8012fe0:	14f8b589 	.word	0x14f8b589

08012fe4 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8012fe4:	b580      	push	{r7, lr}
 8012fe6:	b084      	sub	sp, #16
 8012fe8:	af00      	add	r7, sp, #0
 8012fea:	60f8      	str	r0, [r7, #12]
 8012fec:	60b9      	str	r1, [r7, #8]
 8012fee:	607a      	str	r2, [r7, #4]

  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8012ff0:	e049      	b.n	8013086 <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
  {
    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8012ff2:	68fb      	ldr	r3, [r7, #12]
 8012ff4:	681b      	ldr	r3, [r3, #0]
 8012ff6:	695b      	ldr	r3, [r3, #20]
 8012ff8:	f003 0310 	and.w	r3, r3, #16
 8012ffc:	2b10      	cmp	r3, #16
 8012ffe:	d119      	bne.n	8013034 <I2C_WaitOnRXNEFlagUntilTimeout+0x50>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8013000:	68fb      	ldr	r3, [r7, #12]
 8013002:	681b      	ldr	r3, [r3, #0]
 8013004:	f06f 0210 	mvn.w	r2, #16
 8013008:	615a      	str	r2, [r3, #20]

      hi2c->PreviousState       = I2C_STATE_NONE;
 801300a:	68fb      	ldr	r3, [r7, #12]
 801300c:	2200      	movs	r2, #0
 801300e:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State               = HAL_I2C_STATE_READY;
 8013010:	68fb      	ldr	r3, [r7, #12]
 8013012:	2220      	movs	r2, #32
 8013014:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode                = HAL_I2C_MODE_NONE;
 8013018:	68fb      	ldr	r3, [r7, #12]
 801301a:	2200      	movs	r2, #0
 801301c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->ErrorCode           |= HAL_I2C_ERROR_NONE;
 8013020:	68fb      	ldr	r3, [r7, #12]
 8013022:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8013024:	68fb      	ldr	r3, [r7, #12]
 8013026:	641a      	str	r2, [r3, #64]	@ 0x40

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8013028:	68fb      	ldr	r3, [r7, #12]
 801302a:	2200      	movs	r2, #0
 801302c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

      return HAL_ERROR;
 8013030:	2301      	movs	r3, #1
 8013032:	e030      	b.n	8013096 <I2C_WaitOnRXNEFlagUntilTimeout+0xb2>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8013034:	f7fc f962 	bl	800f2fc <HAL_GetTick>
 8013038:	4602      	mov	r2, r0
 801303a:	687b      	ldr	r3, [r7, #4]
 801303c:	1ad3      	subs	r3, r2, r3
 801303e:	68ba      	ldr	r2, [r7, #8]
 8013040:	429a      	cmp	r2, r3
 8013042:	d302      	bcc.n	801304a <I2C_WaitOnRXNEFlagUntilTimeout+0x66>
 8013044:	68bb      	ldr	r3, [r7, #8]
 8013046:	2b00      	cmp	r3, #0
 8013048:	d11d      	bne.n	8013086 <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET))
 801304a:	68fb      	ldr	r3, [r7, #12]
 801304c:	681b      	ldr	r3, [r3, #0]
 801304e:	695b      	ldr	r3, [r3, #20]
 8013050:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8013054:	2b40      	cmp	r3, #64	@ 0x40
 8013056:	d016      	beq.n	8013086 <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
      {
        hi2c->PreviousState       = I2C_STATE_NONE;
 8013058:	68fb      	ldr	r3, [r7, #12]
 801305a:	2200      	movs	r2, #0
 801305c:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->State               = HAL_I2C_STATE_READY;
 801305e:	68fb      	ldr	r3, [r7, #12]
 8013060:	2220      	movs	r2, #32
 8013062:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        hi2c->Mode                = HAL_I2C_MODE_NONE;
 8013066:	68fb      	ldr	r3, [r7, #12]
 8013068:	2200      	movs	r2, #0
 801306a:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 801306e:	68fb      	ldr	r3, [r7, #12]
 8013070:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8013072:	f043 0220 	orr.w	r2, r3, #32
 8013076:	68fb      	ldr	r3, [r7, #12]
 8013078:	641a      	str	r2, [r3, #64]	@ 0x40

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 801307a:	68fb      	ldr	r3, [r7, #12]
 801307c:	2200      	movs	r2, #0
 801307e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

        return HAL_ERROR;
 8013082:	2301      	movs	r3, #1
 8013084:	e007      	b.n	8013096 <I2C_WaitOnRXNEFlagUntilTimeout+0xb2>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8013086:	68fb      	ldr	r3, [r7, #12]
 8013088:	681b      	ldr	r3, [r3, #0]
 801308a:	695b      	ldr	r3, [r3, #20]
 801308c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8013090:	2b40      	cmp	r3, #64	@ 0x40
 8013092:	d1ae      	bne.n	8012ff2 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 8013094:	2300      	movs	r3, #0
}
 8013096:	4618      	mov	r0, r3
 8013098:	3710      	adds	r7, #16
 801309a:	46bd      	mov	sp, r7
 801309c:	bd80      	pop	{r7, pc}

0801309e <I2C_IsAcknowledgeFailed>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
{
 801309e:	b480      	push	{r7}
 80130a0:	b083      	sub	sp, #12
 80130a2:	af00      	add	r7, sp, #0
 80130a4:	6078      	str	r0, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80130a6:	687b      	ldr	r3, [r7, #4]
 80130a8:	681b      	ldr	r3, [r3, #0]
 80130aa:	695b      	ldr	r3, [r3, #20]
 80130ac:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80130b0:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80130b4:	d11b      	bne.n	80130ee <I2C_IsAcknowledgeFailed+0x50>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80130b6:	687b      	ldr	r3, [r7, #4]
 80130b8:	681b      	ldr	r3, [r3, #0]
 80130ba:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 80130be:	615a      	str	r2, [r3, #20]

    hi2c->PreviousState       = I2C_STATE_NONE;
 80130c0:	687b      	ldr	r3, [r7, #4]
 80130c2:	2200      	movs	r2, #0
 80130c4:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State               = HAL_I2C_STATE_READY;
 80130c6:	687b      	ldr	r3, [r7, #4]
 80130c8:	2220      	movs	r2, #32
 80130ca:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode                = HAL_I2C_MODE_NONE;
 80130ce:	687b      	ldr	r3, [r7, #4]
 80130d0:	2200      	movs	r2, #0
 80130d2:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
 80130d6:	687b      	ldr	r3, [r7, #4]
 80130d8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80130da:	f043 0204 	orr.w	r2, r3, #4
 80130de:	687b      	ldr	r3, [r7, #4]
 80130e0:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80130e2:	687b      	ldr	r3, [r7, #4]
 80130e4:	2200      	movs	r2, #0
 80130e6:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_ERROR;
 80130ea:	2301      	movs	r3, #1
 80130ec:	e000      	b.n	80130f0 <I2C_IsAcknowledgeFailed+0x52>
  }
  return HAL_OK;
 80130ee:	2300      	movs	r3, #0
}
 80130f0:	4618      	mov	r0, r3
 80130f2:	370c      	adds	r7, #12
 80130f4:	46bd      	mov	sp, r7
 80130f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80130fa:	4770      	bx	lr

080130fc <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functional XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
 80130fc:	b480      	push	{r7}
 80130fe:	b083      	sub	sp, #12
 8013100:	af00      	add	r7, sp, #0
 8013102:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
 8013104:	687b      	ldr	r3, [r7, #4]
 8013106:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013108:	f5b3 0f2a 	cmp.w	r3, #11141120	@ 0xaa0000
 801310c:	d103      	bne.n	8013116 <I2C_ConvertOtherXferOptions+0x1a>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
 801310e:	687b      	ldr	r3, [r7, #4]
 8013110:	2201      	movs	r2, #1
 8013112:	62da      	str	r2, [r3, #44]	@ 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
 8013114:	e007      	b.n	8013126 <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
 8013116:	687b      	ldr	r3, [r7, #4]
 8013118:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801311a:	f1b3 4f2a 	cmp.w	r3, #2852126720	@ 0xaa000000
 801311e:	d102      	bne.n	8013126 <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
 8013120:	687b      	ldr	r3, [r7, #4]
 8013122:	2208      	movs	r2, #8
 8013124:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 8013126:	bf00      	nop
 8013128:	370c      	adds	r7, #12
 801312a:	46bd      	mov	sp, r7
 801312c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013130:	4770      	bx	lr
	...

08013134 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8013134:	b580      	push	{r7, lr}
 8013136:	b086      	sub	sp, #24
 8013138:	af00      	add	r7, sp, #0
 801313a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 801313c:	687b      	ldr	r3, [r7, #4]
 801313e:	2b00      	cmp	r3, #0
 8013140:	d101      	bne.n	8013146 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8013142:	2301      	movs	r3, #1
 8013144:	e267      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8013146:	687b      	ldr	r3, [r7, #4]
 8013148:	681b      	ldr	r3, [r3, #0]
 801314a:	f003 0301 	and.w	r3, r3, #1
 801314e:	2b00      	cmp	r3, #0
 8013150:	d075      	beq.n	801323e <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8013152:	4b88      	ldr	r3, [pc, #544]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013154:	689b      	ldr	r3, [r3, #8]
 8013156:	f003 030c 	and.w	r3, r3, #12
 801315a:	2b04      	cmp	r3, #4
 801315c:	d00c      	beq.n	8013178 <HAL_RCC_OscConfig+0x44>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 801315e:	4b85      	ldr	r3, [pc, #532]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013160:	689b      	ldr	r3, [r3, #8]
 8013162:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8013166:	2b08      	cmp	r3, #8
 8013168:	d112      	bne.n	8013190 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 801316a:	4b82      	ldr	r3, [pc, #520]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 801316c:	685b      	ldr	r3, [r3, #4]
 801316e:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8013172:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8013176:	d10b      	bne.n	8013190 <HAL_RCC_OscConfig+0x5c>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8013178:	4b7e      	ldr	r3, [pc, #504]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 801317a:	681b      	ldr	r3, [r3, #0]
 801317c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013180:	2b00      	cmp	r3, #0
 8013182:	d05b      	beq.n	801323c <HAL_RCC_OscConfig+0x108>
 8013184:	687b      	ldr	r3, [r7, #4]
 8013186:	685b      	ldr	r3, [r3, #4]
 8013188:	2b00      	cmp	r3, #0
 801318a:	d157      	bne.n	801323c <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 801318c:	2301      	movs	r3, #1
 801318e:	e242      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8013190:	687b      	ldr	r3, [r7, #4]
 8013192:	685b      	ldr	r3, [r3, #4]
 8013194:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8013198:	d106      	bne.n	80131a8 <HAL_RCC_OscConfig+0x74>
 801319a:	4b76      	ldr	r3, [pc, #472]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 801319c:	681b      	ldr	r3, [r3, #0]
 801319e:	4a75      	ldr	r2, [pc, #468]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131a0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80131a4:	6013      	str	r3, [r2, #0]
 80131a6:	e01d      	b.n	80131e4 <HAL_RCC_OscConfig+0xb0>
 80131a8:	687b      	ldr	r3, [r7, #4]
 80131aa:	685b      	ldr	r3, [r3, #4]
 80131ac:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 80131b0:	d10c      	bne.n	80131cc <HAL_RCC_OscConfig+0x98>
 80131b2:	4b70      	ldr	r3, [pc, #448]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131b4:	681b      	ldr	r3, [r3, #0]
 80131b6:	4a6f      	ldr	r2, [pc, #444]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131b8:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 80131bc:	6013      	str	r3, [r2, #0]
 80131be:	4b6d      	ldr	r3, [pc, #436]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131c0:	681b      	ldr	r3, [r3, #0]
 80131c2:	4a6c      	ldr	r2, [pc, #432]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131c4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80131c8:	6013      	str	r3, [r2, #0]
 80131ca:	e00b      	b.n	80131e4 <HAL_RCC_OscConfig+0xb0>
 80131cc:	4b69      	ldr	r3, [pc, #420]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131ce:	681b      	ldr	r3, [r3, #0]
 80131d0:	4a68      	ldr	r2, [pc, #416]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131d2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80131d6:	6013      	str	r3, [r2, #0]
 80131d8:	4b66      	ldr	r3, [pc, #408]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131da:	681b      	ldr	r3, [r3, #0]
 80131dc:	4a65      	ldr	r2, [pc, #404]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80131de:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80131e2:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 80131e4:	687b      	ldr	r3, [r7, #4]
 80131e6:	685b      	ldr	r3, [r3, #4]
 80131e8:	2b00      	cmp	r3, #0
 80131ea:	d013      	beq.n	8013214 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80131ec:	f7fc f886 	bl	800f2fc <HAL_GetTick>
 80131f0:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80131f2:	e008      	b.n	8013206 <HAL_RCC_OscConfig+0xd2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80131f4:	f7fc f882 	bl	800f2fc <HAL_GetTick>
 80131f8:	4602      	mov	r2, r0
 80131fa:	693b      	ldr	r3, [r7, #16]
 80131fc:	1ad3      	subs	r3, r2, r3
 80131fe:	2b64      	cmp	r3, #100	@ 0x64
 8013200:	d901      	bls.n	8013206 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8013202:	2303      	movs	r3, #3
 8013204:	e207      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8013206:	4b5b      	ldr	r3, [pc, #364]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013208:	681b      	ldr	r3, [r3, #0]
 801320a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 801320e:	2b00      	cmp	r3, #0
 8013210:	d0f0      	beq.n	80131f4 <HAL_RCC_OscConfig+0xc0>
 8013212:	e014      	b.n	801323e <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8013214:	f7fc f872 	bl	800f2fc <HAL_GetTick>
 8013218:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 801321a:	e008      	b.n	801322e <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 801321c:	f7fc f86e 	bl	800f2fc <HAL_GetTick>
 8013220:	4602      	mov	r2, r0
 8013222:	693b      	ldr	r3, [r7, #16]
 8013224:	1ad3      	subs	r3, r2, r3
 8013226:	2b64      	cmp	r3, #100	@ 0x64
 8013228:	d901      	bls.n	801322e <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 801322a:	2303      	movs	r3, #3
 801322c:	e1f3      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 801322e:	4b51      	ldr	r3, [pc, #324]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013230:	681b      	ldr	r3, [r3, #0]
 8013232:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8013236:	2b00      	cmp	r3, #0
 8013238:	d1f0      	bne.n	801321c <HAL_RCC_OscConfig+0xe8>
 801323a:	e000      	b.n	801323e <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 801323c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 801323e:	687b      	ldr	r3, [r7, #4]
 8013240:	681b      	ldr	r3, [r3, #0]
 8013242:	f003 0302 	and.w	r3, r3, #2
 8013246:	2b00      	cmp	r3, #0
 8013248:	d063      	beq.n	8013312 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 801324a:	4b4a      	ldr	r3, [pc, #296]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 801324c:	689b      	ldr	r3, [r3, #8]
 801324e:	f003 030c 	and.w	r3, r3, #12
 8013252:	2b00      	cmp	r3, #0
 8013254:	d00b      	beq.n	801326e <HAL_RCC_OscConfig+0x13a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8013256:	4b47      	ldr	r3, [pc, #284]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013258:	689b      	ldr	r3, [r3, #8]
 801325a:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 801325e:	2b08      	cmp	r3, #8
 8013260:	d11c      	bne.n	801329c <HAL_RCC_OscConfig+0x168>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8013262:	4b44      	ldr	r3, [pc, #272]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013264:	685b      	ldr	r3, [r3, #4]
 8013266:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 801326a:	2b00      	cmp	r3, #0
 801326c:	d116      	bne.n	801329c <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 801326e:	4b41      	ldr	r3, [pc, #260]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013270:	681b      	ldr	r3, [r3, #0]
 8013272:	f003 0302 	and.w	r3, r3, #2
 8013276:	2b00      	cmp	r3, #0
 8013278:	d005      	beq.n	8013286 <HAL_RCC_OscConfig+0x152>
 801327a:	687b      	ldr	r3, [r7, #4]
 801327c:	68db      	ldr	r3, [r3, #12]
 801327e:	2b01      	cmp	r3, #1
 8013280:	d001      	beq.n	8013286 <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 8013282:	2301      	movs	r3, #1
 8013284:	e1c7      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8013286:	4b3b      	ldr	r3, [pc, #236]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013288:	681b      	ldr	r3, [r3, #0]
 801328a:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 801328e:	687b      	ldr	r3, [r7, #4]
 8013290:	691b      	ldr	r3, [r3, #16]
 8013292:	00db      	lsls	r3, r3, #3
 8013294:	4937      	ldr	r1, [pc, #220]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013296:	4313      	orrs	r3, r2
 8013298:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 801329a:	e03a      	b.n	8013312 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 801329c:	687b      	ldr	r3, [r7, #4]
 801329e:	68db      	ldr	r3, [r3, #12]
 80132a0:	2b00      	cmp	r3, #0
 80132a2:	d020      	beq.n	80132e6 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80132a4:	4b34      	ldr	r3, [pc, #208]	@ (8013378 <HAL_RCC_OscConfig+0x244>)
 80132a6:	2201      	movs	r2, #1
 80132a8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80132aa:	f7fc f827 	bl	800f2fc <HAL_GetTick>
 80132ae:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80132b0:	e008      	b.n	80132c4 <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80132b2:	f7fc f823 	bl	800f2fc <HAL_GetTick>
 80132b6:	4602      	mov	r2, r0
 80132b8:	693b      	ldr	r3, [r7, #16]
 80132ba:	1ad3      	subs	r3, r2, r3
 80132bc:	2b02      	cmp	r3, #2
 80132be:	d901      	bls.n	80132c4 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 80132c0:	2303      	movs	r3, #3
 80132c2:	e1a8      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80132c4:	4b2b      	ldr	r3, [pc, #172]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80132c6:	681b      	ldr	r3, [r3, #0]
 80132c8:	f003 0302 	and.w	r3, r3, #2
 80132cc:	2b00      	cmp	r3, #0
 80132ce:	d0f0      	beq.n	80132b2 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80132d0:	4b28      	ldr	r3, [pc, #160]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80132d2:	681b      	ldr	r3, [r3, #0]
 80132d4:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 80132d8:	687b      	ldr	r3, [r7, #4]
 80132da:	691b      	ldr	r3, [r3, #16]
 80132dc:	00db      	lsls	r3, r3, #3
 80132de:	4925      	ldr	r1, [pc, #148]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 80132e0:	4313      	orrs	r3, r2
 80132e2:	600b      	str	r3, [r1, #0]
 80132e4:	e015      	b.n	8013312 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80132e6:	4b24      	ldr	r3, [pc, #144]	@ (8013378 <HAL_RCC_OscConfig+0x244>)
 80132e8:	2200      	movs	r2, #0
 80132ea:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80132ec:	f7fc f806 	bl	800f2fc <HAL_GetTick>
 80132f0:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80132f2:	e008      	b.n	8013306 <HAL_RCC_OscConfig+0x1d2>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80132f4:	f7fc f802 	bl	800f2fc <HAL_GetTick>
 80132f8:	4602      	mov	r2, r0
 80132fa:	693b      	ldr	r3, [r7, #16]
 80132fc:	1ad3      	subs	r3, r2, r3
 80132fe:	2b02      	cmp	r3, #2
 8013300:	d901      	bls.n	8013306 <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 8013302:	2303      	movs	r3, #3
 8013304:	e187      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8013306:	4b1b      	ldr	r3, [pc, #108]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013308:	681b      	ldr	r3, [r3, #0]
 801330a:	f003 0302 	and.w	r3, r3, #2
 801330e:	2b00      	cmp	r3, #0
 8013310:	d1f0      	bne.n	80132f4 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8013312:	687b      	ldr	r3, [r7, #4]
 8013314:	681b      	ldr	r3, [r3, #0]
 8013316:	f003 0308 	and.w	r3, r3, #8
 801331a:	2b00      	cmp	r3, #0
 801331c:	d036      	beq.n	801338c <HAL_RCC_OscConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 801331e:	687b      	ldr	r3, [r7, #4]
 8013320:	695b      	ldr	r3, [r3, #20]
 8013322:	2b00      	cmp	r3, #0
 8013324:	d016      	beq.n	8013354 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8013326:	4b15      	ldr	r3, [pc, #84]	@ (801337c <HAL_RCC_OscConfig+0x248>)
 8013328:	2201      	movs	r2, #1
 801332a:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 801332c:	f7fb ffe6 	bl	800f2fc <HAL_GetTick>
 8013330:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8013332:	e008      	b.n	8013346 <HAL_RCC_OscConfig+0x212>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8013334:	f7fb ffe2 	bl	800f2fc <HAL_GetTick>
 8013338:	4602      	mov	r2, r0
 801333a:	693b      	ldr	r3, [r7, #16]
 801333c:	1ad3      	subs	r3, r2, r3
 801333e:	2b02      	cmp	r3, #2
 8013340:	d901      	bls.n	8013346 <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 8013342:	2303      	movs	r3, #3
 8013344:	e167      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8013346:	4b0b      	ldr	r3, [pc, #44]	@ (8013374 <HAL_RCC_OscConfig+0x240>)
 8013348:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 801334a:	f003 0302 	and.w	r3, r3, #2
 801334e:	2b00      	cmp	r3, #0
 8013350:	d0f0      	beq.n	8013334 <HAL_RCC_OscConfig+0x200>
 8013352:	e01b      	b.n	801338c <HAL_RCC_OscConfig+0x258>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8013354:	4b09      	ldr	r3, [pc, #36]	@ (801337c <HAL_RCC_OscConfig+0x248>)
 8013356:	2200      	movs	r2, #0
 8013358:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 801335a:	f7fb ffcf 	bl	800f2fc <HAL_GetTick>
 801335e:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8013360:	e00e      	b.n	8013380 <HAL_RCC_OscConfig+0x24c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8013362:	f7fb ffcb 	bl	800f2fc <HAL_GetTick>
 8013366:	4602      	mov	r2, r0
 8013368:	693b      	ldr	r3, [r7, #16]
 801336a:	1ad3      	subs	r3, r2, r3
 801336c:	2b02      	cmp	r3, #2
 801336e:	d907      	bls.n	8013380 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 8013370:	2303      	movs	r3, #3
 8013372:	e150      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
 8013374:	40023800 	.word	0x40023800
 8013378:	42470000 	.word	0x42470000
 801337c:	42470e80 	.word	0x42470e80
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8013380:	4b88      	ldr	r3, [pc, #544]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013382:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8013384:	f003 0302 	and.w	r3, r3, #2
 8013388:	2b00      	cmp	r3, #0
 801338a:	d1ea      	bne.n	8013362 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 801338c:	687b      	ldr	r3, [r7, #4]
 801338e:	681b      	ldr	r3, [r3, #0]
 8013390:	f003 0304 	and.w	r3, r3, #4
 8013394:	2b00      	cmp	r3, #0
 8013396:	f000 8097 	beq.w	80134c8 <HAL_RCC_OscConfig+0x394>
  {
    FlagStatus       pwrclkchanged = RESET;
 801339a:	2300      	movs	r3, #0
 801339c:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 801339e:	4b81      	ldr	r3, [pc, #516]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80133a0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80133a2:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80133a6:	2b00      	cmp	r3, #0
 80133a8:	d10f      	bne.n	80133ca <HAL_RCC_OscConfig+0x296>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80133aa:	2300      	movs	r3, #0
 80133ac:	60bb      	str	r3, [r7, #8]
 80133ae:	4b7d      	ldr	r3, [pc, #500]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80133b0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80133b2:	4a7c      	ldr	r2, [pc, #496]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80133b4:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80133b8:	6413      	str	r3, [r2, #64]	@ 0x40
 80133ba:	4b7a      	ldr	r3, [pc, #488]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80133bc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80133be:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80133c2:	60bb      	str	r3, [r7, #8]
 80133c4:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 80133c6:	2301      	movs	r3, #1
 80133c8:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80133ca:	4b77      	ldr	r3, [pc, #476]	@ (80135a8 <HAL_RCC_OscConfig+0x474>)
 80133cc:	681b      	ldr	r3, [r3, #0]
 80133ce:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80133d2:	2b00      	cmp	r3, #0
 80133d4:	d118      	bne.n	8013408 <HAL_RCC_OscConfig+0x2d4>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80133d6:	4b74      	ldr	r3, [pc, #464]	@ (80135a8 <HAL_RCC_OscConfig+0x474>)
 80133d8:	681b      	ldr	r3, [r3, #0]
 80133da:	4a73      	ldr	r2, [pc, #460]	@ (80135a8 <HAL_RCC_OscConfig+0x474>)
 80133dc:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 80133e0:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 80133e2:	f7fb ff8b 	bl	800f2fc <HAL_GetTick>
 80133e6:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80133e8:	e008      	b.n	80133fc <HAL_RCC_OscConfig+0x2c8>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80133ea:	f7fb ff87 	bl	800f2fc <HAL_GetTick>
 80133ee:	4602      	mov	r2, r0
 80133f0:	693b      	ldr	r3, [r7, #16]
 80133f2:	1ad3      	subs	r3, r2, r3
 80133f4:	2b02      	cmp	r3, #2
 80133f6:	d901      	bls.n	80133fc <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 80133f8:	2303      	movs	r3, #3
 80133fa:	e10c      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80133fc:	4b6a      	ldr	r3, [pc, #424]	@ (80135a8 <HAL_RCC_OscConfig+0x474>)
 80133fe:	681b      	ldr	r3, [r3, #0]
 8013400:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8013404:	2b00      	cmp	r3, #0
 8013406:	d0f0      	beq.n	80133ea <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8013408:	687b      	ldr	r3, [r7, #4]
 801340a:	689b      	ldr	r3, [r3, #8]
 801340c:	2b01      	cmp	r3, #1
 801340e:	d106      	bne.n	801341e <HAL_RCC_OscConfig+0x2ea>
 8013410:	4b64      	ldr	r3, [pc, #400]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013412:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013414:	4a63      	ldr	r2, [pc, #396]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013416:	f043 0301 	orr.w	r3, r3, #1
 801341a:	6713      	str	r3, [r2, #112]	@ 0x70
 801341c:	e01c      	b.n	8013458 <HAL_RCC_OscConfig+0x324>
 801341e:	687b      	ldr	r3, [r7, #4]
 8013420:	689b      	ldr	r3, [r3, #8]
 8013422:	2b05      	cmp	r3, #5
 8013424:	d10c      	bne.n	8013440 <HAL_RCC_OscConfig+0x30c>
 8013426:	4b5f      	ldr	r3, [pc, #380]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013428:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801342a:	4a5e      	ldr	r2, [pc, #376]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 801342c:	f043 0304 	orr.w	r3, r3, #4
 8013430:	6713      	str	r3, [r2, #112]	@ 0x70
 8013432:	4b5c      	ldr	r3, [pc, #368]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013434:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013436:	4a5b      	ldr	r2, [pc, #364]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013438:	f043 0301 	orr.w	r3, r3, #1
 801343c:	6713      	str	r3, [r2, #112]	@ 0x70
 801343e:	e00b      	b.n	8013458 <HAL_RCC_OscConfig+0x324>
 8013440:	4b58      	ldr	r3, [pc, #352]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013442:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013444:	4a57      	ldr	r2, [pc, #348]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013446:	f023 0301 	bic.w	r3, r3, #1
 801344a:	6713      	str	r3, [r2, #112]	@ 0x70
 801344c:	4b55      	ldr	r3, [pc, #340]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 801344e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013450:	4a54      	ldr	r2, [pc, #336]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013452:	f023 0304 	bic.w	r3, r3, #4
 8013456:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8013458:	687b      	ldr	r3, [r7, #4]
 801345a:	689b      	ldr	r3, [r3, #8]
 801345c:	2b00      	cmp	r3, #0
 801345e:	d015      	beq.n	801348c <HAL_RCC_OscConfig+0x358>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8013460:	f7fb ff4c 	bl	800f2fc <HAL_GetTick>
 8013464:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8013466:	e00a      	b.n	801347e <HAL_RCC_OscConfig+0x34a>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8013468:	f7fb ff48 	bl	800f2fc <HAL_GetTick>
 801346c:	4602      	mov	r2, r0
 801346e:	693b      	ldr	r3, [r7, #16]
 8013470:	1ad3      	subs	r3, r2, r3
 8013472:	f241 3288 	movw	r2, #5000	@ 0x1388
 8013476:	4293      	cmp	r3, r2
 8013478:	d901      	bls.n	801347e <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 801347a:	2303      	movs	r3, #3
 801347c:	e0cb      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 801347e:	4b49      	ldr	r3, [pc, #292]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013480:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013482:	f003 0302 	and.w	r3, r3, #2
 8013486:	2b00      	cmp	r3, #0
 8013488:	d0ee      	beq.n	8013468 <HAL_RCC_OscConfig+0x334>
 801348a:	e014      	b.n	80134b6 <HAL_RCC_OscConfig+0x382>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 801348c:	f7fb ff36 	bl	800f2fc <HAL_GetTick>
 8013490:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8013492:	e00a      	b.n	80134aa <HAL_RCC_OscConfig+0x376>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8013494:	f7fb ff32 	bl	800f2fc <HAL_GetTick>
 8013498:	4602      	mov	r2, r0
 801349a:	693b      	ldr	r3, [r7, #16]
 801349c:	1ad3      	subs	r3, r2, r3
 801349e:	f241 3288 	movw	r2, #5000	@ 0x1388
 80134a2:	4293      	cmp	r3, r2
 80134a4:	d901      	bls.n	80134aa <HAL_RCC_OscConfig+0x376>
        {
          return HAL_TIMEOUT;
 80134a6:	2303      	movs	r3, #3
 80134a8:	e0b5      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80134aa:	4b3e      	ldr	r3, [pc, #248]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80134ac:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80134ae:	f003 0302 	and.w	r3, r3, #2
 80134b2:	2b00      	cmp	r3, #0
 80134b4:	d1ee      	bne.n	8013494 <HAL_RCC_OscConfig+0x360>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 80134b6:	7dfb      	ldrb	r3, [r7, #23]
 80134b8:	2b01      	cmp	r3, #1
 80134ba:	d105      	bne.n	80134c8 <HAL_RCC_OscConfig+0x394>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80134bc:	4b39      	ldr	r3, [pc, #228]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80134be:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80134c0:	4a38      	ldr	r2, [pc, #224]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80134c2:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 80134c6:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80134c8:	687b      	ldr	r3, [r7, #4]
 80134ca:	699b      	ldr	r3, [r3, #24]
 80134cc:	2b00      	cmp	r3, #0
 80134ce:	f000 80a1 	beq.w	8013614 <HAL_RCC_OscConfig+0x4e0>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80134d2:	4b34      	ldr	r3, [pc, #208]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 80134d4:	689b      	ldr	r3, [r3, #8]
 80134d6:	f003 030c 	and.w	r3, r3, #12
 80134da:	2b08      	cmp	r3, #8
 80134dc:	d05c      	beq.n	8013598 <HAL_RCC_OscConfig+0x464>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80134de:	687b      	ldr	r3, [r7, #4]
 80134e0:	699b      	ldr	r3, [r3, #24]
 80134e2:	2b02      	cmp	r3, #2
 80134e4:	d141      	bne.n	801356a <HAL_RCC_OscConfig+0x436>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80134e6:	4b31      	ldr	r3, [pc, #196]	@ (80135ac <HAL_RCC_OscConfig+0x478>)
 80134e8:	2200      	movs	r2, #0
 80134ea:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80134ec:	f7fb ff06 	bl	800f2fc <HAL_GetTick>
 80134f0:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80134f2:	e008      	b.n	8013506 <HAL_RCC_OscConfig+0x3d2>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80134f4:	f7fb ff02 	bl	800f2fc <HAL_GetTick>
 80134f8:	4602      	mov	r2, r0
 80134fa:	693b      	ldr	r3, [r7, #16]
 80134fc:	1ad3      	subs	r3, r2, r3
 80134fe:	2b02      	cmp	r3, #2
 8013500:	d901      	bls.n	8013506 <HAL_RCC_OscConfig+0x3d2>
          {
            return HAL_TIMEOUT;
 8013502:	2303      	movs	r3, #3
 8013504:	e087      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8013506:	4b27      	ldr	r3, [pc, #156]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013508:	681b      	ldr	r3, [r3, #0]
 801350a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 801350e:	2b00      	cmp	r3, #0
 8013510:	d1f0      	bne.n	80134f4 <HAL_RCC_OscConfig+0x3c0>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8013512:	687b      	ldr	r3, [r7, #4]
 8013514:	69da      	ldr	r2, [r3, #28]
 8013516:	687b      	ldr	r3, [r7, #4]
 8013518:	6a1b      	ldr	r3, [r3, #32]
 801351a:	431a      	orrs	r2, r3
 801351c:	687b      	ldr	r3, [r7, #4]
 801351e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8013520:	019b      	lsls	r3, r3, #6
 8013522:	431a      	orrs	r2, r3
 8013524:	687b      	ldr	r3, [r7, #4]
 8013526:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013528:	085b      	lsrs	r3, r3, #1
 801352a:	3b01      	subs	r3, #1
 801352c:	041b      	lsls	r3, r3, #16
 801352e:	431a      	orrs	r2, r3
 8013530:	687b      	ldr	r3, [r7, #4]
 8013532:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013534:	061b      	lsls	r3, r3, #24
 8013536:	491b      	ldr	r1, [pc, #108]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 8013538:	4313      	orrs	r3, r2
 801353a:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 801353c:	4b1b      	ldr	r3, [pc, #108]	@ (80135ac <HAL_RCC_OscConfig+0x478>)
 801353e:	2201      	movs	r2, #1
 8013540:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8013542:	f7fb fedb 	bl	800f2fc <HAL_GetTick>
 8013546:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8013548:	e008      	b.n	801355c <HAL_RCC_OscConfig+0x428>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 801354a:	f7fb fed7 	bl	800f2fc <HAL_GetTick>
 801354e:	4602      	mov	r2, r0
 8013550:	693b      	ldr	r3, [r7, #16]
 8013552:	1ad3      	subs	r3, r2, r3
 8013554:	2b02      	cmp	r3, #2
 8013556:	d901      	bls.n	801355c <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 8013558:	2303      	movs	r3, #3
 801355a:	e05c      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 801355c:	4b11      	ldr	r3, [pc, #68]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 801355e:	681b      	ldr	r3, [r3, #0]
 8013560:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8013564:	2b00      	cmp	r3, #0
 8013566:	d0f0      	beq.n	801354a <HAL_RCC_OscConfig+0x416>
 8013568:	e054      	b.n	8013614 <HAL_RCC_OscConfig+0x4e0>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 801356a:	4b10      	ldr	r3, [pc, #64]	@ (80135ac <HAL_RCC_OscConfig+0x478>)
 801356c:	2200      	movs	r2, #0
 801356e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8013570:	f7fb fec4 	bl	800f2fc <HAL_GetTick>
 8013574:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8013576:	e008      	b.n	801358a <HAL_RCC_OscConfig+0x456>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8013578:	f7fb fec0 	bl	800f2fc <HAL_GetTick>
 801357c:	4602      	mov	r2, r0
 801357e:	693b      	ldr	r3, [r7, #16]
 8013580:	1ad3      	subs	r3, r2, r3
 8013582:	2b02      	cmp	r3, #2
 8013584:	d901      	bls.n	801358a <HAL_RCC_OscConfig+0x456>
          {
            return HAL_TIMEOUT;
 8013586:	2303      	movs	r3, #3
 8013588:	e045      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 801358a:	4b06      	ldr	r3, [pc, #24]	@ (80135a4 <HAL_RCC_OscConfig+0x470>)
 801358c:	681b      	ldr	r3, [r3, #0]
 801358e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8013592:	2b00      	cmp	r3, #0
 8013594:	d1f0      	bne.n	8013578 <HAL_RCC_OscConfig+0x444>
 8013596:	e03d      	b.n	8013614 <HAL_RCC_OscConfig+0x4e0>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8013598:	687b      	ldr	r3, [r7, #4]
 801359a:	699b      	ldr	r3, [r3, #24]
 801359c:	2b01      	cmp	r3, #1
 801359e:	d107      	bne.n	80135b0 <HAL_RCC_OscConfig+0x47c>
      {
        return HAL_ERROR;
 80135a0:	2301      	movs	r3, #1
 80135a2:	e038      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
 80135a4:	40023800 	.word	0x40023800
 80135a8:	40007000 	.word	0x40007000
 80135ac:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 80135b0:	4b1b      	ldr	r3, [pc, #108]	@ (8013620 <HAL_RCC_OscConfig+0x4ec>)
 80135b2:	685b      	ldr	r3, [r3, #4]
 80135b4:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80135b6:	687b      	ldr	r3, [r7, #4]
 80135b8:	699b      	ldr	r3, [r3, #24]
 80135ba:	2b01      	cmp	r3, #1
 80135bc:	d028      	beq.n	8013610 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80135be:	68fb      	ldr	r3, [r7, #12]
 80135c0:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 80135c4:	687b      	ldr	r3, [r7, #4]
 80135c6:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80135c8:	429a      	cmp	r2, r3
 80135ca:	d121      	bne.n	8013610 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 80135cc:	68fb      	ldr	r3, [r7, #12]
 80135ce:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 80135d2:	687b      	ldr	r3, [r7, #4]
 80135d4:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80135d6:	429a      	cmp	r2, r3
 80135d8:	d11a      	bne.n	8013610 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80135da:	68fa      	ldr	r2, [r7, #12]
 80135dc:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 80135e0:	4013      	ands	r3, r2
 80135e2:	687a      	ldr	r2, [r7, #4]
 80135e4:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 80135e6:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 80135e8:	4293      	cmp	r3, r2
 80135ea:	d111      	bne.n	8013610 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 80135ec:	68fb      	ldr	r3, [r7, #12]
 80135ee:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 80135f2:	687b      	ldr	r3, [r7, #4]
 80135f4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80135f6:	085b      	lsrs	r3, r3, #1
 80135f8:	3b01      	subs	r3, #1
 80135fa:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 80135fc:	429a      	cmp	r2, r3
 80135fe:	d107      	bne.n	8013610 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8013600:	68fb      	ldr	r3, [r7, #12]
 8013602:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 8013606:	687b      	ldr	r3, [r7, #4]
 8013608:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801360a:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 801360c:	429a      	cmp	r2, r3
 801360e:	d001      	beq.n	8013614 <HAL_RCC_OscConfig+0x4e0>
#endif
        {
          return HAL_ERROR;
 8013610:	2301      	movs	r3, #1
 8013612:	e000      	b.n	8013616 <HAL_RCC_OscConfig+0x4e2>
        }
      }
    }
  }
  return HAL_OK;
 8013614:	2300      	movs	r3, #0
}
 8013616:	4618      	mov	r0, r3
 8013618:	3718      	adds	r7, #24
 801361a:	46bd      	mov	sp, r7
 801361c:	bd80      	pop	{r7, pc}
 801361e:	bf00      	nop
 8013620:	40023800 	.word	0x40023800

08013624 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8013624:	b580      	push	{r7, lr}
 8013626:	b084      	sub	sp, #16
 8013628:	af00      	add	r7, sp, #0
 801362a:	6078      	str	r0, [r7, #4]
 801362c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 801362e:	687b      	ldr	r3, [r7, #4]
 8013630:	2b00      	cmp	r3, #0
 8013632:	d101      	bne.n	8013638 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8013634:	2301      	movs	r3, #1
 8013636:	e0cc      	b.n	80137d2 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8013638:	4b68      	ldr	r3, [pc, #416]	@ (80137dc <HAL_RCC_ClockConfig+0x1b8>)
 801363a:	681b      	ldr	r3, [r3, #0]
 801363c:	f003 0307 	and.w	r3, r3, #7
 8013640:	683a      	ldr	r2, [r7, #0]
 8013642:	429a      	cmp	r2, r3
 8013644:	d90c      	bls.n	8013660 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8013646:	4b65      	ldr	r3, [pc, #404]	@ (80137dc <HAL_RCC_ClockConfig+0x1b8>)
 8013648:	683a      	ldr	r2, [r7, #0]
 801364a:	b2d2      	uxtb	r2, r2
 801364c:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 801364e:	4b63      	ldr	r3, [pc, #396]	@ (80137dc <HAL_RCC_ClockConfig+0x1b8>)
 8013650:	681b      	ldr	r3, [r3, #0]
 8013652:	f003 0307 	and.w	r3, r3, #7
 8013656:	683a      	ldr	r2, [r7, #0]
 8013658:	429a      	cmp	r2, r3
 801365a:	d001      	beq.n	8013660 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 801365c:	2301      	movs	r3, #1
 801365e:	e0b8      	b.n	80137d2 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8013660:	687b      	ldr	r3, [r7, #4]
 8013662:	681b      	ldr	r3, [r3, #0]
 8013664:	f003 0302 	and.w	r3, r3, #2
 8013668:	2b00      	cmp	r3, #0
 801366a:	d020      	beq.n	80136ae <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 801366c:	687b      	ldr	r3, [r7, #4]
 801366e:	681b      	ldr	r3, [r3, #0]
 8013670:	f003 0304 	and.w	r3, r3, #4
 8013674:	2b00      	cmp	r3, #0
 8013676:	d005      	beq.n	8013684 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8013678:	4b59      	ldr	r3, [pc, #356]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 801367a:	689b      	ldr	r3, [r3, #8]
 801367c:	4a58      	ldr	r2, [pc, #352]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 801367e:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 8013682:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8013684:	687b      	ldr	r3, [r7, #4]
 8013686:	681b      	ldr	r3, [r3, #0]
 8013688:	f003 0308 	and.w	r3, r3, #8
 801368c:	2b00      	cmp	r3, #0
 801368e:	d005      	beq.n	801369c <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8013690:	4b53      	ldr	r3, [pc, #332]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 8013692:	689b      	ldr	r3, [r3, #8]
 8013694:	4a52      	ldr	r2, [pc, #328]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 8013696:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 801369a:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 801369c:	4b50      	ldr	r3, [pc, #320]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 801369e:	689b      	ldr	r3, [r3, #8]
 80136a0:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 80136a4:	687b      	ldr	r3, [r7, #4]
 80136a6:	689b      	ldr	r3, [r3, #8]
 80136a8:	494d      	ldr	r1, [pc, #308]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 80136aa:	4313      	orrs	r3, r2
 80136ac:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80136ae:	687b      	ldr	r3, [r7, #4]
 80136b0:	681b      	ldr	r3, [r3, #0]
 80136b2:	f003 0301 	and.w	r3, r3, #1
 80136b6:	2b00      	cmp	r3, #0
 80136b8:	d044      	beq.n	8013744 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80136ba:	687b      	ldr	r3, [r7, #4]
 80136bc:	685b      	ldr	r3, [r3, #4]
 80136be:	2b01      	cmp	r3, #1
 80136c0:	d107      	bne.n	80136d2 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80136c2:	4b47      	ldr	r3, [pc, #284]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 80136c4:	681b      	ldr	r3, [r3, #0]
 80136c6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80136ca:	2b00      	cmp	r3, #0
 80136cc:	d119      	bne.n	8013702 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80136ce:	2301      	movs	r3, #1
 80136d0:	e07f      	b.n	80137d2 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80136d2:	687b      	ldr	r3, [r7, #4]
 80136d4:	685b      	ldr	r3, [r3, #4]
 80136d6:	2b02      	cmp	r3, #2
 80136d8:	d003      	beq.n	80136e2 <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 80136da:	687b      	ldr	r3, [r7, #4]
 80136dc:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 80136de:	2b03      	cmp	r3, #3
 80136e0:	d107      	bne.n	80136f2 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80136e2:	4b3f      	ldr	r3, [pc, #252]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 80136e4:	681b      	ldr	r3, [r3, #0]
 80136e6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80136ea:	2b00      	cmp	r3, #0
 80136ec:	d109      	bne.n	8013702 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80136ee:	2301      	movs	r3, #1
 80136f0:	e06f      	b.n	80137d2 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80136f2:	4b3b      	ldr	r3, [pc, #236]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 80136f4:	681b      	ldr	r3, [r3, #0]
 80136f6:	f003 0302 	and.w	r3, r3, #2
 80136fa:	2b00      	cmp	r3, #0
 80136fc:	d101      	bne.n	8013702 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 80136fe:	2301      	movs	r3, #1
 8013700:	e067      	b.n	80137d2 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8013702:	4b37      	ldr	r3, [pc, #220]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 8013704:	689b      	ldr	r3, [r3, #8]
 8013706:	f023 0203 	bic.w	r2, r3, #3
 801370a:	687b      	ldr	r3, [r7, #4]
 801370c:	685b      	ldr	r3, [r3, #4]
 801370e:	4934      	ldr	r1, [pc, #208]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 8013710:	4313      	orrs	r3, r2
 8013712:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8013714:	f7fb fdf2 	bl	800f2fc <HAL_GetTick>
 8013718:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 801371a:	e00a      	b.n	8013732 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 801371c:	f7fb fdee 	bl	800f2fc <HAL_GetTick>
 8013720:	4602      	mov	r2, r0
 8013722:	68fb      	ldr	r3, [r7, #12]
 8013724:	1ad3      	subs	r3, r2, r3
 8013726:	f241 3288 	movw	r2, #5000	@ 0x1388
 801372a:	4293      	cmp	r3, r2
 801372c:	d901      	bls.n	8013732 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 801372e:	2303      	movs	r3, #3
 8013730:	e04f      	b.n	80137d2 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8013732:	4b2b      	ldr	r3, [pc, #172]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 8013734:	689b      	ldr	r3, [r3, #8]
 8013736:	f003 020c 	and.w	r2, r3, #12
 801373a:	687b      	ldr	r3, [r7, #4]
 801373c:	685b      	ldr	r3, [r3, #4]
 801373e:	009b      	lsls	r3, r3, #2
 8013740:	429a      	cmp	r2, r3
 8013742:	d1eb      	bne.n	801371c <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8013744:	4b25      	ldr	r3, [pc, #148]	@ (80137dc <HAL_RCC_ClockConfig+0x1b8>)
 8013746:	681b      	ldr	r3, [r3, #0]
 8013748:	f003 0307 	and.w	r3, r3, #7
 801374c:	683a      	ldr	r2, [r7, #0]
 801374e:	429a      	cmp	r2, r3
 8013750:	d20c      	bcs.n	801376c <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8013752:	4b22      	ldr	r3, [pc, #136]	@ (80137dc <HAL_RCC_ClockConfig+0x1b8>)
 8013754:	683a      	ldr	r2, [r7, #0]
 8013756:	b2d2      	uxtb	r2, r2
 8013758:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 801375a:	4b20      	ldr	r3, [pc, #128]	@ (80137dc <HAL_RCC_ClockConfig+0x1b8>)
 801375c:	681b      	ldr	r3, [r3, #0]
 801375e:	f003 0307 	and.w	r3, r3, #7
 8013762:	683a      	ldr	r2, [r7, #0]
 8013764:	429a      	cmp	r2, r3
 8013766:	d001      	beq.n	801376c <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8013768:	2301      	movs	r3, #1
 801376a:	e032      	b.n	80137d2 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 801376c:	687b      	ldr	r3, [r7, #4]
 801376e:	681b      	ldr	r3, [r3, #0]
 8013770:	f003 0304 	and.w	r3, r3, #4
 8013774:	2b00      	cmp	r3, #0
 8013776:	d008      	beq.n	801378a <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8013778:	4b19      	ldr	r3, [pc, #100]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 801377a:	689b      	ldr	r3, [r3, #8]
 801377c:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 8013780:	687b      	ldr	r3, [r7, #4]
 8013782:	68db      	ldr	r3, [r3, #12]
 8013784:	4916      	ldr	r1, [pc, #88]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 8013786:	4313      	orrs	r3, r2
 8013788:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 801378a:	687b      	ldr	r3, [r7, #4]
 801378c:	681b      	ldr	r3, [r3, #0]
 801378e:	f003 0308 	and.w	r3, r3, #8
 8013792:	2b00      	cmp	r3, #0
 8013794:	d009      	beq.n	80137aa <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8013796:	4b12      	ldr	r3, [pc, #72]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 8013798:	689b      	ldr	r3, [r3, #8]
 801379a:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 801379e:	687b      	ldr	r3, [r7, #4]
 80137a0:	691b      	ldr	r3, [r3, #16]
 80137a2:	00db      	lsls	r3, r3, #3
 80137a4:	490e      	ldr	r1, [pc, #56]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 80137a6:	4313      	orrs	r3, r2
 80137a8:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80137aa:	f000 f821 	bl	80137f0 <HAL_RCC_GetSysClockFreq>
 80137ae:	4602      	mov	r2, r0
 80137b0:	4b0b      	ldr	r3, [pc, #44]	@ (80137e0 <HAL_RCC_ClockConfig+0x1bc>)
 80137b2:	689b      	ldr	r3, [r3, #8]
 80137b4:	091b      	lsrs	r3, r3, #4
 80137b6:	f003 030f 	and.w	r3, r3, #15
 80137ba:	490a      	ldr	r1, [pc, #40]	@ (80137e4 <HAL_RCC_ClockConfig+0x1c0>)
 80137bc:	5ccb      	ldrb	r3, [r1, r3]
 80137be:	fa22 f303 	lsr.w	r3, r2, r3
 80137c2:	4a09      	ldr	r2, [pc, #36]	@ (80137e8 <HAL_RCC_ClockConfig+0x1c4>)
 80137c4:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 80137c6:	4b09      	ldr	r3, [pc, #36]	@ (80137ec <HAL_RCC_ClockConfig+0x1c8>)
 80137c8:	681b      	ldr	r3, [r3, #0]
 80137ca:	4618      	mov	r0, r3
 80137cc:	f7fb fd52 	bl	800f274 <HAL_InitTick>

  return HAL_OK;
 80137d0:	2300      	movs	r3, #0
}
 80137d2:	4618      	mov	r0, r3
 80137d4:	3710      	adds	r7, #16
 80137d6:	46bd      	mov	sp, r7
 80137d8:	bd80      	pop	{r7, pc}
 80137da:	bf00      	nop
 80137dc:	40023c00 	.word	0x40023c00
 80137e0:	40023800 	.word	0x40023800
 80137e4:	08023a1c 	.word	0x08023a1c
 80137e8:	20000144 	.word	0x20000144
 80137ec:	2000034c 	.word	0x2000034c

080137f0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80137f0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80137f4:	b094      	sub	sp, #80	@ 0x50
 80137f6:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 80137f8:	2300      	movs	r3, #0
 80137fa:	647b      	str	r3, [r7, #68]	@ 0x44
 80137fc:	2300      	movs	r3, #0
 80137fe:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8013800:	2300      	movs	r3, #0
 8013802:	643b      	str	r3, [r7, #64]	@ 0x40
  uint32_t sysclockfreq = 0U;
 8013804:	2300      	movs	r3, #0
 8013806:	64bb      	str	r3, [r7, #72]	@ 0x48

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8013808:	4b79      	ldr	r3, [pc, #484]	@ (80139f0 <HAL_RCC_GetSysClockFreq+0x200>)
 801380a:	689b      	ldr	r3, [r3, #8]
 801380c:	f003 030c 	and.w	r3, r3, #12
 8013810:	2b08      	cmp	r3, #8
 8013812:	d00d      	beq.n	8013830 <HAL_RCC_GetSysClockFreq+0x40>
 8013814:	2b08      	cmp	r3, #8
 8013816:	f200 80e1 	bhi.w	80139dc <HAL_RCC_GetSysClockFreq+0x1ec>
 801381a:	2b00      	cmp	r3, #0
 801381c:	d002      	beq.n	8013824 <HAL_RCC_GetSysClockFreq+0x34>
 801381e:	2b04      	cmp	r3, #4
 8013820:	d003      	beq.n	801382a <HAL_RCC_GetSysClockFreq+0x3a>
 8013822:	e0db      	b.n	80139dc <HAL_RCC_GetSysClockFreq+0x1ec>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8013824:	4b73      	ldr	r3, [pc, #460]	@ (80139f4 <HAL_RCC_GetSysClockFreq+0x204>)
 8013826:	64bb      	str	r3, [r7, #72]	@ 0x48
       break;
 8013828:	e0db      	b.n	80139e2 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 801382a:	4b73      	ldr	r3, [pc, #460]	@ (80139f8 <HAL_RCC_GetSysClockFreq+0x208>)
 801382c:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 801382e:	e0d8      	b.n	80139e2 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8013830:	4b6f      	ldr	r3, [pc, #444]	@ (80139f0 <HAL_RCC_GetSysClockFreq+0x200>)
 8013832:	685b      	ldr	r3, [r3, #4]
 8013834:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8013838:	647b      	str	r3, [r7, #68]	@ 0x44
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 801383a:	4b6d      	ldr	r3, [pc, #436]	@ (80139f0 <HAL_RCC_GetSysClockFreq+0x200>)
 801383c:	685b      	ldr	r3, [r3, #4]
 801383e:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8013842:	2b00      	cmp	r3, #0
 8013844:	d063      	beq.n	801390e <HAL_RCC_GetSysClockFreq+0x11e>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8013846:	4b6a      	ldr	r3, [pc, #424]	@ (80139f0 <HAL_RCC_GetSysClockFreq+0x200>)
 8013848:	685b      	ldr	r3, [r3, #4]
 801384a:	099b      	lsrs	r3, r3, #6
 801384c:	2200      	movs	r2, #0
 801384e:	63bb      	str	r3, [r7, #56]	@ 0x38
 8013850:	63fa      	str	r2, [r7, #60]	@ 0x3c
 8013852:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8013854:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8013858:	633b      	str	r3, [r7, #48]	@ 0x30
 801385a:	2300      	movs	r3, #0
 801385c:	637b      	str	r3, [r7, #52]	@ 0x34
 801385e:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	@ 0x30
 8013862:	4622      	mov	r2, r4
 8013864:	462b      	mov	r3, r5
 8013866:	f04f 0000 	mov.w	r0, #0
 801386a:	f04f 0100 	mov.w	r1, #0
 801386e:	0159      	lsls	r1, r3, #5
 8013870:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8013874:	0150      	lsls	r0, r2, #5
 8013876:	4602      	mov	r2, r0
 8013878:	460b      	mov	r3, r1
 801387a:	4621      	mov	r1, r4
 801387c:	1a51      	subs	r1, r2, r1
 801387e:	6139      	str	r1, [r7, #16]
 8013880:	4629      	mov	r1, r5
 8013882:	eb63 0301 	sbc.w	r3, r3, r1
 8013886:	617b      	str	r3, [r7, #20]
 8013888:	f04f 0200 	mov.w	r2, #0
 801388c:	f04f 0300 	mov.w	r3, #0
 8013890:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 8013894:	4659      	mov	r1, fp
 8013896:	018b      	lsls	r3, r1, #6
 8013898:	4651      	mov	r1, sl
 801389a:	ea43 6391 	orr.w	r3, r3, r1, lsr #26
 801389e:	4651      	mov	r1, sl
 80138a0:	018a      	lsls	r2, r1, #6
 80138a2:	4651      	mov	r1, sl
 80138a4:	ebb2 0801 	subs.w	r8, r2, r1
 80138a8:	4659      	mov	r1, fp
 80138aa:	eb63 0901 	sbc.w	r9, r3, r1
 80138ae:	f04f 0200 	mov.w	r2, #0
 80138b2:	f04f 0300 	mov.w	r3, #0
 80138b6:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 80138ba:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 80138be:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 80138c2:	4690      	mov	r8, r2
 80138c4:	4699      	mov	r9, r3
 80138c6:	4623      	mov	r3, r4
 80138c8:	eb18 0303 	adds.w	r3, r8, r3
 80138cc:	60bb      	str	r3, [r7, #8]
 80138ce:	462b      	mov	r3, r5
 80138d0:	eb49 0303 	adc.w	r3, r9, r3
 80138d4:	60fb      	str	r3, [r7, #12]
 80138d6:	f04f 0200 	mov.w	r2, #0
 80138da:	f04f 0300 	mov.w	r3, #0
 80138de:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
 80138e2:	4629      	mov	r1, r5
 80138e4:	024b      	lsls	r3, r1, #9
 80138e6:	4621      	mov	r1, r4
 80138e8:	ea43 53d1 	orr.w	r3, r3, r1, lsr #23
 80138ec:	4621      	mov	r1, r4
 80138ee:	024a      	lsls	r2, r1, #9
 80138f0:	4610      	mov	r0, r2
 80138f2:	4619      	mov	r1, r3
 80138f4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80138f6:	2200      	movs	r2, #0
 80138f8:	62bb      	str	r3, [r7, #40]	@ 0x28
 80138fa:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80138fc:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8013900:	f7ed f9ca 	bl	8000c98 <__aeabi_uldivmod>
 8013904:	4602      	mov	r2, r0
 8013906:	460b      	mov	r3, r1
 8013908:	4613      	mov	r3, r2
 801390a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801390c:	e058      	b.n	80139c0 <HAL_RCC_GetSysClockFreq+0x1d0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 801390e:	4b38      	ldr	r3, [pc, #224]	@ (80139f0 <HAL_RCC_GetSysClockFreq+0x200>)
 8013910:	685b      	ldr	r3, [r3, #4]
 8013912:	099b      	lsrs	r3, r3, #6
 8013914:	2200      	movs	r2, #0
 8013916:	4618      	mov	r0, r3
 8013918:	4611      	mov	r1, r2
 801391a:	f3c0 0308 	ubfx	r3, r0, #0, #9
 801391e:	623b      	str	r3, [r7, #32]
 8013920:	2300      	movs	r3, #0
 8013922:	627b      	str	r3, [r7, #36]	@ 0x24
 8013924:	e9d7 8908 	ldrd	r8, r9, [r7, #32]
 8013928:	4642      	mov	r2, r8
 801392a:	464b      	mov	r3, r9
 801392c:	f04f 0000 	mov.w	r0, #0
 8013930:	f04f 0100 	mov.w	r1, #0
 8013934:	0159      	lsls	r1, r3, #5
 8013936:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 801393a:	0150      	lsls	r0, r2, #5
 801393c:	4602      	mov	r2, r0
 801393e:	460b      	mov	r3, r1
 8013940:	4641      	mov	r1, r8
 8013942:	ebb2 0a01 	subs.w	sl, r2, r1
 8013946:	4649      	mov	r1, r9
 8013948:	eb63 0b01 	sbc.w	fp, r3, r1
 801394c:	f04f 0200 	mov.w	r2, #0
 8013950:	f04f 0300 	mov.w	r3, #0
 8013954:	ea4f 138b 	mov.w	r3, fp, lsl #6
 8013958:	ea43 639a 	orr.w	r3, r3, sl, lsr #26
 801395c:	ea4f 128a 	mov.w	r2, sl, lsl #6
 8013960:	ebb2 040a 	subs.w	r4, r2, sl
 8013964:	eb63 050b 	sbc.w	r5, r3, fp
 8013968:	f04f 0200 	mov.w	r2, #0
 801396c:	f04f 0300 	mov.w	r3, #0
 8013970:	00eb      	lsls	r3, r5, #3
 8013972:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8013976:	00e2      	lsls	r2, r4, #3
 8013978:	4614      	mov	r4, r2
 801397a:	461d      	mov	r5, r3
 801397c:	4643      	mov	r3, r8
 801397e:	18e3      	adds	r3, r4, r3
 8013980:	603b      	str	r3, [r7, #0]
 8013982:	464b      	mov	r3, r9
 8013984:	eb45 0303 	adc.w	r3, r5, r3
 8013988:	607b      	str	r3, [r7, #4]
 801398a:	f04f 0200 	mov.w	r2, #0
 801398e:	f04f 0300 	mov.w	r3, #0
 8013992:	e9d7 4500 	ldrd	r4, r5, [r7]
 8013996:	4629      	mov	r1, r5
 8013998:	028b      	lsls	r3, r1, #10
 801399a:	4621      	mov	r1, r4
 801399c:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 80139a0:	4621      	mov	r1, r4
 80139a2:	028a      	lsls	r2, r1, #10
 80139a4:	4610      	mov	r0, r2
 80139a6:	4619      	mov	r1, r3
 80139a8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80139aa:	2200      	movs	r2, #0
 80139ac:	61bb      	str	r3, [r7, #24]
 80139ae:	61fa      	str	r2, [r7, #28]
 80139b0:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80139b4:	f7ed f970 	bl	8000c98 <__aeabi_uldivmod>
 80139b8:	4602      	mov	r2, r0
 80139ba:	460b      	mov	r3, r1
 80139bc:	4613      	mov	r3, r2
 80139be:	64fb      	str	r3, [r7, #76]	@ 0x4c
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 80139c0:	4b0b      	ldr	r3, [pc, #44]	@ (80139f0 <HAL_RCC_GetSysClockFreq+0x200>)
 80139c2:	685b      	ldr	r3, [r3, #4]
 80139c4:	0c1b      	lsrs	r3, r3, #16
 80139c6:	f003 0303 	and.w	r3, r3, #3
 80139ca:	3301      	adds	r3, #1
 80139cc:	005b      	lsls	r3, r3, #1
 80139ce:	643b      	str	r3, [r7, #64]	@ 0x40

      sysclockfreq = pllvco/pllp;
 80139d0:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80139d2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80139d4:	fbb2 f3f3 	udiv	r3, r2, r3
 80139d8:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 80139da:	e002      	b.n	80139e2 <HAL_RCC_GetSysClockFreq+0x1f2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 80139dc:	4b05      	ldr	r3, [pc, #20]	@ (80139f4 <HAL_RCC_GetSysClockFreq+0x204>)
 80139de:	64bb      	str	r3, [r7, #72]	@ 0x48
      break;
 80139e0:	bf00      	nop
    }
  }
  return sysclockfreq;
 80139e2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 80139e4:	4618      	mov	r0, r3
 80139e6:	3750      	adds	r7, #80	@ 0x50
 80139e8:	46bd      	mov	sp, r7
 80139ea:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80139ee:	bf00      	nop
 80139f0:	40023800 	.word	0x40023800
 80139f4:	00f42400 	.word	0x00f42400
 80139f8:	007a1200 	.word	0x007a1200

080139fc <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80139fc:	b480      	push	{r7}
 80139fe:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8013a00:	4b03      	ldr	r3, [pc, #12]	@ (8013a10 <HAL_RCC_GetHCLKFreq+0x14>)
 8013a02:	681b      	ldr	r3, [r3, #0]
}
 8013a04:	4618      	mov	r0, r3
 8013a06:	46bd      	mov	sp, r7
 8013a08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013a0c:	4770      	bx	lr
 8013a0e:	bf00      	nop
 8013a10:	20000144 	.word	0x20000144

08013a14 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8013a14:	b580      	push	{r7, lr}
 8013a16:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8013a18:	f7ff fff0 	bl	80139fc <HAL_RCC_GetHCLKFreq>
 8013a1c:	4602      	mov	r2, r0
 8013a1e:	4b05      	ldr	r3, [pc, #20]	@ (8013a34 <HAL_RCC_GetPCLK1Freq+0x20>)
 8013a20:	689b      	ldr	r3, [r3, #8]
 8013a22:	0a9b      	lsrs	r3, r3, #10
 8013a24:	f003 0307 	and.w	r3, r3, #7
 8013a28:	4903      	ldr	r1, [pc, #12]	@ (8013a38 <HAL_RCC_GetPCLK1Freq+0x24>)
 8013a2a:	5ccb      	ldrb	r3, [r1, r3]
 8013a2c:	fa22 f303 	lsr.w	r3, r2, r3
}
 8013a30:	4618      	mov	r0, r3
 8013a32:	bd80      	pop	{r7, pc}
 8013a34:	40023800 	.word	0x40023800
 8013a38:	08023a2c 	.word	0x08023a2c

08013a3c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8013a3c:	b580      	push	{r7, lr}
 8013a3e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8013a40:	f7ff ffdc 	bl	80139fc <HAL_RCC_GetHCLKFreq>
 8013a44:	4602      	mov	r2, r0
 8013a46:	4b05      	ldr	r3, [pc, #20]	@ (8013a5c <HAL_RCC_GetPCLK2Freq+0x20>)
 8013a48:	689b      	ldr	r3, [r3, #8]
 8013a4a:	0b5b      	lsrs	r3, r3, #13
 8013a4c:	f003 0307 	and.w	r3, r3, #7
 8013a50:	4903      	ldr	r1, [pc, #12]	@ (8013a60 <HAL_RCC_GetPCLK2Freq+0x24>)
 8013a52:	5ccb      	ldrb	r3, [r1, r3]
 8013a54:	fa22 f303 	lsr.w	r3, r2, r3
}
 8013a58:	4618      	mov	r0, r3
 8013a5a:	bd80      	pop	{r7, pc}
 8013a5c:	40023800 	.word	0x40023800
 8013a60:	08023a2c 	.word	0x08023a2c

08013a64 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8013a64:	b580      	push	{r7, lr}
 8013a66:	b086      	sub	sp, #24
 8013a68:	af00      	add	r7, sp, #0
 8013a6a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8013a6c:	2300      	movs	r3, #0
 8013a6e:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 8013a70:	2300      	movs	r3, #0
 8013a72:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8013a74:	687b      	ldr	r3, [r7, #4]
 8013a76:	681b      	ldr	r3, [r3, #0]
 8013a78:	f003 0301 	and.w	r3, r3, #1
 8013a7c:	2b00      	cmp	r3, #0
 8013a7e:	d105      	bne.n	8013a8c <HAL_RCCEx_PeriphCLKConfig+0x28>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8013a80:	687b      	ldr	r3, [r7, #4]
 8013a82:	681b      	ldr	r3, [r3, #0]
 8013a84:	f003 0304 	and.w	r3, r3, #4
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8013a88:	2b00      	cmp	r3, #0
 8013a8a:	d038      	beq.n	8013afe <HAL_RCCEx_PeriphCLKConfig+0x9a>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8013a8c:	4b68      	ldr	r3, [pc, #416]	@ (8013c30 <HAL_RCCEx_PeriphCLKConfig+0x1cc>)
 8013a8e:	2200      	movs	r2, #0
 8013a90:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8013a92:	f7fb fc33 	bl	800f2fc <HAL_GetTick>
 8013a96:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8013a98:	e008      	b.n	8013aac <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8013a9a:	f7fb fc2f 	bl	800f2fc <HAL_GetTick>
 8013a9e:	4602      	mov	r2, r0
 8013aa0:	697b      	ldr	r3, [r7, #20]
 8013aa2:	1ad3      	subs	r3, r2, r3
 8013aa4:	2b02      	cmp	r3, #2
 8013aa6:	d901      	bls.n	8013aac <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8013aa8:	2303      	movs	r3, #3
 8013aaa:	e0bd      	b.n	8013c28 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8013aac:	4b61      	ldr	r3, [pc, #388]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013aae:	681b      	ldr	r3, [r3, #0]
 8013ab0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013ab4:	2b00      	cmp	r3, #0
 8013ab6:	d1f0      	bne.n	8013a9a <HAL_RCCEx_PeriphCLKConfig+0x36>

#if defined(STM32F411xE)
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 8013ab8:	687b      	ldr	r3, [r7, #4]
 8013aba:	685a      	ldr	r2, [r3, #4]
 8013abc:	687b      	ldr	r3, [r7, #4]
 8013abe:	689b      	ldr	r3, [r3, #8]
 8013ac0:	019b      	lsls	r3, r3, #6
 8013ac2:	431a      	orrs	r2, r3
 8013ac4:	687b      	ldr	r3, [r7, #4]
 8013ac6:	68db      	ldr	r3, [r3, #12]
 8013ac8:	071b      	lsls	r3, r3, #28
 8013aca:	495a      	ldr	r1, [pc, #360]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013acc:	4313      	orrs	r3, r2
 8013ace:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8013ad2:	4b57      	ldr	r3, [pc, #348]	@ (8013c30 <HAL_RCCEx_PeriphCLKConfig+0x1cc>)
 8013ad4:	2201      	movs	r2, #1
 8013ad6:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8013ad8:	f7fb fc10 	bl	800f2fc <HAL_GetTick>
 8013adc:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8013ade:	e008      	b.n	8013af2 <HAL_RCCEx_PeriphCLKConfig+0x8e>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8013ae0:	f7fb fc0c 	bl	800f2fc <HAL_GetTick>
 8013ae4:	4602      	mov	r2, r0
 8013ae6:	697b      	ldr	r3, [r7, #20]
 8013ae8:	1ad3      	subs	r3, r2, r3
 8013aea:	2b02      	cmp	r3, #2
 8013aec:	d901      	bls.n	8013af2 <HAL_RCCEx_PeriphCLKConfig+0x8e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8013aee:	2303      	movs	r3, #3
 8013af0:	e09a      	b.n	8013c28 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8013af2:	4b50      	ldr	r3, [pc, #320]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013af4:	681b      	ldr	r3, [r3, #0]
 8013af6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013afa:	2b00      	cmp	r3, #0
 8013afc:	d0f0      	beq.n	8013ae0 <HAL_RCCEx_PeriphCLKConfig+0x7c>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8013afe:	687b      	ldr	r3, [r7, #4]
 8013b00:	681b      	ldr	r3, [r3, #0]
 8013b02:	f003 0302 	and.w	r3, r3, #2
 8013b06:	2b00      	cmp	r3, #0
 8013b08:	f000 8083 	beq.w	8013c12 <HAL_RCCEx_PeriphCLKConfig+0x1ae>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8013b0c:	2300      	movs	r3, #0
 8013b0e:	60fb      	str	r3, [r7, #12]
 8013b10:	4b48      	ldr	r3, [pc, #288]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013b12:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8013b14:	4a47      	ldr	r2, [pc, #284]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013b16:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8013b1a:	6413      	str	r3, [r2, #64]	@ 0x40
 8013b1c:	4b45      	ldr	r3, [pc, #276]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013b1e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8013b20:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8013b24:	60fb      	str	r3, [r7, #12]
 8013b26:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8013b28:	4b43      	ldr	r3, [pc, #268]	@ (8013c38 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 8013b2a:	681b      	ldr	r3, [r3, #0]
 8013b2c:	4a42      	ldr	r2, [pc, #264]	@ (8013c38 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 8013b2e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8013b32:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 8013b34:	f7fb fbe2 	bl	800f2fc <HAL_GetTick>
 8013b38:	6178      	str	r0, [r7, #20]

    while((PWR->CR & PWR_CR_DBP) == RESET)
 8013b3a:	e008      	b.n	8013b4e <HAL_RCCEx_PeriphCLKConfig+0xea>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8013b3c:	f7fb fbde 	bl	800f2fc <HAL_GetTick>
 8013b40:	4602      	mov	r2, r0
 8013b42:	697b      	ldr	r3, [r7, #20]
 8013b44:	1ad3      	subs	r3, r2, r3
 8013b46:	2b02      	cmp	r3, #2
 8013b48:	d901      	bls.n	8013b4e <HAL_RCCEx_PeriphCLKConfig+0xea>
      {
        return HAL_TIMEOUT;
 8013b4a:	2303      	movs	r3, #3
 8013b4c:	e06c      	b.n	8013c28 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8013b4e:	4b3a      	ldr	r3, [pc, #232]	@ (8013c38 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 8013b50:	681b      	ldr	r3, [r3, #0]
 8013b52:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8013b56:	2b00      	cmp	r3, #0
 8013b58:	d0f0      	beq.n	8013b3c <HAL_RCCEx_PeriphCLKConfig+0xd8>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8013b5a:	4b36      	ldr	r3, [pc, #216]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013b5c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013b5e:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8013b62:	613b      	str	r3, [r7, #16]
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8013b64:	693b      	ldr	r3, [r7, #16]
 8013b66:	2b00      	cmp	r3, #0
 8013b68:	d02f      	beq.n	8013bca <HAL_RCCEx_PeriphCLKConfig+0x166>
 8013b6a:	687b      	ldr	r3, [r7, #4]
 8013b6c:	691b      	ldr	r3, [r3, #16]
 8013b6e:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8013b72:	693a      	ldr	r2, [r7, #16]
 8013b74:	429a      	cmp	r2, r3
 8013b76:	d028      	beq.n	8013bca <HAL_RCCEx_PeriphCLKConfig+0x166>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8013b78:	4b2e      	ldr	r3, [pc, #184]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013b7a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013b7c:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8013b80:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8013b82:	4b2e      	ldr	r3, [pc, #184]	@ (8013c3c <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 8013b84:	2201      	movs	r2, #1
 8013b86:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8013b88:	4b2c      	ldr	r3, [pc, #176]	@ (8013c3c <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 8013b8a:	2200      	movs	r2, #0
 8013b8c:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 8013b8e:	4a29      	ldr	r2, [pc, #164]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013b90:	693b      	ldr	r3, [r7, #16]
 8013b92:	6713      	str	r3, [r2, #112]	@ 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8013b94:	4b27      	ldr	r3, [pc, #156]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013b96:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013b98:	f003 0301 	and.w	r3, r3, #1
 8013b9c:	2b01      	cmp	r3, #1
 8013b9e:	d114      	bne.n	8013bca <HAL_RCCEx_PeriphCLKConfig+0x166>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8013ba0:	f7fb fbac 	bl	800f2fc <HAL_GetTick>
 8013ba4:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8013ba6:	e00a      	b.n	8013bbe <HAL_RCCEx_PeriphCLKConfig+0x15a>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8013ba8:	f7fb fba8 	bl	800f2fc <HAL_GetTick>
 8013bac:	4602      	mov	r2, r0
 8013bae:	697b      	ldr	r3, [r7, #20]
 8013bb0:	1ad3      	subs	r3, r2, r3
 8013bb2:	f241 3288 	movw	r2, #5000	@ 0x1388
 8013bb6:	4293      	cmp	r3, r2
 8013bb8:	d901      	bls.n	8013bbe <HAL_RCCEx_PeriphCLKConfig+0x15a>
          {
            return HAL_TIMEOUT;
 8013bba:	2303      	movs	r3, #3
 8013bbc:	e034      	b.n	8013c28 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8013bbe:	4b1d      	ldr	r3, [pc, #116]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013bc0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8013bc2:	f003 0302 	and.w	r3, r3, #2
 8013bc6:	2b00      	cmp	r3, #0
 8013bc8:	d0ee      	beq.n	8013ba8 <HAL_RCCEx_PeriphCLKConfig+0x144>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8013bca:	687b      	ldr	r3, [r7, #4]
 8013bcc:	691b      	ldr	r3, [r3, #16]
 8013bce:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8013bd2:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8013bd6:	d10d      	bne.n	8013bf4 <HAL_RCCEx_PeriphCLKConfig+0x190>
 8013bd8:	4b16      	ldr	r3, [pc, #88]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013bda:	689b      	ldr	r3, [r3, #8]
 8013bdc:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 8013be0:	687b      	ldr	r3, [r7, #4]
 8013be2:	691b      	ldr	r3, [r3, #16]
 8013be4:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 8013be8:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8013bec:	4911      	ldr	r1, [pc, #68]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013bee:	4313      	orrs	r3, r2
 8013bf0:	608b      	str	r3, [r1, #8]
 8013bf2:	e005      	b.n	8013c00 <HAL_RCCEx_PeriphCLKConfig+0x19c>
 8013bf4:	4b0f      	ldr	r3, [pc, #60]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013bf6:	689b      	ldr	r3, [r3, #8]
 8013bf8:	4a0e      	ldr	r2, [pc, #56]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013bfa:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
 8013bfe:	6093      	str	r3, [r2, #8]
 8013c00:	4b0c      	ldr	r3, [pc, #48]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013c02:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8013c04:	687b      	ldr	r3, [r7, #4]
 8013c06:	691b      	ldr	r3, [r3, #16]
 8013c08:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8013c0c:	4909      	ldr	r1, [pc, #36]	@ (8013c34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8013c0e:	4313      	orrs	r3, r2
 8013c10:	670b      	str	r3, [r1, #112]	@ 0x70
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8013c12:	687b      	ldr	r3, [r7, #4]
 8013c14:	681b      	ldr	r3, [r3, #0]
 8013c16:	f003 0308 	and.w	r3, r3, #8
 8013c1a:	2b00      	cmp	r3, #0
 8013c1c:	d003      	beq.n	8013c26 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8013c1e:	687b      	ldr	r3, [r7, #4]
 8013c20:	7d1a      	ldrb	r2, [r3, #20]
 8013c22:	4b07      	ldr	r3, [pc, #28]	@ (8013c40 <HAL_RCCEx_PeriphCLKConfig+0x1dc>)
 8013c24:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 8013c26:	2300      	movs	r3, #0
}
 8013c28:	4618      	mov	r0, r3
 8013c2a:	3718      	adds	r7, #24
 8013c2c:	46bd      	mov	sp, r7
 8013c2e:	bd80      	pop	{r7, pc}
 8013c30:	42470068 	.word	0x42470068
 8013c34:	40023800 	.word	0x40023800
 8013c38:	40007000 	.word	0x40007000
 8013c3c:	42470e40 	.word	0x42470e40
 8013c40:	424711e0 	.word	0x424711e0

08013c44 <HAL_RTC_Init>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 8013c44:	b580      	push	{r7, lr}
 8013c46:	b084      	sub	sp, #16
 8013c48:	af00      	add	r7, sp, #0
 8013c4a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
 8013c4c:	2301      	movs	r3, #1
 8013c4e:	73fb      	strb	r3, [r7, #15]

  /* Check RTC handler validity */
  if (hrtc == NULL)
 8013c50:	687b      	ldr	r3, [r7, #4]
 8013c52:	2b00      	cmp	r3, #0
 8013c54:	d101      	bne.n	8013c5a <HAL_RTC_Init+0x16>
  {
    return HAL_ERROR;
 8013c56:	2301      	movs	r3, #1
 8013c58:	e073      	b.n	8013d42 <HAL_RTC_Init+0xfe>
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else /* USE_HAL_RTC_REGISTER_CALLBACKS */
  if (hrtc->State == HAL_RTC_STATE_RESET)
 8013c5a:	687b      	ldr	r3, [r7, #4]
 8013c5c:	7f5b      	ldrb	r3, [r3, #29]
 8013c5e:	b2db      	uxtb	r3, r3
 8013c60:	2b00      	cmp	r3, #0
 8013c62:	d105      	bne.n	8013c70 <HAL_RTC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 8013c64:	687b      	ldr	r3, [r7, #4]
 8013c66:	2200      	movs	r2, #0
 8013c68:	771a      	strb	r2, [r3, #28]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 8013c6a:	6878      	ldr	r0, [r7, #4]
 8013c6c:	f7f1 fe5c 	bl	8005928 <HAL_RTC_MspInit>
  }
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 8013c70:	687b      	ldr	r3, [r7, #4]
 8013c72:	2202      	movs	r2, #2
 8013c74:	775a      	strb	r2, [r3, #29]

  /* Check whether the calendar needs to be initialized */
  if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 8013c76:	687b      	ldr	r3, [r7, #4]
 8013c78:	681b      	ldr	r3, [r3, #0]
 8013c7a:	68db      	ldr	r3, [r3, #12]
 8013c7c:	f003 0310 	and.w	r3, r3, #16
 8013c80:	2b10      	cmp	r3, #16
 8013c82:	d055      	beq.n	8013d30 <HAL_RTC_Init+0xec>
  {
    /* Disable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013c84:	687b      	ldr	r3, [r7, #4]
 8013c86:	681b      	ldr	r3, [r3, #0]
 8013c88:	22ca      	movs	r2, #202	@ 0xca
 8013c8a:	625a      	str	r2, [r3, #36]	@ 0x24
 8013c8c:	687b      	ldr	r3, [r7, #4]
 8013c8e:	681b      	ldr	r3, [r3, #0]
 8013c90:	2253      	movs	r2, #83	@ 0x53
 8013c92:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Enter Initialization mode */
    status = RTC_EnterInitMode(hrtc);
 8013c94:	6878      	ldr	r0, [r7, #4]
 8013c96:	f000 f99d 	bl	8013fd4 <RTC_EnterInitMode>
 8013c9a:	4603      	mov	r3, r0
 8013c9c:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
 8013c9e:	7bfb      	ldrb	r3, [r7, #15]
 8013ca0:	2b00      	cmp	r3, #0
 8013ca2:	d12c      	bne.n	8013cfe <HAL_RTC_Init+0xba>
    {
      /* Clear RTC_CR FMT, OSEL and POL Bits */
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8013ca4:	687b      	ldr	r3, [r7, #4]
 8013ca6:	681b      	ldr	r3, [r3, #0]
 8013ca8:	689b      	ldr	r3, [r3, #8]
 8013caa:	687a      	ldr	r2, [r7, #4]
 8013cac:	6812      	ldr	r2, [r2, #0]
 8013cae:	f423 03e0 	bic.w	r3, r3, #7340032	@ 0x700000
 8013cb2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8013cb6:	6093      	str	r3, [r2, #8]
      /* Set RTC_CR register */
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8013cb8:	687b      	ldr	r3, [r7, #4]
 8013cba:	681b      	ldr	r3, [r3, #0]
 8013cbc:	6899      	ldr	r1, [r3, #8]
 8013cbe:	687b      	ldr	r3, [r7, #4]
 8013cc0:	685a      	ldr	r2, [r3, #4]
 8013cc2:	687b      	ldr	r3, [r7, #4]
 8013cc4:	691b      	ldr	r3, [r3, #16]
 8013cc6:	431a      	orrs	r2, r3
 8013cc8:	687b      	ldr	r3, [r7, #4]
 8013cca:	695b      	ldr	r3, [r3, #20]
 8013ccc:	431a      	orrs	r2, r3
 8013cce:	687b      	ldr	r3, [r7, #4]
 8013cd0:	681b      	ldr	r3, [r3, #0]
 8013cd2:	430a      	orrs	r2, r1
 8013cd4:	609a      	str	r2, [r3, #8]

      /* Configure the RTC PRER */
      hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8013cd6:	687b      	ldr	r3, [r7, #4]
 8013cd8:	681b      	ldr	r3, [r3, #0]
 8013cda:	687a      	ldr	r2, [r7, #4]
 8013cdc:	68d2      	ldr	r2, [r2, #12]
 8013cde:	611a      	str	r2, [r3, #16]
      hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 8013ce0:	687b      	ldr	r3, [r7, #4]
 8013ce2:	681b      	ldr	r3, [r3, #0]
 8013ce4:	6919      	ldr	r1, [r3, #16]
 8013ce6:	687b      	ldr	r3, [r7, #4]
 8013ce8:	689b      	ldr	r3, [r3, #8]
 8013cea:	041a      	lsls	r2, r3, #16
 8013cec:	687b      	ldr	r3, [r7, #4]
 8013cee:	681b      	ldr	r3, [r3, #0]
 8013cf0:	430a      	orrs	r2, r1
 8013cf2:	611a      	str	r2, [r3, #16]

      /* Exit Initialization mode */
      status = RTC_ExitInitMode(hrtc);
 8013cf4:	6878      	ldr	r0, [r7, #4]
 8013cf6:	f000 f9a4 	bl	8014042 <RTC_ExitInitMode>
 8013cfa:	4603      	mov	r3, r0
 8013cfc:	73fb      	strb	r3, [r7, #15]
    }

    if (status == HAL_OK)
 8013cfe:	7bfb      	ldrb	r3, [r7, #15]
 8013d00:	2b00      	cmp	r3, #0
 8013d02:	d110      	bne.n	8013d26 <HAL_RTC_Init+0xe2>
    {
      hrtc->Instance->TAFCR &= (uint32_t)~RTC_OUTPUT_TYPE_PUSHPULL;
 8013d04:	687b      	ldr	r3, [r7, #4]
 8013d06:	681b      	ldr	r3, [r3, #0]
 8013d08:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8013d0a:	687b      	ldr	r3, [r7, #4]
 8013d0c:	681b      	ldr	r3, [r3, #0]
 8013d0e:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8013d12:	641a      	str	r2, [r3, #64]	@ 0x40
      hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
 8013d14:	687b      	ldr	r3, [r7, #4]
 8013d16:	681b      	ldr	r3, [r3, #0]
 8013d18:	6c19      	ldr	r1, [r3, #64]	@ 0x40
 8013d1a:	687b      	ldr	r3, [r7, #4]
 8013d1c:	699a      	ldr	r2, [r3, #24]
 8013d1e:	687b      	ldr	r3, [r7, #4]
 8013d20:	681b      	ldr	r3, [r3, #0]
 8013d22:	430a      	orrs	r2, r1
 8013d24:	641a      	str	r2, [r3, #64]	@ 0x40
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013d26:	687b      	ldr	r3, [r7, #4]
 8013d28:	681b      	ldr	r3, [r3, #0]
 8013d2a:	22ff      	movs	r2, #255	@ 0xff
 8013d2c:	625a      	str	r2, [r3, #36]	@ 0x24
 8013d2e:	e001      	b.n	8013d34 <HAL_RTC_Init+0xf0>
  }
  else
  {
    /* The calendar is already initialized */
    status = HAL_OK;
 8013d30:	2300      	movs	r3, #0
 8013d32:	73fb      	strb	r3, [r7, #15]
  }

  if (status == HAL_OK)
 8013d34:	7bfb      	ldrb	r3, [r7, #15]
 8013d36:	2b00      	cmp	r3, #0
 8013d38:	d102      	bne.n	8013d40 <HAL_RTC_Init+0xfc>
  {
    hrtc->State = HAL_RTC_STATE_READY;
 8013d3a:	687b      	ldr	r3, [r7, #4]
 8013d3c:	2201      	movs	r2, #1
 8013d3e:	775a      	strb	r2, [r3, #29]
  }

  return status;
 8013d40:	7bfb      	ldrb	r3, [r7, #15]
}
 8013d42:	4618      	mov	r0, r3
 8013d44:	3710      	adds	r7, #16
 8013d46:	46bd      	mov	sp, r7
 8013d48:	bd80      	pop	{r7, pc}

08013d4a <HAL_RTC_SetTime>:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 8013d4a:	b590      	push	{r4, r7, lr}
 8013d4c:	b087      	sub	sp, #28
 8013d4e:	af00      	add	r7, sp, #0
 8013d50:	60f8      	str	r0, [r7, #12]
 8013d52:	60b9      	str	r1, [r7, #8]
 8013d54:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0U;
 8013d56:	2300      	movs	r3, #0
 8013d58:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8013d5a:	68fb      	ldr	r3, [r7, #12]
 8013d5c:	7f1b      	ldrb	r3, [r3, #28]
 8013d5e:	2b01      	cmp	r3, #1
 8013d60:	d101      	bne.n	8013d66 <HAL_RTC_SetTime+0x1c>
 8013d62:	2302      	movs	r3, #2
 8013d64:	e087      	b.n	8013e76 <HAL_RTC_SetTime+0x12c>
 8013d66:	68fb      	ldr	r3, [r7, #12]
 8013d68:	2201      	movs	r2, #1
 8013d6a:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8013d6c:	68fb      	ldr	r3, [r7, #12]
 8013d6e:	2202      	movs	r2, #2
 8013d70:	775a      	strb	r2, [r3, #29]

  if (Format == RTC_FORMAT_BIN)
 8013d72:	687b      	ldr	r3, [r7, #4]
 8013d74:	2b00      	cmp	r3, #0
 8013d76:	d126      	bne.n	8013dc6 <HAL_RTC_SetTime+0x7c>
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8013d78:	68fb      	ldr	r3, [r7, #12]
 8013d7a:	681b      	ldr	r3, [r3, #0]
 8013d7c:	689b      	ldr	r3, [r3, #8]
 8013d7e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8013d82:	2b00      	cmp	r3, #0
 8013d84:	d102      	bne.n	8013d8c <HAL_RTC_SetTime+0x42>
      assert_param(IS_RTC_HOUR12(sTime->Hours));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00U;
 8013d86:	68bb      	ldr	r3, [r7, #8]
 8013d88:	2200      	movs	r2, #0
 8013d8a:	70da      	strb	r2, [r3, #3]
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
 8013d8c:	68bb      	ldr	r3, [r7, #8]
 8013d8e:	781b      	ldrb	r3, [r3, #0]
 8013d90:	4618      	mov	r0, r3
 8013d92:	f000 f97b 	bl	801408c <RTC_ByteToBcd2>
 8013d96:	4603      	mov	r3, r0
 8013d98:	041c      	lsls	r4, r3, #16
                        ( (uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8013d9a:	68bb      	ldr	r3, [r7, #8]
 8013d9c:	785b      	ldrb	r3, [r3, #1]
 8013d9e:	4618      	mov	r0, r3
 8013da0:	f000 f974 	bl	801408c <RTC_ByteToBcd2>
 8013da4:	4603      	mov	r3, r0
 8013da6:	021b      	lsls	r3, r3, #8
    tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
 8013da8:	431c      	orrs	r4, r3
                        ( (uint32_t)RTC_ByteToBcd2(sTime->Seconds))                   | \
 8013daa:	68bb      	ldr	r3, [r7, #8]
 8013dac:	789b      	ldrb	r3, [r3, #2]
 8013dae:	4618      	mov	r0, r3
 8013db0:	f000 f96c 	bl	801408c <RTC_ByteToBcd2>
 8013db4:	4603      	mov	r3, r0
                        ( (uint32_t)RTC_ByteToBcd2(sTime->Minutes) << RTC_TR_MNU_Pos) | \
 8013db6:	ea44 0203 	orr.w	r2, r4, r3
                        (((uint32_t)sTime->TimeFormat)             << RTC_TR_PM_Pos));
 8013dba:	68bb      	ldr	r3, [r7, #8]
 8013dbc:	78db      	ldrb	r3, [r3, #3]
 8013dbe:	059b      	lsls	r3, r3, #22
    tmpreg = (uint32_t)(( (uint32_t)RTC_ByteToBcd2(sTime->Hours)   << RTC_TR_HU_Pos)  | \
 8013dc0:	4313      	orrs	r3, r2
 8013dc2:	617b      	str	r3, [r7, #20]
 8013dc4:	e018      	b.n	8013df8 <HAL_RTC_SetTime+0xae>
  }
  else
  {
    if ((hrtc->Instance->CR & RTC_CR_FMT) != 0U)
 8013dc6:	68fb      	ldr	r3, [r7, #12]
 8013dc8:	681b      	ldr	r3, [r3, #0]
 8013dca:	689b      	ldr	r3, [r3, #8]
 8013dcc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8013dd0:	2b00      	cmp	r3, #0
 8013dd2:	d102      	bne.n	8013dda <HAL_RTC_SetTime+0x90>
      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00U;
 8013dd4:	68bb      	ldr	r3, [r7, #8]
 8013dd6:	2200      	movs	r2, #0
 8013dd8:	70da      	strb	r2, [r3, #3]
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
 8013dda:	68bb      	ldr	r3, [r7, #8]
 8013ddc:	781b      	ldrb	r3, [r3, #0]
 8013dde:	041a      	lsls	r2, r3, #16
              ((uint32_t)(sTime->Minutes)    << RTC_TR_MNU_Pos) | \
 8013de0:	68bb      	ldr	r3, [r7, #8]
 8013de2:	785b      	ldrb	r3, [r3, #1]
 8013de4:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
 8013de6:	4313      	orrs	r3, r2
              ((uint32_t) sTime->Seconds)                       | \
 8013de8:	68ba      	ldr	r2, [r7, #8]
 8013dea:	7892      	ldrb	r2, [r2, #2]
              ((uint32_t)(sTime->Minutes)    << RTC_TR_MNU_Pos) | \
 8013dec:	431a      	orrs	r2, r3
              ((uint32_t)(sTime->TimeFormat) << RTC_TR_PM_Pos));
 8013dee:	68bb      	ldr	r3, [r7, #8]
 8013df0:	78db      	ldrb	r3, [r3, #3]
 8013df2:	059b      	lsls	r3, r3, #22
    tmpreg = (((uint32_t)(sTime->Hours)      << RTC_TR_HU_Pos)  | \
 8013df4:	4313      	orrs	r3, r2
 8013df6:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013df8:	68fb      	ldr	r3, [r7, #12]
 8013dfa:	681b      	ldr	r3, [r3, #0]
 8013dfc:	22ca      	movs	r2, #202	@ 0xca
 8013dfe:	625a      	str	r2, [r3, #36]	@ 0x24
 8013e00:	68fb      	ldr	r3, [r7, #12]
 8013e02:	681b      	ldr	r3, [r3, #0]
 8013e04:	2253      	movs	r2, #83	@ 0x53
 8013e06:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Enter Initialization mode */
  status = RTC_EnterInitMode(hrtc);
 8013e08:	68f8      	ldr	r0, [r7, #12]
 8013e0a:	f000 f8e3 	bl	8013fd4 <RTC_EnterInitMode>
 8013e0e:	4603      	mov	r3, r0
 8013e10:	74fb      	strb	r3, [r7, #19]

  if (status == HAL_OK)
 8013e12:	7cfb      	ldrb	r3, [r7, #19]
 8013e14:	2b00      	cmp	r3, #0
 8013e16:	d120      	bne.n	8013e5a <HAL_RTC_SetTime+0x110>
  {
    /* Set the RTC_TR register */
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8013e18:	68fb      	ldr	r3, [r7, #12]
 8013e1a:	681a      	ldr	r2, [r3, #0]
 8013e1c:	697b      	ldr	r3, [r7, #20]
 8013e1e:	f003 337f 	and.w	r3, r3, #2139062143	@ 0x7f7f7f7f
 8013e22:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8013e26:	6013      	str	r3, [r2, #0]

    /* Clear the bits to be configured (Deprecated. Use HAL_RTC_DST_xxx functions instead) */
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BKP;
 8013e28:	68fb      	ldr	r3, [r7, #12]
 8013e2a:	681b      	ldr	r3, [r3, #0]
 8013e2c:	689a      	ldr	r2, [r3, #8]
 8013e2e:	68fb      	ldr	r3, [r7, #12]
 8013e30:	681b      	ldr	r3, [r3, #0]
 8013e32:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8013e36:	609a      	str	r2, [r3, #8]

    /* Configure the RTC_CR register (Deprecated. Use HAL_RTC_DST_xxx functions instead) */
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8013e38:	68fb      	ldr	r3, [r7, #12]
 8013e3a:	681b      	ldr	r3, [r3, #0]
 8013e3c:	6899      	ldr	r1, [r3, #8]
 8013e3e:	68bb      	ldr	r3, [r7, #8]
 8013e40:	68da      	ldr	r2, [r3, #12]
 8013e42:	68bb      	ldr	r3, [r7, #8]
 8013e44:	691b      	ldr	r3, [r3, #16]
 8013e46:	431a      	orrs	r2, r3
 8013e48:	68fb      	ldr	r3, [r7, #12]
 8013e4a:	681b      	ldr	r3, [r3, #0]
 8013e4c:	430a      	orrs	r2, r1
 8013e4e:	609a      	str	r2, [r3, #8]

    /* Exit Initialization mode */
    status = RTC_ExitInitMode(hrtc);
 8013e50:	68f8      	ldr	r0, [r7, #12]
 8013e52:	f000 f8f6 	bl	8014042 <RTC_ExitInitMode>
 8013e56:	4603      	mov	r3, r0
 8013e58:	74fb      	strb	r3, [r7, #19]
  }

  if (status == HAL_OK)
 8013e5a:	7cfb      	ldrb	r3, [r7, #19]
 8013e5c:	2b00      	cmp	r3, #0
 8013e5e:	d102      	bne.n	8013e66 <HAL_RTC_SetTime+0x11c>
  {
    hrtc->State = HAL_RTC_STATE_READY;
 8013e60:	68fb      	ldr	r3, [r7, #12]
 8013e62:	2201      	movs	r2, #1
 8013e64:	775a      	strb	r2, [r3, #29]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013e66:	68fb      	ldr	r3, [r7, #12]
 8013e68:	681b      	ldr	r3, [r3, #0]
 8013e6a:	22ff      	movs	r2, #255	@ 0xff
 8013e6c:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8013e6e:	68fb      	ldr	r3, [r7, #12]
 8013e70:	2200      	movs	r2, #0
 8013e72:	771a      	strb	r2, [r3, #28]

  return status;
 8013e74:	7cfb      	ldrb	r3, [r7, #19]
}
 8013e76:	4618      	mov	r0, r3
 8013e78:	371c      	adds	r7, #28
 8013e7a:	46bd      	mov	sp, r7
 8013e7c:	bd90      	pop	{r4, r7, pc}

08013e7e <HAL_RTC_SetDate>:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 8013e7e:	b590      	push	{r4, r7, lr}
 8013e80:	b087      	sub	sp, #28
 8013e82:	af00      	add	r7, sp, #0
 8013e84:	60f8      	str	r0, [r7, #12]
 8013e86:	60b9      	str	r1, [r7, #8]
 8013e88:	607a      	str	r2, [r7, #4]
  uint32_t datetmpreg = 0U;
 8013e8a:	2300      	movs	r3, #0
 8013e8c:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8013e8e:	68fb      	ldr	r3, [r7, #12]
 8013e90:	7f1b      	ldrb	r3, [r3, #28]
 8013e92:	2b01      	cmp	r3, #1
 8013e94:	d101      	bne.n	8013e9a <HAL_RTC_SetDate+0x1c>
 8013e96:	2302      	movs	r3, #2
 8013e98:	e071      	b.n	8013f7e <HAL_RTC_SetDate+0x100>
 8013e9a:	68fb      	ldr	r3, [r7, #12]
 8013e9c:	2201      	movs	r2, #1
 8013e9e:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8013ea0:	68fb      	ldr	r3, [r7, #12]
 8013ea2:	2202      	movs	r2, #2
 8013ea4:	775a      	strb	r2, [r3, #29]

  if ((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8013ea6:	687b      	ldr	r3, [r7, #4]
 8013ea8:	2b00      	cmp	r3, #0
 8013eaa:	d10e      	bne.n	8013eca <HAL_RTC_SetDate+0x4c>
 8013eac:	68bb      	ldr	r3, [r7, #8]
 8013eae:	785b      	ldrb	r3, [r3, #1]
 8013eb0:	f003 0310 	and.w	r3, r3, #16
 8013eb4:	2b00      	cmp	r3, #0
 8013eb6:	d008      	beq.n	8013eca <HAL_RTC_SetDate+0x4c>
  {
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8013eb8:	68bb      	ldr	r3, [r7, #8]
 8013eba:	785b      	ldrb	r3, [r3, #1]
 8013ebc:	f023 0310 	bic.w	r3, r3, #16
 8013ec0:	b2db      	uxtb	r3, r3
 8013ec2:	330a      	adds	r3, #10
 8013ec4:	b2da      	uxtb	r2, r3
 8013ec6:	68bb      	ldr	r3, [r7, #8]
 8013ec8:	705a      	strb	r2, [r3, #1]
  }

  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));

  if (Format == RTC_FORMAT_BIN)
 8013eca:	687b      	ldr	r3, [r7, #4]
 8013ecc:	2b00      	cmp	r3, #0
 8013ece:	d11c      	bne.n	8013f0a <HAL_RTC_SetDate+0x8c>
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
 8013ed0:	68bb      	ldr	r3, [r7, #8]
 8013ed2:	78db      	ldrb	r3, [r3, #3]
 8013ed4:	4618      	mov	r0, r3
 8013ed6:	f000 f8d9 	bl	801408c <RTC_ByteToBcd2>
 8013eda:	4603      	mov	r3, r0
 8013edc:	041c      	lsls	r4, r3, #16
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
 8013ede:	68bb      	ldr	r3, [r7, #8]
 8013ee0:	785b      	ldrb	r3, [r3, #1]
 8013ee2:	4618      	mov	r0, r3
 8013ee4:	f000 f8d2 	bl	801408c <RTC_ByteToBcd2>
 8013ee8:	4603      	mov	r3, r0
 8013eea:	021b      	lsls	r3, r3, #8
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
 8013eec:	431c      	orrs	r4, r3
                  ((uint32_t)RTC_ByteToBcd2(sDate->Date))                   | \
 8013eee:	68bb      	ldr	r3, [r7, #8]
 8013ef0:	789b      	ldrb	r3, [r3, #2]
 8013ef2:	4618      	mov	r0, r3
 8013ef4:	f000 f8ca 	bl	801408c <RTC_ByteToBcd2>
 8013ef8:	4603      	mov	r3, r0
                  ((uint32_t)RTC_ByteToBcd2(sDate->Month) << RTC_DR_MU_Pos) | \
 8013efa:	ea44 0203 	orr.w	r2, r4, r3
                  ((uint32_t)sDate->WeekDay               << RTC_DR_WDU_Pos));
 8013efe:	68bb      	ldr	r3, [r7, #8]
 8013f00:	781b      	ldrb	r3, [r3, #0]
 8013f02:	035b      	lsls	r3, r3, #13
    datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year)  << RTC_DR_YU_Pos) | \
 8013f04:	4313      	orrs	r3, r2
 8013f06:	617b      	str	r3, [r7, #20]
 8013f08:	e00e      	b.n	8013f28 <HAL_RTC_SetDate+0xaa>
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));

    datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \
 8013f0a:	68bb      	ldr	r3, [r7, #8]
 8013f0c:	78db      	ldrb	r3, [r3, #3]
 8013f0e:	041a      	lsls	r2, r3, #16
                  (((uint32_t)sDate->Month)   << RTC_DR_MU_Pos) | \
 8013f10:	68bb      	ldr	r3, [r7, #8]
 8013f12:	785b      	ldrb	r3, [r3, #1]
 8013f14:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \
 8013f16:	4313      	orrs	r3, r2
                  ((uint32_t) sDate->Date)                      | \
 8013f18:	68ba      	ldr	r2, [r7, #8]
 8013f1a:	7892      	ldrb	r2, [r2, #2]
                  (((uint32_t)sDate->Month)   << RTC_DR_MU_Pos) | \
 8013f1c:	431a      	orrs	r2, r3
                  (((uint32_t)sDate->WeekDay) << RTC_DR_WDU_Pos));
 8013f1e:	68bb      	ldr	r3, [r7, #8]
 8013f20:	781b      	ldrb	r3, [r3, #0]
 8013f22:	035b      	lsls	r3, r3, #13
    datetmpreg = ((((uint32_t)sDate->Year)    << RTC_DR_YU_Pos) | \
 8013f24:	4313      	orrs	r3, r2
 8013f26:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8013f28:	68fb      	ldr	r3, [r7, #12]
 8013f2a:	681b      	ldr	r3, [r3, #0]
 8013f2c:	22ca      	movs	r2, #202	@ 0xca
 8013f2e:	625a      	str	r2, [r3, #36]	@ 0x24
 8013f30:	68fb      	ldr	r3, [r7, #12]
 8013f32:	681b      	ldr	r3, [r3, #0]
 8013f34:	2253      	movs	r2, #83	@ 0x53
 8013f36:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Enter Initialization mode */
  status = RTC_EnterInitMode(hrtc);
 8013f38:	68f8      	ldr	r0, [r7, #12]
 8013f3a:	f000 f84b 	bl	8013fd4 <RTC_EnterInitMode>
 8013f3e:	4603      	mov	r3, r0
 8013f40:	74fb      	strb	r3, [r7, #19]

  if (status == HAL_OK)
 8013f42:	7cfb      	ldrb	r3, [r7, #19]
 8013f44:	2b00      	cmp	r3, #0
 8013f46:	d10c      	bne.n	8013f62 <HAL_RTC_SetDate+0xe4>
  {
    /* Set the RTC_DR register */
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8013f48:	68fb      	ldr	r3, [r7, #12]
 8013f4a:	681a      	ldr	r2, [r3, #0]
 8013f4c:	697b      	ldr	r3, [r7, #20]
 8013f4e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 8013f52:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 8013f56:	6053      	str	r3, [r2, #4]

    /* Exit Initialization mode */
    status = RTC_ExitInitMode(hrtc);
 8013f58:	68f8      	ldr	r0, [r7, #12]
 8013f5a:	f000 f872 	bl	8014042 <RTC_ExitInitMode>
 8013f5e:	4603      	mov	r3, r0
 8013f60:	74fb      	strb	r3, [r7, #19]
  }

  if (status == HAL_OK)
 8013f62:	7cfb      	ldrb	r3, [r7, #19]
 8013f64:	2b00      	cmp	r3, #0
 8013f66:	d102      	bne.n	8013f6e <HAL_RTC_SetDate+0xf0>
  {
    hrtc->State = HAL_RTC_STATE_READY;
 8013f68:	68fb      	ldr	r3, [r7, #12]
 8013f6a:	2201      	movs	r2, #1
 8013f6c:	775a      	strb	r2, [r3, #29]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8013f6e:	68fb      	ldr	r3, [r7, #12]
 8013f70:	681b      	ldr	r3, [r3, #0]
 8013f72:	22ff      	movs	r2, #255	@ 0xff
 8013f74:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8013f76:	68fb      	ldr	r3, [r7, #12]
 8013f78:	2200      	movs	r2, #0
 8013f7a:	771a      	strb	r2, [r3, #28]

  return status;
 8013f7c:	7cfb      	ldrb	r3, [r7, #19]
}
 8013f7e:	4618      	mov	r0, r3
 8013f80:	371c      	adds	r7, #28
 8013f82:	46bd      	mov	sp, r7
 8013f84:	bd90      	pop	{r4, r7, pc}
	...

08013f88 <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 8013f88:	b580      	push	{r7, lr}
 8013f8a:	b084      	sub	sp, #16
 8013f8c:	af00      	add	r7, sp, #0
 8013f8e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8013f90:	2300      	movs	r3, #0
 8013f92:	60fb      	str	r3, [r7, #12]

  /* Clear RSF flag, keep reserved bits at reset values (setting other flags has no effect) */
  hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
 8013f94:	687b      	ldr	r3, [r7, #4]
 8013f96:	681b      	ldr	r3, [r3, #0]
 8013f98:	4a0d      	ldr	r2, [pc, #52]	@ (8013fd0 <HAL_RTC_WaitForSynchro+0x48>)
 8013f9a:	60da      	str	r2, [r3, #12]

  /* Get tick */
  tickstart = HAL_GetTick();
 8013f9c:	f7fb f9ae 	bl	800f2fc <HAL_GetTick>
 8013fa0:	60f8      	str	r0, [r7, #12]

  /* Wait the registers to be synchronised */
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013fa2:	e009      	b.n	8013fb8 <HAL_RTC_WaitForSynchro+0x30>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8013fa4:	f7fb f9aa 	bl	800f2fc <HAL_GetTick>
 8013fa8:	4602      	mov	r2, r0
 8013faa:	68fb      	ldr	r3, [r7, #12]
 8013fac:	1ad3      	subs	r3, r2, r3
 8013fae:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8013fb2:	d901      	bls.n	8013fb8 <HAL_RTC_WaitForSynchro+0x30>
    {
      return HAL_TIMEOUT;
 8013fb4:	2303      	movs	r3, #3
 8013fb6:	e007      	b.n	8013fc8 <HAL_RTC_WaitForSynchro+0x40>
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8013fb8:	687b      	ldr	r3, [r7, #4]
 8013fba:	681b      	ldr	r3, [r3, #0]
 8013fbc:	68db      	ldr	r3, [r3, #12]
 8013fbe:	f003 0320 	and.w	r3, r3, #32
 8013fc2:	2b00      	cmp	r3, #0
 8013fc4:	d0ee      	beq.n	8013fa4 <HAL_RTC_WaitForSynchro+0x1c>
    }
  }

  return HAL_OK;
 8013fc6:	2300      	movs	r3, #0
}
 8013fc8:	4618      	mov	r0, r3
 8013fca:	3710      	adds	r7, #16
 8013fcc:	46bd      	mov	sp, r7
 8013fce:	bd80      	pop	{r7, pc}
 8013fd0:	00013f5f 	.word	0x00013f5f

08013fd4 <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 8013fd4:	b580      	push	{r7, lr}
 8013fd6:	b084      	sub	sp, #16
 8013fd8:	af00      	add	r7, sp, #0
 8013fda:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8013fdc:	2300      	movs	r3, #0
 8013fde:	60bb      	str	r3, [r7, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8013fe0:	2300      	movs	r3, #0
 8013fe2:	73fb      	strb	r3, [r7, #15]

  /* Check that Initialization mode is not already set */
  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
 8013fe4:	687b      	ldr	r3, [r7, #4]
 8013fe6:	681b      	ldr	r3, [r3, #0]
 8013fe8:	68db      	ldr	r3, [r3, #12]
 8013fea:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8013fee:	2b00      	cmp	r3, #0
 8013ff0:	d122      	bne.n	8014038 <RTC_EnterInitMode+0x64>
  {
    /* Set INIT bit to enter Initialization mode */
    SET_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 8013ff2:	687b      	ldr	r3, [r7, #4]
 8013ff4:	681b      	ldr	r3, [r3, #0]
 8013ff6:	68da      	ldr	r2, [r3, #12]
 8013ff8:	687b      	ldr	r3, [r7, #4]
 8013ffa:	681b      	ldr	r3, [r3, #0]
 8013ffc:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8014000:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8014002:	f7fb f97b 	bl	800f2fc <HAL_GetTick>
 8014006:	60b8      	str	r0, [r7, #8]

    /* Wait till RTC is in INIT state and if timeout is reached exit */
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 8014008:	e00c      	b.n	8014024 <RTC_EnterInitMode+0x50>
    {
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 801400a:	f7fb f977 	bl	800f2fc <HAL_GetTick>
 801400e:	4602      	mov	r2, r0
 8014010:	68bb      	ldr	r3, [r7, #8]
 8014012:	1ad3      	subs	r3, r2, r3
 8014014:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8014018:	d904      	bls.n	8014024 <RTC_EnterInitMode+0x50>
      {
        /* Set RTC state */
        hrtc->State = HAL_RTC_STATE_ERROR;
 801401a:	687b      	ldr	r3, [r7, #4]
 801401c:	2204      	movs	r2, #4
 801401e:	775a      	strb	r2, [r3, #29]
        status = HAL_ERROR;
 8014020:	2301      	movs	r3, #1
 8014022:	73fb      	strb	r3, [r7, #15]
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 8014024:	687b      	ldr	r3, [r7, #4]
 8014026:	681b      	ldr	r3, [r3, #0]
 8014028:	68db      	ldr	r3, [r3, #12]
 801402a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801402e:	2b00      	cmp	r3, #0
 8014030:	d102      	bne.n	8014038 <RTC_EnterInitMode+0x64>
 8014032:	7bfb      	ldrb	r3, [r7, #15]
 8014034:	2b01      	cmp	r3, #1
 8014036:	d1e8      	bne.n	801400a <RTC_EnterInitMode+0x36>
      }
    }
  }

  return status;
 8014038:	7bfb      	ldrb	r3, [r7, #15]
}
 801403a:	4618      	mov	r0, r3
 801403c:	3710      	adds	r7, #16
 801403e:	46bd      	mov	sp, r7
 8014040:	bd80      	pop	{r7, pc}

08014042 <RTC_ExitInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8014042:	b580      	push	{r7, lr}
 8014044:	b084      	sub	sp, #16
 8014046:	af00      	add	r7, sp, #0
 8014048:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 801404a:	2300      	movs	r3, #0
 801404c:	73fb      	strb	r3, [r7, #15]

  /* Clear INIT bit to exit Initialization mode */
  CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 801404e:	687b      	ldr	r3, [r7, #4]
 8014050:	681b      	ldr	r3, [r3, #0]
 8014052:	68da      	ldr	r2, [r3, #12]
 8014054:	687b      	ldr	r3, [r7, #4]
 8014056:	681b      	ldr	r3, [r3, #0]
 8014058:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 801405c:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD) == 0U)
 801405e:	687b      	ldr	r3, [r7, #4]
 8014060:	681b      	ldr	r3, [r3, #0]
 8014062:	689b      	ldr	r3, [r3, #8]
 8014064:	f003 0320 	and.w	r3, r3, #32
 8014068:	2b00      	cmp	r3, #0
 801406a:	d10a      	bne.n	8014082 <RTC_ExitInitMode+0x40>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 801406c:	6878      	ldr	r0, [r7, #4]
 801406e:	f7ff ff8b 	bl	8013f88 <HAL_RTC_WaitForSynchro>
 8014072:	4603      	mov	r3, r0
 8014074:	2b00      	cmp	r3, #0
 8014076:	d004      	beq.n	8014082 <RTC_ExitInitMode+0x40>
    {
      /* Set RTC state */
      hrtc->State = HAL_RTC_STATE_ERROR;
 8014078:	687b      	ldr	r3, [r7, #4]
 801407a:	2204      	movs	r2, #4
 801407c:	775a      	strb	r2, [r3, #29]
      status = HAL_ERROR;
 801407e:	2301      	movs	r3, #1
 8014080:	73fb      	strb	r3, [r7, #15]
    }
  }

  return status;
 8014082:	7bfb      	ldrb	r3, [r7, #15]
}
 8014084:	4618      	mov	r0, r3
 8014086:	3710      	adds	r7, #16
 8014088:	46bd      	mov	sp, r7
 801408a:	bd80      	pop	{r7, pc}

0801408c <RTC_ByteToBcd2>:
  * @brief  Converts a 2-digit number from decimal to BCD format.
  * @param  number decimal-formatted number (from 0 to 99) to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t number)
{
 801408c:	b480      	push	{r7}
 801408e:	b085      	sub	sp, #20
 8014090:	af00      	add	r7, sp, #0
 8014092:	4603      	mov	r3, r0
 8014094:	71fb      	strb	r3, [r7, #7]
  uint32_t bcdhigh = 0U;
 8014096:	2300      	movs	r3, #0
 8014098:	60fb      	str	r3, [r7, #12]

  while (number >= 10U)
 801409a:	e005      	b.n	80140a8 <RTC_ByteToBcd2+0x1c>
  {
    bcdhigh++;
 801409c:	68fb      	ldr	r3, [r7, #12]
 801409e:	3301      	adds	r3, #1
 80140a0:	60fb      	str	r3, [r7, #12]
    number -= 10U;
 80140a2:	79fb      	ldrb	r3, [r7, #7]
 80140a4:	3b0a      	subs	r3, #10
 80140a6:	71fb      	strb	r3, [r7, #7]
  while (number >= 10U)
 80140a8:	79fb      	ldrb	r3, [r7, #7]
 80140aa:	2b09      	cmp	r3, #9
 80140ac:	d8f6      	bhi.n	801409c <RTC_ByteToBcd2+0x10>
  }

  return ((uint8_t)(bcdhigh << 4U) | number);
 80140ae:	68fb      	ldr	r3, [r7, #12]
 80140b0:	b2db      	uxtb	r3, r3
 80140b2:	011b      	lsls	r3, r3, #4
 80140b4:	b2da      	uxtb	r2, r3
 80140b6:	79fb      	ldrb	r3, [r7, #7]
 80140b8:	4313      	orrs	r3, r2
 80140ba:	b2db      	uxtb	r3, r3
}
 80140bc:	4618      	mov	r0, r3
 80140be:	3714      	adds	r7, #20
 80140c0:	46bd      	mov	sp, r7
 80140c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140c6:	4770      	bx	lr

080140c8 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 80140c8:	b580      	push	{r7, lr}
 80140ca:	b082      	sub	sp, #8
 80140cc:	af00      	add	r7, sp, #0
 80140ce:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80140d0:	687b      	ldr	r3, [r7, #4]
 80140d2:	2b00      	cmp	r3, #0
 80140d4:	d101      	bne.n	80140da <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 80140d6:	2301      	movs	r3, #1
 80140d8:	e041      	b.n	801415e <HAL_TIM_Base_Init+0x96>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80140da:	687b      	ldr	r3, [r7, #4]
 80140dc:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 80140e0:	b2db      	uxtb	r3, r3
 80140e2:	2b00      	cmp	r3, #0
 80140e4:	d106      	bne.n	80140f4 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80140e6:	687b      	ldr	r3, [r7, #4]
 80140e8:	2200      	movs	r2, #0
 80140ea:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 80140ee:	6878      	ldr	r0, [r7, #4]
 80140f0:	f7f1 fc68 	bl	80059c4 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80140f4:	687b      	ldr	r3, [r7, #4]
 80140f6:	2202      	movs	r2, #2
 80140f8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80140fc:	687b      	ldr	r3, [r7, #4]
 80140fe:	681a      	ldr	r2, [r3, #0]
 8014100:	687b      	ldr	r3, [r7, #4]
 8014102:	3304      	adds	r3, #4
 8014104:	4619      	mov	r1, r3
 8014106:	4610      	mov	r0, r2
 8014108:	f000 fc2a 	bl	8014960 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 801410c:	687b      	ldr	r3, [r7, #4]
 801410e:	2201      	movs	r2, #1
 8014110:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8014114:	687b      	ldr	r3, [r7, #4]
 8014116:	2201      	movs	r2, #1
 8014118:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 801411c:	687b      	ldr	r3, [r7, #4]
 801411e:	2201      	movs	r2, #1
 8014120:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 8014124:	687b      	ldr	r3, [r7, #4]
 8014126:	2201      	movs	r2, #1
 8014128:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 801412c:	687b      	ldr	r3, [r7, #4]
 801412e:	2201      	movs	r2, #1
 8014130:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8014134:	687b      	ldr	r3, [r7, #4]
 8014136:	2201      	movs	r2, #1
 8014138:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 801413c:	687b      	ldr	r3, [r7, #4]
 801413e:	2201      	movs	r2, #1
 8014140:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
 8014144:	687b      	ldr	r3, [r7, #4]
 8014146:	2201      	movs	r2, #1
 8014148:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 801414c:	687b      	ldr	r3, [r7, #4]
 801414e:	2201      	movs	r2, #1
 8014150:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 8014154:	687b      	ldr	r3, [r7, #4]
 8014156:	2201      	movs	r2, #1
 8014158:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 801415c:	2300      	movs	r3, #0
}
 801415e:	4618      	mov	r0, r3
 8014160:	3708      	adds	r7, #8
 8014162:	46bd      	mov	sp, r7
 8014164:	bd80      	pop	{r7, pc}
	...

08014168 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 8014168:	b480      	push	{r7}
 801416a:	b085      	sub	sp, #20
 801416c:	af00      	add	r7, sp, #0
 801416e:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8014170:	687b      	ldr	r3, [r7, #4]
 8014172:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8014176:	b2db      	uxtb	r3, r3
 8014178:	2b01      	cmp	r3, #1
 801417a:	d001      	beq.n	8014180 <HAL_TIM_Base_Start+0x18>
  {
    return HAL_ERROR;
 801417c:	2301      	movs	r3, #1
 801417e:	e03c      	b.n	80141fa <HAL_TIM_Base_Start+0x92>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8014180:	687b      	ldr	r3, [r7, #4]
 8014182:	2202      	movs	r2, #2
 8014184:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8014188:	687b      	ldr	r3, [r7, #4]
 801418a:	681b      	ldr	r3, [r3, #0]
 801418c:	4a1e      	ldr	r2, [pc, #120]	@ (8014208 <HAL_TIM_Base_Start+0xa0>)
 801418e:	4293      	cmp	r3, r2
 8014190:	d018      	beq.n	80141c4 <HAL_TIM_Base_Start+0x5c>
 8014192:	687b      	ldr	r3, [r7, #4]
 8014194:	681b      	ldr	r3, [r3, #0]
 8014196:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801419a:	d013      	beq.n	80141c4 <HAL_TIM_Base_Start+0x5c>
 801419c:	687b      	ldr	r3, [r7, #4]
 801419e:	681b      	ldr	r3, [r3, #0]
 80141a0:	4a1a      	ldr	r2, [pc, #104]	@ (801420c <HAL_TIM_Base_Start+0xa4>)
 80141a2:	4293      	cmp	r3, r2
 80141a4:	d00e      	beq.n	80141c4 <HAL_TIM_Base_Start+0x5c>
 80141a6:	687b      	ldr	r3, [r7, #4]
 80141a8:	681b      	ldr	r3, [r3, #0]
 80141aa:	4a19      	ldr	r2, [pc, #100]	@ (8014210 <HAL_TIM_Base_Start+0xa8>)
 80141ac:	4293      	cmp	r3, r2
 80141ae:	d009      	beq.n	80141c4 <HAL_TIM_Base_Start+0x5c>
 80141b0:	687b      	ldr	r3, [r7, #4]
 80141b2:	681b      	ldr	r3, [r3, #0]
 80141b4:	4a17      	ldr	r2, [pc, #92]	@ (8014214 <HAL_TIM_Base_Start+0xac>)
 80141b6:	4293      	cmp	r3, r2
 80141b8:	d004      	beq.n	80141c4 <HAL_TIM_Base_Start+0x5c>
 80141ba:	687b      	ldr	r3, [r7, #4]
 80141bc:	681b      	ldr	r3, [r3, #0]
 80141be:	4a16      	ldr	r2, [pc, #88]	@ (8014218 <HAL_TIM_Base_Start+0xb0>)
 80141c0:	4293      	cmp	r3, r2
 80141c2:	d111      	bne.n	80141e8 <HAL_TIM_Base_Start+0x80>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80141c4:	687b      	ldr	r3, [r7, #4]
 80141c6:	681b      	ldr	r3, [r3, #0]
 80141c8:	689b      	ldr	r3, [r3, #8]
 80141ca:	f003 0307 	and.w	r3, r3, #7
 80141ce:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80141d0:	68fb      	ldr	r3, [r7, #12]
 80141d2:	2b06      	cmp	r3, #6
 80141d4:	d010      	beq.n	80141f8 <HAL_TIM_Base_Start+0x90>
    {
      __HAL_TIM_ENABLE(htim);
 80141d6:	687b      	ldr	r3, [r7, #4]
 80141d8:	681b      	ldr	r3, [r3, #0]
 80141da:	681a      	ldr	r2, [r3, #0]
 80141dc:	687b      	ldr	r3, [r7, #4]
 80141de:	681b      	ldr	r3, [r3, #0]
 80141e0:	f042 0201 	orr.w	r2, r2, #1
 80141e4:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80141e6:	e007      	b.n	80141f8 <HAL_TIM_Base_Start+0x90>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 80141e8:	687b      	ldr	r3, [r7, #4]
 80141ea:	681b      	ldr	r3, [r3, #0]
 80141ec:	681a      	ldr	r2, [r3, #0]
 80141ee:	687b      	ldr	r3, [r7, #4]
 80141f0:	681b      	ldr	r3, [r3, #0]
 80141f2:	f042 0201 	orr.w	r2, r2, #1
 80141f6:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 80141f8:	2300      	movs	r3, #0
}
 80141fa:	4618      	mov	r0, r3
 80141fc:	3714      	adds	r7, #20
 80141fe:	46bd      	mov	sp, r7
 8014200:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014204:	4770      	bx	lr
 8014206:	bf00      	nop
 8014208:	40010000 	.word	0x40010000
 801420c:	40000400 	.word	0x40000400
 8014210:	40000800 	.word	0x40000800
 8014214:	40000c00 	.word	0x40000c00
 8014218:	40014000 	.word	0x40014000

0801421c <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 801421c:	b580      	push	{r7, lr}
 801421e:	b082      	sub	sp, #8
 8014220:	af00      	add	r7, sp, #0
 8014222:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8014224:	687b      	ldr	r3, [r7, #4]
 8014226:	2b00      	cmp	r3, #0
 8014228:	d101      	bne.n	801422e <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 801422a:	2301      	movs	r3, #1
 801422c:	e041      	b.n	80142b2 <HAL_TIM_PWM_Init+0x96>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 801422e:	687b      	ldr	r3, [r7, #4]
 8014230:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8014234:	b2db      	uxtb	r3, r3
 8014236:	2b00      	cmp	r3, #0
 8014238:	d106      	bne.n	8014248 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 801423a:	687b      	ldr	r3, [r7, #4]
 801423c:	2200      	movs	r2, #0
 801423e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 8014242:	6878      	ldr	r0, [r7, #4]
 8014244:	f7f1 fb9c 	bl	8005980 <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8014248:	687b      	ldr	r3, [r7, #4]
 801424a:	2202      	movs	r2, #2
 801424c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8014250:	687b      	ldr	r3, [r7, #4]
 8014252:	681a      	ldr	r2, [r3, #0]
 8014254:	687b      	ldr	r3, [r7, #4]
 8014256:	3304      	adds	r3, #4
 8014258:	4619      	mov	r1, r3
 801425a:	4610      	mov	r0, r2
 801425c:	f000 fb80 	bl	8014960 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8014260:	687b      	ldr	r3, [r7, #4]
 8014262:	2201      	movs	r2, #1
 8014264:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8014268:	687b      	ldr	r3, [r7, #4]
 801426a:	2201      	movs	r2, #1
 801426c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 8014270:	687b      	ldr	r3, [r7, #4]
 8014272:	2201      	movs	r2, #1
 8014274:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 8014278:	687b      	ldr	r3, [r7, #4]
 801427a:	2201      	movs	r2, #1
 801427c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 8014280:	687b      	ldr	r3, [r7, #4]
 8014282:	2201      	movs	r2, #1
 8014284:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8014288:	687b      	ldr	r3, [r7, #4]
 801428a:	2201      	movs	r2, #1
 801428c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 8014290:	687b      	ldr	r3, [r7, #4]
 8014292:	2201      	movs	r2, #1
 8014294:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
 8014298:	687b      	ldr	r3, [r7, #4]
 801429a:	2201      	movs	r2, #1
 801429c:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 80142a0:	687b      	ldr	r3, [r7, #4]
 80142a2:	2201      	movs	r2, #1
 80142a4:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80142a8:	687b      	ldr	r3, [r7, #4]
 80142aa:	2201      	movs	r2, #1
 80142ac:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 80142b0:	2300      	movs	r3, #0
}
 80142b2:	4618      	mov	r0, r3
 80142b4:	3708      	adds	r7, #8
 80142b6:	46bd      	mov	sp, r7
 80142b8:	bd80      	pop	{r7, pc}
	...

080142bc <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 80142bc:	b580      	push	{r7, lr}
 80142be:	b084      	sub	sp, #16
 80142c0:	af00      	add	r7, sp, #0
 80142c2:	6078      	str	r0, [r7, #4]
 80142c4:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80142c6:	683b      	ldr	r3, [r7, #0]
 80142c8:	2b00      	cmp	r3, #0
 80142ca:	d109      	bne.n	80142e0 <HAL_TIM_PWM_Start+0x24>
 80142cc:	687b      	ldr	r3, [r7, #4]
 80142ce:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 80142d2:	b2db      	uxtb	r3, r3
 80142d4:	2b01      	cmp	r3, #1
 80142d6:	bf14      	ite	ne
 80142d8:	2301      	movne	r3, #1
 80142da:	2300      	moveq	r3, #0
 80142dc:	b2db      	uxtb	r3, r3
 80142de:	e022      	b.n	8014326 <HAL_TIM_PWM_Start+0x6a>
 80142e0:	683b      	ldr	r3, [r7, #0]
 80142e2:	2b04      	cmp	r3, #4
 80142e4:	d109      	bne.n	80142fa <HAL_TIM_PWM_Start+0x3e>
 80142e6:	687b      	ldr	r3, [r7, #4]
 80142e8:	f893 303f 	ldrb.w	r3, [r3, #63]	@ 0x3f
 80142ec:	b2db      	uxtb	r3, r3
 80142ee:	2b01      	cmp	r3, #1
 80142f0:	bf14      	ite	ne
 80142f2:	2301      	movne	r3, #1
 80142f4:	2300      	moveq	r3, #0
 80142f6:	b2db      	uxtb	r3, r3
 80142f8:	e015      	b.n	8014326 <HAL_TIM_PWM_Start+0x6a>
 80142fa:	683b      	ldr	r3, [r7, #0]
 80142fc:	2b08      	cmp	r3, #8
 80142fe:	d109      	bne.n	8014314 <HAL_TIM_PWM_Start+0x58>
 8014300:	687b      	ldr	r3, [r7, #4]
 8014302:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8014306:	b2db      	uxtb	r3, r3
 8014308:	2b01      	cmp	r3, #1
 801430a:	bf14      	ite	ne
 801430c:	2301      	movne	r3, #1
 801430e:	2300      	moveq	r3, #0
 8014310:	b2db      	uxtb	r3, r3
 8014312:	e008      	b.n	8014326 <HAL_TIM_PWM_Start+0x6a>
 8014314:	687b      	ldr	r3, [r7, #4]
 8014316:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 801431a:	b2db      	uxtb	r3, r3
 801431c:	2b01      	cmp	r3, #1
 801431e:	bf14      	ite	ne
 8014320:	2301      	movne	r3, #1
 8014322:	2300      	moveq	r3, #0
 8014324:	b2db      	uxtb	r3, r3
 8014326:	2b00      	cmp	r3, #0
 8014328:	d001      	beq.n	801432e <HAL_TIM_PWM_Start+0x72>
  {
    return HAL_ERROR;
 801432a:	2301      	movs	r3, #1
 801432c:	e068      	b.n	8014400 <HAL_TIM_PWM_Start+0x144>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 801432e:	683b      	ldr	r3, [r7, #0]
 8014330:	2b00      	cmp	r3, #0
 8014332:	d104      	bne.n	801433e <HAL_TIM_PWM_Start+0x82>
 8014334:	687b      	ldr	r3, [r7, #4]
 8014336:	2202      	movs	r2, #2
 8014338:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 801433c:	e013      	b.n	8014366 <HAL_TIM_PWM_Start+0xaa>
 801433e:	683b      	ldr	r3, [r7, #0]
 8014340:	2b04      	cmp	r3, #4
 8014342:	d104      	bne.n	801434e <HAL_TIM_PWM_Start+0x92>
 8014344:	687b      	ldr	r3, [r7, #4]
 8014346:	2202      	movs	r2, #2
 8014348:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 801434c:	e00b      	b.n	8014366 <HAL_TIM_PWM_Start+0xaa>
 801434e:	683b      	ldr	r3, [r7, #0]
 8014350:	2b08      	cmp	r3, #8
 8014352:	d104      	bne.n	801435e <HAL_TIM_PWM_Start+0xa2>
 8014354:	687b      	ldr	r3, [r7, #4]
 8014356:	2202      	movs	r2, #2
 8014358:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 801435c:	e003      	b.n	8014366 <HAL_TIM_PWM_Start+0xaa>
 801435e:	687b      	ldr	r3, [r7, #4]
 8014360:	2202      	movs	r2, #2
 8014362:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8014366:	687b      	ldr	r3, [r7, #4]
 8014368:	681b      	ldr	r3, [r3, #0]
 801436a:	2201      	movs	r2, #1
 801436c:	6839      	ldr	r1, [r7, #0]
 801436e:	4618      	mov	r0, r3
 8014370:	f000 fda8 	bl	8014ec4 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8014374:	687b      	ldr	r3, [r7, #4]
 8014376:	681b      	ldr	r3, [r3, #0]
 8014378:	4a23      	ldr	r2, [pc, #140]	@ (8014408 <HAL_TIM_PWM_Start+0x14c>)
 801437a:	4293      	cmp	r3, r2
 801437c:	d107      	bne.n	801438e <HAL_TIM_PWM_Start+0xd2>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 801437e:	687b      	ldr	r3, [r7, #4]
 8014380:	681b      	ldr	r3, [r3, #0]
 8014382:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8014384:	687b      	ldr	r3, [r7, #4]
 8014386:	681b      	ldr	r3, [r3, #0]
 8014388:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 801438c:	645a      	str	r2, [r3, #68]	@ 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 801438e:	687b      	ldr	r3, [r7, #4]
 8014390:	681b      	ldr	r3, [r3, #0]
 8014392:	4a1d      	ldr	r2, [pc, #116]	@ (8014408 <HAL_TIM_PWM_Start+0x14c>)
 8014394:	4293      	cmp	r3, r2
 8014396:	d018      	beq.n	80143ca <HAL_TIM_PWM_Start+0x10e>
 8014398:	687b      	ldr	r3, [r7, #4]
 801439a:	681b      	ldr	r3, [r3, #0]
 801439c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80143a0:	d013      	beq.n	80143ca <HAL_TIM_PWM_Start+0x10e>
 80143a2:	687b      	ldr	r3, [r7, #4]
 80143a4:	681b      	ldr	r3, [r3, #0]
 80143a6:	4a19      	ldr	r2, [pc, #100]	@ (801440c <HAL_TIM_PWM_Start+0x150>)
 80143a8:	4293      	cmp	r3, r2
 80143aa:	d00e      	beq.n	80143ca <HAL_TIM_PWM_Start+0x10e>
 80143ac:	687b      	ldr	r3, [r7, #4]
 80143ae:	681b      	ldr	r3, [r3, #0]
 80143b0:	4a17      	ldr	r2, [pc, #92]	@ (8014410 <HAL_TIM_PWM_Start+0x154>)
 80143b2:	4293      	cmp	r3, r2
 80143b4:	d009      	beq.n	80143ca <HAL_TIM_PWM_Start+0x10e>
 80143b6:	687b      	ldr	r3, [r7, #4]
 80143b8:	681b      	ldr	r3, [r3, #0]
 80143ba:	4a16      	ldr	r2, [pc, #88]	@ (8014414 <HAL_TIM_PWM_Start+0x158>)
 80143bc:	4293      	cmp	r3, r2
 80143be:	d004      	beq.n	80143ca <HAL_TIM_PWM_Start+0x10e>
 80143c0:	687b      	ldr	r3, [r7, #4]
 80143c2:	681b      	ldr	r3, [r3, #0]
 80143c4:	4a14      	ldr	r2, [pc, #80]	@ (8014418 <HAL_TIM_PWM_Start+0x15c>)
 80143c6:	4293      	cmp	r3, r2
 80143c8:	d111      	bne.n	80143ee <HAL_TIM_PWM_Start+0x132>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80143ca:	687b      	ldr	r3, [r7, #4]
 80143cc:	681b      	ldr	r3, [r3, #0]
 80143ce:	689b      	ldr	r3, [r3, #8]
 80143d0:	f003 0307 	and.w	r3, r3, #7
 80143d4:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80143d6:	68fb      	ldr	r3, [r7, #12]
 80143d8:	2b06      	cmp	r3, #6
 80143da:	d010      	beq.n	80143fe <HAL_TIM_PWM_Start+0x142>
    {
      __HAL_TIM_ENABLE(htim);
 80143dc:	687b      	ldr	r3, [r7, #4]
 80143de:	681b      	ldr	r3, [r3, #0]
 80143e0:	681a      	ldr	r2, [r3, #0]
 80143e2:	687b      	ldr	r3, [r7, #4]
 80143e4:	681b      	ldr	r3, [r3, #0]
 80143e6:	f042 0201 	orr.w	r2, r2, #1
 80143ea:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80143ec:	e007      	b.n	80143fe <HAL_TIM_PWM_Start+0x142>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 80143ee:	687b      	ldr	r3, [r7, #4]
 80143f0:	681b      	ldr	r3, [r3, #0]
 80143f2:	681a      	ldr	r2, [r3, #0]
 80143f4:	687b      	ldr	r3, [r7, #4]
 80143f6:	681b      	ldr	r3, [r3, #0]
 80143f8:	f042 0201 	orr.w	r2, r2, #1
 80143fc:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 80143fe:	2300      	movs	r3, #0
}
 8014400:	4618      	mov	r0, r3
 8014402:	3710      	adds	r7, #16
 8014404:	46bd      	mov	sp, r7
 8014406:	bd80      	pop	{r7, pc}
 8014408:	40010000 	.word	0x40010000
 801440c:	40000400 	.word	0x40000400
 8014410:	40000800 	.word	0x40000800
 8014414:	40000c00 	.word	0x40000c00
 8014418:	40014000 	.word	0x40014000

0801441c <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 801441c:	b580      	push	{r7, lr}
 801441e:	b084      	sub	sp, #16
 8014420:	af00      	add	r7, sp, #0
 8014422:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
 8014424:	687b      	ldr	r3, [r7, #4]
 8014426:	681b      	ldr	r3, [r3, #0]
 8014428:	68db      	ldr	r3, [r3, #12]
 801442a:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
 801442c:	687b      	ldr	r3, [r7, #4]
 801442e:	681b      	ldr	r3, [r3, #0]
 8014430:	691b      	ldr	r3, [r3, #16]
 8014432:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 8014434:	68bb      	ldr	r3, [r7, #8]
 8014436:	f003 0302 	and.w	r3, r3, #2
 801443a:	2b00      	cmp	r3, #0
 801443c:	d020      	beq.n	8014480 <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 801443e:	68fb      	ldr	r3, [r7, #12]
 8014440:	f003 0302 	and.w	r3, r3, #2
 8014444:	2b00      	cmp	r3, #0
 8014446:	d01b      	beq.n	8014480 <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8014448:	687b      	ldr	r3, [r7, #4]
 801444a:	681b      	ldr	r3, [r3, #0]
 801444c:	f06f 0202 	mvn.w	r2, #2
 8014450:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8014452:	687b      	ldr	r3, [r7, #4]
 8014454:	2201      	movs	r2, #1
 8014456:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8014458:	687b      	ldr	r3, [r7, #4]
 801445a:	681b      	ldr	r3, [r3, #0]
 801445c:	699b      	ldr	r3, [r3, #24]
 801445e:	f003 0303 	and.w	r3, r3, #3
 8014462:	2b00      	cmp	r3, #0
 8014464:	d003      	beq.n	801446e <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8014466:	6878      	ldr	r0, [r7, #4]
 8014468:	f000 fa5b 	bl	8014922 <HAL_TIM_IC_CaptureCallback>
 801446c:	e005      	b.n	801447a <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 801446e:	6878      	ldr	r0, [r7, #4]
 8014470:	f000 fa4d 	bl	801490e <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8014474:	6878      	ldr	r0, [r7, #4]
 8014476:	f000 fa5e 	bl	8014936 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801447a:	687b      	ldr	r3, [r7, #4]
 801447c:	2200      	movs	r2, #0
 801447e:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8014480:	68bb      	ldr	r3, [r7, #8]
 8014482:	f003 0304 	and.w	r3, r3, #4
 8014486:	2b00      	cmp	r3, #0
 8014488:	d020      	beq.n	80144cc <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 801448a:	68fb      	ldr	r3, [r7, #12]
 801448c:	f003 0304 	and.w	r3, r3, #4
 8014490:	2b00      	cmp	r3, #0
 8014492:	d01b      	beq.n	80144cc <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8014494:	687b      	ldr	r3, [r7, #4]
 8014496:	681b      	ldr	r3, [r3, #0]
 8014498:	f06f 0204 	mvn.w	r2, #4
 801449c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 801449e:	687b      	ldr	r3, [r7, #4]
 80144a0:	2202      	movs	r2, #2
 80144a2:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 80144a4:	687b      	ldr	r3, [r7, #4]
 80144a6:	681b      	ldr	r3, [r3, #0]
 80144a8:	699b      	ldr	r3, [r3, #24]
 80144aa:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 80144ae:	2b00      	cmp	r3, #0
 80144b0:	d003      	beq.n	80144ba <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80144b2:	6878      	ldr	r0, [r7, #4]
 80144b4:	f000 fa35 	bl	8014922 <HAL_TIM_IC_CaptureCallback>
 80144b8:	e005      	b.n	80144c6 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80144ba:	6878      	ldr	r0, [r7, #4]
 80144bc:	f000 fa27 	bl	801490e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80144c0:	6878      	ldr	r0, [r7, #4]
 80144c2:	f000 fa38 	bl	8014936 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80144c6:	687b      	ldr	r3, [r7, #4]
 80144c8:	2200      	movs	r2, #0
 80144ca:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 80144cc:	68bb      	ldr	r3, [r7, #8]
 80144ce:	f003 0308 	and.w	r3, r3, #8
 80144d2:	2b00      	cmp	r3, #0
 80144d4:	d020      	beq.n	8014518 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 80144d6:	68fb      	ldr	r3, [r7, #12]
 80144d8:	f003 0308 	and.w	r3, r3, #8
 80144dc:	2b00      	cmp	r3, #0
 80144de:	d01b      	beq.n	8014518 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 80144e0:	687b      	ldr	r3, [r7, #4]
 80144e2:	681b      	ldr	r3, [r3, #0]
 80144e4:	f06f 0208 	mvn.w	r2, #8
 80144e8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80144ea:	687b      	ldr	r3, [r7, #4]
 80144ec:	2204      	movs	r2, #4
 80144ee:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80144f0:	687b      	ldr	r3, [r7, #4]
 80144f2:	681b      	ldr	r3, [r3, #0]
 80144f4:	69db      	ldr	r3, [r3, #28]
 80144f6:	f003 0303 	and.w	r3, r3, #3
 80144fa:	2b00      	cmp	r3, #0
 80144fc:	d003      	beq.n	8014506 <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80144fe:	6878      	ldr	r0, [r7, #4]
 8014500:	f000 fa0f 	bl	8014922 <HAL_TIM_IC_CaptureCallback>
 8014504:	e005      	b.n	8014512 <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8014506:	6878      	ldr	r0, [r7, #4]
 8014508:	f000 fa01 	bl	801490e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 801450c:	6878      	ldr	r0, [r7, #4]
 801450e:	f000 fa12 	bl	8014936 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8014512:	687b      	ldr	r3, [r7, #4]
 8014514:	2200      	movs	r2, #0
 8014516:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 8014518:	68bb      	ldr	r3, [r7, #8]
 801451a:	f003 0310 	and.w	r3, r3, #16
 801451e:	2b00      	cmp	r3, #0
 8014520:	d020      	beq.n	8014564 <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 8014522:	68fb      	ldr	r3, [r7, #12]
 8014524:	f003 0310 	and.w	r3, r3, #16
 8014528:	2b00      	cmp	r3, #0
 801452a:	d01b      	beq.n	8014564 <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 801452c:	687b      	ldr	r3, [r7, #4]
 801452e:	681b      	ldr	r3, [r3, #0]
 8014530:	f06f 0210 	mvn.w	r2, #16
 8014534:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8014536:	687b      	ldr	r3, [r7, #4]
 8014538:	2208      	movs	r2, #8
 801453a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 801453c:	687b      	ldr	r3, [r7, #4]
 801453e:	681b      	ldr	r3, [r3, #0]
 8014540:	69db      	ldr	r3, [r3, #28]
 8014542:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8014546:	2b00      	cmp	r3, #0
 8014548:	d003      	beq.n	8014552 <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 801454a:	6878      	ldr	r0, [r7, #4]
 801454c:	f000 f9e9 	bl	8014922 <HAL_TIM_IC_CaptureCallback>
 8014550:	e005      	b.n	801455e <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8014552:	6878      	ldr	r0, [r7, #4]
 8014554:	f000 f9db 	bl	801490e <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8014558:	6878      	ldr	r0, [r7, #4]
 801455a:	f000 f9ec 	bl	8014936 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 801455e:	687b      	ldr	r3, [r7, #4]
 8014560:	2200      	movs	r2, #0
 8014562:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8014564:	68bb      	ldr	r3, [r7, #8]
 8014566:	f003 0301 	and.w	r3, r3, #1
 801456a:	2b00      	cmp	r3, #0
 801456c:	d00c      	beq.n	8014588 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 801456e:	68fb      	ldr	r3, [r7, #12]
 8014570:	f003 0301 	and.w	r3, r3, #1
 8014574:	2b00      	cmp	r3, #0
 8014576:	d007      	beq.n	8014588 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8014578:	687b      	ldr	r3, [r7, #4]
 801457a:	681b      	ldr	r3, [r3, #0]
 801457c:	f06f 0201 	mvn.w	r2, #1
 8014580:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8014582:	6878      	ldr	r0, [r7, #4]
 8014584:	f7ec fd06 	bl	8000f94 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if ((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK))
 8014588:	68bb      	ldr	r3, [r7, #8]
 801458a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 801458e:	2b00      	cmp	r3, #0
 8014590:	d00c      	beq.n	80145ac <HAL_TIM_IRQHandler+0x190>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8014592:	68fb      	ldr	r3, [r7, #12]
 8014594:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8014598:	2b00      	cmp	r3, #0
 801459a:	d007      	beq.n	80145ac <HAL_TIM_IRQHandler+0x190>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK);
 801459c:	687b      	ldr	r3, [r7, #4]
 801459e:	681b      	ldr	r3, [r3, #0]
 80145a0:	f06f 0280 	mvn.w	r2, #128	@ 0x80
 80145a4:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 80145a6:	6878      	ldr	r0, [r7, #4]
 80145a8:	f000 fd7c 	bl	80150a4 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 80145ac:	68bb      	ldr	r3, [r7, #8]
 80145ae:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80145b2:	2b00      	cmp	r3, #0
 80145b4:	d00c      	beq.n	80145d0 <HAL_TIM_IRQHandler+0x1b4>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 80145b6:	68fb      	ldr	r3, [r7, #12]
 80145b8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80145bc:	2b00      	cmp	r3, #0
 80145be:	d007      	beq.n	80145d0 <HAL_TIM_IRQHandler+0x1b4>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 80145c0:	687b      	ldr	r3, [r7, #4]
 80145c2:	681b      	ldr	r3, [r3, #0]
 80145c4:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 80145c8:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80145ca:	6878      	ldr	r0, [r7, #4]
 80145cc:	f000 f9bd 	bl	801494a <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 80145d0:	68bb      	ldr	r3, [r7, #8]
 80145d2:	f003 0320 	and.w	r3, r3, #32
 80145d6:	2b00      	cmp	r3, #0
 80145d8:	d00c      	beq.n	80145f4 <HAL_TIM_IRQHandler+0x1d8>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 80145da:	68fb      	ldr	r3, [r7, #12]
 80145dc:	f003 0320 	and.w	r3, r3, #32
 80145e0:	2b00      	cmp	r3, #0
 80145e2:	d007      	beq.n	80145f4 <HAL_TIM_IRQHandler+0x1d8>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 80145e4:	687b      	ldr	r3, [r7, #4]
 80145e6:	681b      	ldr	r3, [r3, #0]
 80145e8:	f06f 0220 	mvn.w	r2, #32
 80145ec:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 80145ee:	6878      	ldr	r0, [r7, #4]
 80145f0:	f000 fd4e 	bl	8015090 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 80145f4:	bf00      	nop
 80145f6:	3710      	adds	r7, #16
 80145f8:	46bd      	mov	sp, r7
 80145fa:	bd80      	pop	{r7, pc}

080145fc <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            const TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 80145fc:	b580      	push	{r7, lr}
 80145fe:	b086      	sub	sp, #24
 8014600:	af00      	add	r7, sp, #0
 8014602:	60f8      	str	r0, [r7, #12]
 8014604:	60b9      	str	r1, [r7, #8]
 8014606:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8014608:	2300      	movs	r3, #0
 801460a:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 801460c:	68fb      	ldr	r3, [r7, #12]
 801460e:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8014612:	2b01      	cmp	r3, #1
 8014614:	d101      	bne.n	801461a <HAL_TIM_PWM_ConfigChannel+0x1e>
 8014616:	2302      	movs	r3, #2
 8014618:	e0ae      	b.n	8014778 <HAL_TIM_PWM_ConfigChannel+0x17c>
 801461a:	68fb      	ldr	r3, [r7, #12]
 801461c:	2201      	movs	r2, #1
 801461e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  switch (Channel)
 8014622:	687b      	ldr	r3, [r7, #4]
 8014624:	2b0c      	cmp	r3, #12
 8014626:	f200 809f 	bhi.w	8014768 <HAL_TIM_PWM_ConfigChannel+0x16c>
 801462a:	a201      	add	r2, pc, #4	@ (adr r2, 8014630 <HAL_TIM_PWM_ConfigChannel+0x34>)
 801462c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014630:	08014665 	.word	0x08014665
 8014634:	08014769 	.word	0x08014769
 8014638:	08014769 	.word	0x08014769
 801463c:	08014769 	.word	0x08014769
 8014640:	080146a5 	.word	0x080146a5
 8014644:	08014769 	.word	0x08014769
 8014648:	08014769 	.word	0x08014769
 801464c:	08014769 	.word	0x08014769
 8014650:	080146e7 	.word	0x080146e7
 8014654:	08014769 	.word	0x08014769
 8014658:	08014769 	.word	0x08014769
 801465c:	08014769 	.word	0x08014769
 8014660:	08014727 	.word	0x08014727
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8014664:	68fb      	ldr	r3, [r7, #12]
 8014666:	681b      	ldr	r3, [r3, #0]
 8014668:	68b9      	ldr	r1, [r7, #8]
 801466a:	4618      	mov	r0, r3
 801466c:	f000 fa04 	bl	8014a78 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8014670:	68fb      	ldr	r3, [r7, #12]
 8014672:	681b      	ldr	r3, [r3, #0]
 8014674:	699a      	ldr	r2, [r3, #24]
 8014676:	68fb      	ldr	r3, [r7, #12]
 8014678:	681b      	ldr	r3, [r3, #0]
 801467a:	f042 0208 	orr.w	r2, r2, #8
 801467e:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8014680:	68fb      	ldr	r3, [r7, #12]
 8014682:	681b      	ldr	r3, [r3, #0]
 8014684:	699a      	ldr	r2, [r3, #24]
 8014686:	68fb      	ldr	r3, [r7, #12]
 8014688:	681b      	ldr	r3, [r3, #0]
 801468a:	f022 0204 	bic.w	r2, r2, #4
 801468e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8014690:	68fb      	ldr	r3, [r7, #12]
 8014692:	681b      	ldr	r3, [r3, #0]
 8014694:	6999      	ldr	r1, [r3, #24]
 8014696:	68bb      	ldr	r3, [r7, #8]
 8014698:	691a      	ldr	r2, [r3, #16]
 801469a:	68fb      	ldr	r3, [r7, #12]
 801469c:	681b      	ldr	r3, [r3, #0]
 801469e:	430a      	orrs	r2, r1
 80146a0:	619a      	str	r2, [r3, #24]
      break;
 80146a2:	e064      	b.n	801476e <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80146a4:	68fb      	ldr	r3, [r7, #12]
 80146a6:	681b      	ldr	r3, [r3, #0]
 80146a8:	68b9      	ldr	r1, [r7, #8]
 80146aa:	4618      	mov	r0, r3
 80146ac:	f000 fa4a 	bl	8014b44 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80146b0:	68fb      	ldr	r3, [r7, #12]
 80146b2:	681b      	ldr	r3, [r3, #0]
 80146b4:	699a      	ldr	r2, [r3, #24]
 80146b6:	68fb      	ldr	r3, [r7, #12]
 80146b8:	681b      	ldr	r3, [r3, #0]
 80146ba:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80146be:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80146c0:	68fb      	ldr	r3, [r7, #12]
 80146c2:	681b      	ldr	r3, [r3, #0]
 80146c4:	699a      	ldr	r2, [r3, #24]
 80146c6:	68fb      	ldr	r3, [r7, #12]
 80146c8:	681b      	ldr	r3, [r3, #0]
 80146ca:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80146ce:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80146d0:	68fb      	ldr	r3, [r7, #12]
 80146d2:	681b      	ldr	r3, [r3, #0]
 80146d4:	6999      	ldr	r1, [r3, #24]
 80146d6:	68bb      	ldr	r3, [r7, #8]
 80146d8:	691b      	ldr	r3, [r3, #16]
 80146da:	021a      	lsls	r2, r3, #8
 80146dc:	68fb      	ldr	r3, [r7, #12]
 80146de:	681b      	ldr	r3, [r3, #0]
 80146e0:	430a      	orrs	r2, r1
 80146e2:	619a      	str	r2, [r3, #24]
      break;
 80146e4:	e043      	b.n	801476e <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80146e6:	68fb      	ldr	r3, [r7, #12]
 80146e8:	681b      	ldr	r3, [r3, #0]
 80146ea:	68b9      	ldr	r1, [r7, #8]
 80146ec:	4618      	mov	r0, r3
 80146ee:	f000 fa95 	bl	8014c1c <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80146f2:	68fb      	ldr	r3, [r7, #12]
 80146f4:	681b      	ldr	r3, [r3, #0]
 80146f6:	69da      	ldr	r2, [r3, #28]
 80146f8:	68fb      	ldr	r3, [r7, #12]
 80146fa:	681b      	ldr	r3, [r3, #0]
 80146fc:	f042 0208 	orr.w	r2, r2, #8
 8014700:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8014702:	68fb      	ldr	r3, [r7, #12]
 8014704:	681b      	ldr	r3, [r3, #0]
 8014706:	69da      	ldr	r2, [r3, #28]
 8014708:	68fb      	ldr	r3, [r7, #12]
 801470a:	681b      	ldr	r3, [r3, #0]
 801470c:	f022 0204 	bic.w	r2, r2, #4
 8014710:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8014712:	68fb      	ldr	r3, [r7, #12]
 8014714:	681b      	ldr	r3, [r3, #0]
 8014716:	69d9      	ldr	r1, [r3, #28]
 8014718:	68bb      	ldr	r3, [r7, #8]
 801471a:	691a      	ldr	r2, [r3, #16]
 801471c:	68fb      	ldr	r3, [r7, #12]
 801471e:	681b      	ldr	r3, [r3, #0]
 8014720:	430a      	orrs	r2, r1
 8014722:	61da      	str	r2, [r3, #28]
      break;
 8014724:	e023      	b.n	801476e <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8014726:	68fb      	ldr	r3, [r7, #12]
 8014728:	681b      	ldr	r3, [r3, #0]
 801472a:	68b9      	ldr	r1, [r7, #8]
 801472c:	4618      	mov	r0, r3
 801472e:	f000 fadf 	bl	8014cf0 <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8014732:	68fb      	ldr	r3, [r7, #12]
 8014734:	681b      	ldr	r3, [r3, #0]
 8014736:	69da      	ldr	r2, [r3, #28]
 8014738:	68fb      	ldr	r3, [r7, #12]
 801473a:	681b      	ldr	r3, [r3, #0]
 801473c:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8014740:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8014742:	68fb      	ldr	r3, [r7, #12]
 8014744:	681b      	ldr	r3, [r3, #0]
 8014746:	69da      	ldr	r2, [r3, #28]
 8014748:	68fb      	ldr	r3, [r7, #12]
 801474a:	681b      	ldr	r3, [r3, #0]
 801474c:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 8014750:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8014752:	68fb      	ldr	r3, [r7, #12]
 8014754:	681b      	ldr	r3, [r3, #0]
 8014756:	69d9      	ldr	r1, [r3, #28]
 8014758:	68bb      	ldr	r3, [r7, #8]
 801475a:	691b      	ldr	r3, [r3, #16]
 801475c:	021a      	lsls	r2, r3, #8
 801475e:	68fb      	ldr	r3, [r7, #12]
 8014760:	681b      	ldr	r3, [r3, #0]
 8014762:	430a      	orrs	r2, r1
 8014764:	61da      	str	r2, [r3, #28]
      break;
 8014766:	e002      	b.n	801476e <HAL_TIM_PWM_ConfigChannel+0x172>
    }

    default:
      status = HAL_ERROR;
 8014768:	2301      	movs	r3, #1
 801476a:	75fb      	strb	r3, [r7, #23]
      break;
 801476c:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 801476e:	68fb      	ldr	r3, [r7, #12]
 8014770:	2200      	movs	r2, #0
 8014772:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return status;
 8014776:	7dfb      	ldrb	r3, [r7, #23]
}
 8014778:	4618      	mov	r0, r3
 801477a:	3718      	adds	r7, #24
 801477c:	46bd      	mov	sp, r7
 801477e:	bd80      	pop	{r7, pc}

08014780 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, const TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 8014780:	b580      	push	{r7, lr}
 8014782:	b084      	sub	sp, #16
 8014784:	af00      	add	r7, sp, #0
 8014786:	6078      	str	r0, [r7, #4]
 8014788:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 801478a:	2300      	movs	r3, #0
 801478c:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 801478e:	687b      	ldr	r3, [r7, #4]
 8014790:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8014794:	2b01      	cmp	r3, #1
 8014796:	d101      	bne.n	801479c <HAL_TIM_ConfigClockSource+0x1c>
 8014798:	2302      	movs	r3, #2
 801479a:	e0b4      	b.n	8014906 <HAL_TIM_ConfigClockSource+0x186>
 801479c:	687b      	ldr	r3, [r7, #4]
 801479e:	2201      	movs	r2, #1
 80147a0:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 80147a4:	687b      	ldr	r3, [r7, #4]
 80147a6:	2202      	movs	r2, #2
 80147a8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 80147ac:	687b      	ldr	r3, [r7, #4]
 80147ae:	681b      	ldr	r3, [r3, #0]
 80147b0:	689b      	ldr	r3, [r3, #8]
 80147b2:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 80147b4:	68bb      	ldr	r3, [r7, #8]
 80147b6:	f023 0377 	bic.w	r3, r3, #119	@ 0x77
 80147ba:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80147bc:	68bb      	ldr	r3, [r7, #8]
 80147be:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 80147c2:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 80147c4:	687b      	ldr	r3, [r7, #4]
 80147c6:	681b      	ldr	r3, [r3, #0]
 80147c8:	68ba      	ldr	r2, [r7, #8]
 80147ca:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 80147cc:	683b      	ldr	r3, [r7, #0]
 80147ce:	681b      	ldr	r3, [r3, #0]
 80147d0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80147d4:	d03e      	beq.n	8014854 <HAL_TIM_ConfigClockSource+0xd4>
 80147d6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80147da:	f200 8087 	bhi.w	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 80147de:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80147e2:	f000 8086 	beq.w	80148f2 <HAL_TIM_ConfigClockSource+0x172>
 80147e6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80147ea:	d87f      	bhi.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 80147ec:	2b70      	cmp	r3, #112	@ 0x70
 80147ee:	d01a      	beq.n	8014826 <HAL_TIM_ConfigClockSource+0xa6>
 80147f0:	2b70      	cmp	r3, #112	@ 0x70
 80147f2:	d87b      	bhi.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 80147f4:	2b60      	cmp	r3, #96	@ 0x60
 80147f6:	d050      	beq.n	801489a <HAL_TIM_ConfigClockSource+0x11a>
 80147f8:	2b60      	cmp	r3, #96	@ 0x60
 80147fa:	d877      	bhi.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 80147fc:	2b50      	cmp	r3, #80	@ 0x50
 80147fe:	d03c      	beq.n	801487a <HAL_TIM_ConfigClockSource+0xfa>
 8014800:	2b50      	cmp	r3, #80	@ 0x50
 8014802:	d873      	bhi.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 8014804:	2b40      	cmp	r3, #64	@ 0x40
 8014806:	d058      	beq.n	80148ba <HAL_TIM_ConfigClockSource+0x13a>
 8014808:	2b40      	cmp	r3, #64	@ 0x40
 801480a:	d86f      	bhi.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 801480c:	2b30      	cmp	r3, #48	@ 0x30
 801480e:	d064      	beq.n	80148da <HAL_TIM_ConfigClockSource+0x15a>
 8014810:	2b30      	cmp	r3, #48	@ 0x30
 8014812:	d86b      	bhi.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 8014814:	2b20      	cmp	r3, #32
 8014816:	d060      	beq.n	80148da <HAL_TIM_ConfigClockSource+0x15a>
 8014818:	2b20      	cmp	r3, #32
 801481a:	d867      	bhi.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
 801481c:	2b00      	cmp	r3, #0
 801481e:	d05c      	beq.n	80148da <HAL_TIM_ConfigClockSource+0x15a>
 8014820:	2b10      	cmp	r3, #16
 8014822:	d05a      	beq.n	80148da <HAL_TIM_ConfigClockSource+0x15a>
 8014824:	e062      	b.n	80148ec <HAL_TIM_ConfigClockSource+0x16c>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 8014826:	687b      	ldr	r3, [r7, #4]
 8014828:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 801482a:	683b      	ldr	r3, [r7, #0]
 801482c:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 801482e:	683b      	ldr	r3, [r7, #0]
 8014830:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 8014832:	683b      	ldr	r3, [r7, #0]
 8014834:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 8014836:	f000 fb25 	bl	8014e84 <TIM_ETR_SetConfig>

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 801483a:	687b      	ldr	r3, [r7, #4]
 801483c:	681b      	ldr	r3, [r3, #0]
 801483e:	689b      	ldr	r3, [r3, #8]
 8014840:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8014842:	68bb      	ldr	r3, [r7, #8]
 8014844:	f043 0377 	orr.w	r3, r3, #119	@ 0x77
 8014848:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 801484a:	687b      	ldr	r3, [r7, #4]
 801484c:	681b      	ldr	r3, [r3, #0]
 801484e:	68ba      	ldr	r2, [r7, #8]
 8014850:	609a      	str	r2, [r3, #8]
      break;
 8014852:	e04f      	b.n	80148f4 <HAL_TIM_ConfigClockSource+0x174>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 8014854:	687b      	ldr	r3, [r7, #4]
 8014856:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 8014858:	683b      	ldr	r3, [r7, #0]
 801485a:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 801485c:	683b      	ldr	r3, [r7, #0]
 801485e:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 8014860:	683b      	ldr	r3, [r7, #0]
 8014862:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 8014864:	f000 fb0e 	bl	8014e84 <TIM_ETR_SetConfig>
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8014868:	687b      	ldr	r3, [r7, #4]
 801486a:	681b      	ldr	r3, [r3, #0]
 801486c:	689a      	ldr	r2, [r3, #8]
 801486e:	687b      	ldr	r3, [r7, #4]
 8014870:	681b      	ldr	r3, [r3, #0]
 8014872:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8014876:	609a      	str	r2, [r3, #8]
      break;
 8014878:	e03c      	b.n	80148f4 <HAL_TIM_ConfigClockSource+0x174>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 801487a:	687b      	ldr	r3, [r7, #4]
 801487c:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 801487e:	683b      	ldr	r3, [r7, #0]
 8014880:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 8014882:	683b      	ldr	r3, [r7, #0]
 8014884:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8014886:	461a      	mov	r2, r3
 8014888:	f000 fa82 	bl	8014d90 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 801488c:	687b      	ldr	r3, [r7, #4]
 801488e:	681b      	ldr	r3, [r3, #0]
 8014890:	2150      	movs	r1, #80	@ 0x50
 8014892:	4618      	mov	r0, r3
 8014894:	f000 fadb 	bl	8014e4e <TIM_ITRx_SetConfig>
      break;
 8014898:	e02c      	b.n	80148f4 <HAL_TIM_ConfigClockSource+0x174>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 801489a:	687b      	ldr	r3, [r7, #4]
 801489c:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 801489e:	683b      	ldr	r3, [r7, #0]
 80148a0:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 80148a2:	683b      	ldr	r3, [r7, #0]
 80148a4:	68db      	ldr	r3, [r3, #12]
      TIM_TI2_ConfigInputStage(htim->Instance,
 80148a6:	461a      	mov	r2, r3
 80148a8:	f000 faa1 	bl	8014dee <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 80148ac:	687b      	ldr	r3, [r7, #4]
 80148ae:	681b      	ldr	r3, [r3, #0]
 80148b0:	2160      	movs	r1, #96	@ 0x60
 80148b2:	4618      	mov	r0, r3
 80148b4:	f000 facb 	bl	8014e4e <TIM_ITRx_SetConfig>
      break;
 80148b8:	e01c      	b.n	80148f4 <HAL_TIM_ConfigClockSource+0x174>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 80148ba:	687b      	ldr	r3, [r7, #4]
 80148bc:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 80148be:	683b      	ldr	r3, [r7, #0]
 80148c0:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 80148c2:	683b      	ldr	r3, [r7, #0]
 80148c4:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 80148c6:	461a      	mov	r2, r3
 80148c8:	f000 fa62 	bl	8014d90 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 80148cc:	687b      	ldr	r3, [r7, #4]
 80148ce:	681b      	ldr	r3, [r3, #0]
 80148d0:	2140      	movs	r1, #64	@ 0x40
 80148d2:	4618      	mov	r0, r3
 80148d4:	f000 fabb 	bl	8014e4e <TIM_ITRx_SetConfig>
      break;
 80148d8:	e00c      	b.n	80148f4 <HAL_TIM_ConfigClockSource+0x174>
    case TIM_CLOCKSOURCE_ITR3:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 80148da:	687b      	ldr	r3, [r7, #4]
 80148dc:	681a      	ldr	r2, [r3, #0]
 80148de:	683b      	ldr	r3, [r7, #0]
 80148e0:	681b      	ldr	r3, [r3, #0]
 80148e2:	4619      	mov	r1, r3
 80148e4:	4610      	mov	r0, r2
 80148e6:	f000 fab2 	bl	8014e4e <TIM_ITRx_SetConfig>
      break;
 80148ea:	e003      	b.n	80148f4 <HAL_TIM_ConfigClockSource+0x174>
    }

    default:
      status = HAL_ERROR;
 80148ec:	2301      	movs	r3, #1
 80148ee:	73fb      	strb	r3, [r7, #15]
      break;
 80148f0:	e000      	b.n	80148f4 <HAL_TIM_ConfigClockSource+0x174>
      break;
 80148f2:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 80148f4:	687b      	ldr	r3, [r7, #4]
 80148f6:	2201      	movs	r2, #1
 80148f8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 80148fc:	687b      	ldr	r3, [r7, #4]
 80148fe:	2200      	movs	r2, #0
 8014900:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return status;
 8014904:	7bfb      	ldrb	r3, [r7, #15]
}
 8014906:	4618      	mov	r0, r3
 8014908:	3710      	adds	r7, #16
 801490a:	46bd      	mov	sp, r7
 801490c:	bd80      	pop	{r7, pc}

0801490e <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 801490e:	b480      	push	{r7}
 8014910:	b083      	sub	sp, #12
 8014912:	af00      	add	r7, sp, #0
 8014914:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8014916:	bf00      	nop
 8014918:	370c      	adds	r7, #12
 801491a:	46bd      	mov	sp, r7
 801491c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014920:	4770      	bx	lr

08014922 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8014922:	b480      	push	{r7}
 8014924:	b083      	sub	sp, #12
 8014926:	af00      	add	r7, sp, #0
 8014928:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 801492a:	bf00      	nop
 801492c:	370c      	adds	r7, #12
 801492e:	46bd      	mov	sp, r7
 8014930:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014934:	4770      	bx	lr

08014936 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8014936:	b480      	push	{r7}
 8014938:	b083      	sub	sp, #12
 801493a:	af00      	add	r7, sp, #0
 801493c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 801493e:	bf00      	nop
 8014940:	370c      	adds	r7, #12
 8014942:	46bd      	mov	sp, r7
 8014944:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014948:	4770      	bx	lr

0801494a <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 801494a:	b480      	push	{r7}
 801494c:	b083      	sub	sp, #12
 801494e:	af00      	add	r7, sp, #0
 8014950:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8014952:	bf00      	nop
 8014954:	370c      	adds	r7, #12
 8014956:	46bd      	mov	sp, r7
 8014958:	f85d 7b04 	ldr.w	r7, [sp], #4
 801495c:	4770      	bx	lr
	...

08014960 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 8014960:	b480      	push	{r7}
 8014962:	b085      	sub	sp, #20
 8014964:	af00      	add	r7, sp, #0
 8014966:	6078      	str	r0, [r7, #4]
 8014968:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 801496a:	687b      	ldr	r3, [r7, #4]
 801496c:	681b      	ldr	r3, [r3, #0]
 801496e:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8014970:	687b      	ldr	r3, [r7, #4]
 8014972:	4a3a      	ldr	r2, [pc, #232]	@ (8014a5c <TIM_Base_SetConfig+0xfc>)
 8014974:	4293      	cmp	r3, r2
 8014976:	d00f      	beq.n	8014998 <TIM_Base_SetConfig+0x38>
 8014978:	687b      	ldr	r3, [r7, #4]
 801497a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801497e:	d00b      	beq.n	8014998 <TIM_Base_SetConfig+0x38>
 8014980:	687b      	ldr	r3, [r7, #4]
 8014982:	4a37      	ldr	r2, [pc, #220]	@ (8014a60 <TIM_Base_SetConfig+0x100>)
 8014984:	4293      	cmp	r3, r2
 8014986:	d007      	beq.n	8014998 <TIM_Base_SetConfig+0x38>
 8014988:	687b      	ldr	r3, [r7, #4]
 801498a:	4a36      	ldr	r2, [pc, #216]	@ (8014a64 <TIM_Base_SetConfig+0x104>)
 801498c:	4293      	cmp	r3, r2
 801498e:	d003      	beq.n	8014998 <TIM_Base_SetConfig+0x38>
 8014990:	687b      	ldr	r3, [r7, #4]
 8014992:	4a35      	ldr	r2, [pc, #212]	@ (8014a68 <TIM_Base_SetConfig+0x108>)
 8014994:	4293      	cmp	r3, r2
 8014996:	d108      	bne.n	80149aa <TIM_Base_SetConfig+0x4a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8014998:	68fb      	ldr	r3, [r7, #12]
 801499a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 801499e:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 80149a0:	683b      	ldr	r3, [r7, #0]
 80149a2:	685b      	ldr	r3, [r3, #4]
 80149a4:	68fa      	ldr	r2, [r7, #12]
 80149a6:	4313      	orrs	r3, r2
 80149a8:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80149aa:	687b      	ldr	r3, [r7, #4]
 80149ac:	4a2b      	ldr	r2, [pc, #172]	@ (8014a5c <TIM_Base_SetConfig+0xfc>)
 80149ae:	4293      	cmp	r3, r2
 80149b0:	d01b      	beq.n	80149ea <TIM_Base_SetConfig+0x8a>
 80149b2:	687b      	ldr	r3, [r7, #4]
 80149b4:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 80149b8:	d017      	beq.n	80149ea <TIM_Base_SetConfig+0x8a>
 80149ba:	687b      	ldr	r3, [r7, #4]
 80149bc:	4a28      	ldr	r2, [pc, #160]	@ (8014a60 <TIM_Base_SetConfig+0x100>)
 80149be:	4293      	cmp	r3, r2
 80149c0:	d013      	beq.n	80149ea <TIM_Base_SetConfig+0x8a>
 80149c2:	687b      	ldr	r3, [r7, #4]
 80149c4:	4a27      	ldr	r2, [pc, #156]	@ (8014a64 <TIM_Base_SetConfig+0x104>)
 80149c6:	4293      	cmp	r3, r2
 80149c8:	d00f      	beq.n	80149ea <TIM_Base_SetConfig+0x8a>
 80149ca:	687b      	ldr	r3, [r7, #4]
 80149cc:	4a26      	ldr	r2, [pc, #152]	@ (8014a68 <TIM_Base_SetConfig+0x108>)
 80149ce:	4293      	cmp	r3, r2
 80149d0:	d00b      	beq.n	80149ea <TIM_Base_SetConfig+0x8a>
 80149d2:	687b      	ldr	r3, [r7, #4]
 80149d4:	4a25      	ldr	r2, [pc, #148]	@ (8014a6c <TIM_Base_SetConfig+0x10c>)
 80149d6:	4293      	cmp	r3, r2
 80149d8:	d007      	beq.n	80149ea <TIM_Base_SetConfig+0x8a>
 80149da:	687b      	ldr	r3, [r7, #4]
 80149dc:	4a24      	ldr	r2, [pc, #144]	@ (8014a70 <TIM_Base_SetConfig+0x110>)
 80149de:	4293      	cmp	r3, r2
 80149e0:	d003      	beq.n	80149ea <TIM_Base_SetConfig+0x8a>
 80149e2:	687b      	ldr	r3, [r7, #4]
 80149e4:	4a23      	ldr	r2, [pc, #140]	@ (8014a74 <TIM_Base_SetConfig+0x114>)
 80149e6:	4293      	cmp	r3, r2
 80149e8:	d108      	bne.n	80149fc <TIM_Base_SetConfig+0x9c>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80149ea:	68fb      	ldr	r3, [r7, #12]
 80149ec:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 80149f0:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80149f2:	683b      	ldr	r3, [r7, #0]
 80149f4:	68db      	ldr	r3, [r3, #12]
 80149f6:	68fa      	ldr	r2, [r7, #12]
 80149f8:	4313      	orrs	r3, r2
 80149fa:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80149fc:	68fb      	ldr	r3, [r7, #12]
 80149fe:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8014a02:	683b      	ldr	r3, [r7, #0]
 8014a04:	695b      	ldr	r3, [r3, #20]
 8014a06:	4313      	orrs	r3, r2
 8014a08:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8014a0a:	687b      	ldr	r3, [r7, #4]
 8014a0c:	68fa      	ldr	r2, [r7, #12]
 8014a0e:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8014a10:	683b      	ldr	r3, [r7, #0]
 8014a12:	689a      	ldr	r2, [r3, #8]
 8014a14:	687b      	ldr	r3, [r7, #4]
 8014a16:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8014a18:	683b      	ldr	r3, [r7, #0]
 8014a1a:	681a      	ldr	r2, [r3, #0]
 8014a1c:	687b      	ldr	r3, [r7, #4]
 8014a1e:	629a      	str	r2, [r3, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8014a20:	687b      	ldr	r3, [r7, #4]
 8014a22:	4a0e      	ldr	r2, [pc, #56]	@ (8014a5c <TIM_Base_SetConfig+0xfc>)
 8014a24:	4293      	cmp	r3, r2
 8014a26:	d103      	bne.n	8014a30 <TIM_Base_SetConfig+0xd0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8014a28:	683b      	ldr	r3, [r7, #0]
 8014a2a:	691a      	ldr	r2, [r3, #16]
 8014a2c:	687b      	ldr	r3, [r7, #4]
 8014a2e:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8014a30:	687b      	ldr	r3, [r7, #4]
 8014a32:	2201      	movs	r2, #1
 8014a34:	615a      	str	r2, [r3, #20]

  /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8014a36:	687b      	ldr	r3, [r7, #4]
 8014a38:	691b      	ldr	r3, [r3, #16]
 8014a3a:	f003 0301 	and.w	r3, r3, #1
 8014a3e:	2b01      	cmp	r3, #1
 8014a40:	d105      	bne.n	8014a4e <TIM_Base_SetConfig+0xee>
  {
    /* Clear the update flag */
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 8014a42:	687b      	ldr	r3, [r7, #4]
 8014a44:	691b      	ldr	r3, [r3, #16]
 8014a46:	f023 0201 	bic.w	r2, r3, #1
 8014a4a:	687b      	ldr	r3, [r7, #4]
 8014a4c:	611a      	str	r2, [r3, #16]
  }
}
 8014a4e:	bf00      	nop
 8014a50:	3714      	adds	r7, #20
 8014a52:	46bd      	mov	sp, r7
 8014a54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a58:	4770      	bx	lr
 8014a5a:	bf00      	nop
 8014a5c:	40010000 	.word	0x40010000
 8014a60:	40000400 	.word	0x40000400
 8014a64:	40000800 	.word	0x40000800
 8014a68:	40000c00 	.word	0x40000c00
 8014a6c:	40014000 	.word	0x40014000
 8014a70:	40014400 	.word	0x40014400
 8014a74:	40014800 	.word	0x40014800

08014a78 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8014a78:	b480      	push	{r7}
 8014a7a:	b087      	sub	sp, #28
 8014a7c:	af00      	add	r7, sp, #0
 8014a7e:	6078      	str	r0, [r7, #4]
 8014a80:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8014a82:	687b      	ldr	r3, [r7, #4]
 8014a84:	6a1b      	ldr	r3, [r3, #32]
 8014a86:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8014a88:	687b      	ldr	r3, [r7, #4]
 8014a8a:	6a1b      	ldr	r3, [r3, #32]
 8014a8c:	f023 0201 	bic.w	r2, r3, #1
 8014a90:	687b      	ldr	r3, [r7, #4]
 8014a92:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8014a94:	687b      	ldr	r3, [r7, #4]
 8014a96:	685b      	ldr	r3, [r3, #4]
 8014a98:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8014a9a:	687b      	ldr	r3, [r7, #4]
 8014a9c:	699b      	ldr	r3, [r3, #24]
 8014a9e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8014aa0:	68fb      	ldr	r3, [r7, #12]
 8014aa2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8014aa6:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8014aa8:	68fb      	ldr	r3, [r7, #12]
 8014aaa:	f023 0303 	bic.w	r3, r3, #3
 8014aae:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8014ab0:	683b      	ldr	r3, [r7, #0]
 8014ab2:	681b      	ldr	r3, [r3, #0]
 8014ab4:	68fa      	ldr	r2, [r7, #12]
 8014ab6:	4313      	orrs	r3, r2
 8014ab8:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8014aba:	697b      	ldr	r3, [r7, #20]
 8014abc:	f023 0302 	bic.w	r3, r3, #2
 8014ac0:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8014ac2:	683b      	ldr	r3, [r7, #0]
 8014ac4:	689b      	ldr	r3, [r3, #8]
 8014ac6:	697a      	ldr	r2, [r7, #20]
 8014ac8:	4313      	orrs	r3, r2
 8014aca:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8014acc:	687b      	ldr	r3, [r7, #4]
 8014ace:	4a1c      	ldr	r2, [pc, #112]	@ (8014b40 <TIM_OC1_SetConfig+0xc8>)
 8014ad0:	4293      	cmp	r3, r2
 8014ad2:	d10c      	bne.n	8014aee <TIM_OC1_SetConfig+0x76>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8014ad4:	697b      	ldr	r3, [r7, #20]
 8014ad6:	f023 0308 	bic.w	r3, r3, #8
 8014ada:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8014adc:	683b      	ldr	r3, [r7, #0]
 8014ade:	68db      	ldr	r3, [r3, #12]
 8014ae0:	697a      	ldr	r2, [r7, #20]
 8014ae2:	4313      	orrs	r3, r2
 8014ae4:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8014ae6:	697b      	ldr	r3, [r7, #20]
 8014ae8:	f023 0304 	bic.w	r3, r3, #4
 8014aec:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8014aee:	687b      	ldr	r3, [r7, #4]
 8014af0:	4a13      	ldr	r2, [pc, #76]	@ (8014b40 <TIM_OC1_SetConfig+0xc8>)
 8014af2:	4293      	cmp	r3, r2
 8014af4:	d111      	bne.n	8014b1a <TIM_OC1_SetConfig+0xa2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 8014af6:	693b      	ldr	r3, [r7, #16]
 8014af8:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8014afc:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8014afe:	693b      	ldr	r3, [r7, #16]
 8014b00:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8014b04:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8014b06:	683b      	ldr	r3, [r7, #0]
 8014b08:	695b      	ldr	r3, [r3, #20]
 8014b0a:	693a      	ldr	r2, [r7, #16]
 8014b0c:	4313      	orrs	r3, r2
 8014b0e:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8014b10:	683b      	ldr	r3, [r7, #0]
 8014b12:	699b      	ldr	r3, [r3, #24]
 8014b14:	693a      	ldr	r2, [r7, #16]
 8014b16:	4313      	orrs	r3, r2
 8014b18:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8014b1a:	687b      	ldr	r3, [r7, #4]
 8014b1c:	693a      	ldr	r2, [r7, #16]
 8014b1e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8014b20:	687b      	ldr	r3, [r7, #4]
 8014b22:	68fa      	ldr	r2, [r7, #12]
 8014b24:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8014b26:	683b      	ldr	r3, [r7, #0]
 8014b28:	685a      	ldr	r2, [r3, #4]
 8014b2a:	687b      	ldr	r3, [r7, #4]
 8014b2c:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8014b2e:	687b      	ldr	r3, [r7, #4]
 8014b30:	697a      	ldr	r2, [r7, #20]
 8014b32:	621a      	str	r2, [r3, #32]
}
 8014b34:	bf00      	nop
 8014b36:	371c      	adds	r7, #28
 8014b38:	46bd      	mov	sp, r7
 8014b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014b3e:	4770      	bx	lr
 8014b40:	40010000 	.word	0x40010000

08014b44 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8014b44:	b480      	push	{r7}
 8014b46:	b087      	sub	sp, #28
 8014b48:	af00      	add	r7, sp, #0
 8014b4a:	6078      	str	r0, [r7, #4]
 8014b4c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8014b4e:	687b      	ldr	r3, [r7, #4]
 8014b50:	6a1b      	ldr	r3, [r3, #32]
 8014b52:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8014b54:	687b      	ldr	r3, [r7, #4]
 8014b56:	6a1b      	ldr	r3, [r3, #32]
 8014b58:	f023 0210 	bic.w	r2, r3, #16
 8014b5c:	687b      	ldr	r3, [r7, #4]
 8014b5e:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8014b60:	687b      	ldr	r3, [r7, #4]
 8014b62:	685b      	ldr	r3, [r3, #4]
 8014b64:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8014b66:	687b      	ldr	r3, [r7, #4]
 8014b68:	699b      	ldr	r3, [r3, #24]
 8014b6a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 8014b6c:	68fb      	ldr	r3, [r7, #12]
 8014b6e:	f423 43e0 	bic.w	r3, r3, #28672	@ 0x7000
 8014b72:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8014b74:	68fb      	ldr	r3, [r7, #12]
 8014b76:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8014b7a:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8014b7c:	683b      	ldr	r3, [r7, #0]
 8014b7e:	681b      	ldr	r3, [r3, #0]
 8014b80:	021b      	lsls	r3, r3, #8
 8014b82:	68fa      	ldr	r2, [r7, #12]
 8014b84:	4313      	orrs	r3, r2
 8014b86:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8014b88:	697b      	ldr	r3, [r7, #20]
 8014b8a:	f023 0320 	bic.w	r3, r3, #32
 8014b8e:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8014b90:	683b      	ldr	r3, [r7, #0]
 8014b92:	689b      	ldr	r3, [r3, #8]
 8014b94:	011b      	lsls	r3, r3, #4
 8014b96:	697a      	ldr	r2, [r7, #20]
 8014b98:	4313      	orrs	r3, r2
 8014b9a:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8014b9c:	687b      	ldr	r3, [r7, #4]
 8014b9e:	4a1e      	ldr	r2, [pc, #120]	@ (8014c18 <TIM_OC2_SetConfig+0xd4>)
 8014ba0:	4293      	cmp	r3, r2
 8014ba2:	d10d      	bne.n	8014bc0 <TIM_OC2_SetConfig+0x7c>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8014ba4:	697b      	ldr	r3, [r7, #20]
 8014ba6:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8014baa:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8014bac:	683b      	ldr	r3, [r7, #0]
 8014bae:	68db      	ldr	r3, [r3, #12]
 8014bb0:	011b      	lsls	r3, r3, #4
 8014bb2:	697a      	ldr	r2, [r7, #20]
 8014bb4:	4313      	orrs	r3, r2
 8014bb6:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8014bb8:	697b      	ldr	r3, [r7, #20]
 8014bba:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8014bbe:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8014bc0:	687b      	ldr	r3, [r7, #4]
 8014bc2:	4a15      	ldr	r2, [pc, #84]	@ (8014c18 <TIM_OC2_SetConfig+0xd4>)
 8014bc4:	4293      	cmp	r3, r2
 8014bc6:	d113      	bne.n	8014bf0 <TIM_OC2_SetConfig+0xac>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 8014bc8:	693b      	ldr	r3, [r7, #16]
 8014bca:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8014bce:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8014bd0:	693b      	ldr	r3, [r7, #16]
 8014bd2:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8014bd6:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8014bd8:	683b      	ldr	r3, [r7, #0]
 8014bda:	695b      	ldr	r3, [r3, #20]
 8014bdc:	009b      	lsls	r3, r3, #2
 8014bde:	693a      	ldr	r2, [r7, #16]
 8014be0:	4313      	orrs	r3, r2
 8014be2:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8014be4:	683b      	ldr	r3, [r7, #0]
 8014be6:	699b      	ldr	r3, [r3, #24]
 8014be8:	009b      	lsls	r3, r3, #2
 8014bea:	693a      	ldr	r2, [r7, #16]
 8014bec:	4313      	orrs	r3, r2
 8014bee:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8014bf0:	687b      	ldr	r3, [r7, #4]
 8014bf2:	693a      	ldr	r2, [r7, #16]
 8014bf4:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8014bf6:	687b      	ldr	r3, [r7, #4]
 8014bf8:	68fa      	ldr	r2, [r7, #12]
 8014bfa:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8014bfc:	683b      	ldr	r3, [r7, #0]
 8014bfe:	685a      	ldr	r2, [r3, #4]
 8014c00:	687b      	ldr	r3, [r7, #4]
 8014c02:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8014c04:	687b      	ldr	r3, [r7, #4]
 8014c06:	697a      	ldr	r2, [r7, #20]
 8014c08:	621a      	str	r2, [r3, #32]
}
 8014c0a:	bf00      	nop
 8014c0c:	371c      	adds	r7, #28
 8014c0e:	46bd      	mov	sp, r7
 8014c10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014c14:	4770      	bx	lr
 8014c16:	bf00      	nop
 8014c18:	40010000 	.word	0x40010000

08014c1c <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8014c1c:	b480      	push	{r7}
 8014c1e:	b087      	sub	sp, #28
 8014c20:	af00      	add	r7, sp, #0
 8014c22:	6078      	str	r0, [r7, #4]
 8014c24:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8014c26:	687b      	ldr	r3, [r7, #4]
 8014c28:	6a1b      	ldr	r3, [r3, #32]
 8014c2a:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8014c2c:	687b      	ldr	r3, [r7, #4]
 8014c2e:	6a1b      	ldr	r3, [r3, #32]
 8014c30:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 8014c34:	687b      	ldr	r3, [r7, #4]
 8014c36:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8014c38:	687b      	ldr	r3, [r7, #4]
 8014c3a:	685b      	ldr	r3, [r3, #4]
 8014c3c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8014c3e:	687b      	ldr	r3, [r7, #4]
 8014c40:	69db      	ldr	r3, [r3, #28]
 8014c42:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 8014c44:	68fb      	ldr	r3, [r7, #12]
 8014c46:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8014c4a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8014c4c:	68fb      	ldr	r3, [r7, #12]
 8014c4e:	f023 0303 	bic.w	r3, r3, #3
 8014c52:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8014c54:	683b      	ldr	r3, [r7, #0]
 8014c56:	681b      	ldr	r3, [r3, #0]
 8014c58:	68fa      	ldr	r2, [r7, #12]
 8014c5a:	4313      	orrs	r3, r2
 8014c5c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8014c5e:	697b      	ldr	r3, [r7, #20]
 8014c60:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8014c64:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8014c66:	683b      	ldr	r3, [r7, #0]
 8014c68:	689b      	ldr	r3, [r3, #8]
 8014c6a:	021b      	lsls	r3, r3, #8
 8014c6c:	697a      	ldr	r2, [r7, #20]
 8014c6e:	4313      	orrs	r3, r2
 8014c70:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8014c72:	687b      	ldr	r3, [r7, #4]
 8014c74:	4a1d      	ldr	r2, [pc, #116]	@ (8014cec <TIM_OC3_SetConfig+0xd0>)
 8014c76:	4293      	cmp	r3, r2
 8014c78:	d10d      	bne.n	8014c96 <TIM_OC3_SetConfig+0x7a>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8014c7a:	697b      	ldr	r3, [r7, #20]
 8014c7c:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8014c80:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8014c82:	683b      	ldr	r3, [r7, #0]
 8014c84:	68db      	ldr	r3, [r3, #12]
 8014c86:	021b      	lsls	r3, r3, #8
 8014c88:	697a      	ldr	r2, [r7, #20]
 8014c8a:	4313      	orrs	r3, r2
 8014c8c:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8014c8e:	697b      	ldr	r3, [r7, #20]
 8014c90:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8014c94:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8014c96:	687b      	ldr	r3, [r7, #4]
 8014c98:	4a14      	ldr	r2, [pc, #80]	@ (8014cec <TIM_OC3_SetConfig+0xd0>)
 8014c9a:	4293      	cmp	r3, r2
 8014c9c:	d113      	bne.n	8014cc6 <TIM_OC3_SetConfig+0xaa>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 8014c9e:	693b      	ldr	r3, [r7, #16]
 8014ca0:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8014ca4:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8014ca6:	693b      	ldr	r3, [r7, #16]
 8014ca8:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 8014cac:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8014cae:	683b      	ldr	r3, [r7, #0]
 8014cb0:	695b      	ldr	r3, [r3, #20]
 8014cb2:	011b      	lsls	r3, r3, #4
 8014cb4:	693a      	ldr	r2, [r7, #16]
 8014cb6:	4313      	orrs	r3, r2
 8014cb8:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8014cba:	683b      	ldr	r3, [r7, #0]
 8014cbc:	699b      	ldr	r3, [r3, #24]
 8014cbe:	011b      	lsls	r3, r3, #4
 8014cc0:	693a      	ldr	r2, [r7, #16]
 8014cc2:	4313      	orrs	r3, r2
 8014cc4:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8014cc6:	687b      	ldr	r3, [r7, #4]
 8014cc8:	693a      	ldr	r2, [r7, #16]
 8014cca:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8014ccc:	687b      	ldr	r3, [r7, #4]
 8014cce:	68fa      	ldr	r2, [r7, #12]
 8014cd0:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8014cd2:	683b      	ldr	r3, [r7, #0]
 8014cd4:	685a      	ldr	r2, [r3, #4]
 8014cd6:	687b      	ldr	r3, [r7, #4]
 8014cd8:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8014cda:	687b      	ldr	r3, [r7, #4]
 8014cdc:	697a      	ldr	r2, [r7, #20]
 8014cde:	621a      	str	r2, [r3, #32]
}
 8014ce0:	bf00      	nop
 8014ce2:	371c      	adds	r7, #28
 8014ce4:	46bd      	mov	sp, r7
 8014ce6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014cea:	4770      	bx	lr
 8014cec:	40010000 	.word	0x40010000

08014cf0 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 8014cf0:	b480      	push	{r7}
 8014cf2:	b087      	sub	sp, #28
 8014cf4:	af00      	add	r7, sp, #0
 8014cf6:	6078      	str	r0, [r7, #4]
 8014cf8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8014cfa:	687b      	ldr	r3, [r7, #4]
 8014cfc:	6a1b      	ldr	r3, [r3, #32]
 8014cfe:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8014d00:	687b      	ldr	r3, [r7, #4]
 8014d02:	6a1b      	ldr	r3, [r3, #32]
 8014d04:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
 8014d08:	687b      	ldr	r3, [r7, #4]
 8014d0a:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8014d0c:	687b      	ldr	r3, [r7, #4]
 8014d0e:	685b      	ldr	r3, [r3, #4]
 8014d10:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8014d12:	687b      	ldr	r3, [r7, #4]
 8014d14:	69db      	ldr	r3, [r3, #28]
 8014d16:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 8014d18:	68fb      	ldr	r3, [r7, #12]
 8014d1a:	f423 43e0 	bic.w	r3, r3, #28672	@ 0x7000
 8014d1e:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8014d20:	68fb      	ldr	r3, [r7, #12]
 8014d22:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8014d26:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8014d28:	683b      	ldr	r3, [r7, #0]
 8014d2a:	681b      	ldr	r3, [r3, #0]
 8014d2c:	021b      	lsls	r3, r3, #8
 8014d2e:	68fa      	ldr	r2, [r7, #12]
 8014d30:	4313      	orrs	r3, r2
 8014d32:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8014d34:	693b      	ldr	r3, [r7, #16]
 8014d36:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 8014d3a:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8014d3c:	683b      	ldr	r3, [r7, #0]
 8014d3e:	689b      	ldr	r3, [r3, #8]
 8014d40:	031b      	lsls	r3, r3, #12
 8014d42:	693a      	ldr	r2, [r7, #16]
 8014d44:	4313      	orrs	r3, r2
 8014d46:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8014d48:	687b      	ldr	r3, [r7, #4]
 8014d4a:	4a10      	ldr	r2, [pc, #64]	@ (8014d8c <TIM_OC4_SetConfig+0x9c>)
 8014d4c:	4293      	cmp	r3, r2
 8014d4e:	d109      	bne.n	8014d64 <TIM_OC4_SetConfig+0x74>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8014d50:	697b      	ldr	r3, [r7, #20]
 8014d52:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8014d56:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8014d58:	683b      	ldr	r3, [r7, #0]
 8014d5a:	695b      	ldr	r3, [r3, #20]
 8014d5c:	019b      	lsls	r3, r3, #6
 8014d5e:	697a      	ldr	r2, [r7, #20]
 8014d60:	4313      	orrs	r3, r2
 8014d62:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8014d64:	687b      	ldr	r3, [r7, #4]
 8014d66:	697a      	ldr	r2, [r7, #20]
 8014d68:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8014d6a:	687b      	ldr	r3, [r7, #4]
 8014d6c:	68fa      	ldr	r2, [r7, #12]
 8014d6e:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8014d70:	683b      	ldr	r3, [r7, #0]
 8014d72:	685a      	ldr	r2, [r3, #4]
 8014d74:	687b      	ldr	r3, [r7, #4]
 8014d76:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8014d78:	687b      	ldr	r3, [r7, #4]
 8014d7a:	693a      	ldr	r2, [r7, #16]
 8014d7c:	621a      	str	r2, [r3, #32]
}
 8014d7e:	bf00      	nop
 8014d80:	371c      	adds	r7, #28
 8014d82:	46bd      	mov	sp, r7
 8014d84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d88:	4770      	bx	lr
 8014d8a:	bf00      	nop
 8014d8c:	40010000 	.word	0x40010000

08014d90 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8014d90:	b480      	push	{r7}
 8014d92:	b087      	sub	sp, #28
 8014d94:	af00      	add	r7, sp, #0
 8014d96:	60f8      	str	r0, [r7, #12]
 8014d98:	60b9      	str	r1, [r7, #8]
 8014d9a:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8014d9c:	68fb      	ldr	r3, [r7, #12]
 8014d9e:	6a1b      	ldr	r3, [r3, #32]
 8014da0:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8014da2:	68fb      	ldr	r3, [r7, #12]
 8014da4:	6a1b      	ldr	r3, [r3, #32]
 8014da6:	f023 0201 	bic.w	r2, r3, #1
 8014daa:	68fb      	ldr	r3, [r7, #12]
 8014dac:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8014dae:	68fb      	ldr	r3, [r7, #12]
 8014db0:	699b      	ldr	r3, [r3, #24]
 8014db2:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8014db4:	693b      	ldr	r3, [r7, #16]
 8014db6:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8014dba:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8014dbc:	687b      	ldr	r3, [r7, #4]
 8014dbe:	011b      	lsls	r3, r3, #4
 8014dc0:	693a      	ldr	r2, [r7, #16]
 8014dc2:	4313      	orrs	r3, r2
 8014dc4:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8014dc6:	697b      	ldr	r3, [r7, #20]
 8014dc8:	f023 030a 	bic.w	r3, r3, #10
 8014dcc:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 8014dce:	697a      	ldr	r2, [r7, #20]
 8014dd0:	68bb      	ldr	r3, [r7, #8]
 8014dd2:	4313      	orrs	r3, r2
 8014dd4:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8014dd6:	68fb      	ldr	r3, [r7, #12]
 8014dd8:	693a      	ldr	r2, [r7, #16]
 8014dda:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8014ddc:	68fb      	ldr	r3, [r7, #12]
 8014dde:	697a      	ldr	r2, [r7, #20]
 8014de0:	621a      	str	r2, [r3, #32]
}
 8014de2:	bf00      	nop
 8014de4:	371c      	adds	r7, #28
 8014de6:	46bd      	mov	sp, r7
 8014de8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014dec:	4770      	bx	lr

08014dee <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8014dee:	b480      	push	{r7}
 8014df0:	b087      	sub	sp, #28
 8014df2:	af00      	add	r7, sp, #0
 8014df4:	60f8      	str	r0, [r7, #12]
 8014df6:	60b9      	str	r1, [r7, #8]
 8014df8:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  tmpccer = TIMx->CCER;
 8014dfa:	68fb      	ldr	r3, [r7, #12]
 8014dfc:	6a1b      	ldr	r3, [r3, #32]
 8014dfe:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8014e00:	68fb      	ldr	r3, [r7, #12]
 8014e02:	6a1b      	ldr	r3, [r3, #32]
 8014e04:	f023 0210 	bic.w	r2, r3, #16
 8014e08:	68fb      	ldr	r3, [r7, #12]
 8014e0a:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8014e0c:	68fb      	ldr	r3, [r7, #12]
 8014e0e:	699b      	ldr	r3, [r3, #24]
 8014e10:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8014e12:	693b      	ldr	r3, [r7, #16]
 8014e14:	f423 4370 	bic.w	r3, r3, #61440	@ 0xf000
 8014e18:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8014e1a:	687b      	ldr	r3, [r7, #4]
 8014e1c:	031b      	lsls	r3, r3, #12
 8014e1e:	693a      	ldr	r2, [r7, #16]
 8014e20:	4313      	orrs	r3, r2
 8014e22:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8014e24:	697b      	ldr	r3, [r7, #20]
 8014e26:	f023 03a0 	bic.w	r3, r3, #160	@ 0xa0
 8014e2a:	617b      	str	r3, [r7, #20]
  tmpccer |= (TIM_ICPolarity << 4U);
 8014e2c:	68bb      	ldr	r3, [r7, #8]
 8014e2e:	011b      	lsls	r3, r3, #4
 8014e30:	697a      	ldr	r2, [r7, #20]
 8014e32:	4313      	orrs	r3, r2
 8014e34:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8014e36:	68fb      	ldr	r3, [r7, #12]
 8014e38:	693a      	ldr	r2, [r7, #16]
 8014e3a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8014e3c:	68fb      	ldr	r3, [r7, #12]
 8014e3e:	697a      	ldr	r2, [r7, #20]
 8014e40:	621a      	str	r2, [r3, #32]
}
 8014e42:	bf00      	nop
 8014e44:	371c      	adds	r7, #28
 8014e46:	46bd      	mov	sp, r7
 8014e48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e4c:	4770      	bx	lr

08014e4e <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 8014e4e:	b480      	push	{r7}
 8014e50:	b085      	sub	sp, #20
 8014e52:	af00      	add	r7, sp, #0
 8014e54:	6078      	str	r0, [r7, #4]
 8014e56:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8014e58:	687b      	ldr	r3, [r7, #4]
 8014e5a:	689b      	ldr	r3, [r3, #8]
 8014e5c:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8014e5e:	68fb      	ldr	r3, [r7, #12]
 8014e60:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8014e64:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8014e66:	683a      	ldr	r2, [r7, #0]
 8014e68:	68fb      	ldr	r3, [r7, #12]
 8014e6a:	4313      	orrs	r3, r2
 8014e6c:	f043 0307 	orr.w	r3, r3, #7
 8014e70:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8014e72:	687b      	ldr	r3, [r7, #4]
 8014e74:	68fa      	ldr	r2, [r7, #12]
 8014e76:	609a      	str	r2, [r3, #8]
}
 8014e78:	bf00      	nop
 8014e7a:	3714      	adds	r7, #20
 8014e7c:	46bd      	mov	sp, r7
 8014e7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e82:	4770      	bx	lr

08014e84 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 8014e84:	b480      	push	{r7}
 8014e86:	b087      	sub	sp, #28
 8014e88:	af00      	add	r7, sp, #0
 8014e8a:	60f8      	str	r0, [r7, #12]
 8014e8c:	60b9      	str	r1, [r7, #8]
 8014e8e:	607a      	str	r2, [r7, #4]
 8014e90:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8014e92:	68fb      	ldr	r3, [r7, #12]
 8014e94:	689b      	ldr	r3, [r3, #8]
 8014e96:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8014e98:	697b      	ldr	r3, [r7, #20]
 8014e9a:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8014e9e:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8014ea0:	683b      	ldr	r3, [r7, #0]
 8014ea2:	021a      	lsls	r2, r3, #8
 8014ea4:	687b      	ldr	r3, [r7, #4]
 8014ea6:	431a      	orrs	r2, r3
 8014ea8:	68bb      	ldr	r3, [r7, #8]
 8014eaa:	4313      	orrs	r3, r2
 8014eac:	697a      	ldr	r2, [r7, #20]
 8014eae:	4313      	orrs	r3, r2
 8014eb0:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8014eb2:	68fb      	ldr	r3, [r7, #12]
 8014eb4:	697a      	ldr	r2, [r7, #20]
 8014eb6:	609a      	str	r2, [r3, #8]
}
 8014eb8:	bf00      	nop
 8014eba:	371c      	adds	r7, #28
 8014ebc:	46bd      	mov	sp, r7
 8014ebe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ec2:	4770      	bx	lr

08014ec4 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8014ec4:	b480      	push	{r7}
 8014ec6:	b087      	sub	sp, #28
 8014ec8:	af00      	add	r7, sp, #0
 8014eca:	60f8      	str	r0, [r7, #12]
 8014ecc:	60b9      	str	r1, [r7, #8]
 8014ece:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8014ed0:	68bb      	ldr	r3, [r7, #8]
 8014ed2:	f003 031f 	and.w	r3, r3, #31
 8014ed6:	2201      	movs	r2, #1
 8014ed8:	fa02 f303 	lsl.w	r3, r2, r3
 8014edc:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8014ede:	68fb      	ldr	r3, [r7, #12]
 8014ee0:	6a1a      	ldr	r2, [r3, #32]
 8014ee2:	697b      	ldr	r3, [r7, #20]
 8014ee4:	43db      	mvns	r3, r3
 8014ee6:	401a      	ands	r2, r3
 8014ee8:	68fb      	ldr	r3, [r7, #12]
 8014eea:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8014eec:	68fb      	ldr	r3, [r7, #12]
 8014eee:	6a1a      	ldr	r2, [r3, #32]
 8014ef0:	68bb      	ldr	r3, [r7, #8]
 8014ef2:	f003 031f 	and.w	r3, r3, #31
 8014ef6:	6879      	ldr	r1, [r7, #4]
 8014ef8:	fa01 f303 	lsl.w	r3, r1, r3
 8014efc:	431a      	orrs	r2, r3
 8014efe:	68fb      	ldr	r3, [r7, #12]
 8014f00:	621a      	str	r2, [r3, #32]
}
 8014f02:	bf00      	nop
 8014f04:	371c      	adds	r7, #28
 8014f06:	46bd      	mov	sp, r7
 8014f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f0c:	4770      	bx	lr
	...

08014f10 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        const TIM_MasterConfigTypeDef *sMasterConfig)
{
 8014f10:	b480      	push	{r7}
 8014f12:	b085      	sub	sp, #20
 8014f14:	af00      	add	r7, sp, #0
 8014f16:	6078      	str	r0, [r7, #4]
 8014f18:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8014f1a:	687b      	ldr	r3, [r7, #4]
 8014f1c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8014f20:	2b01      	cmp	r3, #1
 8014f22:	d101      	bne.n	8014f28 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 8014f24:	2302      	movs	r3, #2
 8014f26:	e050      	b.n	8014fca <HAL_TIMEx_MasterConfigSynchronization+0xba>
 8014f28:	687b      	ldr	r3, [r7, #4]
 8014f2a:	2201      	movs	r2, #1
 8014f2c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8014f30:	687b      	ldr	r3, [r7, #4]
 8014f32:	2202      	movs	r2, #2
 8014f34:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8014f38:	687b      	ldr	r3, [r7, #4]
 8014f3a:	681b      	ldr	r3, [r3, #0]
 8014f3c:	685b      	ldr	r3, [r3, #4]
 8014f3e:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8014f40:	687b      	ldr	r3, [r7, #4]
 8014f42:	681b      	ldr	r3, [r3, #0]
 8014f44:	689b      	ldr	r3, [r3, #8]
 8014f46:	60bb      	str	r3, [r7, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8014f48:	68fb      	ldr	r3, [r7, #12]
 8014f4a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8014f4e:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8014f50:	683b      	ldr	r3, [r7, #0]
 8014f52:	681b      	ldr	r3, [r3, #0]
 8014f54:	68fa      	ldr	r2, [r7, #12]
 8014f56:	4313      	orrs	r3, r2
 8014f58:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8014f5a:	687b      	ldr	r3, [r7, #4]
 8014f5c:	681b      	ldr	r3, [r3, #0]
 8014f5e:	68fa      	ldr	r2, [r7, #12]
 8014f60:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8014f62:	687b      	ldr	r3, [r7, #4]
 8014f64:	681b      	ldr	r3, [r3, #0]
 8014f66:	4a1c      	ldr	r2, [pc, #112]	@ (8014fd8 <HAL_TIMEx_MasterConfigSynchronization+0xc8>)
 8014f68:	4293      	cmp	r3, r2
 8014f6a:	d018      	beq.n	8014f9e <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 8014f6c:	687b      	ldr	r3, [r7, #4]
 8014f6e:	681b      	ldr	r3, [r3, #0]
 8014f70:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8014f74:	d013      	beq.n	8014f9e <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 8014f76:	687b      	ldr	r3, [r7, #4]
 8014f78:	681b      	ldr	r3, [r3, #0]
 8014f7a:	4a18      	ldr	r2, [pc, #96]	@ (8014fdc <HAL_TIMEx_MasterConfigSynchronization+0xcc>)
 8014f7c:	4293      	cmp	r3, r2
 8014f7e:	d00e      	beq.n	8014f9e <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 8014f80:	687b      	ldr	r3, [r7, #4]
 8014f82:	681b      	ldr	r3, [r3, #0]
 8014f84:	4a16      	ldr	r2, [pc, #88]	@ (8014fe0 <HAL_TIMEx_MasterConfigSynchronization+0xd0>)
 8014f86:	4293      	cmp	r3, r2
 8014f88:	d009      	beq.n	8014f9e <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 8014f8a:	687b      	ldr	r3, [r7, #4]
 8014f8c:	681b      	ldr	r3, [r3, #0]
 8014f8e:	4a15      	ldr	r2, [pc, #84]	@ (8014fe4 <HAL_TIMEx_MasterConfigSynchronization+0xd4>)
 8014f90:	4293      	cmp	r3, r2
 8014f92:	d004      	beq.n	8014f9e <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 8014f94:	687b      	ldr	r3, [r7, #4]
 8014f96:	681b      	ldr	r3, [r3, #0]
 8014f98:	4a13      	ldr	r2, [pc, #76]	@ (8014fe8 <HAL_TIMEx_MasterConfigSynchronization+0xd8>)
 8014f9a:	4293      	cmp	r3, r2
 8014f9c:	d10c      	bne.n	8014fb8 <HAL_TIMEx_MasterConfigSynchronization+0xa8>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 8014f9e:	68bb      	ldr	r3, [r7, #8]
 8014fa0:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8014fa4:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8014fa6:	683b      	ldr	r3, [r7, #0]
 8014fa8:	685b      	ldr	r3, [r3, #4]
 8014faa:	68ba      	ldr	r2, [r7, #8]
 8014fac:	4313      	orrs	r3, r2
 8014fae:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8014fb0:	687b      	ldr	r3, [r7, #4]
 8014fb2:	681b      	ldr	r3, [r3, #0]
 8014fb4:	68ba      	ldr	r2, [r7, #8]
 8014fb6:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8014fb8:	687b      	ldr	r3, [r7, #4]
 8014fba:	2201      	movs	r2, #1
 8014fbc:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 8014fc0:	687b      	ldr	r3, [r7, #4]
 8014fc2:	2200      	movs	r2, #0
 8014fc4:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 8014fc8:	2300      	movs	r3, #0
}
 8014fca:	4618      	mov	r0, r3
 8014fcc:	3714      	adds	r7, #20
 8014fce:	46bd      	mov	sp, r7
 8014fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014fd4:	4770      	bx	lr
 8014fd6:	bf00      	nop
 8014fd8:	40010000 	.word	0x40010000
 8014fdc:	40000400 	.word	0x40000400
 8014fe0:	40000800 	.word	0x40000800
 8014fe4:	40000c00 	.word	0x40000c00
 8014fe8:	40014000 	.word	0x40014000

08014fec <HAL_TIMEx_ConfigBreakDeadTime>:
  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                const TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 8014fec:	b480      	push	{r7}
 8014fee:	b085      	sub	sp, #20
 8014ff0:	af00      	add	r7, sp, #0
 8014ff2:	6078      	str	r0, [r7, #4]
 8014ff4:	6039      	str	r1, [r7, #0]
  /* Keep this variable initialized to 0 as it is used to configure BDTR register */
  uint32_t tmpbdtr = 0U;
 8014ff6:	2300      	movs	r3, #0
 8014ff8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 8014ffa:	687b      	ldr	r3, [r7, #4]
 8014ffc:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8015000:	2b01      	cmp	r3, #1
 8015002:	d101      	bne.n	8015008 <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
 8015004:	2302      	movs	r3, #2
 8015006:	e03d      	b.n	8015084 <HAL_TIMEx_ConfigBreakDeadTime+0x98>
 8015008:	687b      	ldr	r3, [r7, #4]
 801500a:	2201      	movs	r2, #1
 801500c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
 8015010:	68fb      	ldr	r3, [r7, #12]
 8015012:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
 8015016:	683b      	ldr	r3, [r7, #0]
 8015018:	68db      	ldr	r3, [r3, #12]
 801501a:	4313      	orrs	r3, r2
 801501c:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 801501e:	68fb      	ldr	r3, [r7, #12]
 8015020:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 8015024:	683b      	ldr	r3, [r7, #0]
 8015026:	689b      	ldr	r3, [r3, #8]
 8015028:	4313      	orrs	r3, r2
 801502a:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 801502c:	68fb      	ldr	r3, [r7, #12]
 801502e:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
 8015032:	683b      	ldr	r3, [r7, #0]
 8015034:	685b      	ldr	r3, [r3, #4]
 8015036:	4313      	orrs	r3, r2
 8015038:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 801503a:	68fb      	ldr	r3, [r7, #12]
 801503c:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 8015040:	683b      	ldr	r3, [r7, #0]
 8015042:	681b      	ldr	r3, [r3, #0]
 8015044:	4313      	orrs	r3, r2
 8015046:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8015048:	68fb      	ldr	r3, [r7, #12]
 801504a:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
 801504e:	683b      	ldr	r3, [r7, #0]
 8015050:	691b      	ldr	r3, [r3, #16]
 8015052:	4313      	orrs	r3, r2
 8015054:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8015056:	68fb      	ldr	r3, [r7, #12]
 8015058:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
 801505c:	683b      	ldr	r3, [r7, #0]
 801505e:	695b      	ldr	r3, [r3, #20]
 8015060:	4313      	orrs	r3, r2
 8015062:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8015064:	68fb      	ldr	r3, [r7, #12]
 8015066:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
 801506a:	683b      	ldr	r3, [r7, #0]
 801506c:	69db      	ldr	r3, [r3, #28]
 801506e:	4313      	orrs	r3, r2
 8015070:	60fb      	str	r3, [r7, #12]


  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 8015072:	687b      	ldr	r3, [r7, #4]
 8015074:	681b      	ldr	r3, [r3, #0]
 8015076:	68fa      	ldr	r2, [r7, #12]
 8015078:	645a      	str	r2, [r3, #68]	@ 0x44

  __HAL_UNLOCK(htim);
 801507a:	687b      	ldr	r3, [r7, #4]
 801507c:	2200      	movs	r2, #0
 801507e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 8015082:	2300      	movs	r3, #0
}
 8015084:	4618      	mov	r0, r3
 8015086:	3714      	adds	r7, #20
 8015088:	46bd      	mov	sp, r7
 801508a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801508e:	4770      	bx	lr

08015090 <HAL_TIMEx_CommutCallback>:
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8015090:	b480      	push	{r7}
 8015092:	b083      	sub	sp, #12
 8015094:	af00      	add	r7, sp, #0
 8015096:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8015098:	bf00      	nop
 801509a:	370c      	adds	r7, #12
 801509c:	46bd      	mov	sp, r7
 801509e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80150a2:	4770      	bx	lr

080150a4 <HAL_TIMEx_BreakCallback>:
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 80150a4:	b480      	push	{r7}
 80150a6:	b083      	sub	sp, #12
 80150a8:	af00      	add	r7, sp, #0
 80150aa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 80150ac:	bf00      	nop
 80150ae:	370c      	adds	r7, #12
 80150b0:	46bd      	mov	sp, r7
 80150b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80150b6:	4770      	bx	lr

080150b8 <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80150b8:	b580      	push	{r7, lr}
 80150ba:	b082      	sub	sp, #8
 80150bc:	af00      	add	r7, sp, #0
 80150be:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80150c0:	687b      	ldr	r3, [r7, #4]
 80150c2:	2b00      	cmp	r3, #0
 80150c4:	d101      	bne.n	80150ca <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80150c6:	2301      	movs	r3, #1
 80150c8:	e042      	b.n	8015150 <HAL_UART_Init+0x98>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if (huart->gState == HAL_UART_STATE_RESET)
 80150ca:	687b      	ldr	r3, [r7, #4]
 80150cc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80150d0:	b2db      	uxtb	r3, r3
 80150d2:	2b00      	cmp	r3, #0
 80150d4:	d106      	bne.n	80150e4 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80150d6:	687b      	ldr	r3, [r7, #4]
 80150d8:	2200      	movs	r2, #0
 80150da:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80150de:	6878      	ldr	r0, [r7, #4]
 80150e0:	f000 f83a 	bl	8015158 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80150e4:	687b      	ldr	r3, [r7, #4]
 80150e6:	2224      	movs	r2, #36	@ 0x24
 80150e8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 80150ec:	687b      	ldr	r3, [r7, #4]
 80150ee:	681b      	ldr	r3, [r3, #0]
 80150f0:	68da      	ldr	r2, [r3, #12]
 80150f2:	687b      	ldr	r3, [r7, #4]
 80150f4:	681b      	ldr	r3, [r3, #0]
 80150f6:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 80150fa:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 80150fc:	6878      	ldr	r0, [r7, #4]
 80150fe:	f000 fb8d 	bl	801581c <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8015102:	687b      	ldr	r3, [r7, #4]
 8015104:	681b      	ldr	r3, [r3, #0]
 8015106:	691a      	ldr	r2, [r3, #16]
 8015108:	687b      	ldr	r3, [r7, #4]
 801510a:	681b      	ldr	r3, [r3, #0]
 801510c:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 8015110:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8015112:	687b      	ldr	r3, [r7, #4]
 8015114:	681b      	ldr	r3, [r3, #0]
 8015116:	695a      	ldr	r2, [r3, #20]
 8015118:	687b      	ldr	r3, [r7, #4]
 801511a:	681b      	ldr	r3, [r3, #0]
 801511c:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 8015120:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8015122:	687b      	ldr	r3, [r7, #4]
 8015124:	681b      	ldr	r3, [r3, #0]
 8015126:	68da      	ldr	r2, [r3, #12]
 8015128:	687b      	ldr	r3, [r7, #4]
 801512a:	681b      	ldr	r3, [r3, #0]
 801512c:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8015130:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8015132:	687b      	ldr	r3, [r7, #4]
 8015134:	2200      	movs	r2, #0
 8015136:	645a      	str	r2, [r3, #68]	@ 0x44
  huart->gState = HAL_UART_STATE_READY;
 8015138:	687b      	ldr	r3, [r7, #4]
 801513a:	2220      	movs	r2, #32
 801513c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  huart->RxState = HAL_UART_STATE_READY;
 8015140:	687b      	ldr	r3, [r7, #4]
 8015142:	2220      	movs	r2, #32
 8015144:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8015148:	687b      	ldr	r3, [r7, #4]
 801514a:	2200      	movs	r2, #0
 801514c:	635a      	str	r2, [r3, #52]	@ 0x34

  return HAL_OK;
 801514e:	2300      	movs	r3, #0
}
 8015150:	4618      	mov	r0, r3
 8015152:	3708      	adds	r7, #8
 8015154:	46bd      	mov	sp, r7
 8015156:	bd80      	pop	{r7, pc}

08015158 <HAL_UART_MspInit>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8015158:	b480      	push	{r7}
 801515a:	b083      	sub	sp, #12
 801515c:	af00      	add	r7, sp, #0
 801515e:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_MspInit could be implemented in the user file
   */
}
 8015160:	bf00      	nop
 8015162:	370c      	adds	r7, #12
 8015164:	46bd      	mov	sp, r7
 8015166:	f85d 7b04 	ldr.w	r7, [sp], #4
 801516a:	4770      	bx	lr

0801516c <HAL_UART_Transmit>:
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 801516c:	b580      	push	{r7, lr}
 801516e:	b08a      	sub	sp, #40	@ 0x28
 8015170:	af02      	add	r7, sp, #8
 8015172:	60f8      	str	r0, [r7, #12]
 8015174:	60b9      	str	r1, [r7, #8]
 8015176:	603b      	str	r3, [r7, #0]
 8015178:	4613      	mov	r3, r2
 801517a:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart = 0U;
 801517c:	2300      	movs	r3, #0
 801517e:	617b      	str	r3, [r7, #20]

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8015180:	68fb      	ldr	r3, [r7, #12]
 8015182:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8015186:	b2db      	uxtb	r3, r3
 8015188:	2b20      	cmp	r3, #32
 801518a:	d175      	bne.n	8015278 <HAL_UART_Transmit+0x10c>
  {
    if ((pData == NULL) || (Size == 0U))
 801518c:	68bb      	ldr	r3, [r7, #8]
 801518e:	2b00      	cmp	r3, #0
 8015190:	d002      	beq.n	8015198 <HAL_UART_Transmit+0x2c>
 8015192:	88fb      	ldrh	r3, [r7, #6]
 8015194:	2b00      	cmp	r3, #0
 8015196:	d101      	bne.n	801519c <HAL_UART_Transmit+0x30>
    {
      return  HAL_ERROR;
 8015198:	2301      	movs	r3, #1
 801519a:	e06e      	b.n	801527a <HAL_UART_Transmit+0x10e>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 801519c:	68fb      	ldr	r3, [r7, #12]
 801519e:	2200      	movs	r2, #0
 80151a0:	645a      	str	r2, [r3, #68]	@ 0x44
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80151a2:	68fb      	ldr	r3, [r7, #12]
 80151a4:	2221      	movs	r2, #33	@ 0x21
 80151a6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 80151aa:	f7fa f8a7 	bl	800f2fc <HAL_GetTick>
 80151ae:	6178      	str	r0, [r7, #20]

    huart->TxXferSize = Size;
 80151b0:	68fb      	ldr	r3, [r7, #12]
 80151b2:	88fa      	ldrh	r2, [r7, #6]
 80151b4:	849a      	strh	r2, [r3, #36]	@ 0x24
    huart->TxXferCount = Size;
 80151b6:	68fb      	ldr	r3, [r7, #12]
 80151b8:	88fa      	ldrh	r2, [r7, #6]
 80151ba:	84da      	strh	r2, [r3, #38]	@ 0x26

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80151bc:	68fb      	ldr	r3, [r7, #12]
 80151be:	689b      	ldr	r3, [r3, #8]
 80151c0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80151c4:	d108      	bne.n	80151d8 <HAL_UART_Transmit+0x6c>
 80151c6:	68fb      	ldr	r3, [r7, #12]
 80151c8:	691b      	ldr	r3, [r3, #16]
 80151ca:	2b00      	cmp	r3, #0
 80151cc:	d104      	bne.n	80151d8 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
 80151ce:	2300      	movs	r3, #0
 80151d0:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 80151d2:	68bb      	ldr	r3, [r7, #8]
 80151d4:	61bb      	str	r3, [r7, #24]
 80151d6:	e003      	b.n	80151e0 <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
 80151d8:	68bb      	ldr	r3, [r7, #8]
 80151da:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 80151dc:	2300      	movs	r3, #0
 80151de:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 80151e0:	e02e      	b.n	8015240 <HAL_UART_Transmit+0xd4>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80151e2:	683b      	ldr	r3, [r7, #0]
 80151e4:	9300      	str	r3, [sp, #0]
 80151e6:	697b      	ldr	r3, [r7, #20]
 80151e8:	2200      	movs	r2, #0
 80151ea:	2180      	movs	r1, #128	@ 0x80
 80151ec:	68f8      	ldr	r0, [r7, #12]
 80151ee:	f000 f995 	bl	801551c <UART_WaitOnFlagUntilTimeout>
 80151f2:	4603      	mov	r3, r0
 80151f4:	2b00      	cmp	r3, #0
 80151f6:	d005      	beq.n	8015204 <HAL_UART_Transmit+0x98>
      {
        huart->gState = HAL_UART_STATE_READY;
 80151f8:	68fb      	ldr	r3, [r7, #12]
 80151fa:	2220      	movs	r2, #32
 80151fc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

        return HAL_TIMEOUT;
 8015200:	2303      	movs	r3, #3
 8015202:	e03a      	b.n	801527a <HAL_UART_Transmit+0x10e>
      }
      if (pdata8bits == NULL)
 8015204:	69fb      	ldr	r3, [r7, #28]
 8015206:	2b00      	cmp	r3, #0
 8015208:	d10b      	bne.n	8015222 <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 801520a:	69bb      	ldr	r3, [r7, #24]
 801520c:	881b      	ldrh	r3, [r3, #0]
 801520e:	461a      	mov	r2, r3
 8015210:	68fb      	ldr	r3, [r7, #12]
 8015212:	681b      	ldr	r3, [r3, #0]
 8015214:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8015218:	605a      	str	r2, [r3, #4]
        pdata16bits++;
 801521a:	69bb      	ldr	r3, [r7, #24]
 801521c:	3302      	adds	r3, #2
 801521e:	61bb      	str	r3, [r7, #24]
 8015220:	e007      	b.n	8015232 <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 8015222:	69fb      	ldr	r3, [r7, #28]
 8015224:	781a      	ldrb	r2, [r3, #0]
 8015226:	68fb      	ldr	r3, [r7, #12]
 8015228:	681b      	ldr	r3, [r3, #0]
 801522a:	605a      	str	r2, [r3, #4]
        pdata8bits++;
 801522c:	69fb      	ldr	r3, [r7, #28]
 801522e:	3301      	adds	r3, #1
 8015230:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 8015232:	68fb      	ldr	r3, [r7, #12]
 8015234:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
 8015236:	b29b      	uxth	r3, r3
 8015238:	3b01      	subs	r3, #1
 801523a:	b29a      	uxth	r2, r3
 801523c:	68fb      	ldr	r3, [r7, #12]
 801523e:	84da      	strh	r2, [r3, #38]	@ 0x26
    while (huart->TxXferCount > 0U)
 8015240:	68fb      	ldr	r3, [r7, #12]
 8015242:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
 8015244:	b29b      	uxth	r3, r3
 8015246:	2b00      	cmp	r3, #0
 8015248:	d1cb      	bne.n	80151e2 <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 801524a:	683b      	ldr	r3, [r7, #0]
 801524c:	9300      	str	r3, [sp, #0]
 801524e:	697b      	ldr	r3, [r7, #20]
 8015250:	2200      	movs	r2, #0
 8015252:	2140      	movs	r1, #64	@ 0x40
 8015254:	68f8      	ldr	r0, [r7, #12]
 8015256:	f000 f961 	bl	801551c <UART_WaitOnFlagUntilTimeout>
 801525a:	4603      	mov	r3, r0
 801525c:	2b00      	cmp	r3, #0
 801525e:	d005      	beq.n	801526c <HAL_UART_Transmit+0x100>
    {
      huart->gState = HAL_UART_STATE_READY;
 8015260:	68fb      	ldr	r3, [r7, #12]
 8015262:	2220      	movs	r2, #32
 8015264:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      return HAL_TIMEOUT;
 8015268:	2303      	movs	r3, #3
 801526a:	e006      	b.n	801527a <HAL_UART_Transmit+0x10e>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 801526c:	68fb      	ldr	r3, [r7, #12]
 801526e:	2220      	movs	r2, #32
 8015270:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    return HAL_OK;
 8015274:	2300      	movs	r3, #0
 8015276:	e000      	b.n	801527a <HAL_UART_Transmit+0x10e>
  }
  else
  {
    return HAL_BUSY;
 8015278:	2302      	movs	r3, #2
  }
}
 801527a:	4618      	mov	r0, r3
 801527c:	3720      	adds	r7, #32
 801527e:	46bd      	mov	sp, r7
 8015280:	bd80      	pop	{r7, pc}

08015282 <HAL_UART_Receive_DMA>:
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @note   When the UART parity is enabled (PCE = 1) the received data contains the parity bit.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8015282:	b580      	push	{r7, lr}
 8015284:	b084      	sub	sp, #16
 8015286:	af00      	add	r7, sp, #0
 8015288:	60f8      	str	r0, [r7, #12]
 801528a:	60b9      	str	r1, [r7, #8]
 801528c:	4613      	mov	r3, r2
 801528e:	80fb      	strh	r3, [r7, #6]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 8015290:	68fb      	ldr	r3, [r7, #12]
 8015292:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8015296:	b2db      	uxtb	r3, r3
 8015298:	2b20      	cmp	r3, #32
 801529a:	d112      	bne.n	80152c2 <HAL_UART_Receive_DMA+0x40>
  {
    if ((pData == NULL) || (Size == 0U))
 801529c:	68bb      	ldr	r3, [r7, #8]
 801529e:	2b00      	cmp	r3, #0
 80152a0:	d002      	beq.n	80152a8 <HAL_UART_Receive_DMA+0x26>
 80152a2:	88fb      	ldrh	r3, [r7, #6]
 80152a4:	2b00      	cmp	r3, #0
 80152a6:	d101      	bne.n	80152ac <HAL_UART_Receive_DMA+0x2a>
    {
      return HAL_ERROR;
 80152a8:	2301      	movs	r3, #1
 80152aa:	e00b      	b.n	80152c4 <HAL_UART_Receive_DMA+0x42>
    }

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80152ac:	68fb      	ldr	r3, [r7, #12]
 80152ae:	2200      	movs	r2, #0
 80152b0:	631a      	str	r2, [r3, #48]	@ 0x30

    return (UART_Start_Receive_DMA(huart, pData, Size));
 80152b2:	88fb      	ldrh	r3, [r7, #6]
 80152b4:	461a      	mov	r2, r3
 80152b6:	68b9      	ldr	r1, [r7, #8]
 80152b8:	68f8      	ldr	r0, [r7, #12]
 80152ba:	f000 f989 	bl	80155d0 <UART_Start_Receive_DMA>
 80152be:	4603      	mov	r3, r0
 80152c0:	e000      	b.n	80152c4 <HAL_UART_Receive_DMA+0x42>
  }
  else
  {
    return HAL_BUSY;
 80152c2:	2302      	movs	r3, #2
  }
}
 80152c4:	4618      	mov	r0, r3
 80152c6:	3710      	adds	r7, #16
 80152c8:	46bd      	mov	sp, r7
 80152ca:	bd80      	pop	{r7, pc}

080152cc <HAL_UART_RxCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 80152cc:	b480      	push	{r7}
 80152ce:	b083      	sub	sp, #12
 80152d0:	af00      	add	r7, sp, #0
 80152d2:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */
}
 80152d4:	bf00      	nop
 80152d6:	370c      	adds	r7, #12
 80152d8:	46bd      	mov	sp, r7
 80152da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152de:	4770      	bx	lr

080152e0 <HAL_UART_RxHalfCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 80152e0:	b480      	push	{r7}
 80152e2:	b083      	sub	sp, #12
 80152e4:	af00      	add	r7, sp, #0
 80152e6:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback could be implemented in the user file
   */
}
 80152e8:	bf00      	nop
 80152ea:	370c      	adds	r7, #12
 80152ec:	46bd      	mov	sp, r7
 80152ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152f2:	4770      	bx	lr

080152f4 <HAL_UART_ErrorCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 80152f4:	b480      	push	{r7}
 80152f6:	b083      	sub	sp, #12
 80152f8:	af00      	add	r7, sp, #0
 80152fa:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_ErrorCallback could be implemented in the user file
   */
}
 80152fc:	bf00      	nop
 80152fe:	370c      	adds	r7, #12
 8015300:	46bd      	mov	sp, r7
 8015302:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015306:	4770      	bx	lr

08015308 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8015308:	b480      	push	{r7}
 801530a:	b083      	sub	sp, #12
 801530c:	af00      	add	r7, sp, #0
 801530e:	6078      	str	r0, [r7, #4]
 8015310:	460b      	mov	r3, r1
 8015312:	807b      	strh	r3, [r7, #2]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 8015314:	bf00      	nop
 8015316:	370c      	adds	r7, #12
 8015318:	46bd      	mov	sp, r7
 801531a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801531e:	4770      	bx	lr

08015320 <UART_DMAReceiveCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 8015320:	b580      	push	{r7, lr}
 8015322:	b09c      	sub	sp, #112	@ 0x70
 8015324:	af00      	add	r7, sp, #0
 8015326:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8015328:	687b      	ldr	r3, [r7, #4]
 801532a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801532c:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /* DMA Normal mode*/
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 801532e:	687b      	ldr	r3, [r7, #4]
 8015330:	681b      	ldr	r3, [r3, #0]
 8015332:	681b      	ldr	r3, [r3, #0]
 8015334:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8015338:	2b00      	cmp	r3, #0
 801533a:	d172      	bne.n	8015422 <UART_DMAReceiveCplt+0x102>
  {
    huart->RxXferCount = 0U;
 801533c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801533e:	2200      	movs	r2, #0
 8015340:	85da      	strh	r2, [r3, #46]	@ 0x2e

    /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8015342:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015344:	681b      	ldr	r3, [r3, #0]
 8015346:	330c      	adds	r3, #12
 8015348:	64fb      	str	r3, [r7, #76]	@ 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801534a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801534c:	e853 3f00 	ldrex	r3, [r3]
 8015350:	64bb      	str	r3, [r7, #72]	@ 0x48
   return(result);
 8015352:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015354:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8015358:	66bb      	str	r3, [r7, #104]	@ 0x68
 801535a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801535c:	681b      	ldr	r3, [r3, #0]
 801535e:	330c      	adds	r3, #12
 8015360:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8015362:	65ba      	str	r2, [r7, #88]	@ 0x58
 8015364:	657b      	str	r3, [r7, #84]	@ 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015366:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8015368:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801536a:	e841 2300 	strex	r3, r2, [r1]
 801536e:	653b      	str	r3, [r7, #80]	@ 0x50
   return(result);
 8015370:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8015372:	2b00      	cmp	r3, #0
 8015374:	d1e5      	bne.n	8015342 <UART_DMAReceiveCplt+0x22>
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8015376:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015378:	681b      	ldr	r3, [r3, #0]
 801537a:	3314      	adds	r3, #20
 801537c:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801537e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8015380:	e853 3f00 	ldrex	r3, [r3]
 8015384:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 8015386:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015388:	f023 0301 	bic.w	r3, r3, #1
 801538c:	667b      	str	r3, [r7, #100]	@ 0x64
 801538e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015390:	681b      	ldr	r3, [r3, #0]
 8015392:	3314      	adds	r3, #20
 8015394:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8015396:	647a      	str	r2, [r7, #68]	@ 0x44
 8015398:	643b      	str	r3, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801539a:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801539c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801539e:	e841 2300 	strex	r3, r2, [r1]
 80153a2:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 80153a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80153a6:	2b00      	cmp	r3, #0
 80153a8:	d1e5      	bne.n	8015376 <UART_DMAReceiveCplt+0x56>

    /* Disable the DMA transfer for the receiver request by setting the DMAR bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80153aa:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80153ac:	681b      	ldr	r3, [r3, #0]
 80153ae:	3314      	adds	r3, #20
 80153b0:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80153b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80153b4:	e853 3f00 	ldrex	r3, [r3]
 80153b8:	623b      	str	r3, [r7, #32]
   return(result);
 80153ba:	6a3b      	ldr	r3, [r7, #32]
 80153bc:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80153c0:	663b      	str	r3, [r7, #96]	@ 0x60
 80153c2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80153c4:	681b      	ldr	r3, [r3, #0]
 80153c6:	3314      	adds	r3, #20
 80153c8:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80153ca:	633a      	str	r2, [r7, #48]	@ 0x30
 80153cc:	62fb      	str	r3, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80153ce:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80153d0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80153d2:	e841 2300 	strex	r3, r2, [r1]
 80153d6:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 80153d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80153da:	2b00      	cmp	r3, #0
 80153dc:	d1e5      	bne.n	80153aa <UART_DMAReceiveCplt+0x8a>

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 80153de:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80153e0:	2220      	movs	r2, #32
 80153e2:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80153e6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80153e8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80153ea:	2b01      	cmp	r3, #1
 80153ec:	d119      	bne.n	8015422 <UART_DMAReceiveCplt+0x102>
    {
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80153ee:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80153f0:	681b      	ldr	r3, [r3, #0]
 80153f2:	330c      	adds	r3, #12
 80153f4:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80153f6:	693b      	ldr	r3, [r7, #16]
 80153f8:	e853 3f00 	ldrex	r3, [r3]
 80153fc:	60fb      	str	r3, [r7, #12]
   return(result);
 80153fe:	68fb      	ldr	r3, [r7, #12]
 8015400:	f023 0310 	bic.w	r3, r3, #16
 8015404:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8015406:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015408:	681b      	ldr	r3, [r3, #0]
 801540a:	330c      	adds	r3, #12
 801540c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801540e:	61fa      	str	r2, [r7, #28]
 8015410:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015412:	69b9      	ldr	r1, [r7, #24]
 8015414:	69fa      	ldr	r2, [r7, #28]
 8015416:	e841 2300 	strex	r3, r2, [r1]
 801541a:	617b      	str	r3, [r7, #20]
   return(result);
 801541c:	697b      	ldr	r3, [r7, #20]
 801541e:	2b00      	cmp	r3, #0
 8015420:	d1e5      	bne.n	80153ee <UART_DMAReceiveCplt+0xce>
    }
  }

  /* Initialize type of RxEvent that correspond to RxEvent callback execution;
   In this case, Rx Event type is Transfer Complete */
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8015422:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015424:	2200      	movs	r2, #0
 8015426:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8015428:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801542a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801542c:	2b01      	cmp	r3, #1
 801542e:	d106      	bne.n	801543e <UART_DMAReceiveCplt+0x11e>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8015430:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015432:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 8015434:	4619      	mov	r1, r3
 8015436:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8015438:	f7ff ff66 	bl	8015308 <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx complete callback*/
    HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 801543c:	e002      	b.n	8015444 <UART_DMAReceiveCplt+0x124>
    HAL_UART_RxCpltCallback(huart);
 801543e:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8015440:	f7ff ff44 	bl	80152cc <HAL_UART_RxCpltCallback>
}
 8015444:	bf00      	nop
 8015446:	3770      	adds	r7, #112	@ 0x70
 8015448:	46bd      	mov	sp, r7
 801544a:	bd80      	pop	{r7, pc}

0801544c <UART_DMARxHalfCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 801544c:	b580      	push	{r7, lr}
 801544e:	b084      	sub	sp, #16
 8015450:	af00      	add	r7, sp, #0
 8015452:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8015454:	687b      	ldr	r3, [r7, #4]
 8015456:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8015458:	60fb      	str	r3, [r7, #12]

  /* Initialize type of RxEvent that correspond to RxEvent callback execution;
     In this case, Rx Event type is Half Transfer */
  huart->RxEventType = HAL_UART_RXEVENT_HT;
 801545a:	68fb      	ldr	r3, [r7, #12]
 801545c:	2201      	movs	r2, #1
 801545e:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8015460:	68fb      	ldr	r3, [r7, #12]
 8015462:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8015464:	2b01      	cmp	r3, #1
 8015466:	d108      	bne.n	801547a <UART_DMARxHalfCplt+0x2e>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize / 2U);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
 8015468:	68fb      	ldr	r3, [r7, #12]
 801546a:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 801546c:	085b      	lsrs	r3, r3, #1
 801546e:	b29b      	uxth	r3, r3
 8015470:	4619      	mov	r1, r3
 8015472:	68f8      	ldr	r0, [r7, #12]
 8015474:	f7ff ff48 	bl	8015308 <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx Half complete callback*/
    HAL_UART_RxHalfCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 8015478:	e002      	b.n	8015480 <UART_DMARxHalfCplt+0x34>
    HAL_UART_RxHalfCpltCallback(huart);
 801547a:	68f8      	ldr	r0, [r7, #12]
 801547c:	f7ff ff30 	bl	80152e0 <HAL_UART_RxHalfCpltCallback>
}
 8015480:	bf00      	nop
 8015482:	3710      	adds	r7, #16
 8015484:	46bd      	mov	sp, r7
 8015486:	bd80      	pop	{r7, pc}

08015488 <UART_DMAError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 8015488:	b580      	push	{r7, lr}
 801548a:	b084      	sub	sp, #16
 801548c:	af00      	add	r7, sp, #0
 801548e:	6078      	str	r0, [r7, #4]
  uint32_t dmarequest = 0x00U;
 8015490:	2300      	movs	r3, #0
 8015492:	60fb      	str	r3, [r7, #12]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8015494:	687b      	ldr	r3, [r7, #4]
 8015496:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8015498:	60bb      	str	r3, [r7, #8]

  /* Stop UART DMA Tx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 801549a:	68bb      	ldr	r3, [r7, #8]
 801549c:	681b      	ldr	r3, [r3, #0]
 801549e:	695b      	ldr	r3, [r3, #20]
 80154a0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80154a4:	2b80      	cmp	r3, #128	@ 0x80
 80154a6:	bf0c      	ite	eq
 80154a8:	2301      	moveq	r3, #1
 80154aa:	2300      	movne	r3, #0
 80154ac:	b2db      	uxtb	r3, r3
 80154ae:	60fb      	str	r3, [r7, #12]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 80154b0:	68bb      	ldr	r3, [r7, #8]
 80154b2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80154b6:	b2db      	uxtb	r3, r3
 80154b8:	2b21      	cmp	r3, #33	@ 0x21
 80154ba:	d108      	bne.n	80154ce <UART_DMAError+0x46>
 80154bc:	68fb      	ldr	r3, [r7, #12]
 80154be:	2b00      	cmp	r3, #0
 80154c0:	d005      	beq.n	80154ce <UART_DMAError+0x46>
  {
    huart->TxXferCount = 0x00U;
 80154c2:	68bb      	ldr	r3, [r7, #8]
 80154c4:	2200      	movs	r2, #0
 80154c6:	84da      	strh	r2, [r3, #38]	@ 0x26
    UART_EndTxTransfer(huart);
 80154c8:	68b8      	ldr	r0, [r7, #8]
 80154ca:	f000 f91b 	bl	8015704 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 80154ce:	68bb      	ldr	r3, [r7, #8]
 80154d0:	681b      	ldr	r3, [r3, #0]
 80154d2:	695b      	ldr	r3, [r3, #20]
 80154d4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80154d8:	2b40      	cmp	r3, #64	@ 0x40
 80154da:	bf0c      	ite	eq
 80154dc:	2301      	moveq	r3, #1
 80154de:	2300      	movne	r3, #0
 80154e0:	b2db      	uxtb	r3, r3
 80154e2:	60fb      	str	r3, [r7, #12]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 80154e4:	68bb      	ldr	r3, [r7, #8]
 80154e6:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 80154ea:	b2db      	uxtb	r3, r3
 80154ec:	2b22      	cmp	r3, #34	@ 0x22
 80154ee:	d108      	bne.n	8015502 <UART_DMAError+0x7a>
 80154f0:	68fb      	ldr	r3, [r7, #12]
 80154f2:	2b00      	cmp	r3, #0
 80154f4:	d005      	beq.n	8015502 <UART_DMAError+0x7a>
  {
    huart->RxXferCount = 0x00U;
 80154f6:	68bb      	ldr	r3, [r7, #8]
 80154f8:	2200      	movs	r2, #0
 80154fa:	85da      	strh	r2, [r3, #46]	@ 0x2e
    UART_EndRxTransfer(huart);
 80154fc:	68b8      	ldr	r0, [r7, #8]
 80154fe:	f000 f929 	bl	8015754 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8015502:	68bb      	ldr	r3, [r7, #8]
 8015504:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8015506:	f043 0210 	orr.w	r2, r3, #16
 801550a:	68bb      	ldr	r3, [r7, #8]
 801550c:	645a      	str	r2, [r3, #68]	@ 0x44
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 801550e:	68b8      	ldr	r0, [r7, #8]
 8015510:	f7ff fef0 	bl	80152f4 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8015514:	bf00      	nop
 8015516:	3710      	adds	r7, #16
 8015518:	46bd      	mov	sp, r7
 801551a:	bd80      	pop	{r7, pc}

0801551c <UART_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                                     uint32_t Tickstart, uint32_t Timeout)
{
 801551c:	b580      	push	{r7, lr}
 801551e:	b086      	sub	sp, #24
 8015520:	af00      	add	r7, sp, #0
 8015522:	60f8      	str	r0, [r7, #12]
 8015524:	60b9      	str	r1, [r7, #8]
 8015526:	603b      	str	r3, [r7, #0]
 8015528:	4613      	mov	r3, r2
 801552a:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 801552c:	e03b      	b.n	80155a6 <UART_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 801552e:	6a3b      	ldr	r3, [r7, #32]
 8015530:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
 8015534:	d037      	beq.n	80155a6 <UART_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8015536:	f7f9 fee1 	bl	800f2fc <HAL_GetTick>
 801553a:	4602      	mov	r2, r0
 801553c:	683b      	ldr	r3, [r7, #0]
 801553e:	1ad3      	subs	r3, r2, r3
 8015540:	6a3a      	ldr	r2, [r7, #32]
 8015542:	429a      	cmp	r2, r3
 8015544:	d302      	bcc.n	801554c <UART_WaitOnFlagUntilTimeout+0x30>
 8015546:	6a3b      	ldr	r3, [r7, #32]
 8015548:	2b00      	cmp	r3, #0
 801554a:	d101      	bne.n	8015550 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 801554c:	2303      	movs	r3, #3
 801554e:	e03a      	b.n	80155c6 <UART_WaitOnFlagUntilTimeout+0xaa>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8015550:	68fb      	ldr	r3, [r7, #12]
 8015552:	681b      	ldr	r3, [r3, #0]
 8015554:	68db      	ldr	r3, [r3, #12]
 8015556:	f003 0304 	and.w	r3, r3, #4
 801555a:	2b00      	cmp	r3, #0
 801555c:	d023      	beq.n	80155a6 <UART_WaitOnFlagUntilTimeout+0x8a>
 801555e:	68bb      	ldr	r3, [r7, #8]
 8015560:	2b80      	cmp	r3, #128	@ 0x80
 8015562:	d020      	beq.n	80155a6 <UART_WaitOnFlagUntilTimeout+0x8a>
 8015564:	68bb      	ldr	r3, [r7, #8]
 8015566:	2b40      	cmp	r3, #64	@ 0x40
 8015568:	d01d      	beq.n	80155a6 <UART_WaitOnFlagUntilTimeout+0x8a>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 801556a:	68fb      	ldr	r3, [r7, #12]
 801556c:	681b      	ldr	r3, [r3, #0]
 801556e:	681b      	ldr	r3, [r3, #0]
 8015570:	f003 0308 	and.w	r3, r3, #8
 8015574:	2b08      	cmp	r3, #8
 8015576:	d116      	bne.n	80155a6 <UART_WaitOnFlagUntilTimeout+0x8a>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_OREFLAG(huart);
 8015578:	2300      	movs	r3, #0
 801557a:	617b      	str	r3, [r7, #20]
 801557c:	68fb      	ldr	r3, [r7, #12]
 801557e:	681b      	ldr	r3, [r3, #0]
 8015580:	681b      	ldr	r3, [r3, #0]
 8015582:	617b      	str	r3, [r7, #20]
 8015584:	68fb      	ldr	r3, [r7, #12]
 8015586:	681b      	ldr	r3, [r3, #0]
 8015588:	685b      	ldr	r3, [r3, #4]
 801558a:	617b      	str	r3, [r7, #20]
 801558c:	697b      	ldr	r3, [r7, #20]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 801558e:	68f8      	ldr	r0, [r7, #12]
 8015590:	f000 f8e0 	bl	8015754 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8015594:	68fb      	ldr	r3, [r7, #12]
 8015596:	2208      	movs	r2, #8
 8015598:	645a      	str	r2, [r3, #68]	@ 0x44

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 801559a:	68fb      	ldr	r3, [r7, #12]
 801559c:	2200      	movs	r2, #0
 801559e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
 80155a2:	2301      	movs	r3, #1
 80155a4:	e00f      	b.n	80155c6 <UART_WaitOnFlagUntilTimeout+0xaa>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80155a6:	68fb      	ldr	r3, [r7, #12]
 80155a8:	681b      	ldr	r3, [r3, #0]
 80155aa:	681a      	ldr	r2, [r3, #0]
 80155ac:	68bb      	ldr	r3, [r7, #8]
 80155ae:	4013      	ands	r3, r2
 80155b0:	68ba      	ldr	r2, [r7, #8]
 80155b2:	429a      	cmp	r2, r3
 80155b4:	bf0c      	ite	eq
 80155b6:	2301      	moveq	r3, #1
 80155b8:	2300      	movne	r3, #0
 80155ba:	b2db      	uxtb	r3, r3
 80155bc:	461a      	mov	r2, r3
 80155be:	79fb      	ldrb	r3, [r7, #7]
 80155c0:	429a      	cmp	r2, r3
 80155c2:	d0b4      	beq.n	801552e <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 80155c4:	2300      	movs	r3, #0
}
 80155c6:	4618      	mov	r0, r3
 80155c8:	3718      	adds	r7, #24
 80155ca:	46bd      	mov	sp, r7
 80155cc:	bd80      	pop	{r7, pc}
	...

080155d0 <UART_Start_Receive_DMA>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80155d0:	b580      	push	{r7, lr}
 80155d2:	b098      	sub	sp, #96	@ 0x60
 80155d4:	af00      	add	r7, sp, #0
 80155d6:	60f8      	str	r0, [r7, #12]
 80155d8:	60b9      	str	r1, [r7, #8]
 80155da:	4613      	mov	r3, r2
 80155dc:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;

  huart->pRxBuffPtr = pData;
 80155de:	68ba      	ldr	r2, [r7, #8]
 80155e0:	68fb      	ldr	r3, [r7, #12]
 80155e2:	629a      	str	r2, [r3, #40]	@ 0x28
  huart->RxXferSize = Size;
 80155e4:	68fb      	ldr	r3, [r7, #12]
 80155e6:	88fa      	ldrh	r2, [r7, #6]
 80155e8:	859a      	strh	r2, [r3, #44]	@ 0x2c

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80155ea:	68fb      	ldr	r3, [r7, #12]
 80155ec:	2200      	movs	r2, #0
 80155ee:	645a      	str	r2, [r3, #68]	@ 0x44
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 80155f0:	68fb      	ldr	r3, [r7, #12]
 80155f2:	2222      	movs	r2, #34	@ 0x22
 80155f4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* Set the UART DMA transfer complete callback */
  huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 80155f8:	68fb      	ldr	r3, [r7, #12]
 80155fa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80155fc:	4a3e      	ldr	r2, [pc, #248]	@ (80156f8 <UART_Start_Receive_DMA+0x128>)
 80155fe:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Set the UART DMA Half transfer complete callback */
  huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8015600:	68fb      	ldr	r3, [r7, #12]
 8015602:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8015604:	4a3d      	ldr	r2, [pc, #244]	@ (80156fc <UART_Start_Receive_DMA+0x12c>)
 8015606:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Set the DMA error callback */
  huart->hdmarx->XferErrorCallback = UART_DMAError;
 8015608:	68fb      	ldr	r3, [r7, #12]
 801560a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801560c:	4a3c      	ldr	r2, [pc, #240]	@ (8015700 <UART_Start_Receive_DMA+0x130>)
 801560e:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Set the DMA abort callback */
  huart->hdmarx->XferAbortCallback = NULL;
 8015610:	68fb      	ldr	r3, [r7, #12]
 8015612:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8015614:	2200      	movs	r2, #0
 8015616:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Enable the DMA stream */
  tmp = (uint32_t *)&pData;
 8015618:	f107 0308 	add.w	r3, r7, #8
 801561c:	65fb      	str	r3, [r7, #92]	@ 0x5c
  HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
 801561e:	68fb      	ldr	r3, [r7, #12]
 8015620:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8015622:	68fb      	ldr	r3, [r7, #12]
 8015624:	681b      	ldr	r3, [r3, #0]
 8015626:	3304      	adds	r3, #4
 8015628:	4619      	mov	r1, r3
 801562a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801562c:	681a      	ldr	r2, [r3, #0]
 801562e:	88fb      	ldrh	r3, [r7, #6]
 8015630:	f7f9 fff3 	bl	800f61a <HAL_DMA_Start_IT>

  /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
  __HAL_UART_CLEAR_OREFLAG(huart);
 8015634:	2300      	movs	r3, #0
 8015636:	613b      	str	r3, [r7, #16]
 8015638:	68fb      	ldr	r3, [r7, #12]
 801563a:	681b      	ldr	r3, [r3, #0]
 801563c:	681b      	ldr	r3, [r3, #0]
 801563e:	613b      	str	r3, [r7, #16]
 8015640:	68fb      	ldr	r3, [r7, #12]
 8015642:	681b      	ldr	r3, [r3, #0]
 8015644:	685b      	ldr	r3, [r3, #4]
 8015646:	613b      	str	r3, [r7, #16]
 8015648:	693b      	ldr	r3, [r7, #16]

  if (huart->Init.Parity != UART_PARITY_NONE)
 801564a:	68fb      	ldr	r3, [r7, #12]
 801564c:	691b      	ldr	r3, [r3, #16]
 801564e:	2b00      	cmp	r3, #0
 8015650:	d019      	beq.n	8015686 <UART_Start_Receive_DMA+0xb6>
  {
    /* Enable the UART Parity Error Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8015652:	68fb      	ldr	r3, [r7, #12]
 8015654:	681b      	ldr	r3, [r3, #0]
 8015656:	330c      	adds	r3, #12
 8015658:	643b      	str	r3, [r7, #64]	@ 0x40
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801565a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801565c:	e853 3f00 	ldrex	r3, [r3]
 8015660:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 8015662:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8015664:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8015668:	65bb      	str	r3, [r7, #88]	@ 0x58
 801566a:	68fb      	ldr	r3, [r7, #12]
 801566c:	681b      	ldr	r3, [r3, #0]
 801566e:	330c      	adds	r3, #12
 8015670:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015672:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8015674:	64bb      	str	r3, [r7, #72]	@ 0x48
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015676:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8015678:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801567a:	e841 2300 	strex	r3, r2, [r1]
 801567e:	647b      	str	r3, [r7, #68]	@ 0x44
   return(result);
 8015680:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015682:	2b00      	cmp	r3, #0
 8015684:	d1e5      	bne.n	8015652 <UART_Start_Receive_DMA+0x82>
  }

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8015686:	68fb      	ldr	r3, [r7, #12]
 8015688:	681b      	ldr	r3, [r3, #0]
 801568a:	3314      	adds	r3, #20
 801568c:	62fb      	str	r3, [r7, #44]	@ 0x2c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801568e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015690:	e853 3f00 	ldrex	r3, [r3]
 8015694:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 8015696:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8015698:	f043 0301 	orr.w	r3, r3, #1
 801569c:	657b      	str	r3, [r7, #84]	@ 0x54
 801569e:	68fb      	ldr	r3, [r7, #12]
 80156a0:	681b      	ldr	r3, [r3, #0]
 80156a2:	3314      	adds	r3, #20
 80156a4:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 80156a6:	63ba      	str	r2, [r7, #56]	@ 0x38
 80156a8:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80156aa:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80156ac:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80156ae:	e841 2300 	strex	r3, r2, [r1]
 80156b2:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 80156b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80156b6:	2b00      	cmp	r3, #0
 80156b8:	d1e5      	bne.n	8015686 <UART_Start_Receive_DMA+0xb6>

  /* Enable the DMA transfer for the receiver request by setting the DMAR bit
  in the UART CR3 register */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80156ba:	68fb      	ldr	r3, [r7, #12]
 80156bc:	681b      	ldr	r3, [r3, #0]
 80156be:	3314      	adds	r3, #20
 80156c0:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80156c2:	69bb      	ldr	r3, [r7, #24]
 80156c4:	e853 3f00 	ldrex	r3, [r3]
 80156c8:	617b      	str	r3, [r7, #20]
   return(result);
 80156ca:	697b      	ldr	r3, [r7, #20]
 80156cc:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 80156d0:	653b      	str	r3, [r7, #80]	@ 0x50
 80156d2:	68fb      	ldr	r3, [r7, #12]
 80156d4:	681b      	ldr	r3, [r3, #0]
 80156d6:	3314      	adds	r3, #20
 80156d8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80156da:	627a      	str	r2, [r7, #36]	@ 0x24
 80156dc:	623b      	str	r3, [r7, #32]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80156de:	6a39      	ldr	r1, [r7, #32]
 80156e0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80156e2:	e841 2300 	strex	r3, r2, [r1]
 80156e6:	61fb      	str	r3, [r7, #28]
   return(result);
 80156e8:	69fb      	ldr	r3, [r7, #28]
 80156ea:	2b00      	cmp	r3, #0
 80156ec:	d1e5      	bne.n	80156ba <UART_Start_Receive_DMA+0xea>

  return HAL_OK;
 80156ee:	2300      	movs	r3, #0
}
 80156f0:	4618      	mov	r0, r3
 80156f2:	3760      	adds	r7, #96	@ 0x60
 80156f4:	46bd      	mov	sp, r7
 80156f6:	bd80      	pop	{r7, pc}
 80156f8:	08015321 	.word	0x08015321
 80156fc:	0801544d 	.word	0x0801544d
 8015700:	08015489 	.word	0x08015489

08015704 <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 8015704:	b480      	push	{r7}
 8015706:	b089      	sub	sp, #36	@ 0x24
 8015708:	af00      	add	r7, sp, #0
 801570a:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE and TCIE interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 801570c:	687b      	ldr	r3, [r7, #4]
 801570e:	681b      	ldr	r3, [r3, #0]
 8015710:	330c      	adds	r3, #12
 8015712:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015714:	68fb      	ldr	r3, [r7, #12]
 8015716:	e853 3f00 	ldrex	r3, [r3]
 801571a:	60bb      	str	r3, [r7, #8]
   return(result);
 801571c:	68bb      	ldr	r3, [r7, #8]
 801571e:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 8015722:	61fb      	str	r3, [r7, #28]
 8015724:	687b      	ldr	r3, [r7, #4]
 8015726:	681b      	ldr	r3, [r3, #0]
 8015728:	330c      	adds	r3, #12
 801572a:	69fa      	ldr	r2, [r7, #28]
 801572c:	61ba      	str	r2, [r7, #24]
 801572e:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015730:	6979      	ldr	r1, [r7, #20]
 8015732:	69ba      	ldr	r2, [r7, #24]
 8015734:	e841 2300 	strex	r3, r2, [r1]
 8015738:	613b      	str	r3, [r7, #16]
   return(result);
 801573a:	693b      	ldr	r3, [r7, #16]
 801573c:	2b00      	cmp	r3, #0
 801573e:	d1e5      	bne.n	801570c <UART_EndTxTransfer+0x8>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8015740:	687b      	ldr	r3, [r7, #4]
 8015742:	2220      	movs	r2, #32
 8015744:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
}
 8015748:	bf00      	nop
 801574a:	3724      	adds	r7, #36	@ 0x24
 801574c:	46bd      	mov	sp, r7
 801574e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015752:	4770      	bx	lr

08015754 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8015754:	b480      	push	{r7}
 8015756:	b095      	sub	sp, #84	@ 0x54
 8015758:	af00      	add	r7, sp, #0
 801575a:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 801575c:	687b      	ldr	r3, [r7, #4]
 801575e:	681b      	ldr	r3, [r3, #0]
 8015760:	330c      	adds	r3, #12
 8015762:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015764:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8015766:	e853 3f00 	ldrex	r3, [r3]
 801576a:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 801576c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801576e:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 8015772:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8015774:	687b      	ldr	r3, [r7, #4]
 8015776:	681b      	ldr	r3, [r3, #0]
 8015778:	330c      	adds	r3, #12
 801577a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801577c:	643a      	str	r2, [r7, #64]	@ 0x40
 801577e:	63fb      	str	r3, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8015780:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8015782:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8015784:	e841 2300 	strex	r3, r2, [r1]
 8015788:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
 801578a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801578c:	2b00      	cmp	r3, #0
 801578e:	d1e5      	bne.n	801575c <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8015790:	687b      	ldr	r3, [r7, #4]
 8015792:	681b      	ldr	r3, [r3, #0]
 8015794:	3314      	adds	r3, #20
 8015796:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8015798:	6a3b      	ldr	r3, [r7, #32]
 801579a:	e853 3f00 	ldrex	r3, [r3]
 801579e:	61fb      	str	r3, [r7, #28]
   return(result);
 80157a0:	69fb      	ldr	r3, [r7, #28]
 80157a2:	f023 0301 	bic.w	r3, r3, #1
 80157a6:	64bb      	str	r3, [r7, #72]	@ 0x48
 80157a8:	687b      	ldr	r3, [r7, #4]
 80157aa:	681b      	ldr	r3, [r3, #0]
 80157ac:	3314      	adds	r3, #20
 80157ae:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80157b0:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80157b2:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80157b4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80157b6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80157b8:	e841 2300 	strex	r3, r2, [r1]
 80157bc:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 80157be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80157c0:	2b00      	cmp	r3, #0
 80157c2:	d1e5      	bne.n	8015790 <UART_EndRxTransfer+0x3c>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80157c4:	687b      	ldr	r3, [r7, #4]
 80157c6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80157c8:	2b01      	cmp	r3, #1
 80157ca:	d119      	bne.n	8015800 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80157cc:	687b      	ldr	r3, [r7, #4]
 80157ce:	681b      	ldr	r3, [r3, #0]
 80157d0:	330c      	adds	r3, #12
 80157d2:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80157d4:	68fb      	ldr	r3, [r7, #12]
 80157d6:	e853 3f00 	ldrex	r3, [r3]
 80157da:	60bb      	str	r3, [r7, #8]
   return(result);
 80157dc:	68bb      	ldr	r3, [r7, #8]
 80157de:	f023 0310 	bic.w	r3, r3, #16
 80157e2:	647b      	str	r3, [r7, #68]	@ 0x44
 80157e4:	687b      	ldr	r3, [r7, #4]
 80157e6:	681b      	ldr	r3, [r3, #0]
 80157e8:	330c      	adds	r3, #12
 80157ea:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80157ec:	61ba      	str	r2, [r7, #24]
 80157ee:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80157f0:	6979      	ldr	r1, [r7, #20]
 80157f2:	69ba      	ldr	r2, [r7, #24]
 80157f4:	e841 2300 	strex	r3, r2, [r1]
 80157f8:	613b      	str	r3, [r7, #16]
   return(result);
 80157fa:	693b      	ldr	r3, [r7, #16]
 80157fc:	2b00      	cmp	r3, #0
 80157fe:	d1e5      	bne.n	80157cc <UART_EndRxTransfer+0x78>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8015800:	687b      	ldr	r3, [r7, #4]
 8015802:	2220      	movs	r2, #32
 8015804:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8015808:	687b      	ldr	r3, [r7, #4]
 801580a:	2200      	movs	r2, #0
 801580c:	631a      	str	r2, [r3, #48]	@ 0x30
}
 801580e:	bf00      	nop
 8015810:	3754      	adds	r7, #84	@ 0x54
 8015812:	46bd      	mov	sp, r7
 8015814:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015818:	4770      	bx	lr
	...

0801581c <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 801581c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8015820:	b0c0      	sub	sp, #256	@ 0x100
 8015822:	af00      	add	r7, sp, #0
 8015824:	f8c7 00f4 	str.w	r0, [r7, #244]	@ 0xf4
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8015828:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801582c:	681b      	ldr	r3, [r3, #0]
 801582e:	691b      	ldr	r3, [r3, #16]
 8015830:	f423 5040 	bic.w	r0, r3, #12288	@ 0x3000
 8015834:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015838:	68d9      	ldr	r1, [r3, #12]
 801583a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801583e:	681a      	ldr	r2, [r3, #0]
 8015840:	ea40 0301 	orr.w	r3, r0, r1
 8015844:	6113      	str	r3, [r2, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 8015846:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801584a:	689a      	ldr	r2, [r3, #8]
 801584c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015850:	691b      	ldr	r3, [r3, #16]
 8015852:	431a      	orrs	r2, r3
 8015854:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015858:	695b      	ldr	r3, [r3, #20]
 801585a:	431a      	orrs	r2, r3
 801585c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015860:	69db      	ldr	r3, [r3, #28]
 8015862:	4313      	orrs	r3, r2
 8015864:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
  MODIFY_REG(huart->Instance->CR1,
 8015868:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801586c:	681b      	ldr	r3, [r3, #0]
 801586e:	68db      	ldr	r3, [r3, #12]
 8015870:	f423 4116 	bic.w	r1, r3, #38400	@ 0x9600
 8015874:	f021 010c 	bic.w	r1, r1, #12
 8015878:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801587c:	681a      	ldr	r2, [r3, #0]
 801587e:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8015882:	430b      	orrs	r3, r1
 8015884:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8015886:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801588a:	681b      	ldr	r3, [r3, #0]
 801588c:	695b      	ldr	r3, [r3, #20]
 801588e:	f423 7040 	bic.w	r0, r3, #768	@ 0x300
 8015892:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015896:	6999      	ldr	r1, [r3, #24]
 8015898:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801589c:	681a      	ldr	r2, [r3, #0]
 801589e:	ea40 0301 	orr.w	r3, r0, r1
 80158a2:	6153      	str	r3, [r2, #20]
    if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
    {
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 80158a4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80158a8:	681a      	ldr	r2, [r3, #0]
 80158aa:	4b8f      	ldr	r3, [pc, #572]	@ (8015ae8 <UART_SetConfig+0x2cc>)
 80158ac:	429a      	cmp	r2, r3
 80158ae:	d005      	beq.n	80158bc <UART_SetConfig+0xa0>
 80158b0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80158b4:	681a      	ldr	r2, [r3, #0]
 80158b6:	4b8d      	ldr	r3, [pc, #564]	@ (8015aec <UART_SetConfig+0x2d0>)
 80158b8:	429a      	cmp	r2, r3
 80158ba:	d104      	bne.n	80158c6 <UART_SetConfig+0xaa>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 80158bc:	f7fe f8be 	bl	8013a3c <HAL_RCC_GetPCLK2Freq>
 80158c0:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
 80158c4:	e003      	b.n	80158ce <UART_SetConfig+0xb2>
      pclk = HAL_RCC_GetPCLK2Freq();
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
 80158c6:	f7fe f8a5 	bl	8013a14 <HAL_RCC_GetPCLK1Freq>
 80158ca:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
    }
  /*-------------------------- USART BRR Configuration ---------------------*/
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80158ce:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80158d2:	69db      	ldr	r3, [r3, #28]
 80158d4:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80158d8:	f040 810c 	bne.w	8015af4 <UART_SetConfig+0x2d8>
  {
    huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 80158dc:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80158e0:	2200      	movs	r2, #0
 80158e2:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 80158e6:	f8c7 20ec 	str.w	r2, [r7, #236]	@ 0xec
 80158ea:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	@ 0xe8
 80158ee:	4622      	mov	r2, r4
 80158f0:	462b      	mov	r3, r5
 80158f2:	1891      	adds	r1, r2, r2
 80158f4:	65b9      	str	r1, [r7, #88]	@ 0x58
 80158f6:	415b      	adcs	r3, r3
 80158f8:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80158fa:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	@ 0x58
 80158fe:	4621      	mov	r1, r4
 8015900:	eb12 0801 	adds.w	r8, r2, r1
 8015904:	4629      	mov	r1, r5
 8015906:	eb43 0901 	adc.w	r9, r3, r1
 801590a:	f04f 0200 	mov.w	r2, #0
 801590e:	f04f 0300 	mov.w	r3, #0
 8015912:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8015916:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 801591a:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 801591e:	4690      	mov	r8, r2
 8015920:	4699      	mov	r9, r3
 8015922:	4623      	mov	r3, r4
 8015924:	eb18 0303 	adds.w	r3, r8, r3
 8015928:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 801592c:	462b      	mov	r3, r5
 801592e:	eb49 0303 	adc.w	r3, r9, r3
 8015932:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8015936:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801593a:	685b      	ldr	r3, [r3, #4]
 801593c:	2200      	movs	r2, #0
 801593e:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 8015942:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
 8015946:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	@ 0xd8
 801594a:	460b      	mov	r3, r1
 801594c:	18db      	adds	r3, r3, r3
 801594e:	653b      	str	r3, [r7, #80]	@ 0x50
 8015950:	4613      	mov	r3, r2
 8015952:	eb42 0303 	adc.w	r3, r2, r3
 8015956:	657b      	str	r3, [r7, #84]	@ 0x54
 8015958:	e9d7 2314 	ldrd	r2, r3, [r7, #80]	@ 0x50
 801595c:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
 8015960:	f7eb f99a 	bl	8000c98 <__aeabi_uldivmod>
 8015964:	4602      	mov	r2, r0
 8015966:	460b      	mov	r3, r1
 8015968:	4b61      	ldr	r3, [pc, #388]	@ (8015af0 <UART_SetConfig+0x2d4>)
 801596a:	fba3 2302 	umull	r2, r3, r3, r2
 801596e:	095b      	lsrs	r3, r3, #5
 8015970:	011c      	lsls	r4, r3, #4
 8015972:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8015976:	2200      	movs	r2, #0
 8015978:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 801597c:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
 8015980:	e9d7 8934 	ldrd	r8, r9, [r7, #208]	@ 0xd0
 8015984:	4642      	mov	r2, r8
 8015986:	464b      	mov	r3, r9
 8015988:	1891      	adds	r1, r2, r2
 801598a:	64b9      	str	r1, [r7, #72]	@ 0x48
 801598c:	415b      	adcs	r3, r3
 801598e:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8015990:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	@ 0x48
 8015994:	4641      	mov	r1, r8
 8015996:	eb12 0a01 	adds.w	sl, r2, r1
 801599a:	4649      	mov	r1, r9
 801599c:	eb43 0b01 	adc.w	fp, r3, r1
 80159a0:	f04f 0200 	mov.w	r2, #0
 80159a4:	f04f 0300 	mov.w	r3, #0
 80159a8:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80159ac:	ea43 735a 	orr.w	r3, r3, sl, lsr #29
 80159b0:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80159b4:	4692      	mov	sl, r2
 80159b6:	469b      	mov	fp, r3
 80159b8:	4643      	mov	r3, r8
 80159ba:	eb1a 0303 	adds.w	r3, sl, r3
 80159be:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 80159c2:	464b      	mov	r3, r9
 80159c4:	eb4b 0303 	adc.w	r3, fp, r3
 80159c8:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 80159cc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 80159d0:	685b      	ldr	r3, [r3, #4]
 80159d2:	2200      	movs	r2, #0
 80159d4:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80159d8:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
 80159dc:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 80159e0:	460b      	mov	r3, r1
 80159e2:	18db      	adds	r3, r3, r3
 80159e4:	643b      	str	r3, [r7, #64]	@ 0x40
 80159e6:	4613      	mov	r3, r2
 80159e8:	eb42 0303 	adc.w	r3, r2, r3
 80159ec:	647b      	str	r3, [r7, #68]	@ 0x44
 80159ee:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
 80159f2:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
 80159f6:	f7eb f94f 	bl	8000c98 <__aeabi_uldivmod>
 80159fa:	4602      	mov	r2, r0
 80159fc:	460b      	mov	r3, r1
 80159fe:	4611      	mov	r1, r2
 8015a00:	4b3b      	ldr	r3, [pc, #236]	@ (8015af0 <UART_SetConfig+0x2d4>)
 8015a02:	fba3 2301 	umull	r2, r3, r3, r1
 8015a06:	095b      	lsrs	r3, r3, #5
 8015a08:	2264      	movs	r2, #100	@ 0x64
 8015a0a:	fb02 f303 	mul.w	r3, r2, r3
 8015a0e:	1acb      	subs	r3, r1, r3
 8015a10:	00db      	lsls	r3, r3, #3
 8015a12:	f103 0232 	add.w	r2, r3, #50	@ 0x32
 8015a16:	4b36      	ldr	r3, [pc, #216]	@ (8015af0 <UART_SetConfig+0x2d4>)
 8015a18:	fba3 2302 	umull	r2, r3, r3, r2
 8015a1c:	095b      	lsrs	r3, r3, #5
 8015a1e:	005b      	lsls	r3, r3, #1
 8015a20:	f403 73f8 	and.w	r3, r3, #496	@ 0x1f0
 8015a24:	441c      	add	r4, r3
 8015a26:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8015a2a:	2200      	movs	r2, #0
 8015a2c:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8015a30:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
 8015a34:	e9d7 892e 	ldrd	r8, r9, [r7, #184]	@ 0xb8
 8015a38:	4642      	mov	r2, r8
 8015a3a:	464b      	mov	r3, r9
 8015a3c:	1891      	adds	r1, r2, r2
 8015a3e:	63b9      	str	r1, [r7, #56]	@ 0x38
 8015a40:	415b      	adcs	r3, r3
 8015a42:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8015a44:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
 8015a48:	4641      	mov	r1, r8
 8015a4a:	1851      	adds	r1, r2, r1
 8015a4c:	6339      	str	r1, [r7, #48]	@ 0x30
 8015a4e:	4649      	mov	r1, r9
 8015a50:	414b      	adcs	r3, r1
 8015a52:	637b      	str	r3, [r7, #52]	@ 0x34
 8015a54:	f04f 0200 	mov.w	r2, #0
 8015a58:	f04f 0300 	mov.w	r3, #0
 8015a5c:	e9d7 ab0c 	ldrd	sl, fp, [r7, #48]	@ 0x30
 8015a60:	4659      	mov	r1, fp
 8015a62:	00cb      	lsls	r3, r1, #3
 8015a64:	4651      	mov	r1, sl
 8015a66:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8015a6a:	4651      	mov	r1, sl
 8015a6c:	00ca      	lsls	r2, r1, #3
 8015a6e:	4610      	mov	r0, r2
 8015a70:	4619      	mov	r1, r3
 8015a72:	4603      	mov	r3, r0
 8015a74:	4642      	mov	r2, r8
 8015a76:	189b      	adds	r3, r3, r2
 8015a78:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 8015a7c:	464b      	mov	r3, r9
 8015a7e:	460a      	mov	r2, r1
 8015a80:	eb42 0303 	adc.w	r3, r2, r3
 8015a84:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8015a88:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015a8c:	685b      	ldr	r3, [r3, #4]
 8015a8e:	2200      	movs	r2, #0
 8015a90:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 8015a94:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
 8015a98:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 8015a9c:	460b      	mov	r3, r1
 8015a9e:	18db      	adds	r3, r3, r3
 8015aa0:	62bb      	str	r3, [r7, #40]	@ 0x28
 8015aa2:	4613      	mov	r3, r2
 8015aa4:	eb42 0303 	adc.w	r3, r2, r3
 8015aa8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8015aaa:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	@ 0x28
 8015aae:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
 8015ab2:	f7eb f8f1 	bl	8000c98 <__aeabi_uldivmod>
 8015ab6:	4602      	mov	r2, r0
 8015ab8:	460b      	mov	r3, r1
 8015aba:	4b0d      	ldr	r3, [pc, #52]	@ (8015af0 <UART_SetConfig+0x2d4>)
 8015abc:	fba3 1302 	umull	r1, r3, r3, r2
 8015ac0:	095b      	lsrs	r3, r3, #5
 8015ac2:	2164      	movs	r1, #100	@ 0x64
 8015ac4:	fb01 f303 	mul.w	r3, r1, r3
 8015ac8:	1ad3      	subs	r3, r2, r3
 8015aca:	00db      	lsls	r3, r3, #3
 8015acc:	3332      	adds	r3, #50	@ 0x32
 8015ace:	4a08      	ldr	r2, [pc, #32]	@ (8015af0 <UART_SetConfig+0x2d4>)
 8015ad0:	fba2 2303 	umull	r2, r3, r2, r3
 8015ad4:	095b      	lsrs	r3, r3, #5
 8015ad6:	f003 0207 	and.w	r2, r3, #7
 8015ada:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015ade:	681b      	ldr	r3, [r3, #0]
 8015ae0:	4422      	add	r2, r4
 8015ae2:	609a      	str	r2, [r3, #8]
  }
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
}
 8015ae4:	e106      	b.n	8015cf4 <UART_SetConfig+0x4d8>
 8015ae6:	bf00      	nop
 8015ae8:	40011000 	.word	0x40011000
 8015aec:	40011400 	.word	0x40011400
 8015af0:	51eb851f 	.word	0x51eb851f
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8015af4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8015af8:	2200      	movs	r2, #0
 8015afa:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8015afe:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8015b02:	e9d7 8928 	ldrd	r8, r9, [r7, #160]	@ 0xa0
 8015b06:	4642      	mov	r2, r8
 8015b08:	464b      	mov	r3, r9
 8015b0a:	1891      	adds	r1, r2, r2
 8015b0c:	6239      	str	r1, [r7, #32]
 8015b0e:	415b      	adcs	r3, r3
 8015b10:	627b      	str	r3, [r7, #36]	@ 0x24
 8015b12:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 8015b16:	4641      	mov	r1, r8
 8015b18:	1854      	adds	r4, r2, r1
 8015b1a:	4649      	mov	r1, r9
 8015b1c:	eb43 0501 	adc.w	r5, r3, r1
 8015b20:	f04f 0200 	mov.w	r2, #0
 8015b24:	f04f 0300 	mov.w	r3, #0
 8015b28:	00eb      	lsls	r3, r5, #3
 8015b2a:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8015b2e:	00e2      	lsls	r2, r4, #3
 8015b30:	4614      	mov	r4, r2
 8015b32:	461d      	mov	r5, r3
 8015b34:	4643      	mov	r3, r8
 8015b36:	18e3      	adds	r3, r4, r3
 8015b38:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 8015b3c:	464b      	mov	r3, r9
 8015b3e:	eb45 0303 	adc.w	r3, r5, r3
 8015b42:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 8015b46:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015b4a:	685b      	ldr	r3, [r3, #4]
 8015b4c:	2200      	movs	r2, #0
 8015b4e:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8015b52:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 8015b56:	f04f 0200 	mov.w	r2, #0
 8015b5a:	f04f 0300 	mov.w	r3, #0
 8015b5e:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	@ 0x90
 8015b62:	4629      	mov	r1, r5
 8015b64:	008b      	lsls	r3, r1, #2
 8015b66:	4621      	mov	r1, r4
 8015b68:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 8015b6c:	4621      	mov	r1, r4
 8015b6e:	008a      	lsls	r2, r1, #2
 8015b70:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
 8015b74:	f7eb f890 	bl	8000c98 <__aeabi_uldivmod>
 8015b78:	4602      	mov	r2, r0
 8015b7a:	460b      	mov	r3, r1
 8015b7c:	4b60      	ldr	r3, [pc, #384]	@ (8015d00 <UART_SetConfig+0x4e4>)
 8015b7e:	fba3 2302 	umull	r2, r3, r3, r2
 8015b82:	095b      	lsrs	r3, r3, #5
 8015b84:	011c      	lsls	r4, r3, #4
 8015b86:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8015b8a:	2200      	movs	r2, #0
 8015b8c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8015b90:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 8015b94:	e9d7 8922 	ldrd	r8, r9, [r7, #136]	@ 0x88
 8015b98:	4642      	mov	r2, r8
 8015b9a:	464b      	mov	r3, r9
 8015b9c:	1891      	adds	r1, r2, r2
 8015b9e:	61b9      	str	r1, [r7, #24]
 8015ba0:	415b      	adcs	r3, r3
 8015ba2:	61fb      	str	r3, [r7, #28]
 8015ba4:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8015ba8:	4641      	mov	r1, r8
 8015baa:	1851      	adds	r1, r2, r1
 8015bac:	6139      	str	r1, [r7, #16]
 8015bae:	4649      	mov	r1, r9
 8015bb0:	414b      	adcs	r3, r1
 8015bb2:	617b      	str	r3, [r7, #20]
 8015bb4:	f04f 0200 	mov.w	r2, #0
 8015bb8:	f04f 0300 	mov.w	r3, #0
 8015bbc:	e9d7 ab04 	ldrd	sl, fp, [r7, #16]
 8015bc0:	4659      	mov	r1, fp
 8015bc2:	00cb      	lsls	r3, r1, #3
 8015bc4:	4651      	mov	r1, sl
 8015bc6:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8015bca:	4651      	mov	r1, sl
 8015bcc:	00ca      	lsls	r2, r1, #3
 8015bce:	4610      	mov	r0, r2
 8015bd0:	4619      	mov	r1, r3
 8015bd2:	4603      	mov	r3, r0
 8015bd4:	4642      	mov	r2, r8
 8015bd6:	189b      	adds	r3, r3, r2
 8015bd8:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8015bdc:	464b      	mov	r3, r9
 8015bde:	460a      	mov	r2, r1
 8015be0:	eb42 0303 	adc.w	r3, r2, r3
 8015be4:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 8015be8:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015bec:	685b      	ldr	r3, [r3, #4]
 8015bee:	2200      	movs	r2, #0
 8015bf0:	67bb      	str	r3, [r7, #120]	@ 0x78
 8015bf2:	67fa      	str	r2, [r7, #124]	@ 0x7c
 8015bf4:	f04f 0200 	mov.w	r2, #0
 8015bf8:	f04f 0300 	mov.w	r3, #0
 8015bfc:	e9d7 891e 	ldrd	r8, r9, [r7, #120]	@ 0x78
 8015c00:	4649      	mov	r1, r9
 8015c02:	008b      	lsls	r3, r1, #2
 8015c04:	4641      	mov	r1, r8
 8015c06:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 8015c0a:	4641      	mov	r1, r8
 8015c0c:	008a      	lsls	r2, r1, #2
 8015c0e:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
 8015c12:	f7eb f841 	bl	8000c98 <__aeabi_uldivmod>
 8015c16:	4602      	mov	r2, r0
 8015c18:	460b      	mov	r3, r1
 8015c1a:	4611      	mov	r1, r2
 8015c1c:	4b38      	ldr	r3, [pc, #224]	@ (8015d00 <UART_SetConfig+0x4e4>)
 8015c1e:	fba3 2301 	umull	r2, r3, r3, r1
 8015c22:	095b      	lsrs	r3, r3, #5
 8015c24:	2264      	movs	r2, #100	@ 0x64
 8015c26:	fb02 f303 	mul.w	r3, r2, r3
 8015c2a:	1acb      	subs	r3, r1, r3
 8015c2c:	011b      	lsls	r3, r3, #4
 8015c2e:	3332      	adds	r3, #50	@ 0x32
 8015c30:	4a33      	ldr	r2, [pc, #204]	@ (8015d00 <UART_SetConfig+0x4e4>)
 8015c32:	fba2 2303 	umull	r2, r3, r2, r3
 8015c36:	095b      	lsrs	r3, r3, #5
 8015c38:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8015c3c:	441c      	add	r4, r3
 8015c3e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 8015c42:	2200      	movs	r2, #0
 8015c44:	673b      	str	r3, [r7, #112]	@ 0x70
 8015c46:	677a      	str	r2, [r7, #116]	@ 0x74
 8015c48:	e9d7 891c 	ldrd	r8, r9, [r7, #112]	@ 0x70
 8015c4c:	4642      	mov	r2, r8
 8015c4e:	464b      	mov	r3, r9
 8015c50:	1891      	adds	r1, r2, r2
 8015c52:	60b9      	str	r1, [r7, #8]
 8015c54:	415b      	adcs	r3, r3
 8015c56:	60fb      	str	r3, [r7, #12]
 8015c58:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8015c5c:	4641      	mov	r1, r8
 8015c5e:	1851      	adds	r1, r2, r1
 8015c60:	6039      	str	r1, [r7, #0]
 8015c62:	4649      	mov	r1, r9
 8015c64:	414b      	adcs	r3, r1
 8015c66:	607b      	str	r3, [r7, #4]
 8015c68:	f04f 0200 	mov.w	r2, #0
 8015c6c:	f04f 0300 	mov.w	r3, #0
 8015c70:	e9d7 ab00 	ldrd	sl, fp, [r7]
 8015c74:	4659      	mov	r1, fp
 8015c76:	00cb      	lsls	r3, r1, #3
 8015c78:	4651      	mov	r1, sl
 8015c7a:	ea43 7351 	orr.w	r3, r3, r1, lsr #29
 8015c7e:	4651      	mov	r1, sl
 8015c80:	00ca      	lsls	r2, r1, #3
 8015c82:	4610      	mov	r0, r2
 8015c84:	4619      	mov	r1, r3
 8015c86:	4603      	mov	r3, r0
 8015c88:	4642      	mov	r2, r8
 8015c8a:	189b      	adds	r3, r3, r2
 8015c8c:	66bb      	str	r3, [r7, #104]	@ 0x68
 8015c8e:	464b      	mov	r3, r9
 8015c90:	460a      	mov	r2, r1
 8015c92:	eb42 0303 	adc.w	r3, r2, r3
 8015c96:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8015c98:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015c9c:	685b      	ldr	r3, [r3, #4]
 8015c9e:	2200      	movs	r2, #0
 8015ca0:	663b      	str	r3, [r7, #96]	@ 0x60
 8015ca2:	667a      	str	r2, [r7, #100]	@ 0x64
 8015ca4:	f04f 0200 	mov.w	r2, #0
 8015ca8:	f04f 0300 	mov.w	r3, #0
 8015cac:	e9d7 8918 	ldrd	r8, r9, [r7, #96]	@ 0x60
 8015cb0:	4649      	mov	r1, r9
 8015cb2:	008b      	lsls	r3, r1, #2
 8015cb4:	4641      	mov	r1, r8
 8015cb6:	ea43 7391 	orr.w	r3, r3, r1, lsr #30
 8015cba:	4641      	mov	r1, r8
 8015cbc:	008a      	lsls	r2, r1, #2
 8015cbe:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
 8015cc2:	f7ea ffe9 	bl	8000c98 <__aeabi_uldivmod>
 8015cc6:	4602      	mov	r2, r0
 8015cc8:	460b      	mov	r3, r1
 8015cca:	4b0d      	ldr	r3, [pc, #52]	@ (8015d00 <UART_SetConfig+0x4e4>)
 8015ccc:	fba3 1302 	umull	r1, r3, r3, r2
 8015cd0:	095b      	lsrs	r3, r3, #5
 8015cd2:	2164      	movs	r1, #100	@ 0x64
 8015cd4:	fb01 f303 	mul.w	r3, r1, r3
 8015cd8:	1ad3      	subs	r3, r2, r3
 8015cda:	011b      	lsls	r3, r3, #4
 8015cdc:	3332      	adds	r3, #50	@ 0x32
 8015cde:	4a08      	ldr	r2, [pc, #32]	@ (8015d00 <UART_SetConfig+0x4e4>)
 8015ce0:	fba2 2303 	umull	r2, r3, r2, r3
 8015ce4:	095b      	lsrs	r3, r3, #5
 8015ce6:	f003 020f 	and.w	r2, r3, #15
 8015cea:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015cee:	681b      	ldr	r3, [r3, #0]
 8015cf0:	4422      	add	r2, r4
 8015cf2:	609a      	str	r2, [r3, #8]
}
 8015cf4:	bf00      	nop
 8015cf6:	f507 7780 	add.w	r7, r7, #256	@ 0x100
 8015cfa:	46bd      	mov	sp, r7
 8015cfc:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8015d00:	51eb851f 	.word	0x51eb851f

08015d04 <DataHist_parameters>:
 8015d04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015d08:	9c09      	ldr	r4, [sp, #36]	@ 0x24
 8015d0a:	f8dd c018 	ldr.w	ip, [sp, #24]
 8015d0e:	7020      	strb	r0, [r4, #0]
 8015d10:	6808      	ldr	r0, [r1, #0]
 8015d12:	6060      	str	r0, [r4, #4]
 8015d14:	6848      	ldr	r0, [r1, #4]
 8015d16:	60a0      	str	r0, [r4, #8]
 8015d18:	6888      	ldr	r0, [r1, #8]
 8015d1a:	60e0      	str	r0, [r4, #12]
 8015d1c:	68c8      	ldr	r0, [r1, #12]
 8015d1e:	6120      	str	r0, [r4, #16]
 8015d20:	6908      	ldr	r0, [r1, #16]
 8015d22:	6160      	str	r0, [r4, #20]
 8015d24:	6948      	ldr	r0, [r1, #20]
 8015d26:	61a0      	str	r0, [r4, #24]
 8015d28:	6988      	ldr	r0, [r1, #24]
 8015d2a:	61e0      	str	r0, [r4, #28]
 8015d2c:	69c8      	ldr	r0, [r1, #28]
 8015d2e:	6220      	str	r0, [r4, #32]
 8015d30:	6a09      	ldr	r1, [r1, #32]
 8015d32:	6261      	str	r1, [r4, #36]	@ 0x24
 8015d34:	e9dd 6507 	ldrd	r6, r5, [sp, #28]
 8015d38:	8811      	ldrh	r1, [r2, #0]
 8015d3a:	edd2 7a01 	vldr	s15, [r2, #4]
 8015d3e:	8521      	strh	r1, [r4, #40]	@ 0x28
 8015d40:	f102 0e80 	add.w	lr, r2, #128	@ 0x80
 8015d44:	f104 0830 	add.w	r8, r4, #48	@ 0x30
 8015d48:	2700      	movs	r7, #0
 8015d4a:	f1ae 0278 	sub.w	r2, lr, #120	@ 0x78
 8015d4e:	4641      	mov	r1, r8
 8015d50:	f852 0b04 	ldr.w	r0, [r2], #4
 8015d54:	f841 0b04 	str.w	r0, [r1], #4
 8015d58:	4572      	cmp	r2, lr
 8015d5a:	d1f9      	bne.n	8015d50 <DataHist_parameters+0x4c>
 8015d5c:	371e      	adds	r7, #30
 8015d5e:	2f5a      	cmp	r7, #90	@ 0x5a
 8015d60:	f108 0878 	add.w	r8, r8, #120	@ 0x78
 8015d64:	f102 0e78 	add.w	lr, r2, #120	@ 0x78
 8015d68:	d1ef      	bne.n	8015d4a <DataHist_parameters+0x46>
 8015d6a:	edc4 7a0b 	vstr	s15, [r4, #44]	@ 0x2c
 8015d6e:	881a      	ldrh	r2, [r3, #0]
 8015d70:	f8d3 8004 	ldr.w	r8, [r3, #4]
 8015d74:	f8a4 2198 	strh.w	r2, [r4, #408]	@ 0x198
 8015d78:	f103 0e80 	add.w	lr, r3, #128	@ 0x80
 8015d7c:	f504 77d0 	add.w	r7, r4, #416	@ 0x1a0
 8015d80:	2000      	movs	r0, #0
 8015d82:	f1ae 0378 	sub.w	r3, lr, #120	@ 0x78
 8015d86:	463a      	mov	r2, r7
 8015d88:	f853 1b04 	ldr.w	r1, [r3], #4
 8015d8c:	f842 1b04 	str.w	r1, [r2], #4
 8015d90:	4573      	cmp	r3, lr
 8015d92:	d1f9      	bne.n	8015d88 <DataHist_parameters+0x84>
 8015d94:	301e      	adds	r0, #30
 8015d96:	285a      	cmp	r0, #90	@ 0x5a
 8015d98:	f107 0778 	add.w	r7, r7, #120	@ 0x78
 8015d9c:	f103 0e78 	add.w	lr, r3, #120	@ 0x78
 8015da0:	d1ef      	bne.n	8015d82 <DataHist_parameters+0x7e>
 8015da2:	f8c4 819c 	str.w	r8, [r4, #412]	@ 0x19c
 8015da6:	f8bc 3000 	ldrh.w	r3, [ip]
 8015daa:	f8dc 7004 	ldr.w	r7, [ip, #4]
 8015dae:	f8a4 3308 	strh.w	r3, [r4, #776]	@ 0x308
 8015db2:	f10c 0c80 	add.w	ip, ip, #128	@ 0x80
 8015db6:	f504 7e44 	add.w	lr, r4, #784	@ 0x310
 8015dba:	2000      	movs	r0, #0
 8015dbc:	f1ac 0378 	sub.w	r3, ip, #120	@ 0x78
 8015dc0:	4672      	mov	r2, lr
 8015dc2:	f853 1b04 	ldr.w	r1, [r3], #4
 8015dc6:	f842 1b04 	str.w	r1, [r2], #4
 8015dca:	4563      	cmp	r3, ip
 8015dcc:	d1f9      	bne.n	8015dc2 <DataHist_parameters+0xbe>
 8015dce:	301e      	adds	r0, #30
 8015dd0:	285a      	cmp	r0, #90	@ 0x5a
 8015dd2:	f10e 0e78 	add.w	lr, lr, #120	@ 0x78
 8015dd6:	f103 0c78 	add.w	ip, r3, #120	@ 0x78
 8015dda:	d1ef      	bne.n	8015dbc <DataHist_parameters+0xb8>
 8015ddc:	f8c4 730c 	str.w	r7, [r4, #780]	@ 0x30c
 8015de0:	8833      	ldrh	r3, [r6, #0]
 8015de2:	6877      	ldr	r7, [r6, #4]
 8015de4:	f8a4 3478 	strh.w	r3, [r4, #1144]	@ 0x478
 8015de8:	f106 0080 	add.w	r0, r6, #128	@ 0x80
 8015dec:	f504 6c90 	add.w	ip, r4, #1152	@ 0x480
 8015df0:	2600      	movs	r6, #0
 8015df2:	f1a0 0378 	sub.w	r3, r0, #120	@ 0x78
 8015df6:	4662      	mov	r2, ip
 8015df8:	f853 1b04 	ldr.w	r1, [r3], #4
 8015dfc:	f842 1b04 	str.w	r1, [r2], #4
 8015e00:	4283      	cmp	r3, r0
 8015e02:	d1f9      	bne.n	8015df8 <DataHist_parameters+0xf4>
 8015e04:	361e      	adds	r6, #30
 8015e06:	2e5a      	cmp	r6, #90	@ 0x5a
 8015e08:	f10c 0c78 	add.w	ip, ip, #120	@ 0x78
 8015e0c:	f103 0078 	add.w	r0, r3, #120	@ 0x78
 8015e10:	d1ef      	bne.n	8015df2 <DataHist_parameters+0xee>
 8015e12:	f504 638f 	add.w	r3, r4, #1144	@ 0x478
 8015e16:	69aa      	ldr	r2, [r5, #24]
 8015e18:	605f      	str	r7, [r3, #4]
 8015e1a:	f504 63bd 	add.w	r3, r4, #1512	@ 0x5e8
 8015e1e:	7829      	ldrb	r1, [r5, #0]
 8015e20:	f884 15e8 	strb.w	r1, [r4, #1512]	@ 0x5e8
 8015e24:	619a      	str	r2, [r3, #24]
 8015e26:	6869      	ldr	r1, [r5, #4]
 8015e28:	6059      	str	r1, [r3, #4]
 8015e2a:	f504 62be 	add.w	r2, r4, #1520	@ 0x5f0
 8015e2e:	68a9      	ldr	r1, [r5, #8]
 8015e30:	6011      	str	r1, [r2, #0]
 8015e32:	f204 52f4 	addw	r2, r4, #1524	@ 0x5f4
 8015e36:	68e9      	ldr	r1, [r5, #12]
 8015e38:	6011      	str	r1, [r2, #0]
 8015e3a:	f504 62bf 	add.w	r2, r4, #1528	@ 0x5f8
 8015e3e:	6929      	ldr	r1, [r5, #16]
 8015e40:	6011      	str	r1, [r2, #0]
 8015e42:	f204 52fc 	addw	r2, r4, #1532	@ 0x5fc
 8015e46:	6969      	ldr	r1, [r5, #20]
 8015e48:	6011      	str	r1, [r2, #0]
 8015e4a:	69e9      	ldr	r1, [r5, #28]
 8015e4c:	61d9      	str	r1, [r3, #28]
 8015e4e:	f504 62c1 	add.w	r2, r4, #1544	@ 0x608
 8015e52:	6a2b      	ldr	r3, [r5, #32]
 8015e54:	6013      	str	r3, [r2, #0]
 8015e56:	f204 630c 	addw	r3, r4, #1548	@ 0x60c
 8015e5a:	6a6a      	ldr	r2, [r5, #36]	@ 0x24
 8015e5c:	601a      	str	r2, [r3, #0]
 8015e5e:	f504 63c2 	add.w	r3, r4, #1552	@ 0x610
 8015e62:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 8015e64:	601a      	str	r2, [r3, #0]
 8015e66:	f204 6414 	addw	r4, r4, #1556	@ 0x614
 8015e6a:	6aeb      	ldr	r3, [r5, #44]	@ 0x2c
 8015e6c:	6023      	str	r3, [r4, #0]
 8015e6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015e72:	bf00      	nop

08015e74 <rotVect>:
 8015e74:	f991 3001 	ldrsb.w	r3, [r1, #1]
 8015e78:	ed92 7a01 	vldr	s14, [r2, #4]
 8015e7c:	ed92 6a00 	vldr	s12, [r2]
 8015e80:	ee07 3a90 	vmov	s15, r3
 8015e84:	f991 3000 	ldrsb.w	r3, [r1]
 8015e88:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8015e8c:	ee06 3a90 	vmov	s13, r3
 8015e90:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015e94:	f991 3002 	ldrsb.w	r3, [r1, #2]
 8015e98:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8015e9c:	ee07 3a10 	vmov	s14, r3
 8015ea0:	eee6 7a86 	vfma.f32	s15, s13, s12
 8015ea4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8015ea8:	edd2 6a02 	vldr	s13, [r2, #8]
 8015eac:	eee7 7a26 	vfma.f32	s15, s14, s13
 8015eb0:	edc0 7a00 	vstr	s15, [r0]
 8015eb4:	f991 3004 	ldrsb.w	r3, [r1, #4]
 8015eb8:	ed92 7a01 	vldr	s14, [r2, #4]
 8015ebc:	ed92 6a00 	vldr	s12, [r2]
 8015ec0:	ee07 3a90 	vmov	s15, r3
 8015ec4:	f991 3003 	ldrsb.w	r3, [r1, #3]
 8015ec8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8015ecc:	ee06 3a90 	vmov	s13, r3
 8015ed0:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015ed4:	f991 3005 	ldrsb.w	r3, [r1, #5]
 8015ed8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8015edc:	ee07 3a10 	vmov	s14, r3
 8015ee0:	eee6 7a86 	vfma.f32	s15, s13, s12
 8015ee4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8015ee8:	edd2 6a02 	vldr	s13, [r2, #8]
 8015eec:	eee7 7a26 	vfma.f32	s15, s14, s13
 8015ef0:	edc0 7a01 	vstr	s15, [r0, #4]
 8015ef4:	f991 3007 	ldrsb.w	r3, [r1, #7]
 8015ef8:	ed92 7a01 	vldr	s14, [r2, #4]
 8015efc:	ed92 6a00 	vldr	s12, [r2]
 8015f00:	ee07 3a90 	vmov	s15, r3
 8015f04:	f991 3006 	ldrsb.w	r3, [r1, #6]
 8015f08:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8015f0c:	ee06 3a90 	vmov	s13, r3
 8015f10:	ee67 7a87 	vmul.f32	s15, s15, s14
 8015f14:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8015f18:	f991 3008 	ldrsb.w	r3, [r1, #8]
 8015f1c:	eee6 7a86 	vfma.f32	s15, s13, s12
 8015f20:	ee07 3a10 	vmov	s14, r3
 8015f24:	edd2 6a02 	vldr	s13, [r2, #8]
 8015f28:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8015f2c:	eee7 7a26 	vfma.f32	s15, s14, s13
 8015f30:	edc0 7a02 	vstr	s15, [r0, #8]
 8015f34:	4770      	bx	lr
 8015f36:	bf00      	nop

08015f38 <findAxis>:
 8015f38:	f990 3000 	ldrsb.w	r3, [r0]
 8015f3c:	2b01      	cmp	r3, #1
 8015f3e:	d027      	beq.n	8015f90 <findAxis+0x58>
 8015f40:	3301      	adds	r3, #1
 8015f42:	d00e      	beq.n	8015f62 <findAxis+0x2a>
 8015f44:	f990 3003 	ldrsb.w	r3, [r0, #3]
 8015f48:	2b01      	cmp	r3, #1
 8015f4a:	d053      	beq.n	8015ff4 <findAxis+0xbc>
 8015f4c:	3301      	adds	r3, #1
 8015f4e:	d048      	beq.n	8015fe2 <findAxis+0xaa>
 8015f50:	f990 3006 	ldrsb.w	r3, [r0, #6]
 8015f54:	2b01      	cmp	r3, #1
 8015f56:	d053      	beq.n	8016000 <findAxis+0xc8>
 8015f58:	3301      	adds	r3, #1
 8015f5a:	d104      	bne.n	8015f66 <findAxis+0x2e>
 8015f5c:	2364      	movs	r3, #100	@ 0x64
 8015f5e:	700b      	strb	r3, [r1, #0]
 8015f60:	e001      	b.n	8015f66 <findAxis+0x2e>
 8015f62:	2377      	movs	r3, #119	@ 0x77
 8015f64:	700b      	strb	r3, [r1, #0]
 8015f66:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8015f6a:	2b01      	cmp	r3, #1
 8015f6c:	d016      	beq.n	8015f9c <findAxis+0x64>
 8015f6e:	3301      	adds	r3, #1
 8015f70:	d02e      	beq.n	8015fd0 <findAxis+0x98>
 8015f72:	f990 3004 	ldrsb.w	r3, [r0, #4]
 8015f76:	2b01      	cmp	r3, #1
 8015f78:	d039      	beq.n	8015fee <findAxis+0xb6>
 8015f7a:	3301      	adds	r3, #1
 8015f7c:	d034      	beq.n	8015fe8 <findAxis+0xb0>
 8015f7e:	f990 3007 	ldrsb.w	r3, [r0, #7]
 8015f82:	2b01      	cmp	r3, #1
 8015f84:	d03f      	beq.n	8016006 <findAxis+0xce>
 8015f86:	3301      	adds	r3, #1
 8015f88:	d10a      	bne.n	8015fa0 <findAxis+0x68>
 8015f8a:	2364      	movs	r3, #100	@ 0x64
 8015f8c:	704b      	strb	r3, [r1, #1]
 8015f8e:	e007      	b.n	8015fa0 <findAxis+0x68>
 8015f90:	2365      	movs	r3, #101	@ 0x65
 8015f92:	700b      	strb	r3, [r1, #0]
 8015f94:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8015f98:	2b01      	cmp	r3, #1
 8015f9a:	d1e8      	bne.n	8015f6e <findAxis+0x36>
 8015f9c:	2365      	movs	r3, #101	@ 0x65
 8015f9e:	704b      	strb	r3, [r1, #1]
 8015fa0:	f990 3002 	ldrsb.w	r3, [r0, #2]
 8015fa4:	2b01      	cmp	r3, #1
 8015fa6:	d010      	beq.n	8015fca <findAxis+0x92>
 8015fa8:	3301      	adds	r3, #1
 8015faa:	d014      	beq.n	8015fd6 <findAxis+0x9e>
 8015fac:	f990 3005 	ldrsb.w	r3, [r0, #5]
 8015fb0:	2b01      	cmp	r3, #1
 8015fb2:	d022      	beq.n	8015ffa <findAxis+0xc2>
 8015fb4:	3301      	adds	r3, #1
 8015fb6:	d011      	beq.n	8015fdc <findAxis+0xa4>
 8015fb8:	f990 3008 	ldrsb.w	r3, [r0, #8]
 8015fbc:	2b01      	cmp	r3, #1
 8015fbe:	d025      	beq.n	801600c <findAxis+0xd4>
 8015fc0:	3301      	adds	r3, #1
 8015fc2:	bf04      	itt	eq
 8015fc4:	2364      	moveq	r3, #100	@ 0x64
 8015fc6:	708b      	strbeq	r3, [r1, #2]
 8015fc8:	4770      	bx	lr
 8015fca:	2365      	movs	r3, #101	@ 0x65
 8015fcc:	708b      	strb	r3, [r1, #2]
 8015fce:	4770      	bx	lr
 8015fd0:	2377      	movs	r3, #119	@ 0x77
 8015fd2:	704b      	strb	r3, [r1, #1]
 8015fd4:	e7e4      	b.n	8015fa0 <findAxis+0x68>
 8015fd6:	2377      	movs	r3, #119	@ 0x77
 8015fd8:	708b      	strb	r3, [r1, #2]
 8015fda:	4770      	bx	lr
 8015fdc:	2373      	movs	r3, #115	@ 0x73
 8015fde:	708b      	strb	r3, [r1, #2]
 8015fe0:	4770      	bx	lr
 8015fe2:	2373      	movs	r3, #115	@ 0x73
 8015fe4:	700b      	strb	r3, [r1, #0]
 8015fe6:	e7be      	b.n	8015f66 <findAxis+0x2e>
 8015fe8:	2373      	movs	r3, #115	@ 0x73
 8015fea:	704b      	strb	r3, [r1, #1]
 8015fec:	e7d8      	b.n	8015fa0 <findAxis+0x68>
 8015fee:	236e      	movs	r3, #110	@ 0x6e
 8015ff0:	704b      	strb	r3, [r1, #1]
 8015ff2:	e7d5      	b.n	8015fa0 <findAxis+0x68>
 8015ff4:	236e      	movs	r3, #110	@ 0x6e
 8015ff6:	700b      	strb	r3, [r1, #0]
 8015ff8:	e7b5      	b.n	8015f66 <findAxis+0x2e>
 8015ffa:	236e      	movs	r3, #110	@ 0x6e
 8015ffc:	708b      	strb	r3, [r1, #2]
 8015ffe:	4770      	bx	lr
 8016000:	2375      	movs	r3, #117	@ 0x75
 8016002:	700b      	strb	r3, [r1, #0]
 8016004:	e7af      	b.n	8015f66 <findAxis+0x2e>
 8016006:	2375      	movs	r3, #117	@ 0x75
 8016008:	704b      	strb	r3, [r1, #1]
 801600a:	e7c9      	b.n	8015fa0 <findAxis+0x68>
 801600c:	2375      	movs	r3, #117	@ 0x75
 801600e:	708b      	strb	r3, [r1, #2]
 8016010:	4770      	bx	lr
 8016012:	bf00      	nop
 8016014:	0000      	movs	r0, r0
	...

08016018 <findDirection>:
 8016018:	b5d0      	push	{r4, r6, r7, lr}
 801601a:	ed2d 8b04 	vpush	{d8-d9}
 801601e:	eef0 8ac0 	vabs.f32	s17, s0
 8016022:	eeb0 8ae0 	vabs.f32	s16, s1
 8016026:	eef4 8ac8 	vcmpe.f32	s17, s16
 801602a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801602e:	4604      	mov	r4, r0
 8016030:	eeb0 9ac1 	vabs.f32	s18, s2
 8016034:	dd36      	ble.n	80160a4 <findDirection+0x8c>
 8016036:	eef4 8ac9 	vcmpe.f32	s17, s18
 801603a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801603e:	dd31      	ble.n	80160a4 <findDirection+0x8c>
 8016040:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8016044:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016048:	ee18 0a90 	vmov	r0, s17
 801604c:	f340 8094 	ble.w	8016178 <findDirection+0x160>
 8016050:	f7ea fa82 	bl	8000558 <__aeabi_f2d>
 8016054:	4606      	mov	r6, r0
 8016056:	ee18 0a10 	vmov	r0, s16
 801605a:	460f      	mov	r7, r1
 801605c:	f7ea fa7c 	bl	8000558 <__aeabi_f2d>
 8016060:	a387      	add	r3, pc, #540	@ (adr r3, 8016280 <findDirection+0x268>)
 8016062:	e9d3 2300 	ldrd	r2, r3, [r3]
 8016066:	f7ea facf 	bl	8000608 <__aeabi_dmul>
 801606a:	4602      	mov	r2, r0
 801606c:	460b      	mov	r3, r1
 801606e:	4630      	mov	r0, r6
 8016070:	4639      	mov	r1, r7
 8016072:	f7ea fd59 	bl	8000b28 <__aeabi_dcmpgt>
 8016076:	b188      	cbz	r0, 801609c <findDirection+0x84>
 8016078:	ee19 0a10 	vmov	r0, s18
 801607c:	f7ea fa6c 	bl	8000558 <__aeabi_f2d>
 8016080:	a37f      	add	r3, pc, #508	@ (adr r3, 8016280 <findDirection+0x268>)
 8016082:	e9d3 2300 	ldrd	r2, r3, [r3]
 8016086:	f7ea fabf 	bl	8000608 <__aeabi_dmul>
 801608a:	4602      	mov	r2, r0
 801608c:	460b      	mov	r3, r1
 801608e:	4630      	mov	r0, r6
 8016090:	4639      	mov	r1, r7
 8016092:	f7ea fd49 	bl	8000b28 <__aeabi_dcmpgt>
 8016096:	2800      	cmp	r0, #0
 8016098:	bf18      	it	ne
 801609a:	2404      	movne	r4, #4
 801609c:	ecbd 8b04 	vpop	{d8-d9}
 80160a0:	4620      	mov	r0, r4
 80160a2:	bdd0      	pop	{r4, r6, r7, pc}
 80160a4:	eeb4 8ac9 	vcmpe.f32	s16, s18
 80160a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80160ac:	dd32      	ble.n	8016114 <findDirection+0xfc>
 80160ae:	eef5 0ac0 	vcmpe.f32	s1, #0.0
 80160b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80160b6:	ee18 0a10 	vmov	r0, s16
 80160ba:	f340 8086 	ble.w	80161ca <findDirection+0x1b2>
 80160be:	f7ea fa4b 	bl	8000558 <__aeabi_f2d>
 80160c2:	4606      	mov	r6, r0
 80160c4:	ee18 0a90 	vmov	r0, s17
 80160c8:	460f      	mov	r7, r1
 80160ca:	f7ea fa45 	bl	8000558 <__aeabi_f2d>
 80160ce:	a36c      	add	r3, pc, #432	@ (adr r3, 8016280 <findDirection+0x268>)
 80160d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80160d4:	f7ea fa98 	bl	8000608 <__aeabi_dmul>
 80160d8:	4602      	mov	r2, r0
 80160da:	460b      	mov	r3, r1
 80160dc:	4630      	mov	r0, r6
 80160de:	4639      	mov	r1, r7
 80160e0:	f7ea fd22 	bl	8000b28 <__aeabi_dcmpgt>
 80160e4:	2800      	cmp	r0, #0
 80160e6:	d0d9      	beq.n	801609c <findDirection+0x84>
 80160e8:	ee19 0a10 	vmov	r0, s18
 80160ec:	f7ea fa34 	bl	8000558 <__aeabi_f2d>
 80160f0:	a363      	add	r3, pc, #396	@ (adr r3, 8016280 <findDirection+0x268>)
 80160f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80160f6:	f7ea fa87 	bl	8000608 <__aeabi_dmul>
 80160fa:	4602      	mov	r2, r0
 80160fc:	460b      	mov	r3, r1
 80160fe:	4630      	mov	r0, r6
 8016100:	4639      	mov	r1, r7
 8016102:	f7ea fd11 	bl	8000b28 <__aeabi_dcmpgt>
 8016106:	ecbd 8b04 	vpop	{d8-d9}
 801610a:	2800      	cmp	r0, #0
 801610c:	bf18      	it	ne
 801610e:	2401      	movne	r4, #1
 8016110:	4620      	mov	r0, r4
 8016112:	bdd0      	pop	{r4, r6, r7, pc}
 8016114:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
 8016118:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801611c:	ee19 0a10 	vmov	r0, s18
 8016120:	dd7f      	ble.n	8016222 <findDirection+0x20a>
 8016122:	f7ea fa19 	bl	8000558 <__aeabi_f2d>
 8016126:	4606      	mov	r6, r0
 8016128:	ee18 0a10 	vmov	r0, s16
 801612c:	460f      	mov	r7, r1
 801612e:	f7ea fa13 	bl	8000558 <__aeabi_f2d>
 8016132:	a353      	add	r3, pc, #332	@ (adr r3, 8016280 <findDirection+0x268>)
 8016134:	e9d3 2300 	ldrd	r2, r3, [r3]
 8016138:	f7ea fa66 	bl	8000608 <__aeabi_dmul>
 801613c:	4602      	mov	r2, r0
 801613e:	460b      	mov	r3, r1
 8016140:	4630      	mov	r0, r6
 8016142:	4639      	mov	r1, r7
 8016144:	f7ea fcf0 	bl	8000b28 <__aeabi_dcmpgt>
 8016148:	2800      	cmp	r0, #0
 801614a:	d0a7      	beq.n	801609c <findDirection+0x84>
 801614c:	ee18 0a90 	vmov	r0, s17
 8016150:	f7ea fa02 	bl	8000558 <__aeabi_f2d>
 8016154:	a34a      	add	r3, pc, #296	@ (adr r3, 8016280 <findDirection+0x268>)
 8016156:	e9d3 2300 	ldrd	r2, r3, [r3]
 801615a:	f7ea fa55 	bl	8000608 <__aeabi_dmul>
 801615e:	4602      	mov	r2, r0
 8016160:	460b      	mov	r3, r1
 8016162:	4630      	mov	r0, r6
 8016164:	4639      	mov	r1, r7
 8016166:	f7ea fcdf 	bl	8000b28 <__aeabi_dcmpgt>
 801616a:	ecbd 8b04 	vpop	{d8-d9}
 801616e:	2800      	cmp	r0, #0
 8016170:	bf18      	it	ne
 8016172:	2400      	movne	r4, #0
 8016174:	4620      	mov	r0, r4
 8016176:	bdd0      	pop	{r4, r6, r7, pc}
 8016178:	f7ea f9ee 	bl	8000558 <__aeabi_f2d>
 801617c:	4606      	mov	r6, r0
 801617e:	ee18 0a10 	vmov	r0, s16
 8016182:	460f      	mov	r7, r1
 8016184:	f7ea f9e8 	bl	8000558 <__aeabi_f2d>
 8016188:	a33d      	add	r3, pc, #244	@ (adr r3, 8016280 <findDirection+0x268>)
 801618a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801618e:	f7ea fa3b 	bl	8000608 <__aeabi_dmul>
 8016192:	4602      	mov	r2, r0
 8016194:	460b      	mov	r3, r1
 8016196:	4630      	mov	r0, r6
 8016198:	4639      	mov	r1, r7
 801619a:	f7ea fcc5 	bl	8000b28 <__aeabi_dcmpgt>
 801619e:	2800      	cmp	r0, #0
 80161a0:	f43f af7c 	beq.w	801609c <findDirection+0x84>
 80161a4:	ee19 0a10 	vmov	r0, s18
 80161a8:	f7ea f9d6 	bl	8000558 <__aeabi_f2d>
 80161ac:	a334      	add	r3, pc, #208	@ (adr r3, 8016280 <findDirection+0x268>)
 80161ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80161b2:	f7ea fa29 	bl	8000608 <__aeabi_dmul>
 80161b6:	4602      	mov	r2, r0
 80161b8:	460b      	mov	r3, r1
 80161ba:	4630      	mov	r0, r6
 80161bc:	4639      	mov	r1, r7
 80161be:	f7ea fcb3 	bl	8000b28 <__aeabi_dcmpgt>
 80161c2:	2800      	cmp	r0, #0
 80161c4:	bf18      	it	ne
 80161c6:	2405      	movne	r4, #5
 80161c8:	e768      	b.n	801609c <findDirection+0x84>
 80161ca:	f7ea f9c5 	bl	8000558 <__aeabi_f2d>
 80161ce:	4606      	mov	r6, r0
 80161d0:	ee18 0a90 	vmov	r0, s17
 80161d4:	460f      	mov	r7, r1
 80161d6:	f7ea f9bf 	bl	8000558 <__aeabi_f2d>
 80161da:	a329      	add	r3, pc, #164	@ (adr r3, 8016280 <findDirection+0x268>)
 80161dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80161e0:	f7ea fa12 	bl	8000608 <__aeabi_dmul>
 80161e4:	4602      	mov	r2, r0
 80161e6:	460b      	mov	r3, r1
 80161e8:	4630      	mov	r0, r6
 80161ea:	4639      	mov	r1, r7
 80161ec:	f7ea fc9c 	bl	8000b28 <__aeabi_dcmpgt>
 80161f0:	2800      	cmp	r0, #0
 80161f2:	f43f af53 	beq.w	801609c <findDirection+0x84>
 80161f6:	ee19 0a10 	vmov	r0, s18
 80161fa:	f7ea f9ad 	bl	8000558 <__aeabi_f2d>
 80161fe:	a320      	add	r3, pc, #128	@ (adr r3, 8016280 <findDirection+0x268>)
 8016200:	e9d3 2300 	ldrd	r2, r3, [r3]
 8016204:	f7ea fa00 	bl	8000608 <__aeabi_dmul>
 8016208:	4602      	mov	r2, r0
 801620a:	460b      	mov	r3, r1
 801620c:	4630      	mov	r0, r6
 801620e:	4639      	mov	r1, r7
 8016210:	f7ea fc8a 	bl	8000b28 <__aeabi_dcmpgt>
 8016214:	ecbd 8b04 	vpop	{d8-d9}
 8016218:	2800      	cmp	r0, #0
 801621a:	bf18      	it	ne
 801621c:	2403      	movne	r4, #3
 801621e:	4620      	mov	r0, r4
 8016220:	bdd0      	pop	{r4, r6, r7, pc}
 8016222:	f7ea f999 	bl	8000558 <__aeabi_f2d>
 8016226:	4606      	mov	r6, r0
 8016228:	ee18 0a10 	vmov	r0, s16
 801622c:	460f      	mov	r7, r1
 801622e:	f7ea f993 	bl	8000558 <__aeabi_f2d>
 8016232:	a313      	add	r3, pc, #76	@ (adr r3, 8016280 <findDirection+0x268>)
 8016234:	e9d3 2300 	ldrd	r2, r3, [r3]
 8016238:	f7ea f9e6 	bl	8000608 <__aeabi_dmul>
 801623c:	4602      	mov	r2, r0
 801623e:	460b      	mov	r3, r1
 8016240:	4630      	mov	r0, r6
 8016242:	4639      	mov	r1, r7
 8016244:	f7ea fc70 	bl	8000b28 <__aeabi_dcmpgt>
 8016248:	2800      	cmp	r0, #0
 801624a:	f43f af27 	beq.w	801609c <findDirection+0x84>
 801624e:	ee18 0a90 	vmov	r0, s17
 8016252:	f7ea f981 	bl	8000558 <__aeabi_f2d>
 8016256:	a30a      	add	r3, pc, #40	@ (adr r3, 8016280 <findDirection+0x268>)
 8016258:	e9d3 2300 	ldrd	r2, r3, [r3]
 801625c:	f7ea f9d4 	bl	8000608 <__aeabi_dmul>
 8016260:	4602      	mov	r2, r0
 8016262:	460b      	mov	r3, r1
 8016264:	4630      	mov	r0, r6
 8016266:	4639      	mov	r1, r7
 8016268:	f7ea fc5e 	bl	8000b28 <__aeabi_dcmpgt>
 801626c:	ecbd 8b04 	vpop	{d8-d9}
 8016270:	2800      	cmp	r0, #0
 8016272:	bf18      	it	ne
 8016274:	2402      	movne	r4, #2
 8016276:	4620      	mov	r0, r4
 8016278:	bdd0      	pop	{r4, r6, r7, pc}
 801627a:	bf00      	nop
 801627c:	f3af 8000 	nop.w
 8016280:	e0000000 	.word	0xe0000000
 8016284:	3ff6b851 	.word	0x3ff6b851

08016288 <updateOrientation>:
 8016288:	2300      	movs	r3, #0
 801628a:	6003      	str	r3, [r0, #0]
 801628c:	6043      	str	r3, [r0, #4]
 801628e:	7203      	strb	r3, [r0, #8]
 8016290:	f891 c000 	ldrb.w	ip, [r1]
 8016294:	784a      	ldrb	r2, [r1, #1]
 8016296:	f1ac 0342 	sub.w	r3, ip, #66	@ 0x42
 801629a:	2b17      	cmp	r3, #23
 801629c:	bf98      	it	ls
 801629e:	f10c 0c20 	addls.w	ip, ip, #32
 80162a2:	f1a2 0342 	sub.w	r3, r2, #66	@ 0x42
 80162a6:	bf98      	it	ls
 80162a8:	fa5f fc8c 	uxtbls.w	ip, ip
 80162ac:	2b17      	cmp	r3, #23
 80162ae:	788b      	ldrb	r3, [r1, #2]
 80162b0:	bf98      	it	ls
 80162b2:	3220      	addls	r2, #32
 80162b4:	f1a3 0142 	sub.w	r1, r3, #66	@ 0x42
 80162b8:	bf98      	it	ls
 80162ba:	b2d2      	uxtbls	r2, r2
 80162bc:	2917      	cmp	r1, #23
 80162be:	bf98      	it	ls
 80162c0:	3320      	addls	r3, #32
 80162c2:	f1ac 0c64 	sub.w	ip, ip, #100	@ 0x64
 80162c6:	bf98      	it	ls
 80162c8:	b2db      	uxtbls	r3, r3
 80162ca:	f1bc 0f13 	cmp.w	ip, #19
 80162ce:	d80d      	bhi.n	80162ec <updateOrientation+0x64>
 80162d0:	e8df f00c 	tbb	[pc, ip]
 80162d4:	0c0c0a32 	.word	0x0c0c0a32
 80162d8:	0c0c0c0c 	.word	0x0c0c0c0c
 80162dc:	0c350c0c 	.word	0x0c350c0c
 80162e0:	380c0c0c 	.word	0x380c0c0c
 80162e4:	3e0c3b0c 	.word	0x3e0c3b0c
 80162e8:	2101      	movs	r1, #1
 80162ea:	7001      	strb	r1, [r0, #0]
 80162ec:	3a64      	subs	r2, #100	@ 0x64
 80162ee:	2a13      	cmp	r2, #19
 80162f0:	d80d      	bhi.n	801630e <updateOrientation+0x86>
 80162f2:	e8df f002 	tbb	[pc, r2]
 80162f6:	0a30      	.short	0x0a30
 80162f8:	0c0c0c0c 	.word	0x0c0c0c0c
 80162fc:	0c0c0c0c 	.word	0x0c0c0c0c
 8016300:	0c0c0c33 	.word	0x0c0c0c33
 8016304:	390c360c 	.word	0x390c360c
 8016308:	3c0c      	.short	0x3c0c
 801630a:	2201      	movs	r2, #1
 801630c:	7042      	strb	r2, [r0, #1]
 801630e:	3b64      	subs	r3, #100	@ 0x64
 8016310:	2b13      	cmp	r3, #19
 8016312:	d80d      	bhi.n	8016330 <updateOrientation+0xa8>
 8016314:	e8df f003 	tbb	[pc, r3]
 8016318:	0c0c2e0a 	.word	0x0c0c2e0a
 801631c:	0c0c0c0c 	.word	0x0c0c0c0c
 8016320:	0c310c0c 	.word	0x0c310c0c
 8016324:	340c0c0c 	.word	0x340c0c0c
 8016328:	0d0c370c 	.word	0x0d0c370c
 801632c:	23ff      	movs	r3, #255	@ 0xff
 801632e:	7203      	strb	r3, [r0, #8]
 8016330:	4770      	bx	lr
 8016332:	23ff      	movs	r3, #255	@ 0xff
 8016334:	7083      	strb	r3, [r0, #2]
 8016336:	4770      	bx	lr
 8016338:	21ff      	movs	r1, #255	@ 0xff
 801633a:	7181      	strb	r1, [r0, #6]
 801633c:	e7d6      	b.n	80162ec <updateOrientation+0x64>
 801633e:	2101      	movs	r1, #1
 8016340:	70c1      	strb	r1, [r0, #3]
 8016342:	e7d3      	b.n	80162ec <updateOrientation+0x64>
 8016344:	21ff      	movs	r1, #255	@ 0xff
 8016346:	70c1      	strb	r1, [r0, #3]
 8016348:	e7d0      	b.n	80162ec <updateOrientation+0x64>
 801634a:	2101      	movs	r1, #1
 801634c:	7181      	strb	r1, [r0, #6]
 801634e:	e7cd      	b.n	80162ec <updateOrientation+0x64>
 8016350:	21ff      	movs	r1, #255	@ 0xff
 8016352:	7001      	strb	r1, [r0, #0]
 8016354:	e7ca      	b.n	80162ec <updateOrientation+0x64>
 8016356:	22ff      	movs	r2, #255	@ 0xff
 8016358:	71c2      	strb	r2, [r0, #7]
 801635a:	e7d8      	b.n	801630e <updateOrientation+0x86>
 801635c:	2201      	movs	r2, #1
 801635e:	7102      	strb	r2, [r0, #4]
 8016360:	e7d5      	b.n	801630e <updateOrientation+0x86>
 8016362:	22ff      	movs	r2, #255	@ 0xff
 8016364:	7102      	strb	r2, [r0, #4]
 8016366:	e7d2      	b.n	801630e <updateOrientation+0x86>
 8016368:	2201      	movs	r2, #1
 801636a:	71c2      	strb	r2, [r0, #7]
 801636c:	e7cf      	b.n	801630e <updateOrientation+0x86>
 801636e:	22ff      	movs	r2, #255	@ 0xff
 8016370:	7042      	strb	r2, [r0, #1]
 8016372:	e7cc      	b.n	801630e <updateOrientation+0x86>
 8016374:	2301      	movs	r3, #1
 8016376:	7083      	strb	r3, [r0, #2]
 8016378:	4770      	bx	lr
 801637a:	2301      	movs	r3, #1
 801637c:	7143      	strb	r3, [r0, #5]
 801637e:	4770      	bx	lr
 8016380:	23ff      	movs	r3, #255	@ 0xff
 8016382:	7143      	strb	r3, [r0, #5]
 8016384:	4770      	bx	lr
 8016386:	2301      	movs	r3, #1
 8016388:	7203      	strb	r3, [r0, #8]
 801638a:	4770      	bx	lr

0801638c <qmult>:
 801638c:	ed91 2a03 	vldr	s4, [r1, #12]
 8016390:	ed90 3a01 	vldr	s6, [r0, #4]
 8016394:	edd0 5a02 	vldr	s11, [r0, #8]
 8016398:	edd1 4a01 	vldr	s9, [r1, #4]
 801639c:	ed90 4a00 	vldr	s8, [r0]
 80163a0:	ed91 5a02 	vldr	s10, [r1, #8]
 80163a4:	edd1 3a00 	vldr	s7, [r1]
 80163a8:	edd0 2a03 	vldr	s5, [r0, #12]
 80163ac:	ee25 6aa4 	vmul.f32	s12, s11, s9
 80163b0:	ee62 6a03 	vmul.f32	s13, s4, s6
 80163b4:	ee22 7a25 	vmul.f32	s14, s4, s11
 80163b8:	ee64 7ac3 	vnmul.f32	s15, s9, s6
 80163bc:	eea4 6a02 	vfma.f32	s12, s8, s4
 80163c0:	eee4 6a05 	vfma.f32	s13, s8, s10
 80163c4:	eea3 7a23 	vfma.f32	s14, s6, s7
 80163c8:	eee4 7a63 	vfms.f32	s15, s8, s7
 80163cc:	eea2 6aa3 	vfma.f32	s12, s5, s7
 80163d0:	eee4 6aa2 	vfma.f32	s13, s9, s5
 80163d4:	eea5 7a22 	vfma.f32	s14, s10, s5
 80163d8:	eee2 7a22 	vfma.f32	s15, s4, s5
 80163dc:	eea3 6a45 	vfms.f32	s12, s6, s10
 80163e0:	eee5 6ae3 	vfms.f32	s13, s11, s7
 80163e4:	eea4 7a64 	vfms.f32	s14, s8, s9
 80163e8:	eee5 7a65 	vfms.f32	s15, s10, s11
 80163ec:	ed82 6a00 	vstr	s12, [r2]
 80163f0:	edc2 6a01 	vstr	s13, [r2, #4]
 80163f4:	ed82 7a02 	vstr	s14, [r2, #8]
 80163f8:	edc2 7a03 	vstr	s15, [r2, #12]
 80163fc:	4770      	bx	lr
 80163fe:	bf00      	nop

08016400 <dataDerivative5>:
 8016400:	ed90 7a01 	vldr	s14, [r0, #4]
 8016404:	edd0 7a0a 	vldr	s15, [r0, #40]	@ 0x28
 8016408:	edd0 6a04 	vldr	s13, [r0, #16]
 801640c:	ed90 6a00 	vldr	s12, [r0]
 8016410:	ed90 4a02 	vldr	s8, [r0, #8]
 8016414:	edd0 4a09 	vldr	s9, [r0, #36]	@ 0x24
 8016418:	eeb8 5a00 	vmov.f32	s10, #128	@ 0xc0000000 -2.0
 801641c:	eee7 7a05 	vfma.f32	s15, s14, s10
 8016420:	ed90 7a03 	vldr	s14, [r0, #12]
 8016424:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8016428:	edd0 6a0b 	vldr	s13, [r0, #44]	@ 0x2c
 801642c:	ee96 7a05 	vfnms.f32	s14, s12, s10
 8016430:	eee4 6a05 	vfma.f32	s13, s8, s10
 8016434:	ed90 6a0d 	vldr	s12, [r0, #52]	@ 0x34
 8016438:	ed90 5a0c 	vldr	s10, [r0, #48]	@ 0x30
 801643c:	eef0 5a00 	vmov.f32	s11, #0	@ 0x40000000  2.0
 8016440:	eee6 7a25 	vfma.f32	s15, s12, s11
 8016444:	ee37 7a24 	vadd.f32	s14, s14, s9
 8016448:	eeb0 6a66 	vmov.f32	s12, s13
 801644c:	eddf 6a0e 	vldr	s13, [pc, #56]	@ 8016488 <dataDerivative5+0x88>
 8016450:	eea5 7a25 	vfma.f32	s14, s10, s11
 8016454:	ee60 6a26 	vmul.f32	s13, s0, s13
 8016458:	ed90 5a05 	vldr	s10, [r0, #20]
 801645c:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8016460:	ee36 6a45 	vsub.f32	s12, s12, s10
 8016464:	ed90 5a0e 	vldr	s10, [r0, #56]	@ 0x38
 8016468:	ee27 7a26 	vmul.f32	s14, s14, s13
 801646c:	eea5 6a25 	vfma.f32	s12, s10, s11
 8016470:	ee27 0aa7 	vmul.f32	s0, s15, s15
 8016474:	ee66 6a86 	vmul.f32	s13, s13, s12
 8016478:	eea7 0a07 	vfma.f32	s0, s14, s14
 801647c:	eea6 0aa6 	vfma.f32	s0, s13, s13
 8016480:	eeb1 0ac0 	vsqrt.f32	s0, s0
 8016484:	4770      	bx	lr
 8016486:	bf00      	nop
 8016488:	3dcccccd 	.word	0x3dcccccd

0801648c <b_dcm2q>:
 801648c:	ed90 5a08 	vldr	s10, [r0, #32]
 8016490:	edd0 7a00 	vldr	s15, [r0]
 8016494:	edd0 6a04 	vldr	s13, [r0, #16]
 8016498:	ee37 7a85 	vadd.f32	s14, s15, s10
 801649c:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
 80164a0:	ee36 7ac7 	vsub.f32	s14, s13, s14
 80164a4:	eeff 4a00 	vmov.f32	s9, #240	@ 0xbf800000 -1.0
 80164a8:	eeb4 7ac6 	vcmpe.f32	s14, s12
 80164ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80164b0:	bfc5      	ittet	gt
 80164b2:	eeb7 6a00 	vmovgt.f32	s12, #112	@ 0x3f800000  1.0
 80164b6:	ee37 7a06 	vaddgt.f32	s14, s14, s12
 80164ba:	eddf 5a43 	vldrle	s11, [pc, #268]	@ 80165c8 <b_dcm2q+0x13c>
 80164be:	eef1 5ac7 	vsqrtgt.f32	s11, s14
 80164c2:	ee36 7aa7 	vadd.f32	s14, s13, s15
 80164c6:	ee35 6a47 	vsub.f32	s12, s10, s14
 80164ca:	ee35 7a07 	vadd.f32	s14, s10, s14
 80164ce:	eeb4 6ae4 	vcmpe.f32	s12, s9
 80164d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80164d6:	bfc5      	ittet	gt
 80164d8:	eef7 4a00 	vmovgt.f32	s9, #112	@ 0x3f800000  1.0
 80164dc:	ee76 4a24 	vaddgt.f32	s9, s12, s9
 80164e0:	ed9f 6a39 	vldrle	s12, [pc, #228]	@ 80165c8 <b_dcm2q+0x13c>
 80164e4:	eeb1 6ae4 	vsqrtgt.f32	s12, s9
 80164e8:	eeff 4a00 	vmov.f32	s9, #240	@ 0xbf800000 -1.0
 80164ec:	eeb4 7ae4 	vcmpe.f32	s14, s9
 80164f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80164f4:	dd5b      	ble.n	80165ae <b_dcm2q+0x122>
 80164f6:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 80164fa:	ee37 7a24 	vadd.f32	s14, s14, s9
 80164fe:	eeb6 4a00 	vmov.f32	s8, #96	@ 0x3f000000  0.5
 8016502:	eef1 4ac7 	vsqrt.f32	s9, s14
 8016506:	ee64 4a84 	vmul.f32	s9, s9, s8
 801650a:	ee76 6a85 	vadd.f32	s13, s13, s10
 801650e:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8016512:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8016516:	edd0 6a07 	vldr	s13, [r0, #28]
 801651a:	eef4 7ac7 	vcmpe.f32	s15, s14
 801651e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016522:	bf85      	ittet	hi
 8016524:	eeb7 7a00 	vmovhi.f32	s14, #112	@ 0x3f800000  1.0
 8016528:	ee77 7a87 	vaddhi.f32	s15, s15, s14
 801652c:	ed9f 7a26 	vldrls	s14, [pc, #152]	@ 80165c8 <b_dcm2q+0x13c>
 8016530:	eeb1 7ae7 	vsqrthi.f32	s14, s15
 8016534:	edd0 7a05 	vldr	s15, [r0, #20]
 8016538:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801653c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016540:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016544:	d43c      	bmi.n	80165c0 <b_dcm2q+0x134>
 8016546:	bfd8      	it	le
 8016548:	ee27 7a27 	vmulle.f32	s14, s14, s15
 801654c:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8016550:	ee27 7a27 	vmul.f32	s14, s14, s15
 8016554:	ed81 7a00 	vstr	s14, [r1]
 8016558:	edd0 7a06 	vldr	s15, [r0, #24]
 801655c:	ed90 7a02 	vldr	s14, [r0, #8]
 8016560:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8016564:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016568:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801656c:	d425      	bmi.n	80165ba <b_dcm2q+0x12e>
 801656e:	bfd8      	it	le
 8016570:	ee65 5aa7 	vmulle.f32	s11, s11, s15
 8016574:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8016578:	ee65 5aa7 	vmul.f32	s11, s11, s15
 801657c:	edc1 5a01 	vstr	s11, [r1, #4]
 8016580:	edd0 7a01 	vldr	s15, [r0, #4]
 8016584:	ed90 7a03 	vldr	s14, [r0, #12]
 8016588:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801658c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8016590:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016594:	d40e      	bmi.n	80165b4 <b_dcm2q+0x128>
 8016596:	bfd8      	it	le
 8016598:	ee26 6a27 	vmulle.f32	s12, s12, s15
 801659c:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 80165a0:	ee26 6a27 	vmul.f32	s12, s12, s15
 80165a4:	edc1 4a03 	vstr	s9, [r1, #12]
 80165a8:	ed81 6a02 	vstr	s12, [r1, #8]
 80165ac:	4770      	bx	lr
 80165ae:	eddf 4a06 	vldr	s9, [pc, #24]	@ 80165c8 <b_dcm2q+0x13c>
 80165b2:	e7aa      	b.n	801650a <b_dcm2q+0x7e>
 80165b4:	eeb1 6a46 	vneg.f32	s12, s12
 80165b8:	e7f0      	b.n	801659c <b_dcm2q+0x110>
 80165ba:	eef1 5a65 	vneg.f32	s11, s11
 80165be:	e7d9      	b.n	8016574 <b_dcm2q+0xe8>
 80165c0:	eeb1 7a47 	vneg.f32	s14, s14
 80165c4:	e7c2      	b.n	801654c <b_dcm2q+0xc0>
 80165c6:	bf00      	nop
 80165c8:	00000000 	.word	0x00000000

080165cc <getRotationMatrix>:
 80165cc:	b538      	push	{r3, r4, r5, lr}
 80165ce:	4613      	mov	r3, r2
 80165d0:	4605      	mov	r5, r0
 80165d2:	460c      	mov	r4, r1
 80165d4:	4618      	mov	r0, r3
 80165d6:	2224      	movs	r2, #36	@ 0x24
 80165d8:	2100      	movs	r1, #0
 80165da:	f007 f834 	bl	801d646 <memset>
 80165de:	edd5 5a00 	vldr	s11, [r5]
 80165e2:	ed9f 3a49 	vldr	s6, [pc, #292]	@ 8016708 <getRotationMatrix+0x13c>
 80165e6:	edc0 5a02 	vstr	s11, [r0, #8]
 80165ea:	edd5 4a01 	vldr	s9, [r5, #4]
 80165ee:	edc0 4a05 	vstr	s9, [r0, #20]
 80165f2:	ed95 5a02 	vldr	s10, [r5, #8]
 80165f6:	ed80 5a08 	vstr	s10, [r0, #32]
 80165fa:	ed94 4a02 	vldr	s8, [r4, #8]
 80165fe:	edd4 3a01 	vldr	s7, [r4, #4]
 8016602:	ed94 6a00 	vldr	s12, [r4]
 8016606:	ee64 6ac4 	vnmul.f32	s13, s9, s8
 801660a:	ee65 7ae3 	vnmul.f32	s15, s11, s7
 801660e:	eee3 6a85 	vfma.f32	s13, s7, s10
 8016612:	4603      	mov	r3, r0
 8016614:	eee6 7a24 	vfma.f32	s15, s12, s9
 8016618:	ee25 7a46 	vnmul.f32	s14, s10, s12
 801661c:	eeb0 6ae6 	vabs.f32	s12, s13
 8016620:	eeb4 6ac3 	vcmpe.f32	s12, s6
 8016624:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016628:	eea4 7a25 	vfma.f32	s14, s8, s11
 801662c:	bfdc      	itt	le
 801662e:	ee86 4a83 	vdivle.f32	s8, s13, s6
 8016632:	eeb0 6a43 	vmovle.f32	s12, s6
 8016636:	eef0 3ac7 	vabs.f32	s7, s14
 801663a:	eeb4 6ae3 	vcmpe.f32	s12, s7
 801663e:	bfd4      	ite	le
 8016640:	ee24 4a04 	vmulle.f32	s8, s8, s8
 8016644:	eeb7 4a00 	vmovgt.f32	s8, #112	@ 0x3f800000  1.0
 8016648:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801664c:	ed80 7a03 	vstr	s14, [r0, #12]
 8016650:	edc0 7a06 	vstr	s15, [r0, #24]
 8016654:	d43f      	bmi.n	80166d6 <getRotationMatrix+0x10a>
 8016656:	eec7 3a06 	vdiv.f32	s7, s14, s12
 801665a:	eea3 4aa3 	vfma.f32	s8, s7, s7
 801665e:	eeb0 3a44 	vmov.f32	s6, s8
 8016662:	eeb0 4ae7 	vabs.f32	s8, s15
 8016666:	eeb4 6ac4 	vcmpe.f32	s12, s8
 801666a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801666e:	d543      	bpl.n	80166f8 <getRotationMatrix+0x12c>
 8016670:	eec6 2a04 	vdiv.f32	s5, s12, s8
 8016674:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 8016678:	ee62 2aa2 	vmul.f32	s5, s5, s5
 801667c:	eeb0 6a44 	vmov.f32	s12, s8
 8016680:	eee3 3a22 	vfma.f32	s7, s6, s5
 8016684:	eeb1 4ae3 	vsqrt.f32	s8, s7
 8016688:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 801668c:	ee24 6a06 	vmul.f32	s12, s8, s12
 8016690:	ee83 4a86 	vdiv.f32	s8, s7, s12
 8016694:	ee27 7a04 	vmul.f32	s14, s14, s8
 8016698:	ee67 7a84 	vmul.f32	s15, s15, s8
 801669c:	ee66 6a84 	vmul.f32	s13, s13, s8
 80166a0:	ee65 3a47 	vnmul.f32	s7, s10, s14
 80166a4:	ee25 4ae7 	vnmul.f32	s8, s11, s15
 80166a8:	ee24 6ae6 	vnmul.f32	s12, s9, s13
 80166ac:	eee7 3aa4 	vfma.f32	s7, s15, s9
 80166b0:	eef0 4a44 	vmov.f32	s9, s8
 80166b4:	eee6 4a85 	vfma.f32	s9, s13, s10
 80166b8:	eea7 6a25 	vfma.f32	s12, s14, s11
 80166bc:	edc3 6a00 	vstr	s13, [r3]
 80166c0:	ed83 7a03 	vstr	s14, [r3, #12]
 80166c4:	edc3 7a06 	vstr	s15, [r3, #24]
 80166c8:	edc3 3a01 	vstr	s7, [r3, #4]
 80166cc:	edc3 4a04 	vstr	s9, [r3, #16]
 80166d0:	ed83 6a07 	vstr	s12, [r3, #28]
 80166d4:	bd38      	pop	{r3, r4, r5, pc}
 80166d6:	eec6 2a23 	vdiv.f32	s5, s12, s7
 80166da:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 80166de:	ee62 2aa2 	vmul.f32	s5, s5, s5
 80166e2:	eeb0 6a63 	vmov.f32	s12, s7
 80166e6:	eea4 3a22 	vfma.f32	s6, s8, s5
 80166ea:	eeb0 4ae7 	vabs.f32	s8, s15
 80166ee:	eeb4 6ac4 	vcmpe.f32	s12, s8
 80166f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80166f6:	d4bb      	bmi.n	8016670 <getRotationMatrix+0xa4>
 80166f8:	ee87 4a86 	vdiv.f32	s8, s15, s12
 80166fc:	eef0 3a43 	vmov.f32	s7, s6
 8016700:	eee4 3a04 	vfma.f32	s7, s8, s8
 8016704:	e7be      	b.n	8016684 <getRotationMatrix+0xb8>
 8016706:	bf00      	nop
 8016708:	00000000 	.word	0x00000000

0801670c <kf_update>:
 801670c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016710:	ed2d 8b10 	vpush	{d8-d15}
 8016714:	f2ad 4d2c 	subw	sp, sp, #1068	@ 0x42c
 8016718:	3901      	subs	r1, #1
 801671a:	f8dd 4490 	ldr.w	r4, [sp, #1168]	@ 0x490
 801671e:	9303      	str	r3, [sp, #12]
 8016720:	ed94 2a00 	vldr	s4, [r4]
 8016724:	edd4 2a01 	vldr	s5, [r4, #4]
 8016728:	ed94 3a02 	vldr	s6, [r4, #8]
 801672c:	edd4 3a03 	vldr	s7, [r4, #12]
 8016730:	ed94 4a04 	vldr	s8, [r4, #16]
 8016734:	edd4 4a05 	vldr	s9, [r4, #20]
 8016738:	ed94 5a06 	vldr	s10, [r4, #24]
 801673c:	edd4 5a07 	vldr	s11, [r4, #28]
 8016740:	ed94 6a08 	vldr	s12, [r4, #32]
 8016744:	edd4 6a09 	vldr	s13, [r4, #36]	@ 0x24
 8016748:	ed94 7a0a 	vldr	s14, [r4, #40]	@ 0x28
 801674c:	edd4 7a0b 	vldr	s15, [r4, #44]	@ 0x2c
 8016750:	ed9f 8a1c 	vldr	s16, [pc, #112]	@ 80167c4 <kf_update+0xb8>
 8016754:	9104      	str	r1, [sp, #16]
 8016756:	ab0b      	add	r3, sp, #44	@ 0x2c
 8016758:	ee22 2a02 	vmul.f32	s4, s4, s4
 801675c:	ee62 2aa2 	vmul.f32	s5, s5, s5
 8016760:	ee23 3a03 	vmul.f32	s6, s6, s6
 8016764:	ee63 3aa3 	vmul.f32	s7, s7, s7
 8016768:	ee24 4a04 	vmul.f32	s8, s8, s8
 801676c:	ee64 4aa4 	vmul.f32	s9, s9, s9
 8016770:	ee25 5a05 	vmul.f32	s10, s10, s10
 8016774:	ee65 5aa5 	vmul.f32	s11, s11, s11
 8016778:	ee26 6a06 	vmul.f32	s12, s12, s12
 801677c:	ee66 6aa6 	vmul.f32	s13, s13, s13
 8016780:	ee27 7a07 	vmul.f32	s14, s14, s14
 8016784:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8016788:	9302      	str	r3, [sp, #8]
 801678a:	2300      	movs	r3, #0
 801678c:	4606      	mov	r6, r0
 801678e:	9200      	str	r2, [sp, #0]
 8016790:	ed8d 2a0b 	vstr	s4, [sp, #44]	@ 0x2c
 8016794:	edcd 2a0c 	vstr	s5, [sp, #48]	@ 0x30
 8016798:	ed8d 3a0d 	vstr	s6, [sp, #52]	@ 0x34
 801679c:	edcd 3a0e 	vstr	s7, [sp, #56]	@ 0x38
 80167a0:	ed8d 4a0f 	vstr	s8, [sp, #60]	@ 0x3c
 80167a4:	edcd 4a10 	vstr	s9, [sp, #64]	@ 0x40
 80167a8:	ed8d 5a11 	vstr	s10, [sp, #68]	@ 0x44
 80167ac:	edcd 5a12 	vstr	s11, [sp, #72]	@ 0x48
 80167b0:	ed8d 6a13 	vstr	s12, [sp, #76]	@ 0x4c
 80167b4:	edcd 6a14 	vstr	s13, [sp, #80]	@ 0x50
 80167b8:	ed8d 7a15 	vstr	s14, [sp, #84]	@ 0x54
 80167bc:	edcd 7a16 	vstr	s15, [sp, #88]	@ 0x58
 80167c0:	9301      	str	r3, [sp, #4]
 80167c2:	e010      	b.n	80167e6 <kf_update+0xda>
 80167c4:	00000000 	.word	0x00000000
 80167c8:	9a00      	ldr	r2, [sp, #0]
 80167ca:	9b01      	ldr	r3, [sp, #4]
 80167cc:	3204      	adds	r2, #4
 80167ce:	9200      	str	r2, [sp, #0]
 80167d0:	9a02      	ldr	r2, [sp, #8]
 80167d2:	3204      	adds	r2, #4
 80167d4:	9202      	str	r2, [sp, #8]
 80167d6:	9a03      	ldr	r2, [sp, #12]
 80167d8:	3301      	adds	r3, #1
 80167da:	3204      	adds	r2, #4
 80167dc:	2b0c      	cmp	r3, #12
 80167de:	9301      	str	r3, [sp, #4]
 80167e0:	9203      	str	r2, [sp, #12]
 80167e2:	f000 857b 	beq.w	80172dc <kf_update+0xbd0>
 80167e6:	9a04      	ldr	r2, [sp, #16]
 80167e8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80167ec:	9204      	str	r2, [sp, #16]
 80167ee:	2b00      	cmp	r3, #0
 80167f0:	d0ea      	beq.n	80167c8 <kf_update+0xbc>
 80167f2:	9a03      	ldr	r2, [sp, #12]
 80167f4:	ed8d 8a17 	vstr	s16, [sp, #92]	@ 0x5c
 80167f8:	f106 0328 	add.w	r3, r6, #40	@ 0x28
 80167fc:	ac17      	add	r4, sp, #92	@ 0x5c
 80167fe:	edd2 da00 	vldr	s27, [r2]
 8016802:	ed92 ea0c 	vldr	s28, [r2, #48]	@ 0x30
 8016806:	edd2 ea18 	vldr	s29, [r2, #96]	@ 0x60
 801680a:	ed92 fa24 	vldr	s30, [r2, #144]	@ 0x90
 801680e:	edd2 fa30 	vldr	s31, [r2, #192]	@ 0xc0
 8016812:	edd2 6a3c 	vldr	s13, [r2, #240]	@ 0xf0
 8016816:	ed92 6a48 	vldr	s12, [r2, #288]	@ 0x120
 801681a:	edd2 5a54 	vldr	s11, [r2, #336]	@ 0x150
 801681e:	ed92 5a60 	vldr	s10, [r2, #384]	@ 0x180
 8016822:	9305      	str	r3, [sp, #20]
 8016824:	ed8d 8a18 	vstr	s16, [sp, #96]	@ 0x60
 8016828:	ed8d 8a19 	vstr	s16, [sp, #100]	@ 0x64
 801682c:	ed8d 8a1a 	vstr	s16, [sp, #104]	@ 0x68
 8016830:	ed8d 8a1b 	vstr	s16, [sp, #108]	@ 0x6c
 8016834:	ed8d 8a1c 	vstr	s16, [sp, #112]	@ 0x70
 8016838:	ed8d 8a1d 	vstr	s16, [sp, #116]	@ 0x74
 801683c:	ed8d 8a1e 	vstr	s16, [sp, #120]	@ 0x78
 8016840:	ed8d 8a1f 	vstr	s16, [sp, #124]	@ 0x7c
 8016844:	f106 014c 	add.w	r1, r6, #76	@ 0x4c
 8016848:	4622      	mov	r2, r4
 801684a:	ecb3 7a01 	vldmia	r3!, {s14}
 801684e:	ecf2 7a01 	vldmia	r2!, {s15}
 8016852:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016856:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801685a:	d006      	beq.n	801686a <kf_update+0x15e>
 801685c:	eef5 da40 	vcmp.f32	s27, #0.0
 8016860:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016864:	bf18      	it	ne
 8016866:	eee7 7a2d 	vfmane.f32	s15, s14, s27
 801686a:	ed93 7a08 	vldr	s14, [r3, #32]
 801686e:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016876:	d006      	beq.n	8016886 <kf_update+0x17a>
 8016878:	eeb5 ea40 	vcmp.f32	s28, #0.0
 801687c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016880:	bf18      	it	ne
 8016882:	eee7 7a0e 	vfmane.f32	s15, s14, s28
 8016886:	ed93 7a11 	vldr	s14, [r3, #68]	@ 0x44
 801688a:	eeb5 7a40 	vcmp.f32	s14, #0.0
 801688e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016892:	d006      	beq.n	80168a2 <kf_update+0x196>
 8016894:	eef5 ea40 	vcmp.f32	s29, #0.0
 8016898:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801689c:	bf18      	it	ne
 801689e:	eee7 7a2e 	vfmane.f32	s15, s14, s29
 80168a2:	ed93 7a1a 	vldr	s14, [r3, #104]	@ 0x68
 80168a6:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80168aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168ae:	d006      	beq.n	80168be <kf_update+0x1b2>
 80168b0:	eeb5 fa40 	vcmp.f32	s30, #0.0
 80168b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168b8:	bf18      	it	ne
 80168ba:	eee7 7a0f 	vfmane.f32	s15, s14, s30
 80168be:	ed93 7a23 	vldr	s14, [r3, #140]	@ 0x8c
 80168c2:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80168c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168ca:	d006      	beq.n	80168da <kf_update+0x1ce>
 80168cc:	eef5 fa40 	vcmp.f32	s31, #0.0
 80168d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168d4:	bf18      	it	ne
 80168d6:	eee7 7a2f 	vfmane.f32	s15, s14, s31
 80168da:	ed93 7a2c 	vldr	s14, [r3, #176]	@ 0xb0
 80168de:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80168e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168e6:	d006      	beq.n	80168f6 <kf_update+0x1ea>
 80168e8:	eef5 6a40 	vcmp.f32	s13, #0.0
 80168ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168f0:	bf18      	it	ne
 80168f2:	eee7 7a26 	vfmane.f32	s15, s14, s13
 80168f6:	ed93 7a35 	vldr	s14, [r3, #212]	@ 0xd4
 80168fa:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80168fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016902:	d006      	beq.n	8016912 <kf_update+0x206>
 8016904:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8016908:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801690c:	bf18      	it	ne
 801690e:	eee7 7a06 	vfmane.f32	s15, s14, s12
 8016912:	ed93 7a3e 	vldr	s14, [r3, #248]	@ 0xf8
 8016916:	eeb5 7a40 	vcmp.f32	s14, #0.0
 801691a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801691e:	d006      	beq.n	801692e <kf_update+0x222>
 8016920:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016924:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016928:	bf18      	it	ne
 801692a:	eee7 7a25 	vfmane.f32	s15, s14, s11
 801692e:	ed93 7a47 	vldr	s14, [r3, #284]	@ 0x11c
 8016932:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016936:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801693a:	d006      	beq.n	801694a <kf_update+0x23e>
 801693c:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8016940:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016944:	bf18      	it	ne
 8016946:	eee7 7a05 	vfmane.f32	s15, s14, s10
 801694a:	4299      	cmp	r1, r3
 801694c:	ed42 7a01 	vstr	s15, [r2, #-4]
 8016950:	f47f af7b 	bne.w	801684a <kf_update+0x13e>
 8016954:	eef5 da40 	vcmp.f32	s27, #0.0
 8016958:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801695c:	eddd ba17 	vldr	s23, [sp, #92]	@ 0x5c
 8016960:	f040 8492 	bne.w	8017288 <kf_update+0xb7c>
 8016964:	eef0 7a6d 	vmov.f32	s15, s27
 8016968:	eeb5 ea40 	vcmp.f32	s28, #0.0
 801696c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016970:	ed9d ca18 	vldr	s24, [sp, #96]	@ 0x60
 8016974:	d006      	beq.n	8016984 <kf_update+0x278>
 8016976:	eeb5 ca40 	vcmp.f32	s24, #0.0
 801697a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801697e:	bf18      	it	ne
 8016980:	eeec 7a0e 	vfmane.f32	s15, s24, s28
 8016984:	eef5 ea40 	vcmp.f32	s29, #0.0
 8016988:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801698c:	ed9d aa19 	vldr	s20, [sp, #100]	@ 0x64
 8016990:	d006      	beq.n	80169a0 <kf_update+0x294>
 8016992:	eeb5 aa40 	vcmp.f32	s20, #0.0
 8016996:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801699a:	bf18      	it	ne
 801699c:	eeea 7a2e 	vfmane.f32	s15, s20, s29
 80169a0:	eeb5 fa40 	vcmp.f32	s30, #0.0
 80169a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169a8:	ed9d da1a 	vldr	s26, [sp, #104]	@ 0x68
 80169ac:	d006      	beq.n	80169bc <kf_update+0x2b0>
 80169ae:	eeb5 da40 	vcmp.f32	s26, #0.0
 80169b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169b6:	bf18      	it	ne
 80169b8:	eeed 7a0f 	vfmane.f32	s15, s26, s30
 80169bc:	eef5 fa40 	vcmp.f32	s31, #0.0
 80169c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169c4:	eddd ca1b 	vldr	s25, [sp, #108]	@ 0x6c
 80169c8:	d006      	beq.n	80169d8 <kf_update+0x2cc>
 80169ca:	eef5 ca40 	vcmp.f32	s25, #0.0
 80169ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169d2:	bf18      	it	ne
 80169d4:	eeec 7aaf 	vfmane.f32	s15, s25, s31
 80169d8:	eef5 6a40 	vcmp.f32	s13, #0.0
 80169dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169e0:	ed9d ba1c 	vldr	s22, [sp, #112]	@ 0x70
 80169e4:	d006      	beq.n	80169f4 <kf_update+0x2e8>
 80169e6:	eeb5 ba40 	vcmp.f32	s22, #0.0
 80169ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169ee:	bf18      	it	ne
 80169f0:	eeeb 7a26 	vfmane.f32	s15, s22, s13
 80169f4:	eeb5 6a40 	vcmp.f32	s12, #0.0
 80169f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80169fc:	eddd aa1d 	vldr	s21, [sp, #116]	@ 0x74
 8016a00:	d006      	beq.n	8016a10 <kf_update+0x304>
 8016a02:	eef5 aa40 	vcmp.f32	s21, #0.0
 8016a06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a0a:	bf18      	it	ne
 8016a0c:	eeea 7a86 	vfmane.f32	s15, s21, s12
 8016a10:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016a14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a18:	eddd 9a1e 	vldr	s19, [sp, #120]	@ 0x78
 8016a1c:	d006      	beq.n	8016a2c <kf_update+0x320>
 8016a1e:	eef5 9a40 	vcmp.f32	s19, #0.0
 8016a22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a26:	bf18      	it	ne
 8016a28:	eee9 7aa5 	vfmane.f32	s15, s19, s11
 8016a2c:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8016a30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a34:	ed9d 9a1f 	vldr	s18, [sp, #124]	@ 0x7c
 8016a38:	d006      	beq.n	8016a48 <kf_update+0x33c>
 8016a3a:	eeb5 9a40 	vcmp.f32	s18, #0.0
 8016a3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016a42:	bf18      	it	ne
 8016a44:	eee9 7a05 	vfmane.f32	s15, s18, s10
 8016a48:	9b02      	ldr	r3, [sp, #8]
 8016a4a:	ed93 7a00 	vldr	s14, [r3]
 8016a4e:	9b01      	ldr	r3, [sp, #4]
 8016a50:	ee77 7a87 	vadd.f32	s15, s15, s14
 8016a54:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 8016a58:	ee84 7aa7 	vdiv.f32	s14, s9, s15
 8016a5c:	2b05      	cmp	r3, #5
 8016a5e:	ee6b ba87 	vmul.f32	s23, s23, s14
 8016a62:	ee2c ca07 	vmul.f32	s24, s24, s14
 8016a66:	ee2a aa07 	vmul.f32	s20, s20, s14
 8016a6a:	ee2d da07 	vmul.f32	s26, s26, s14
 8016a6e:	ee67 ca2c 	vmul.f32	s25, s14, s25
 8016a72:	ee27 ba0b 	vmul.f32	s22, s14, s22
 8016a76:	ee67 aa2a 	vmul.f32	s21, s14, s21
 8016a7a:	ee69 9a87 	vmul.f32	s19, s19, s14
 8016a7e:	ee29 9a07 	vmul.f32	s18, s18, s14
 8016a82:	edcd ba17 	vstr	s23, [sp, #92]	@ 0x5c
 8016a86:	ed8d ca18 	vstr	s24, [sp, #96]	@ 0x60
 8016a8a:	ed8d aa19 	vstr	s20, [sp, #100]	@ 0x64
 8016a8e:	ed8d da1a 	vstr	s26, [sp, #104]	@ 0x68
 8016a92:	edcd ca1b 	vstr	s25, [sp, #108]	@ 0x6c
 8016a96:	ed8d ba1c 	vstr	s22, [sp, #112]	@ 0x70
 8016a9a:	edcd aa1d 	vstr	s21, [sp, #116]	@ 0x74
 8016a9e:	edcd 9a1e 	vstr	s19, [sp, #120]	@ 0x78
 8016aa2:	ed8d 9a1f 	vstr	s18, [sp, #124]	@ 0x7c
 8016aa6:	f340 83eb 	ble.w	8017280 <kf_update+0xb74>
 8016aaa:	eef5 da40 	vcmp.f32	s27, #0.0
 8016aae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ab2:	f000 8456 	beq.w	8017362 <kf_update+0xc56>
 8016ab6:	edd6 7a01 	vldr	s15, [r6, #4]
 8016aba:	eef5 7a40 	vcmp.f32	s15, #0.0
 8016abe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ac2:	f040 8477 	bne.w	80173b4 <kf_update+0xca8>
 8016ac6:	eeb5 ea40 	vcmp.f32	s28, #0.0
 8016aca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ace:	d008      	beq.n	8016ae2 <kf_update+0x3d6>
 8016ad0:	ed96 7a02 	vldr	s14, [r6, #8]
 8016ad4:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016ad8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016adc:	bf18      	it	ne
 8016ade:	eee7 7a0e 	vfmane.f32	s15, s14, s28
 8016ae2:	eef5 ea40 	vcmp.f32	s29, #0.0
 8016ae6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016aea:	d008      	beq.n	8016afe <kf_update+0x3f2>
 8016aec:	ed96 7a03 	vldr	s14, [r6, #12]
 8016af0:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016af4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016af8:	bf18      	it	ne
 8016afa:	eee7 7a2e 	vfmane.f32	s15, s14, s29
 8016afe:	eeb5 fa40 	vcmp.f32	s30, #0.0
 8016b02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b06:	d008      	beq.n	8016b1a <kf_update+0x40e>
 8016b08:	ed96 7a04 	vldr	s14, [r6, #16]
 8016b0c:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016b10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b14:	bf18      	it	ne
 8016b16:	eee7 7a0f 	vfmane.f32	s15, s14, s30
 8016b1a:	eef5 fa40 	vcmp.f32	s31, #0.0
 8016b1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b22:	d008      	beq.n	8016b36 <kf_update+0x42a>
 8016b24:	ed96 7a05 	vldr	s14, [r6, #20]
 8016b28:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016b2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b30:	bf18      	it	ne
 8016b32:	eee7 7a2f 	vfmane.f32	s15, s14, s31
 8016b36:	eef5 6a40 	vcmp.f32	s13, #0.0
 8016b3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b3e:	d008      	beq.n	8016b52 <kf_update+0x446>
 8016b40:	ed96 7a06 	vldr	s14, [r6, #24]
 8016b44:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016b48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b4c:	bf18      	it	ne
 8016b4e:	eee7 7a26 	vfmane.f32	s15, s14, s13
 8016b52:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8016b56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b5a:	d008      	beq.n	8016b6e <kf_update+0x462>
 8016b5c:	ed96 7a07 	vldr	s14, [r6, #28]
 8016b60:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016b64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b68:	bf18      	it	ne
 8016b6a:	eee7 7a06 	vfmane.f32	s15, s14, s12
 8016b6e:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016b72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b76:	d008      	beq.n	8016b8a <kf_update+0x47e>
 8016b78:	ed96 7a08 	vldr	s14, [r6, #32]
 8016b7c:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016b80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b84:	bf18      	it	ne
 8016b86:	eee7 7a25 	vfmane.f32	s15, s14, s11
 8016b8a:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8016b8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b92:	d008      	beq.n	8016ba6 <kf_update+0x49a>
 8016b94:	ed96 7a09 	vldr	s14, [r6, #36]	@ 0x24
 8016b98:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8016b9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ba0:	bf18      	it	ne
 8016ba2:	eee7 7a05 	vfmane.f32	s15, s14, s10
 8016ba6:	9b00      	ldr	r3, [sp, #0]
 8016ba8:	edd3 8a00 	vldr	s17, [r3]
 8016bac:	ee78 8ae7 	vsub.f32	s17, s17, s15
 8016bb0:	f44f 72a2 	mov.w	r2, #324	@ 0x144
 8016bb4:	2100      	movs	r1, #0
 8016bb6:	a868      	add	r0, sp, #416	@ 0x1a0
 8016bb8:	ed8d 5a09 	vstr	s10, [sp, #36]	@ 0x24
 8016bbc:	edcd 5a08 	vstr	s11, [sp, #32]
 8016bc0:	ed8d 6a07 	vstr	s12, [sp, #28]
 8016bc4:	edcd 6a06 	vstr	s13, [sp, #24]
 8016bc8:	f006 fd3d 	bl	801d646 <memset>
 8016bcc:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016bce:	ed9d 5a09 	vldr	s10, [sp, #36]	@ 0x24
 8016bd2:	eddd 5a08 	vldr	s11, [sp, #32]
 8016bd6:	ed9d 6a07 	vldr	s12, [sp, #28]
 8016bda:	eddd 6a06 	vldr	s13, [sp, #24]
 8016bde:	a971      	add	r1, sp, #452	@ 0x1c4
 8016be0:	461a      	mov	r2, r3
 8016be2:	ecf4 7a01 	vldmia	r4!, {s15}
 8016be6:	eef5 7a40 	vcmp.f32	s15, #0.0
 8016bea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bee:	d062      	beq.n	8016cb6 <kf_update+0x5aa>
 8016bf0:	eef5 da40 	vcmp.f32	s27, #0.0
 8016bf4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bf8:	d005      	beq.n	8016c06 <kf_update+0x4fa>
 8016bfa:	ed92 7a00 	vldr	s14, [r2]
 8016bfe:	eea7 7aad 	vfma.f32	s14, s15, s27
 8016c02:	ed82 7a00 	vstr	s14, [r2]
 8016c06:	eeb5 ea40 	vcmp.f32	s28, #0.0
 8016c0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c0e:	d005      	beq.n	8016c1c <kf_update+0x510>
 8016c10:	ed92 7a09 	vldr	s14, [r2, #36]	@ 0x24
 8016c14:	eea7 7a8e 	vfma.f32	s14, s15, s28
 8016c18:	ed82 7a09 	vstr	s14, [r2, #36]	@ 0x24
 8016c1c:	eef5 ea40 	vcmp.f32	s29, #0.0
 8016c20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c24:	d005      	beq.n	8016c32 <kf_update+0x526>
 8016c26:	ed92 7a12 	vldr	s14, [r2, #72]	@ 0x48
 8016c2a:	eea7 7aae 	vfma.f32	s14, s15, s29
 8016c2e:	ed82 7a12 	vstr	s14, [r2, #72]	@ 0x48
 8016c32:	eeb5 fa40 	vcmp.f32	s30, #0.0
 8016c36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c3a:	d005      	beq.n	8016c48 <kf_update+0x53c>
 8016c3c:	ed92 7a1b 	vldr	s14, [r2, #108]	@ 0x6c
 8016c40:	eea7 7a8f 	vfma.f32	s14, s15, s30
 8016c44:	ed82 7a1b 	vstr	s14, [r2, #108]	@ 0x6c
 8016c48:	eef5 fa40 	vcmp.f32	s31, #0.0
 8016c4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c50:	d005      	beq.n	8016c5e <kf_update+0x552>
 8016c52:	ed92 7a24 	vldr	s14, [r2, #144]	@ 0x90
 8016c56:	eea7 7aaf 	vfma.f32	s14, s15, s31
 8016c5a:	ed82 7a24 	vstr	s14, [r2, #144]	@ 0x90
 8016c5e:	eef5 6a40 	vcmp.f32	s13, #0.0
 8016c62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c66:	d005      	beq.n	8016c74 <kf_update+0x568>
 8016c68:	ed92 7a2d 	vldr	s14, [r2, #180]	@ 0xb4
 8016c6c:	eea7 7aa6 	vfma.f32	s14, s15, s13
 8016c70:	ed82 7a2d 	vstr	s14, [r2, #180]	@ 0xb4
 8016c74:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8016c78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c7c:	d005      	beq.n	8016c8a <kf_update+0x57e>
 8016c7e:	ed92 7a36 	vldr	s14, [r2, #216]	@ 0xd8
 8016c82:	eea7 7a86 	vfma.f32	s14, s15, s12
 8016c86:	ed82 7a36 	vstr	s14, [r2, #216]	@ 0xd8
 8016c8a:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016c8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c92:	d005      	beq.n	8016ca0 <kf_update+0x594>
 8016c94:	ed92 7a3f 	vldr	s14, [r2, #252]	@ 0xfc
 8016c98:	eea7 7aa5 	vfma.f32	s14, s15, s11
 8016c9c:	ed82 7a3f 	vstr	s14, [r2, #252]	@ 0xfc
 8016ca0:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8016ca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ca8:	d005      	beq.n	8016cb6 <kf_update+0x5aa>
 8016caa:	ed92 7a48 	vldr	s14, [r2, #288]	@ 0x120
 8016cae:	eea7 7a85 	vfma.f32	s14, s15, s10
 8016cb2:	ed82 7a48 	vstr	s14, [r2, #288]	@ 0x120
 8016cb6:	3204      	adds	r2, #4
 8016cb8:	4291      	cmp	r1, r2
 8016cba:	d192      	bne.n	8016be2 <kf_update+0x4d6>
 8016cbc:	afb9      	add	r7, sp, #740	@ 0x2e4
 8016cbe:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8016cc2:	a868      	add	r0, sp, #416	@ 0x1a0
 8016cc4:	463a      	mov	r2, r7
 8016cc6:	f04f 0b02 	mov.w	fp, #2
 8016cca:	f04f 0e03 	mov.w	lr, #3
 8016cce:	f04f 0c04 	mov.w	ip, #4
 8016cd2:	f04f 0a05 	mov.w	sl, #5
 8016cd6:	f04f 0906 	mov.w	r9, #6
 8016cda:	f04f 0807 	mov.w	r8, #7
 8016cde:	2408      	movs	r4, #8
 8016ce0:	2100      	movs	r1, #0
 8016ce2:	9306      	str	r3, [sp, #24]
 8016ce4:	e07b      	b.n	8016dde <kf_update+0x6d2>
 8016ce6:	edd0 7a00 	vldr	s15, [r0]
 8016cea:	ed82 8a01 	vstr	s16, [r2, #4]
 8016cee:	eef1 7a67 	vneg.f32	s15, s15
 8016cf2:	2901      	cmp	r1, #1
 8016cf4:	edc0 7a00 	vstr	s15, [r0]
 8016cf8:	f1a4 0507 	sub.w	r5, r4, #7
 8016cfc:	f000 8110 	beq.w	8016f20 <kf_update+0x814>
 8016d00:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016d02:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8016d06:	edd5 7a00 	vldr	s15, [r5]
 8016d0a:	ed82 8a02 	vstr	s16, [r2, #8]
 8016d0e:	eef1 7a67 	vneg.f32	s15, s15
 8016d12:	2902      	cmp	r1, #2
 8016d14:	edc5 7a00 	vstr	s15, [r5]
 8016d18:	f000 80ef 	beq.w	8016efa <kf_update+0x7ee>
 8016d1c:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016d1e:	eb03 058b 	add.w	r5, r3, fp, lsl #2
 8016d22:	edd5 7a00 	vldr	s15, [r5]
 8016d26:	ed82 8a03 	vstr	s16, [r2, #12]
 8016d2a:	eef1 7a67 	vneg.f32	s15, s15
 8016d2e:	2903      	cmp	r1, #3
 8016d30:	edc5 7a00 	vstr	s15, [r5]
 8016d34:	d176      	bne.n	8016e24 <kf_update+0x718>
 8016d36:	edd0 7a03 	vldr	s15, [r0, #12]
 8016d3a:	ed82 8a04 	vstr	s16, [r2, #16]
 8016d3e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016d42:	eb03 058c 	add.w	r5, r3, ip, lsl #2
 8016d46:	edc0 7a03 	vstr	s15, [r0, #12]
 8016d4a:	edd5 7a00 	vldr	s15, [r5]
 8016d4e:	ed82 8a05 	vstr	s16, [r2, #20]
 8016d52:	eef1 7a67 	vneg.f32	s15, s15
 8016d56:	edc5 7a00 	vstr	s15, [r5]
 8016d5a:	eb03 058a 	add.w	r5, r3, sl, lsl #2
 8016d5e:	edd5 7a00 	vldr	s15, [r5]
 8016d62:	ed82 8a06 	vstr	s16, [r2, #24]
 8016d66:	eef1 7a67 	vneg.f32	s15, s15
 8016d6a:	edc5 7a00 	vstr	s15, [r5]
 8016d6e:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016d70:	eb03 0589 	add.w	r5, r3, r9, lsl #2
 8016d74:	edd5 7a00 	vldr	s15, [r5]
 8016d78:	ed82 8a07 	vstr	s16, [r2, #28]
 8016d7c:	eef1 7a67 	vneg.f32	s15, s15
 8016d80:	2907      	cmp	r1, #7
 8016d82:	edc5 7a00 	vstr	s15, [r5]
 8016d86:	f040 80a4 	bne.w	8016ed2 <kf_update+0x7c6>
 8016d8a:	edd0 7a07 	vldr	s15, [r0, #28]
 8016d8e:	ed82 8a08 	vstr	s16, [r2, #32]
 8016d92:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016d96:	edc0 7a07 	vstr	s15, [r0, #28]
 8016d9a:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016d9c:	eb03 0584 	add.w	r5, r3, r4, lsl #2
 8016da0:	edd5 7a00 	vldr	s15, [r5]
 8016da4:	00a5      	lsls	r5, r4, #2
 8016da6:	eef1 7a67 	vneg.f32	s15, s15
 8016daa:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016dac:	3101      	adds	r1, #1
 8016dae:	441d      	add	r5, r3
 8016db0:	2909      	cmp	r1, #9
 8016db2:	edc5 7a00 	vstr	s15, [r5]
 8016db6:	f102 0224 	add.w	r2, r2, #36	@ 0x24
 8016dba:	f104 0409 	add.w	r4, r4, #9
 8016dbe:	f100 0024 	add.w	r0, r0, #36	@ 0x24
 8016dc2:	f108 0809 	add.w	r8, r8, #9
 8016dc6:	f109 0909 	add.w	r9, r9, #9
 8016dca:	f10a 0a09 	add.w	sl, sl, #9
 8016dce:	f10c 0c09 	add.w	ip, ip, #9
 8016dd2:	f10e 0e09 	add.w	lr, lr, #9
 8016dd6:	f10b 0b09 	add.w	fp, fp, #9
 8016dda:	f000 80d2 	beq.w	8016f82 <kf_update+0x876>
 8016dde:	ed82 8a00 	vstr	s16, [r2]
 8016de2:	2900      	cmp	r1, #0
 8016de4:	f47f af7f 	bne.w	8016ce6 <kf_update+0x5da>
 8016de8:	eddd 7a68 	vldr	s15, [sp, #416]	@ 0x1a0
 8016dec:	ed82 8a01 	vstr	s16, [r2, #4]
 8016df0:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016df4:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016df6:	1fe5      	subs	r5, r4, #7
 8016df8:	edc0 7a00 	vstr	s15, [r0]
 8016dfc:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8016e00:	edd5 7a00 	vldr	s15, [r5]
 8016e04:	ed82 8a02 	vstr	s16, [r2, #8]
 8016e08:	eef1 7a67 	vneg.f32	s15, s15
 8016e0c:	edc5 7a00 	vstr	s15, [r5]
 8016e10:	ed82 8a03 	vstr	s16, [r2, #12]
 8016e14:	eb03 058b 	add.w	r5, r3, fp, lsl #2
 8016e18:	edd5 7a00 	vldr	s15, [r5]
 8016e1c:	eef1 7a67 	vneg.f32	s15, s15
 8016e20:	edc5 7a00 	vstr	s15, [r5]
 8016e24:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016e26:	eb03 058e 	add.w	r5, r3, lr, lsl #2
 8016e2a:	edd5 7a00 	vldr	s15, [r5]
 8016e2e:	ed82 8a04 	vstr	s16, [r2, #16]
 8016e32:	eef1 7a67 	vneg.f32	s15, s15
 8016e36:	2904      	cmp	r1, #4
 8016e38:	edc5 7a00 	vstr	s15, [r5]
 8016e3c:	d02d      	beq.n	8016e9a <kf_update+0x78e>
 8016e3e:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016e40:	eb03 058c 	add.w	r5, r3, ip, lsl #2
 8016e44:	edd5 7a00 	vldr	s15, [r5]
 8016e48:	ed82 8a05 	vstr	s16, [r2, #20]
 8016e4c:	eef1 7a67 	vneg.f32	s15, s15
 8016e50:	2905      	cmp	r1, #5
 8016e52:	edc5 7a00 	vstr	s15, [r5]
 8016e56:	d077      	beq.n	8016f48 <kf_update+0x83c>
 8016e58:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016e5a:	eb03 058a 	add.w	r5, r3, sl, lsl #2
 8016e5e:	edd5 7a00 	vldr	s15, [r5]
 8016e62:	ed82 8a06 	vstr	s16, [r2, #24]
 8016e66:	eef1 7a67 	vneg.f32	s15, s15
 8016e6a:	2906      	cmp	r1, #6
 8016e6c:	edc5 7a00 	vstr	s15, [r5]
 8016e70:	f47f af7d 	bne.w	8016d6e <kf_update+0x662>
 8016e74:	edd0 7a06 	vldr	s15, [r0, #24]
 8016e78:	ed82 8a07 	vstr	s16, [r2, #28]
 8016e7c:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016e80:	ed82 8a08 	vstr	s16, [r2, #32]
 8016e84:	edc0 7a06 	vstr	s15, [r0, #24]
 8016e88:	eb03 0588 	add.w	r5, r3, r8, lsl #2
 8016e8c:	edd5 7a00 	vldr	s15, [r5]
 8016e90:	eef1 7a67 	vneg.f32	s15, s15
 8016e94:	edc5 7a00 	vstr	s15, [r5]
 8016e98:	e77f      	b.n	8016d9a <kf_update+0x68e>
 8016e9a:	edd0 7a04 	vldr	s15, [r0, #16]
 8016e9e:	ed82 8a05 	vstr	s16, [r2, #20]
 8016ea2:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016ea6:	eb03 058a 	add.w	r5, r3, sl, lsl #2
 8016eaa:	edc0 7a04 	vstr	s15, [r0, #16]
 8016eae:	edd5 7a00 	vldr	s15, [r5]
 8016eb2:	ed82 8a06 	vstr	s16, [r2, #24]
 8016eb6:	eef1 7a67 	vneg.f32	s15, s15
 8016eba:	edc5 7a00 	vstr	s15, [r5]
 8016ebe:	eb03 0589 	add.w	r5, r3, r9, lsl #2
 8016ec2:	edd5 7a00 	vldr	s15, [r5]
 8016ec6:	ed82 8a07 	vstr	s16, [r2, #28]
 8016eca:	eef1 7a67 	vneg.f32	s15, s15
 8016ece:	edc5 7a00 	vstr	s15, [r5]
 8016ed2:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016ed4:	eb03 0588 	add.w	r5, r3, r8, lsl #2
 8016ed8:	edd5 7a00 	vldr	s15, [r5]
 8016edc:	ed82 8a08 	vstr	s16, [r2, #32]
 8016ee0:	eef1 7a67 	vneg.f32	s15, s15
 8016ee4:	2908      	cmp	r1, #8
 8016ee6:	edc5 7a00 	vstr	s15, [r5]
 8016eea:	f47f af56 	bne.w	8016d9a <kf_update+0x68e>
 8016eee:	edd0 7a08 	vldr	s15, [r0, #32]
 8016ef2:	00a5      	lsls	r5, r4, #2
 8016ef4:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016ef8:	e757      	b.n	8016daa <kf_update+0x69e>
 8016efa:	edd0 7a02 	vldr	s15, [r0, #8]
 8016efe:	ed82 8a03 	vstr	s16, [r2, #12]
 8016f02:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016f06:	eb03 058e 	add.w	r5, r3, lr, lsl #2
 8016f0a:	edc0 7a02 	vstr	s15, [r0, #8]
 8016f0e:	edd5 7a00 	vldr	s15, [r5]
 8016f12:	ed82 8a04 	vstr	s16, [r2, #16]
 8016f16:	eef1 7a67 	vneg.f32	s15, s15
 8016f1a:	edc5 7a00 	vstr	s15, [r5]
 8016f1e:	e78e      	b.n	8016e3e <kf_update+0x732>
 8016f20:	edd0 7a01 	vldr	s15, [r0, #4]
 8016f24:	ed82 8a02 	vstr	s16, [r2, #8]
 8016f28:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016f2c:	ab68      	add	r3, sp, #416	@ 0x1a0
 8016f2e:	ed82 8a03 	vstr	s16, [r2, #12]
 8016f32:	edc0 7a01 	vstr	s15, [r0, #4]
 8016f36:	eb03 058b 	add.w	r5, r3, fp, lsl #2
 8016f3a:	edd5 7a00 	vldr	s15, [r5]
 8016f3e:	eef1 7a67 	vneg.f32	s15, s15
 8016f42:	edc5 7a00 	vstr	s15, [r5]
 8016f46:	e76d      	b.n	8016e24 <kf_update+0x718>
 8016f48:	edd0 7a05 	vldr	s15, [r0, #20]
 8016f4c:	ed82 8a06 	vstr	s16, [r2, #24]
 8016f50:	ee77 7a67 	vsub.f32	s15, s14, s15
 8016f54:	eb03 0589 	add.w	r5, r3, r9, lsl #2
 8016f58:	edc0 7a05 	vstr	s15, [r0, #20]
 8016f5c:	edd5 7a00 	vldr	s15, [r5]
 8016f60:	ed82 8a07 	vstr	s16, [r2, #28]
 8016f64:	eef1 7a67 	vneg.f32	s15, s15
 8016f68:	edc5 7a00 	vstr	s15, [r5]
 8016f6c:	ed82 8a08 	vstr	s16, [r2, #32]
 8016f70:	eb03 0588 	add.w	r5, r3, r8, lsl #2
 8016f74:	edd5 7a00 	vldr	s15, [r5]
 8016f78:	eef1 7a67 	vneg.f32	s15, s15
 8016f7c:	edc5 7a00 	vstr	s15, [r5]
 8016f80:	e70b      	b.n	8016d9a <kf_update+0x68e>
 8016f82:	9b06      	ldr	r3, [sp, #24]
 8016f84:	2400      	movs	r4, #0
 8016f86:	f506 70a2 	add.w	r0, r6, #324	@ 0x144
 8016f8a:	ecf3 3a01 	vldmia	r3!, {s7}
 8016f8e:	ed93 4a08 	vldr	s8, [r3, #32]
 8016f92:	edd3 4a11 	vldr	s9, [r3, #68]	@ 0x44
 8016f96:	ed93 5a1a 	vldr	s10, [r3, #104]	@ 0x68
 8016f9a:	edd3 5a23 	vldr	s11, [r3, #140]	@ 0x8c
 8016f9e:	ed93 6a2c 	vldr	s12, [r3, #176]	@ 0xb0
 8016fa2:	edd3 6a35 	vldr	s13, [r3, #212]	@ 0xd4
 8016fa6:	ed93 7a3e 	vldr	s14, [r3, #248]	@ 0xf8
 8016faa:	edd3 7a47 	vldr	s15, [r3, #284]	@ 0x11c
 8016fae:	4632      	mov	r2, r6
 8016fb0:	4639      	mov	r1, r7
 8016fb2:	eef5 3a40 	vcmp.f32	s7, #0.0
 8016fb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016fba:	d00c      	beq.n	8016fd6 <kf_update+0x8ca>
 8016fbc:	ed92 3a0a 	vldr	s6, [r2, #40]	@ 0x28
 8016fc0:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8016fc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016fc8:	d005      	beq.n	8016fd6 <kf_update+0x8ca>
 8016fca:	edd1 2a00 	vldr	s5, [r1]
 8016fce:	eee3 2a83 	vfma.f32	s5, s7, s6
 8016fd2:	edc1 2a00 	vstr	s5, [r1]
 8016fd6:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8016fda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016fde:	d00c      	beq.n	8016ffa <kf_update+0x8ee>
 8016fe0:	ed92 3a0b 	vldr	s6, [r2, #44]	@ 0x2c
 8016fe4:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8016fe8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016fec:	d005      	beq.n	8016ffa <kf_update+0x8ee>
 8016fee:	edd1 2a00 	vldr	s5, [r1]
 8016ff2:	eee4 2a03 	vfma.f32	s5, s8, s6
 8016ff6:	edc1 2a00 	vstr	s5, [r1]
 8016ffa:	eef5 4a40 	vcmp.f32	s9, #0.0
 8016ffe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017002:	d00c      	beq.n	801701e <kf_update+0x912>
 8017004:	ed92 3a0c 	vldr	s6, [r2, #48]	@ 0x30
 8017008:	eeb5 3a40 	vcmp.f32	s6, #0.0
 801700c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017010:	d005      	beq.n	801701e <kf_update+0x912>
 8017012:	edd1 2a00 	vldr	s5, [r1]
 8017016:	eee4 2a83 	vfma.f32	s5, s9, s6
 801701a:	edc1 2a00 	vstr	s5, [r1]
 801701e:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8017022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017026:	d00c      	beq.n	8017042 <kf_update+0x936>
 8017028:	ed92 3a0d 	vldr	s6, [r2, #52]	@ 0x34
 801702c:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8017030:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017034:	d005      	beq.n	8017042 <kf_update+0x936>
 8017036:	edd1 2a00 	vldr	s5, [r1]
 801703a:	eee5 2a03 	vfma.f32	s5, s10, s6
 801703e:	edc1 2a00 	vstr	s5, [r1]
 8017042:	eef5 5a40 	vcmp.f32	s11, #0.0
 8017046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801704a:	d00c      	beq.n	8017066 <kf_update+0x95a>
 801704c:	ed92 3a0e 	vldr	s6, [r2, #56]	@ 0x38
 8017050:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8017054:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017058:	d005      	beq.n	8017066 <kf_update+0x95a>
 801705a:	edd1 2a00 	vldr	s5, [r1]
 801705e:	eee5 2a83 	vfma.f32	s5, s11, s6
 8017062:	edc1 2a00 	vstr	s5, [r1]
 8017066:	eeb5 6a40 	vcmp.f32	s12, #0.0
 801706a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801706e:	d00c      	beq.n	801708a <kf_update+0x97e>
 8017070:	ed92 3a0f 	vldr	s6, [r2, #60]	@ 0x3c
 8017074:	eeb5 3a40 	vcmp.f32	s6, #0.0
 8017078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801707c:	d005      	beq.n	801708a <kf_update+0x97e>
 801707e:	edd1 2a00 	vldr	s5, [r1]
 8017082:	eee6 2a03 	vfma.f32	s5, s12, s6
 8017086:	edc1 2a00 	vstr	s5, [r1]
 801708a:	eef5 6a40 	vcmp.f32	s13, #0.0
 801708e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017092:	d00c      	beq.n	80170ae <kf_update+0x9a2>
 8017094:	ed92 3a10 	vldr	s6, [r2, #64]	@ 0x40
 8017098:	eeb5 3a40 	vcmp.f32	s6, #0.0
 801709c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80170a0:	d005      	beq.n	80170ae <kf_update+0x9a2>
 80170a2:	edd1 2a00 	vldr	s5, [r1]
 80170a6:	eee6 2a83 	vfma.f32	s5, s13, s6
 80170aa:	edc1 2a00 	vstr	s5, [r1]
 80170ae:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80170b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80170b6:	d00c      	beq.n	80170d2 <kf_update+0x9c6>
 80170b8:	ed92 3a11 	vldr	s6, [r2, #68]	@ 0x44
 80170bc:	eeb5 3a40 	vcmp.f32	s6, #0.0
 80170c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80170c4:	d005      	beq.n	80170d2 <kf_update+0x9c6>
 80170c6:	edd1 2a00 	vldr	s5, [r1]
 80170ca:	eee7 2a03 	vfma.f32	s5, s14, s6
 80170ce:	edc1 2a00 	vstr	s5, [r1]
 80170d2:	eef5 7a40 	vcmp.f32	s15, #0.0
 80170d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80170da:	d00c      	beq.n	80170f6 <kf_update+0x9ea>
 80170dc:	ed92 3a12 	vldr	s6, [r2, #72]	@ 0x48
 80170e0:	eeb5 3a40 	vcmp.f32	s6, #0.0
 80170e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80170e8:	d005      	beq.n	80170f6 <kf_update+0x9ea>
 80170ea:	edd1 2a00 	vldr	s5, [r1]
 80170ee:	eee7 2a83 	vfma.f32	s5, s15, s6
 80170f2:	edc1 2a00 	vstr	s5, [r1]
 80170f6:	3224      	adds	r2, #36	@ 0x24
 80170f8:	4282      	cmp	r2, r0
 80170fa:	f101 0124 	add.w	r1, r1, #36	@ 0x24
 80170fe:	f47f af58 	bne.w	8016fb2 <kf_update+0x8a6>
 8017102:	3401      	adds	r4, #1
 8017104:	2c09      	cmp	r4, #9
 8017106:	f107 0704 	add.w	r7, r7, #4
 801710a:	f47f af3e 	bne.w	8016f8a <kf_update+0x87e>
 801710e:	9805      	ldr	r0, [sp, #20]
 8017110:	f44f 72a2 	mov.w	r2, #324	@ 0x144
 8017114:	a9b9      	add	r1, sp, #740	@ 0x2e4
 8017116:	f006 fb16 	bl	801d746 <memcpy>
 801711a:	eef5 ba40 	vcmp.f32	s23, #0.0
 801711e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017122:	d05f      	beq.n	80171e4 <kf_update+0xad8>
 8017124:	eef5 8a40 	vcmp.f32	s17, #0.0
 8017128:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801712c:	d05a      	beq.n	80171e4 <kf_update+0xad8>
 801712e:	eeb5 ca40 	vcmp.f32	s24, #0.0
 8017132:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017136:	ee68 baab 	vmul.f32	s23, s17, s23
 801713a:	f000 812c 	beq.w	8017396 <kf_update+0xc8a>
 801713e:	eeb5 aa40 	vcmp.f32	s20, #0.0
 8017142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017146:	ee2c ca28 	vmul.f32	s24, s24, s17
 801714a:	f000 8121 	beq.w	8017390 <kf_update+0xc84>
 801714e:	eeb5 da40 	vcmp.f32	s26, #0.0
 8017152:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017156:	ee68 7a8a 	vmul.f32	s15, s17, s20
 801715a:	f000 8114 	beq.w	8017386 <kf_update+0xc7a>
 801715e:	eef5 ca40 	vcmp.f32	s25, #0.0
 8017162:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017166:	ee28 7a8d 	vmul.f32	s14, s17, s26
 801716a:	eeb0 aa4c 	vmov.f32	s20, s24
 801716e:	f040 812f 	bne.w	80173d0 <kf_update+0xcc4>
 8017172:	eef0 ca47 	vmov.f32	s25, s14
 8017176:	eeb0 da67 	vmov.f32	s26, s15
 801717a:	eeb5 ba40 	vcmp.f32	s22, #0.0
 801717e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017182:	d065      	beq.n	8017250 <kf_update+0xb44>
 8017184:	eef5 8a40 	vcmp.f32	s17, #0.0
 8017188:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801718c:	f000 80f0 	beq.w	8017370 <kf_update+0xc64>
 8017190:	eef0 7a48 	vmov.f32	s15, s16
 8017194:	eef5 aa40 	vcmp.f32	s21, #0.0
 8017198:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801719c:	ee28 7a8b 	vmul.f32	s14, s17, s22
 80171a0:	d17d      	bne.n	801729e <kf_update+0xb92>
 80171a2:	eef0 aa47 	vmov.f32	s21, s14
 80171a6:	eeb0 ba67 	vmov.f32	s22, s15
 80171aa:	eef5 9a40 	vcmp.f32	s19, #0.0
 80171ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80171b2:	f000 8082 	beq.w	80172ba <kf_update+0xbae>
 80171b6:	eef5 8a40 	vcmp.f32	s17, #0.0
 80171ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80171be:	f000 80da 	beq.w	8017376 <kf_update+0xc6a>
 80171c2:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80171c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80171ca:	ee28 7aa9 	vmul.f32	s14, s17, s19
 80171ce:	eef0 7a48 	vmov.f32	s15, s16
 80171d2:	f040 812a 	bne.w	801742a <kf_update+0xd1e>
 80171d6:	eef0 8a49 	vmov.f32	s17, s18
 80171da:	eef0 9a67 	vmov.f32	s19, s15
 80171de:	eeb0 9a47 	vmov.f32	s18, s14
 80171e2:	e086      	b.n	80172f2 <kf_update+0xbe6>
 80171e4:	eeb5 ca40 	vcmp.f32	s24, #0.0
 80171e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80171ec:	d005      	beq.n	80171fa <kf_update+0xaee>
 80171ee:	eef5 8a40 	vcmp.f32	s17, #0.0
 80171f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80171f6:	f040 80f9 	bne.w	80173ec <kf_update+0xce0>
 80171fa:	eeb5 aa40 	vcmp.f32	s20, #0.0
 80171fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017202:	d071      	beq.n	80172e8 <kf_update+0xbdc>
 8017204:	eef5 8a40 	vcmp.f32	s17, #0.0
 8017208:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801720c:	f040 8116 	bne.w	801743c <kf_update+0xd30>
 8017210:	eeb0 aa68 	vmov.f32	s20, s17
 8017214:	eef0 ba68 	vmov.f32	s23, s17
 8017218:	eeb5 da40 	vcmp.f32	s26, #0.0
 801721c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017220:	d007      	beq.n	8017232 <kf_update+0xb26>
 8017222:	eef5 8a40 	vcmp.f32	s17, #0.0
 8017226:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801722a:	f040 80c7 	bne.w	80173bc <kf_update+0xcb0>
 801722e:	eeb0 da68 	vmov.f32	s26, s17
 8017232:	eef5 ca40 	vcmp.f32	s25, #0.0
 8017236:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801723a:	d09e      	beq.n	801717a <kf_update+0xa6e>
 801723c:	eef5 8a40 	vcmp.f32	s17, #0.0
 8017240:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017244:	f040 80f7 	bne.w	8017436 <kf_update+0xd2a>
 8017248:	eeb0 ba68 	vmov.f32	s22, s17
 801724c:	eef0 ca68 	vmov.f32	s25, s17
 8017250:	eef5 aa40 	vcmp.f32	s21, #0.0
 8017254:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017258:	d0a7      	beq.n	80171aa <kf_update+0xa9e>
 801725a:	eef5 8a40 	vcmp.f32	s17, #0.0
 801725e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017262:	f040 80ce 	bne.w	8017402 <kf_update+0xcf6>
 8017266:	eef5 9a40 	vcmp.f32	s19, #0.0
 801726a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801726e:	f000 8087 	beq.w	8017380 <kf_update+0xc74>
 8017272:	eeb0 9a68 	vmov.f32	s18, s17
 8017276:	eef0 9a68 	vmov.f32	s19, s17
 801727a:	eef0 aa68 	vmov.f32	s21, s17
 801727e:	e038      	b.n	80172f2 <kf_update+0xbe6>
 8017280:	9b00      	ldr	r3, [sp, #0]
 8017282:	edd3 8a00 	vldr	s17, [r3]
 8017286:	e493      	b.n	8016bb0 <kf_update+0x4a4>
 8017288:	eef5 ba40 	vcmp.f32	s23, #0.0
 801728c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017290:	bf14      	ite	ne
 8017292:	ee6b 7aad 	vmulne.f32	s15, s23, s27
 8017296:	eef0 7a6b 	vmoveq.f32	s15, s23
 801729a:	f7ff bb65 	b.w	8016968 <kf_update+0x25c>
 801729e:	eef5 9a40 	vcmp.f32	s19, #0.0
 80172a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80172a6:	eeb0 ba67 	vmov.f32	s22, s15
 80172aa:	ee68 7aaa 	vmul.f32	s15, s17, s21
 80172ae:	f040 80b2 	bne.w	8017416 <kf_update+0xd0a>
 80172b2:	eef0 9a67 	vmov.f32	s19, s15
 80172b6:	eef0 aa47 	vmov.f32	s21, s14
 80172ba:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80172be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80172c2:	d014      	beq.n	80172ee <kf_update+0xbe2>
 80172c4:	eef5 8a40 	vcmp.f32	s17, #0.0
 80172c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80172cc:	d04d      	beq.n	801736a <kf_update+0xc5e>
 80172ce:	eeb0 7a48 	vmov.f32	s14, s16
 80172d2:	ee68 8a89 	vmul.f32	s17, s17, s18
 80172d6:	eeb0 9a47 	vmov.f32	s18, s14
 80172da:	e00a      	b.n	80172f2 <kf_update+0xbe6>
 80172dc:	f20d 4d2c 	addw	sp, sp, #1068	@ 0x42c
 80172e0:	ecbd 8b10 	vpop	{d8-d15}
 80172e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80172e8:	eef0 ba4a 	vmov.f32	s23, s20
 80172ec:	e794      	b.n	8017218 <kf_update+0xb0c>
 80172ee:	eef0 8a49 	vmov.f32	s17, s18
 80172f2:	edd6 3a01 	vldr	s7, [r6, #4]
 80172f6:	ed96 4a02 	vldr	s8, [r6, #8]
 80172fa:	edd6 4a03 	vldr	s9, [r6, #12]
 80172fe:	ed96 5a04 	vldr	s10, [r6, #16]
 8017302:	edd6 5a05 	vldr	s11, [r6, #20]
 8017306:	ed96 6a06 	vldr	s12, [r6, #24]
 801730a:	edd6 6a07 	vldr	s13, [r6, #28]
 801730e:	ed96 7a08 	vldr	s14, [r6, #32]
 8017312:	edd6 7a09 	vldr	s15, [r6, #36]	@ 0x24
 8017316:	ee73 baab 	vadd.f32	s23, s7, s23
 801731a:	ee34 aa0a 	vadd.f32	s20, s8, s20
 801731e:	ee34 da8d 	vadd.f32	s26, s9, s26
 8017322:	ee75 ca2c 	vadd.f32	s25, s10, s25
 8017326:	ee35 ba8b 	vadd.f32	s22, s11, s22
 801732a:	ee76 aa2a 	vadd.f32	s21, s12, s21
 801732e:	ee76 9aa9 	vadd.f32	s19, s13, s19
 8017332:	ee37 9a09 	vadd.f32	s18, s14, s18
 8017336:	ee77 8aa8 	vadd.f32	s17, s15, s17
 801733a:	edc6 ba01 	vstr	s23, [r6, #4]
 801733e:	ed86 aa02 	vstr	s20, [r6, #8]
 8017342:	ed86 da03 	vstr	s26, [r6, #12]
 8017346:	edc6 ca04 	vstr	s25, [r6, #16]
 801734a:	ed86 ba05 	vstr	s22, [r6, #20]
 801734e:	edc6 aa06 	vstr	s21, [r6, #24]
 8017352:	edc6 9a07 	vstr	s19, [r6, #28]
 8017356:	ed86 9a08 	vstr	s18, [r6, #32]
 801735a:	edc6 8a09 	vstr	s17, [r6, #36]	@ 0x24
 801735e:	f7ff ba33 	b.w	80167c8 <kf_update+0xbc>
 8017362:	eef0 7a6d 	vmov.f32	s15, s27
 8017366:	f7ff bbae 	b.w	8016ac6 <kf_update+0x3ba>
 801736a:	eeb0 9a68 	vmov.f32	s18, s17
 801736e:	e7c0      	b.n	80172f2 <kf_update+0xbe6>
 8017370:	eeb0 ba68 	vmov.f32	s22, s17
 8017374:	e76c      	b.n	8017250 <kf_update+0xb44>
 8017376:	eeb0 9a68 	vmov.f32	s18, s17
 801737a:	eef0 9a68 	vmov.f32	s19, s17
 801737e:	e7b8      	b.n	80172f2 <kf_update+0xbe6>
 8017380:	eef0 aa69 	vmov.f32	s21, s19
 8017384:	e799      	b.n	80172ba <kf_update+0xbae>
 8017386:	eeb0 da67 	vmov.f32	s26, s15
 801738a:	eeb0 aa4c 	vmov.f32	s20, s24
 801738e:	e750      	b.n	8017232 <kf_update+0xb26>
 8017390:	eeb0 aa4c 	vmov.f32	s20, s24
 8017394:	e740      	b.n	8017218 <kf_update+0xb0c>
 8017396:	eeb5 aa40 	vcmp.f32	s20, #0.0
 801739a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801739e:	f43f af3b 	beq.w	8017218 <kf_update+0xb0c>
 80173a2:	eeb5 da40 	vcmp.f32	s26, #0.0
 80173a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80173aa:	ee68 7a8a 	vmul.f32	s15, s17, s20
 80173ae:	f47f aed6 	bne.w	801715e <kf_update+0xa52>
 80173b2:	e7e8      	b.n	8017386 <kf_update+0xc7a>
 80173b4:	ee67 7aad 	vmul.f32	s15, s15, s27
 80173b8:	f7ff bb85 	b.w	8016ac6 <kf_update+0x3ba>
 80173bc:	eef5 ca40 	vcmp.f32	s25, #0.0
 80173c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80173c4:	ee28 7a8d 	vmul.f32	s14, s17, s26
 80173c8:	eef0 7a48 	vmov.f32	s15, s16
 80173cc:	f43f aed1 	beq.w	8017172 <kf_update+0xa66>
 80173d0:	eeb0 da67 	vmov.f32	s26, s15
 80173d4:	eeb5 ba40 	vcmp.f32	s22, #0.0
 80173d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80173dc:	ee68 7aac 	vmul.f32	s15, s17, s25
 80173e0:	d126      	bne.n	8017430 <kf_update+0xd24>
 80173e2:	eeb0 ba67 	vmov.f32	s22, s15
 80173e6:	eef0 ca47 	vmov.f32	s25, s14
 80173ea:	e731      	b.n	8017250 <kf_update+0xb44>
 80173ec:	eeb5 aa40 	vcmp.f32	s20, #0.0
 80173f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80173f4:	ee2c ca28 	vmul.f32	s24, s24, s17
 80173f8:	eef0 ba48 	vmov.f32	s23, s16
 80173fc:	f47f aea7 	bne.w	801714e <kf_update+0xa42>
 8017400:	e7c6      	b.n	8017390 <kf_update+0xc84>
 8017402:	eef5 9a40 	vcmp.f32	s19, #0.0
 8017406:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801740a:	ee68 7aaa 	vmul.f32	s15, s17, s21
 801740e:	eeb0 7a48 	vmov.f32	s14, s16
 8017412:	f43f af4e 	beq.w	80172b2 <kf_update+0xba6>
 8017416:	eeb5 9a40 	vcmp.f32	s18, #0.0
 801741a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801741e:	eef0 aa47 	vmov.f32	s21, s14
 8017422:	ee28 7aa9 	vmul.f32	s14, s17, s19
 8017426:	f43f aed6 	beq.w	80171d6 <kf_update+0xaca>
 801742a:	eef0 9a67 	vmov.f32	s19, s15
 801742e:	e750      	b.n	80172d2 <kf_update+0xbc6>
 8017430:	eef0 ca47 	vmov.f32	s25, s14
 8017434:	e6ae      	b.n	8017194 <kf_update+0xa88>
 8017436:	eeb0 7a48 	vmov.f32	s14, s16
 801743a:	e7cb      	b.n	80173d4 <kf_update+0xcc8>
 801743c:	ed9f ca06 	vldr	s24, [pc, #24]	@ 8017458 <kf_update+0xd4c>
 8017440:	eeb5 da40 	vcmp.f32	s26, #0.0
 8017444:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017448:	ee68 7a8a 	vmul.f32	s15, s17, s20
 801744c:	eef0 ba4c 	vmov.f32	s23, s24
 8017450:	f47f ae85 	bne.w	801715e <kf_update+0xa52>
 8017454:	e797      	b.n	8017386 <kf_update+0xc7a>
 8017456:	bf00      	nop
 8017458:	00000000 	.word	0x00000000

0801745c <q2hpr>:
 801745c:	b510      	push	{r4, lr}
 801745e:	ed90 7a00 	vldr	s14, [r0]
 8017462:	edd0 6a01 	vldr	s13, [r0, #4]
 8017466:	edd0 7a02 	vldr	s15, [r0, #8]
 801746a:	edd0 4a03 	vldr	s9, [r0, #12]
 801746e:	ed2d 8b0a 	vpush	{d8-d12}
 8017472:	ee27 0a26 	vmul.f32	s0, s14, s13
 8017476:	ee27 5a27 	vmul.f32	s10, s14, s15
 801747a:	ee66 5aa7 	vmul.f32	s11, s13, s15
 801747e:	ee67 0a07 	vmul.f32	s1, s14, s14
 8017482:	ee26 aaa6 	vmul.f32	s20, s13, s13
 8017486:	ee27 6aa7 	vmul.f32	s12, s15, s15
 801748a:	ee27 7a24 	vmul.f32	s14, s14, s9
 801748e:	ee66 6aa4 	vmul.f32	s13, s13, s9
 8017492:	ee67 7aa4 	vmul.f32	s15, s15, s9
 8017496:	ee70 9aa0 	vadd.f32	s19, s1, s1
 801749a:	ee3a aa0a 	vadd.f32	s20, s20, s20
 801749e:	ee36 ba06 	vadd.f32	s22, s12, s12
 80174a2:	ee70 aa00 	vadd.f32	s21, s0, s0
 80174a6:	ee35 ca05 	vadd.f32	s24, s10, s10
 80174aa:	ee77 8a07 	vadd.f32	s17, s14, s14
 80174ae:	ee75 baa5 	vadd.f32	s23, s11, s11
 80174b2:	ee36 9aa6 	vadd.f32	s18, s13, s13
 80174b6:	ee37 8aa7 	vadd.f32	s16, s15, s15
 80174ba:	460c      	mov	r4, r1
 80174bc:	bb8a      	cbnz	r2, 8017522 <q2hpr+0xc6>
 80174be:	ee79 0a8b 	vadd.f32	s1, s19, s22
 80174c2:	eeb7 ba00 	vmov.f32	s22, #112	@ 0x3f800000  1.0
 80174c6:	ee7b 0a60 	vsub.f32	s1, s22, s1
 80174ca:	ee3a 0ac8 	vsub.f32	s0, s21, s16
 80174ce:	f008 f9f3 	bl	801f8b8 <atan2f>
 80174d2:	eeb0 8a40 	vmov.f32	s16, s0
 80174d6:	ed84 8a00 	vstr	s16, [r4]
 80174da:	ee38 0aab 	vadd.f32	s0, s17, s23
 80174de:	f008 f9bf 	bl	801f860 <asinf>
 80174e2:	ee79 0a8a 	vadd.f32	s1, s19, s20
 80174e6:	eef0 8a40 	vmov.f32	s17, s0
 80174ea:	ee7b 0a60 	vsub.f32	s1, s22, s1
 80174ee:	ee3c 0a49 	vsub.f32	s0, s24, s18
 80174f2:	f008 f9e1 	bl	801f8b8 <atan2f>
 80174f6:	eef1 8a68 	vneg.f32	s17, s17
 80174fa:	eeb0 9a40 	vmov.f32	s18, s0
 80174fe:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8017502:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017506:	ed84 9a02 	vstr	s18, [r4, #8]
 801750a:	edc4 8a01 	vstr	s17, [r4, #4]
 801750e:	d505      	bpl.n	801751c <q2hpr+0xc0>
 8017510:	ed9f 0a15 	vldr	s0, [pc, #84]	@ 8017568 <q2hpr+0x10c>
 8017514:	ee38 8a00 	vadd.f32	s16, s16, s0
 8017518:	ed84 8a00 	vstr	s16, [r4]
 801751c:	ecbd 8b0a 	vpop	{d8-d12}
 8017520:	bd10      	pop	{r4, pc}
 8017522:	ee3c 0a49 	vsub.f32	s0, s24, s18
 8017526:	f008 f99b 	bl	801f860 <asinf>
 801752a:	ee79 0a8a 	vadd.f32	s1, s19, s20
 801752e:	eef7 9a00 	vmov.f32	s19, #112	@ 0x3f800000  1.0
 8017532:	ee79 0ae0 	vsub.f32	s1, s19, s1
 8017536:	eeb0 9a40 	vmov.f32	s18, s0
 801753a:	ee38 0aab 	vadd.f32	s0, s17, s23
 801753e:	f008 f9bb 	bl	801f8b8 <atan2f>
 8017542:	ee7a 0a0b 	vadd.f32	s1, s20, s22
 8017546:	eef0 8a40 	vmov.f32	s17, s0
 801754a:	ee3a 0a88 	vadd.f32	s0, s21, s16
 801754e:	ee79 0ae0 	vsub.f32	s1, s19, s1
 8017552:	eeb1 0a40 	vneg.f32	s0, s0
 8017556:	f008 f9af 	bl	801f8b8 <atan2f>
 801755a:	eef1 8a68 	vneg.f32	s17, s17
 801755e:	eeb0 8a40 	vmov.f32	s16, s0
 8017562:	ed84 0a00 	vstr	s0, [r4]
 8017566:	e7ca      	b.n	80174fe <q2hpr+0xa2>
 8017568:	40c90fdb 	.word	0x40c90fdb

0801756c <output_update>:
 801756c:	edd0 7a01 	vldr	s15, [r0, #4]
 8017570:	edd0 5a00 	vldr	s11, [r0]
 8017574:	edd0 6a02 	vldr	s13, [r0, #8]
 8017578:	ed90 5a03 	vldr	s10, [r0, #12]
 801757c:	ee27 6aa7 	vmul.f32	s12, s15, s15
 8017580:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017584:	ee27 7aa6 	vmul.f32	s14, s15, s13
 8017588:	eea5 6aa5 	vfma.f32	s12, s11, s11
 801758c:	4615      	mov	r5, r2
 801758e:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8017592:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8017596:	eea5 7a85 	vfma.f32	s14, s11, s10
 801759a:	460f      	mov	r7, r1
 801759c:	461e      	mov	r6, r3
 801759e:	ee65 6aa6 	vmul.f32	s13, s11, s13
 80175a2:	ee67 7a85 	vmul.f32	s15, s15, s10
 80175a6:	ee36 6a06 	vadd.f32	s12, s12, s12
 80175aa:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 80175ae:	ee76 6aa6 	vadd.f32	s13, s13, s13
 80175b2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80175b6:	ee37 7a07 	vadd.f32	s14, s14, s14
 80175ba:	ee35 5ac6 	vsub.f32	s10, s11, s12
 80175be:	2a00      	cmp	r2, #0
 80175c0:	d145      	bne.n	801764e <output_update+0xe2>
 80175c2:	ee77 7ae6 	vsub.f32	s15, s15, s13
 80175c6:	eeb1 7a47 	vneg.f32	s14, s14
 80175ca:	ed83 7a00 	vstr	s14, [r3]
 80175ce:	edc3 7a01 	vstr	s15, [r3, #4]
 80175d2:	ed83 5a02 	vstr	s10, [r3, #8]
 80175d6:	4629      	mov	r1, r5
 80175d8:	4604      	mov	r4, r0
 80175da:	f7ff ff3f 	bl	801745c <q2hpr>
 80175de:	ed95 7a01 	vldr	s14, [r5, #4]
 80175e2:	edd5 7a02 	vldr	s15, [r5, #8]
 80175e6:	edd5 6a00 	vldr	s13, [r5]
 80175ea:	ed9f 6a43 	vldr	s12, [pc, #268]	@ 80176f8 <output_update+0x18c>
 80175ee:	ee27 7a46 	vnmul.f32	s14, s14, s12
 80175f2:	ee67 7ac6 	vnmul.f32	s15, s15, s12
 80175f6:	ee66 6a86 	vmul.f32	s13, s13, s12
 80175fa:	ed85 7a01 	vstr	s14, [r5, #4]
 80175fe:	edc5 6a00 	vstr	s13, [r5]
 8017602:	edc5 7a02 	vstr	s15, [r5, #8]
 8017606:	ed97 7a01 	vldr	s14, [r7, #4]
 801760a:	edd6 7a00 	vldr	s15, [r6]
 801760e:	6823      	ldr	r3, [r4, #0]
 8017610:	ee77 7a87 	vadd.f32	s15, s15, s14
 8017614:	edc8 7a00 	vstr	s15, [r8]
 8017618:	ed97 7a00 	vldr	s14, [r7]
 801761c:	edd6 7a01 	vldr	s15, [r6, #4]
 8017620:	ee77 7a87 	vadd.f32	s15, s15, s14
 8017624:	edc8 7a01 	vstr	s15, [r8, #4]
 8017628:	edd6 7a02 	vldr	s15, [r6, #8]
 801762c:	ed97 7a02 	vldr	s14, [r7, #8]
 8017630:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8017634:	edc8 7a02 	vstr	s15, [r8, #8]
 8017638:	edd4 7a02 	vldr	s15, [r4, #8]
 801763c:	6862      	ldr	r2, [r4, #4]
 801763e:	6022      	str	r2, [r4, #0]
 8017640:	eef1 7a67 	vneg.f32	s15, s15
 8017644:	6063      	str	r3, [r4, #4]
 8017646:	edc4 7a02 	vstr	s15, [r4, #8]
 801764a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801764e:	2a01      	cmp	r2, #1
 8017650:	d015      	beq.n	801767e <output_update+0x112>
 8017652:	ed9f 6a29 	vldr	s12, [pc, #164]	@ 80176f8 <output_update+0x18c>
 8017656:	edd5 6a00 	vldr	s13, [r5]
 801765a:	ed95 7a01 	vldr	s14, [r5, #4]
 801765e:	edd5 7a02 	vldr	s15, [r5, #8]
 8017662:	ee66 6a86 	vmul.f32	s13, s13, s12
 8017666:	ee27 7a06 	vmul.f32	s14, s14, s12
 801766a:	ee67 7a86 	vmul.f32	s15, s15, s12
 801766e:	edc5 6a00 	vstr	s13, [r5]
 8017672:	ed85 7a01 	vstr	s14, [r5, #4]
 8017676:	edc5 7a02 	vstr	s15, [r5, #8]
 801767a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801767e:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8017682:	ee36 6a65 	vsub.f32	s12, s12, s11
 8017686:	eeb1 7a47 	vneg.f32	s14, s14
 801768a:	edc3 7a00 	vstr	s15, [r3]
 801768e:	ed83 7a01 	vstr	s14, [r3, #4]
 8017692:	ed83 6a02 	vstr	s12, [r3, #8]
 8017696:	4629      	mov	r1, r5
 8017698:	f7ff fee0 	bl	801745c <q2hpr>
 801769c:	edd5 6a00 	vldr	s13, [r5]
 80176a0:	ed95 7a01 	vldr	s14, [r5, #4]
 80176a4:	edd5 7a02 	vldr	s15, [r5, #8]
 80176a8:	ed9f 6a13 	vldr	s12, [pc, #76]	@ 80176f8 <output_update+0x18c>
 80176ac:	ee27 7a06 	vmul.f32	s14, s14, s12
 80176b0:	ee67 7a86 	vmul.f32	s15, s15, s12
 80176b4:	ee66 6a86 	vmul.f32	s13, s13, s12
 80176b8:	ed85 7a01 	vstr	s14, [r5, #4]
 80176bc:	edc5 6a00 	vstr	s13, [r5]
 80176c0:	edc5 7a02 	vstr	s15, [r5, #8]
 80176c4:	ed97 7a00 	vldr	s14, [r7]
 80176c8:	edd6 7a00 	vldr	s15, [r6]
 80176cc:	ee77 7a87 	vadd.f32	s15, s15, s14
 80176d0:	edc8 7a00 	vstr	s15, [r8]
 80176d4:	ed97 7a01 	vldr	s14, [r7, #4]
 80176d8:	edd6 7a01 	vldr	s15, [r6, #4]
 80176dc:	ee77 7a87 	vadd.f32	s15, s15, s14
 80176e0:	edc8 7a01 	vstr	s15, [r8, #4]
 80176e4:	edd6 7a02 	vldr	s15, [r6, #8]
 80176e8:	ed97 7a02 	vldr	s14, [r7, #8]
 80176ec:	ee77 7a87 	vadd.f32	s15, s15, s14
 80176f0:	edc8 7a02 	vstr	s15, [r8, #8]
 80176f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80176f8:	42652ee1 	.word	0x42652ee1
 80176fc:	00000000 	.word	0x00000000

08017700 <MFX_emptyAttitude>:
 8017700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017704:	ed2d 8b02 	vpush	{d8}
 8017708:	4fe9      	ldr	r7, [pc, #932]	@ (8017ab0 <MFX_emptyAttitude+0x3b0>)
 801770a:	eddf 8aea 	vldr	s17, [pc, #936]	@ 8017ab4 <MFX_emptyAttitude+0x3b4>
 801770e:	f6ad 4dd4 	subw	sp, sp, #3284	@ 0xcd4
 8017712:	f50d 64d7 	add.w	r4, sp, #1720	@ 0x6b8
 8017716:	f04f 0800 	mov.w	r8, #0
 801771a:	46bc      	mov	ip, r7
 801771c:	e9c4 8800 	strd	r8, r8, [r4]
 8017720:	f83c 3b04 	ldrh.w	r3, [ip], #4
 8017724:	f8c4 8008 	str.w	r8, [r4, #8]
 8017728:	f88d 854a 	strb.w	r8, [sp, #1354]	@ 0x54a
 801772c:	f8ad 3548 	strh.w	r3, [sp, #1352]	@ 0x548
 8017730:	4681      	mov	r9, r0
 8017732:	f8dd 3548 	ldr.w	r3, [sp, #1352]	@ 0x548
 8017736:	f8ad 30a8 	strh.w	r3, [sp, #168]	@ 0xa8
 801773a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801773e:	0c1b      	lsrs	r3, r3, #16
 8017740:	f88d 30aa 	strb.w	r3, [sp, #170]	@ 0xaa
 8017744:	ab2b      	add	r3, sp, #172	@ 0xac
 8017746:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 801774a:	ab2e      	add	r3, sp, #184	@ 0xb8
 801774c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8017750:	ab31      	add	r3, sp, #196	@ 0xc4
 8017752:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8017756:	ab34      	add	r3, sp, #208	@ 0xd0
 8017758:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 801775c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8017760:	ab37      	add	r3, sp, #220	@ 0xdc
 8017762:	edcd 8a08 	vstr	s17, [sp, #32]
 8017766:	edcd 8a09 	vstr	s17, [sp, #36]	@ 0x24
 801776a:	edcd 8a0a 	vstr	s17, [sp, #40]	@ 0x28
 801776e:	ed8d 8a0b 	vstr	s16, [sp, #44]	@ 0x2c
 8017772:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 8017776:	ab3a      	add	r3, sp, #232	@ 0xe8
 8017778:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 801777c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017780:	f10d 0e44 	add.w	lr, sp, #68	@ 0x44
 8017784:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8017788:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801778c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8017790:	f44f 75b4 	mov.w	r5, #360	@ 0x168
 8017794:	f8dc 3000 	ldr.w	r3, [ip]
 8017798:	f8ce 3000 	str.w	r3, [lr]
 801779c:	462a      	mov	r2, r5
 801779e:	4641      	mov	r1, r8
 80177a0:	4620      	mov	r0, r4
 80177a2:	f005 ff50 	bl	801d646 <memset>
 80177a6:	f44f 56f0 	mov.w	r6, #7680	@ 0x1e00
 80177aa:	462a      	mov	r2, r5
 80177ac:	4621      	mov	r1, r4
 80177ae:	a840      	add	r0, sp, #256	@ 0x100
 80177b0:	f8ad 60f8 	strh.w	r6, [sp, #248]	@ 0xf8
 80177b4:	f005 ffc7 	bl	801d746 <memcpy>
 80177b8:	462a      	mov	r2, r5
 80177ba:	4641      	mov	r1, r8
 80177bc:	4620      	mov	r0, r4
 80177be:	ed8d 8a3f 	vstr	s16, [sp, #252]	@ 0xfc
 80177c2:	f005 ff40 	bl	801d646 <memset>
 80177c6:	462a      	mov	r2, r5
 80177c8:	4621      	mov	r1, r4
 80177ca:	a89c      	add	r0, sp, #624	@ 0x270
 80177cc:	f8ad 6268 	strh.w	r6, [sp, #616]	@ 0x268
 80177d0:	f005 ffb9 	bl	801d746 <memcpy>
 80177d4:	462a      	mov	r2, r5
 80177d6:	4641      	mov	r1, r8
 80177d8:	4620      	mov	r0, r4
 80177da:	ed8d 8a9b 	vstr	s16, [sp, #620]	@ 0x26c
 80177de:	f005 ff32 	bl	801d646 <memset>
 80177e2:	462a      	mov	r2, r5
 80177e4:	4621      	mov	r1, r4
 80177e6:	a8f8      	add	r0, sp, #992	@ 0x3e0
 80177e8:	f8ad 63d8 	strh.w	r6, [sp, #984]	@ 0x3d8
 80177ec:	f005 ffab 	bl	801d746 <memcpy>
 80177f0:	462a      	mov	r2, r5
 80177f2:	4641      	mov	r1, r8
 80177f4:	4620      	mov	r0, r4
 80177f6:	ed8d 8af7 	vstr	s16, [sp, #988]	@ 0x3dc
 80177fa:	f005 ff24 	bl	801d646 <memset>
 80177fe:	462a      	mov	r2, r5
 8017800:	4621      	mov	r1, r4
 8017802:	f50d 60aa 	add.w	r0, sp, #1360	@ 0x550
 8017806:	f8ad 6548 	strh.w	r6, [sp, #1352]	@ 0x548
 801780a:	f005 ff9c 	bl	801d746 <memcpy>
 801780e:	f04f 0301 	mov.w	r3, #1
 8017812:	f88d 3068 	strb.w	r3, [sp, #104]	@ 0x68
 8017816:	f107 0528 	add.w	r5, r7, #40	@ 0x28
 801781a:	4ba7      	ldr	r3, [pc, #668]	@ (8017ab8 <MFX_emptyAttitude+0x3b8>)
 801781c:	9320      	str	r3, [sp, #128]	@ 0x80
 801781e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017820:	ae0c      	add	r6, sp, #48	@ 0x30
 8017822:	46b3      	mov	fp, r6
 8017824:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8017826:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
 801782a:	e9c4 8800 	strd	r8, r8, [r4]
 801782e:	e9c4 8802 	strd	r8, r8, [r4, #8]
 8017832:	f8c4 8010 	str.w	r8, [r4, #16]
 8017836:	f10d 0c6c 	add.w	ip, sp, #108	@ 0x6c
 801783a:	46a6      	mov	lr, r4
 801783c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8017840:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8017844:	f50d 6aa9 	add.w	sl, sp, #1352	@ 0x548
 8017848:	682d      	ldr	r5, [r5, #0]
 801784a:	f8cc 5000 	str.w	r5, [ip]
 801784e:	af21      	add	r7, sp, #132	@ 0x84
 8017850:	ed8a 8a01 	vstr	s16, [sl, #4]
 8017854:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8017856:	ab1a      	add	r3, sp, #104	@ 0x68
 8017858:	e9cd a301 	strd	sl, r3, [sp, #4]
 801785c:	abf6      	add	r3, sp, #984	@ 0x3d8
 801785e:	9300      	str	r3, [sp, #0]
 8017860:	aa3e      	add	r2, sp, #248	@ 0xf8
 8017862:	f8c7 8000 	str.w	r8, [r7]
 8017866:	ab9a      	add	r3, sp, #616	@ 0x268
 8017868:	a911      	add	r1, sp, #68	@ 0x44
 801786a:	9403      	str	r4, [sp, #12]
 801786c:	2001      	movs	r0, #1
 801786e:	f7fe fa49 	bl	8015d04 <DataHist_parameters>
 8017872:	4b92      	ldr	r3, [pc, #584]	@ (8017abc <MFX_emptyAttitude+0x3bc>)
 8017874:	f8c9 3018 	str.w	r3, [r9, #24]
 8017878:	4b91      	ldr	r3, [pc, #580]	@ (8017ac0 <MFX_emptyAttitude+0x3c0>)
 801787a:	f8c9 301c 	str.w	r3, [r9, #28]
 801787e:	4b91      	ldr	r3, [pc, #580]	@ (8017ac4 <MFX_emptyAttitude+0x3c4>)
 8017880:	f8c9 3020 	str.w	r3, [r9, #32]
 8017884:	4b90      	ldr	r3, [pc, #576]	@ (8017ac8 <MFX_emptyAttitude+0x3c8>)
 8017886:	f8c9 3024 	str.w	r3, [r9, #36]	@ 0x24
 801788a:	ae2b      	add	r6, sp, #172	@ 0xac
 801788c:	4b8f      	ldr	r3, [pc, #572]	@ (8017acc <MFX_emptyAttitude+0x3cc>)
 801788e:	f8c9 3028 	str.w	r3, [r9, #40]	@ 0x28
 8017892:	ce07      	ldmia	r6!, {r0, r1, r2}
 8017894:	4b8e      	ldr	r3, [pc, #568]	@ (8017ad0 <MFX_emptyAttitude+0x3d0>)
 8017896:	f8c9 302c 	str.w	r3, [r9, #44]	@ 0x2c
 801789a:	4b8e      	ldr	r3, [pc, #568]	@ (8017ad4 <MFX_emptyAttitude+0x3d4>)
 801789c:	f8c9 3030 	str.w	r3, [r9, #48]	@ 0x30
 80178a0:	4b8d      	ldr	r3, [pc, #564]	@ (8017ad8 <MFX_emptyAttitude+0x3d8>)
 80178a2:	f8c9 3034 	str.w	r3, [r9, #52]	@ 0x34
 80178a6:	f8bd 30a8 	ldrh.w	r3, [sp, #168]	@ 0xa8
 80178aa:	f8a9 3070 	strh.w	r3, [r9, #112]	@ 0x70
 80178ae:	ad2e      	add	r5, sp, #184	@ 0xb8
 80178b0:	f89d 30aa 	ldrb.w	r3, [sp, #170]	@ 0xaa
 80178b4:	f8c9 0074 	str.w	r0, [r9, #116]	@ 0x74
 80178b8:	f8c9 1078 	str.w	r1, [r9, #120]	@ 0x78
 80178bc:	f8c9 207c 	str.w	r2, [r9, #124]	@ 0x7c
 80178c0:	cd07      	ldmia	r5!, {r0, r1, r2}
 80178c2:	f889 3072 	strb.w	r3, [r9, #114]	@ 0x72
 80178c6:	f240 1301 	movw	r3, #257	@ 0x101
 80178ca:	ed9f 6b77 	vldr	d6, [pc, #476]	@ 8017aa8 <MFX_emptyAttitude+0x3a8>
 80178ce:	f8a9 3000 	strh.w	r3, [r9]
 80178d2:	f8a9 3004 	strh.w	r3, [r9, #4]
 80178d6:	4b81      	ldr	r3, [pc, #516]	@ (8017adc <MFX_emptyAttitude+0x3dc>)
 80178d8:	f8c9 300c 	str.w	r3, [r9, #12]
 80178dc:	4b80      	ldr	r3, [pc, #512]	@ (8017ae0 <MFX_emptyAttitude+0x3e0>)
 80178de:	f8c9 3014 	str.w	r3, [r9, #20]
 80178e2:	f509 7346 	add.w	r3, r9, #792	@ 0x318
 80178e6:	9304      	str	r3, [sp, #16]
 80178e8:	f8c9 0080 	str.w	r0, [r9, #128]	@ 0x80
 80178ec:	ed89 6b16 	vstr	d6, [r9, #88]	@ 0x58
 80178f0:	ed89 6b18 	vstr	d6, [r9, #96]	@ 0x60
 80178f4:	f10d 0ac4 	add.w	sl, sp, #196	@ 0xc4
 80178f8:	f8a9 8002 	strh.w	r8, [r9, #2]
 80178fc:	ed89 8a02 	vstr	s16, [r9, #8]
 8017900:	ed89 8a04 	vstr	s16, [r9, #16]
 8017904:	ed89 6b1a 	vstr	d6, [r9, #104]	@ 0x68
 8017908:	f8c9 1084 	str.w	r1, [r9, #132]	@ 0x84
 801790c:	f8c9 2088 	str.w	r2, [r9, #136]	@ 0x88
 8017910:	e8ba 0007 	ldmia.w	sl!, {r0, r1, r2}
 8017914:	f10d 0bd0 	add.w	fp, sp, #208	@ 0xd0
 8017918:	f8c9 008c 	str.w	r0, [r9, #140]	@ 0x8c
 801791c:	f8c9 1090 	str.w	r1, [r9, #144]	@ 0x90
 8017920:	f8c9 2094 	str.w	r2, [r9, #148]	@ 0x94
 8017924:	e8bb 0007 	ldmia.w	fp!, {r0, r1, r2}
 8017928:	af37      	add	r7, sp, #220	@ 0xdc
 801792a:	f8c9 0098 	str.w	r0, [r9, #152]	@ 0x98
 801792e:	f8c9 109c 	str.w	r1, [r9, #156]	@ 0x9c
 8017932:	f8c9 20a0 	str.w	r2, [r9, #160]	@ 0xa0
 8017936:	cf07      	ldmia	r7!, {r0, r1, r2}
 8017938:	f10d 0ee8 	add.w	lr, sp, #232	@ 0xe8
 801793c:	f8c9 00a4 	str.w	r0, [r9, #164]	@ 0xa4
 8017940:	f8c9 10a8 	str.w	r1, [r9, #168]	@ 0xa8
 8017944:	f8c9 20ac 	str.w	r2, [r9, #172]	@ 0xac
 8017948:	e8be 0007 	ldmia.w	lr!, {r0, r1, r2}
 801794c:	eddf 7a65 	vldr	s15, [pc, #404]	@ 8017ae4 <MFX_emptyAttitude+0x3e4>
 8017950:	ed9f 5a65 	vldr	s10, [pc, #404]	@ 8017ae8 <MFX_emptyAttitude+0x3e8>
 8017954:	ed9f 7a65 	vldr	s14, [pc, #404]	@ 8017aec <MFX_emptyAttitude+0x3ec>
 8017958:	f8c9 00b0 	str.w	r0, [r9, #176]	@ 0xb0
 801795c:	f44f 1c48 	mov.w	ip, #3276800	@ 0x320000
 8017960:	eef6 5a00 	vmov.f32	s11, #96	@ 0x3f000000  0.5
 8017964:	f8c9 10b4 	str.w	r1, [r9, #180]	@ 0xb4
 8017968:	ed89 5a65 	vstr	s10, [r9, #404]	@ 0x194
 801796c:	edc9 5a66 	vstr	s11, [r9, #408]	@ 0x198
 8017970:	ed89 7a67 	vstr	s14, [r9, #412]	@ 0x19c
 8017974:	edc9 8a64 	vstr	s17, [r9, #400]	@ 0x190
 8017978:	edc9 8a30 	vstr	s17, [r9, #192]	@ 0xc0
 801797c:	edc9 8a4a 	vstr	s17, [r9, #296]	@ 0x128
 8017980:	edc9 8a31 	vstr	s17, [r9, #196]	@ 0xc4
 8017984:	f04f 0101 	mov.w	r1, #1
 8017988:	f8c9 20b8 	str.w	r2, [r9, #184]	@ 0xb8
 801798c:	edc9 8a4b 	vstr	s17, [r9, #300]	@ 0x12c
 8017990:	edc9 8a32 	vstr	s17, [r9, #200]	@ 0xc8
 8017994:	edc9 8a4c 	vstr	s17, [r9, #304]	@ 0x130
 8017998:	edc9 8a33 	vstr	s17, [r9, #204]	@ 0xcc
 801799c:	edc9 8a4d 	vstr	s17, [r9, #308]	@ 0x134
 80179a0:	edc9 8a34 	vstr	s17, [r9, #208]	@ 0xd0
 80179a4:	edc9 8a4e 	vstr	s17, [r9, #312]	@ 0x138
 80179a8:	edc9 8a35 	vstr	s17, [r9, #212]	@ 0xd4
 80179ac:	edc9 8a4f 	vstr	s17, [r9, #316]	@ 0x13c
 80179b0:	edc9 8a36 	vstr	s17, [r9, #216]	@ 0xd8
 80179b4:	edc9 8a50 	vstr	s17, [r9, #320]	@ 0x140
 80179b8:	edc9 8a37 	vstr	s17, [r9, #220]	@ 0xdc
 80179bc:	edc9 8a51 	vstr	s17, [r9, #324]	@ 0x144
 80179c0:	edc9 8a38 	vstr	s17, [r9, #224]	@ 0xe0
 80179c4:	edc9 8a52 	vstr	s17, [r9, #328]	@ 0x148
 80179c8:	edc9 8a39 	vstr	s17, [r9, #228]	@ 0xe4
 80179cc:	edc9 8a53 	vstr	s17, [r9, #332]	@ 0x14c
 80179d0:	edc9 8a3a 	vstr	s17, [r9, #232]	@ 0xe8
 80179d4:	edc9 8a54 	vstr	s17, [r9, #336]	@ 0x150
 80179d8:	edc9 8a3b 	vstr	s17, [r9, #236]	@ 0xec
 80179dc:	edc9 8a55 	vstr	s17, [r9, #340]	@ 0x154
 80179e0:	edc9 8a3c 	vstr	s17, [r9, #240]	@ 0xf0
 80179e4:	edc9 8a56 	vstr	s17, [r9, #344]	@ 0x158
 80179e8:	edc9 8a3d 	vstr	s17, [r9, #244]	@ 0xf4
 80179ec:	edc9 8a57 	vstr	s17, [r9, #348]	@ 0x15c
 80179f0:	edc9 8a3e 	vstr	s17, [r9, #248]	@ 0xf8
 80179f4:	edc9 8a58 	vstr	s17, [r9, #352]	@ 0x160
 80179f8:	edc9 8a3f 	vstr	s17, [r9, #252]	@ 0xfc
 80179fc:	edc9 8a59 	vstr	s17, [r9, #356]	@ 0x164
 8017a00:	edc9 8a40 	vstr	s17, [r9, #256]	@ 0x100
 8017a04:	edc9 8a5a 	vstr	s17, [r9, #360]	@ 0x168
 8017a08:	edc9 8a41 	vstr	s17, [r9, #260]	@ 0x104
 8017a0c:	edc9 8a5b 	vstr	s17, [r9, #364]	@ 0x16c
 8017a10:	f8c9 c1a0 	str.w	ip, [r9, #416]	@ 0x1a0
 8017a14:	edc9 7a75 	vstr	s15, [r9, #468]	@ 0x1d4
 8017a18:	edc9 7a7f 	vstr	s15, [r9, #508]	@ 0x1fc
 8017a1c:	edc9 8a42 	vstr	s17, [r9, #264]	@ 0x108
 8017a20:	edc9 8a5c 	vstr	s17, [r9, #368]	@ 0x170
 8017a24:	edc9 8a43 	vstr	s17, [r9, #268]	@ 0x10c
 8017a28:	edc9 8a5d 	vstr	s17, [r9, #372]	@ 0x174
 8017a2c:	edc9 8a44 	vstr	s17, [r9, #272]	@ 0x110
 8017a30:	edc9 8a5e 	vstr	s17, [r9, #376]	@ 0x178
 8017a34:	edc9 8a45 	vstr	s17, [r9, #276]	@ 0x114
 8017a38:	edc9 8a5f 	vstr	s17, [r9, #380]	@ 0x17c
 8017a3c:	edc9 8a46 	vstr	s17, [r9, #280]	@ 0x118
 8017a40:	edc9 8a60 	vstr	s17, [r9, #384]	@ 0x180
 8017a44:	edc9 8a47 	vstr	s17, [r9, #284]	@ 0x11c
 8017a48:	edc9 8a61 	vstr	s17, [r9, #388]	@ 0x184
 8017a4c:	edc9 8a48 	vstr	s17, [r9, #288]	@ 0x120
 8017a50:	edc9 8a62 	vstr	s17, [r9, #392]	@ 0x188
 8017a54:	edc9 8a49 	vstr	s17, [r9, #292]	@ 0x124
 8017a58:	edc9 8a63 	vstr	s17, [r9, #396]	@ 0x18c
 8017a5c:	f889 81a4 	strb.w	r8, [r9, #420]	@ 0x1a4
 8017a60:	f8c9 81a6 	str.w	r8, [r9, #422]	@ 0x1a6
 8017a64:	edc9 8a6c 	vstr	s17, [r9, #432]	@ 0x1b0
 8017a68:	edc9 8a76 	vstr	s17, [r9, #472]	@ 0x1d8
 8017a6c:	edc9 8a77 	vstr	s17, [r9, #476]	@ 0x1dc
 8017a70:	edc9 8a78 	vstr	s17, [r9, #480]	@ 0x1e0
 8017a74:	edc9 8a79 	vstr	s17, [r9, #484]	@ 0x1e4
 8017a78:	edc9 8a7a 	vstr	s17, [r9, #488]	@ 0x1e8
 8017a7c:	edc9 8a7b 	vstr	s17, [r9, #492]	@ 0x1ec
 8017a80:	edc9 8a7c 	vstr	s17, [r9, #496]	@ 0x1f0
 8017a84:	edc9 8a7d 	vstr	s17, [r9, #500]	@ 0x1f4
 8017a88:	edc9 8a6d 	vstr	s17, [r9, #436]	@ 0x1b4
 8017a8c:	edc9 8a7e 	vstr	s17, [r9, #504]	@ 0x1f8
 8017a90:	edc9 8a80 	vstr	s17, [r9, #512]	@ 0x200
 8017a94:	edc9 7a89 	vstr	s15, [r9, #548]	@ 0x224
 8017a98:	edc9 7a93 	vstr	s15, [r9, #588]	@ 0x24c
 8017a9c:	edc9 7a9d 	vstr	s15, [r9, #628]	@ 0x274
 8017aa0:	e026      	b.n	8017af0 <MFX_emptyAttitude+0x3f0>
 8017aa2:	bf00      	nop
 8017aa4:	f3af 8000 	nop.w
	...
 8017ab0:	080239bc 	.word	0x080239bc
 8017ab4:	00000000 	.word	0x00000000
 8017ab8:	40a00000 	.word	0x40a00000
 8017abc:	3a9d4952 	.word	0x3a9d4952
 8017ac0:	3ac49ba6 	.word	0x3ac49ba6
 8017ac4:	3b03126f 	.word	0x3b03126f
 8017ac8:	3a83126f 	.word	0x3a83126f
 8017acc:	3f639581 	.word	0x3f639581
 8017ad0:	402ab021 	.word	0x402ab021
 8017ad4:	3f13f7cf 	.word	0x3f13f7cf
 8017ad8:	3f2ac083 	.word	0x3f2ac083
 8017adc:	01010100 	.word	0x01010100
 8017ae0:	41200000 	.word	0x41200000
 8017ae4:	447a0000 	.word	0x447a0000
 8017ae8:	3f4ccccd 	.word	0x3f4ccccd
 8017aec:	3f333333 	.word	0x3f333333
 8017af0:	edc9 8a81 	vstr	s17, [r9, #516]	@ 0x204
 8017af4:	edc9 8a82 	vstr	s17, [r9, #520]	@ 0x208
 8017af8:	edc9 8a83 	vstr	s17, [r9, #524]	@ 0x20c
 8017afc:	edc9 8a84 	vstr	s17, [r9, #528]	@ 0x210
 8017b00:	edc9 8a85 	vstr	s17, [r9, #532]	@ 0x214
 8017b04:	edc9 8a86 	vstr	s17, [r9, #536]	@ 0x218
 8017b08:	edc9 8a6e 	vstr	s17, [r9, #440]	@ 0x1b8
 8017b0c:	edc9 8a87 	vstr	s17, [r9, #540]	@ 0x21c
 8017b10:	edc9 8a88 	vstr	s17, [r9, #544]	@ 0x220
 8017b14:	edc9 8a8a 	vstr	s17, [r9, #552]	@ 0x228
 8017b18:	edc9 8a8b 	vstr	s17, [r9, #556]	@ 0x22c
 8017b1c:	edc9 8a8c 	vstr	s17, [r9, #560]	@ 0x230
 8017b20:	edc9 8a8d 	vstr	s17, [r9, #564]	@ 0x234
 8017b24:	edc9 8a8e 	vstr	s17, [r9, #568]	@ 0x238
 8017b28:	edc9 8a8f 	vstr	s17, [r9, #572]	@ 0x23c
 8017b2c:	edc9 8a6f 	vstr	s17, [r9, #444]	@ 0x1bc
 8017b30:	edc9 8a90 	vstr	s17, [r9, #576]	@ 0x240
 8017b34:	edc9 8a91 	vstr	s17, [r9, #580]	@ 0x244
 8017b38:	edc9 8a92 	vstr	s17, [r9, #584]	@ 0x248
 8017b3c:	edc9 8a94 	vstr	s17, [r9, #592]	@ 0x250
 8017b40:	edc9 8a95 	vstr	s17, [r9, #596]	@ 0x254
 8017b44:	edc9 8a96 	vstr	s17, [r9, #600]	@ 0x258
 8017b48:	edc9 8a97 	vstr	s17, [r9, #604]	@ 0x25c
 8017b4c:	edc9 8a98 	vstr	s17, [r9, #608]	@ 0x260
 8017b50:	edc9 8a70 	vstr	s17, [r9, #448]	@ 0x1c0
 8017b54:	edc9 8a99 	vstr	s17, [r9, #612]	@ 0x264
 8017b58:	edc9 8a9a 	vstr	s17, [r9, #616]	@ 0x268
 8017b5c:	edc9 8a9b 	vstr	s17, [r9, #620]	@ 0x26c
 8017b60:	edc9 8a9c 	vstr	s17, [r9, #624]	@ 0x270
 8017b64:	edc9 8a9e 	vstr	s17, [r9, #632]	@ 0x278
 8017b68:	edc9 7aa7 	vstr	s15, [r9, #668]	@ 0x29c
 8017b6c:	edc9 7ab1 	vstr	s15, [r9, #708]	@ 0x2c4
 8017b70:	edc9 7abb 	vstr	s15, [r9, #748]	@ 0x2ec
 8017b74:	edc9 8a9f 	vstr	s17, [r9, #636]	@ 0x27c
 8017b78:	edc9 8aa0 	vstr	s17, [r9, #640]	@ 0x280
 8017b7c:	edc9 8aa1 	vstr	s17, [r9, #644]	@ 0x284
 8017b80:	edc9 8a71 	vstr	s17, [r9, #452]	@ 0x1c4
 8017b84:	edc9 8aa2 	vstr	s17, [r9, #648]	@ 0x288
 8017b88:	edc9 8aa3 	vstr	s17, [r9, #652]	@ 0x28c
 8017b8c:	edc9 8aa4 	vstr	s17, [r9, #656]	@ 0x290
 8017b90:	edc9 8aa5 	vstr	s17, [r9, #660]	@ 0x294
 8017b94:	edc9 8aa6 	vstr	s17, [r9, #664]	@ 0x298
 8017b98:	edc9 8aa8 	vstr	s17, [r9, #672]	@ 0x2a0
 8017b9c:	edc9 8aa9 	vstr	s17, [r9, #676]	@ 0x2a4
 8017ba0:	edc9 8aaa 	vstr	s17, [r9, #680]	@ 0x2a8
 8017ba4:	edc9 8a72 	vstr	s17, [r9, #456]	@ 0x1c8
 8017ba8:	edc9 8aab 	vstr	s17, [r9, #684]	@ 0x2ac
 8017bac:	edc9 8aac 	vstr	s17, [r9, #688]	@ 0x2b0
 8017bb0:	edc9 8aad 	vstr	s17, [r9, #692]	@ 0x2b4
 8017bb4:	edc9 8aae 	vstr	s17, [r9, #696]	@ 0x2b8
 8017bb8:	edc9 8aaf 	vstr	s17, [r9, #700]	@ 0x2bc
 8017bbc:	edc9 8ab0 	vstr	s17, [r9, #704]	@ 0x2c0
 8017bc0:	edc9 8ab2 	vstr	s17, [r9, #712]	@ 0x2c8
 8017bc4:	edc9 8ab3 	vstr	s17, [r9, #716]	@ 0x2cc
 8017bc8:	edc9 8a73 	vstr	s17, [r9, #460]	@ 0x1cc
 8017bcc:	edc9 8ab4 	vstr	s17, [r9, #720]	@ 0x2d0
 8017bd0:	edc9 8ab5 	vstr	s17, [r9, #724]	@ 0x2d4
 8017bd4:	edc9 8ab6 	vstr	s17, [r9, #728]	@ 0x2d8
 8017bd8:	edc9 8ab7 	vstr	s17, [r9, #732]	@ 0x2dc
 8017bdc:	edc9 8ab8 	vstr	s17, [r9, #736]	@ 0x2e0
 8017be0:	edc9 8ab9 	vstr	s17, [r9, #740]	@ 0x2e4
 8017be4:	edc9 8aba 	vstr	s17, [r9, #744]	@ 0x2e8
 8017be8:	edc9 8abc 	vstr	s17, [r9, #752]	@ 0x2f0
 8017bec:	9a04      	ldr	r2, [sp, #16]
 8017bee:	f889 11ac 	strb.w	r1, [r9, #428]	@ 0x1ac
 8017bf2:	edc9 8a74 	vstr	s17, [r9, #464]	@ 0x1d0
 8017bf6:	edc9 7ac5 	vstr	s15, [r9, #788]	@ 0x314
 8017bfa:	9203      	str	r2, [sp, #12]
 8017bfc:	f50d 624a 	add.w	r2, sp, #3232	@ 0xca0
 8017c00:	9202      	str	r2, [sp, #8]
 8017c02:	f50d 6233 	add.w	r2, sp, #2864	@ 0xb30
 8017c06:	9201      	str	r2, [sp, #4]
 8017c08:	f50d 621c 	add.w	r2, sp, #2496	@ 0x9c0
 8017c0c:	9200      	str	r2, [sp, #0]
 8017c0e:	7820      	ldrb	r0, [r4, #0]
 8017c10:	edc9 8abd 	vstr	s17, [r9, #756]	@ 0x2f4
 8017c14:	f50d 6305 	add.w	r3, sp, #2128	@ 0x850
 8017c18:	f50d 62dc 	add.w	r2, sp, #1760	@ 0x6e0
 8017c1c:	f20d 61bc 	addw	r1, sp, #1724	@ 0x6bc
 8017c20:	edc9 8abe 	vstr	s17, [r9, #760]	@ 0x2f8
 8017c24:	edc9 8abf 	vstr	s17, [r9, #764]	@ 0x2fc
 8017c28:	edc9 8ac0 	vstr	s17, [r9, #768]	@ 0x300
 8017c2c:	edc9 8ac1 	vstr	s17, [r9, #772]	@ 0x304
 8017c30:	edc9 8ac2 	vstr	s17, [r9, #776]	@ 0x308
 8017c34:	edc9 8ac3 	vstr	s17, [r9, #780]	@ 0x30c
 8017c38:	edc9 8ac4 	vstr	s17, [r9, #784]	@ 0x310
 8017c3c:	f7fe f862 	bl	8015d04 <DataHist_parameters>
 8017c40:	f609 1344 	addw	r3, r9, #2372	@ 0x944
 8017c44:	f509 6216 	add.w	r2, r9, #2400	@ 0x960
 8017c48:	f609 1168 	addw	r1, r9, #2408	@ 0x968
 8017c4c:	f509 6017 	add.w	r0, r9, #2416	@ 0x970
 8017c50:	f10d 0c20 	add.w	ip, sp, #32
 8017c54:	9304      	str	r3, [sp, #16]
 8017c56:	9205      	str	r2, [sp, #20]
 8017c58:	9106      	str	r1, [sp, #24]
 8017c5a:	9007      	str	r0, [sp, #28]
 8017c5c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017c60:	f8c9 393c 	str.w	r3, [r9, #2364]	@ 0x93c
 8017c64:	9b04      	ldr	r3, [sp, #16]
 8017c66:	f8c9 0930 	str.w	r0, [r9, #2352]	@ 0x930
 8017c6a:	f8c9 1934 	str.w	r1, [r9, #2356]	@ 0x934
 8017c6e:	f8c9 2938 	str.w	r2, [r9, #2360]	@ 0x938
 8017c72:	9906      	ldr	r1, [sp, #24]
 8017c74:	9a05      	ldr	r2, [sp, #20]
 8017c76:	9807      	ldr	r0, [sp, #28]
 8017c78:	f509 6b14 	add.w	fp, r9, #2368	@ 0x940
 8017c7c:	f609 1a5c 	addw	sl, r9, #2396	@ 0x95c
 8017c80:	edcb 8a00 	vstr	s17, [fp]
 8017c84:	f609 1748 	addw	r7, r9, #2376	@ 0x948
 8017c88:	edca 8a00 	vstr	s17, [sl]
 8017c8c:	f609 1664 	addw	r6, r9, #2404	@ 0x964
 8017c90:	edc3 8a00 	vstr	s17, [r3]
 8017c94:	f609 1554 	addw	r5, r9, #2388	@ 0x954
 8017c98:	f609 1458 	addw	r4, r9, #2392	@ 0x958
 8017c9c:	f609 1e6c 	addw	lr, r9, #2412	@ 0x96c
 8017ca0:	230a      	movs	r3, #10
 8017ca2:	edc2 8a00 	vstr	s17, [r2]
 8017ca6:	edc7 8a00 	vstr	s17, [r7]
 8017caa:	edc6 8a00 	vstr	s17, [r6]
 8017cae:	f8c9 894c 	str.w	r8, [r9, #2380]	@ 0x94c
 8017cb2:	f8a9 8950 	strh.w	r8, [r9, #2384]	@ 0x950
 8017cb6:	edc5 8a00 	vstr	s17, [r5]
 8017cba:	ed84 8a00 	vstr	s16, [r4]
 8017cbe:	edc1 8a00 	vstr	s17, [r1]
 8017cc2:	edc0 8a00 	vstr	s17, [r0]
 8017cc6:	edce 8a00 	vstr	s17, [lr]
 8017cca:	f8c9 3974 	str.w	r3, [r9, #2420]	@ 0x974
 8017cce:	f889 8978 	strb.w	r8, [r9, #2424]	@ 0x978
 8017cd2:	f60d 4dd4 	addw	sp, sp, #3284	@ 0xcd4
 8017cd6:	ecbd 8b02 	vpop	{d8}
 8017cda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017cde:	bf00      	nop

08017ce0 <iNemoEngine_API_Update>:
 8017ce0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017ce4:	ed2d 8b10 	vpush	{d8-d15}
 8017ce8:	f2ad 5d94 	subw	sp, sp, #1428	@ 0x594
 8017cec:	eeb0 8a40 	vmov.f32	s16, s0
 8017cf0:	9006      	str	r0, [sp, #24]
 8017cf2:	9114      	str	r1, [sp, #80]	@ 0x50
 8017cf4:	4614      	mov	r4, r2
 8017cf6:	9324      	str	r3, [sp, #144]	@ 0x90
 8017cf8:	2b00      	cmp	r3, #0
 8017cfa:	f000 8222 	beq.w	8018142 <iNemoEngine_API_Update+0x462>
 8017cfe:	68e0      	ldr	r0, [r4, #12]
 8017d00:	6921      	ldr	r1, [r4, #16]
 8017d02:	6962      	ldr	r2, [r4, #20]
 8017d04:	9d06      	ldr	r5, [sp, #24]
 8017d06:	aba1      	add	r3, sp, #644	@ 0x284
 8017d08:	c307      	stmia	r3!, {r0, r1, r2}
 8017d0a:	6820      	ldr	r0, [r4, #0]
 8017d0c:	6861      	ldr	r1, [r4, #4]
 8017d0e:	68a2      	ldr	r2, [r4, #8]
 8017d10:	ab9e      	add	r3, sp, #632	@ 0x278
 8017d12:	c307      	stmia	r3!, {r0, r1, r2}
 8017d14:	69a0      	ldr	r0, [r4, #24]
 8017d16:	69e1      	ldr	r1, [r4, #28]
 8017d18:	6a22      	ldr	r2, [r4, #32]
 8017d1a:	f895 4978 	ldrb.w	r4, [r5, #2424]	@ 0x978
 8017d1e:	aba4      	add	r3, sp, #656	@ 0x290
 8017d20:	c307      	stmia	r3!, {r0, r1, r2}
 8017d22:	b12c      	cbz	r4, 8017d30 <iNemoEngine_API_Update+0x50>
 8017d24:	f8b5 2950 	ldrh.w	r2, [r5, #2384]	@ 0x950
 8017d28:	792b      	ldrb	r3, [r5, #4]
 8017d2a:	429a      	cmp	r2, r3
 8017d2c:	f082 82a5 	bcs.w	801a27a <iNemoEngine_API_Update+0x259a>
 8017d30:	9c06      	ldr	r4, [sp, #24]
 8017d32:	ae31      	add	r6, sp, #196	@ 0xc4
 8017d34:	f104 033a 	add.w	r3, r4, #58	@ 0x3a
 8017d38:	4619      	mov	r1, r3
 8017d3a:	4630      	mov	r0, r6
 8017d3c:	aaa1      	add	r2, sp, #644	@ 0x284
 8017d3e:	9320      	str	r3, [sp, #128]	@ 0x80
 8017d40:	ad37      	add	r5, sp, #220	@ 0xdc
 8017d42:	f7fe f897 	bl	8015e74 <rotVect>
 8017d46:	aaa4      	add	r2, sp, #656	@ 0x290
 8017d48:	f104 014c 	add.w	r1, r4, #76	@ 0x4c
 8017d4c:	a834      	add	r0, sp, #208	@ 0xd0
 8017d4e:	f7fe f891 	bl	8015e74 <rotVect>
 8017d52:	aa9e      	add	r2, sp, #632	@ 0x278
 8017d54:	f104 0143 	add.w	r1, r4, #67	@ 0x43
 8017d58:	4628      	mov	r0, r5
 8017d5a:	f7fe f88b 	bl	8015e74 <rotVect>
 8017d5e:	f894 3039 	ldrb.w	r3, [r4, #57]	@ 0x39
 8017d62:	b923      	cbnz	r3, 8017d6e <iNemoEngine_API_Update+0x8e>
 8017d64:	4b9d      	ldr	r3, [pc, #628]	@ (8017fdc <iNemoEngine_API_Update+0x2fc>)
 8017d66:	606b      	str	r3, [r5, #4]
 8017d68:	60ab      	str	r3, [r5, #8]
 8017d6a:	2300      	movs	r3, #0
 8017d6c:	602b      	str	r3, [r5, #0]
 8017d6e:	9b06      	ldr	r3, [sp, #24]
 8017d70:	f8d3 794c 	ldr.w	r7, [r3, #2380]	@ 0x94c
 8017d74:	2f09      	cmp	r7, #9
 8017d76:	d851      	bhi.n	8017e1c <iNemoEngine_API_Update+0x13c>
 8017d78:	edd6 aa01 	vldr	s21, [r6, #4]
 8017d7c:	ed96 ba00 	vldr	s22, [r6]
 8017d80:	ed96 aa02 	vldr	s20, [r6, #8]
 8017d84:	ee6a 7aaa 	vmul.f32	s15, s21, s21
 8017d88:	eef7 ba00 	vmov.f32	s23, #112	@ 0x3f800000  1.0
 8017d8c:	eeeb 7a0b 	vfma.f32	s15, s22, s22
 8017d90:	eeea 7a0a 	vfma.f32	s15, s20, s20
 8017d94:	ee17 0a90 	vmov	r0, s15
 8017d98:	f7e8 fbde 	bl	8000558 <__aeabi_f2d>
 8017d9c:	ec41 0b10 	vmov	d0, r0, r1
 8017da0:	f007 fc4e 	bl	801f640 <sqrt>
 8017da4:	ec51 0b10 	vmov	r0, r1, d0
 8017da8:	f7e8 ff26 	bl	8000bf8 <__aeabi_d2f>
 8017dac:	ee07 0a90 	vmov	s15, r0
 8017db0:	ee8b 7aa7 	vdiv.f32	s14, s23, s15
 8017db4:	ed95 9a01 	vldr	s18, [r5, #4]
 8017db8:	edd5 9a00 	vldr	s19, [r5]
 8017dbc:	edd5 8a02 	vldr	s17, [r5, #8]
 8017dc0:	ee69 7a09 	vmul.f32	s15, s18, s18
 8017dc4:	ee2b ba07 	vmul.f32	s22, s22, s14
 8017dc8:	eee9 7aa9 	vfma.f32	s15, s19, s19
 8017dcc:	ee6a aa87 	vmul.f32	s21, s21, s14
 8017dd0:	eee8 7aa8 	vfma.f32	s15, s17, s17
 8017dd4:	ee2a aa07 	vmul.f32	s20, s20, s14
 8017dd8:	ee17 0a90 	vmov	r0, s15
 8017ddc:	ed86 ba00 	vstr	s22, [r6]
 8017de0:	edc6 aa01 	vstr	s21, [r6, #4]
 8017de4:	ed86 aa02 	vstr	s20, [r6, #8]
 8017de8:	f7e8 fbb6 	bl	8000558 <__aeabi_f2d>
 8017dec:	ec41 0b10 	vmov	d0, r0, r1
 8017df0:	f007 fc26 	bl	801f640 <sqrt>
 8017df4:	ec51 0b10 	vmov	r0, r1, d0
 8017df8:	f7e8 fefe 	bl	8000bf8 <__aeabi_d2f>
 8017dfc:	ee07 0a90 	vmov	s15, r0
 8017e00:	eecb 7aa7 	vdiv.f32	s15, s23, s15
 8017e04:	ee69 9aa7 	vmul.f32	s19, s19, s15
 8017e08:	ee29 9a27 	vmul.f32	s18, s18, s15
 8017e0c:	ee68 8aa7 	vmul.f32	s17, s17, s15
 8017e10:	edc5 9a00 	vstr	s19, [r5]
 8017e14:	ed85 9a01 	vstr	s18, [r5, #4]
 8017e18:	edc5 8a02 	vstr	s17, [r5, #8]
 8017e1c:	9906      	ldr	r1, [sp, #24]
 8017e1e:	790b      	ldrb	r3, [r1, #4]
 8017e20:	f8b1 2950 	ldrh.w	r2, [r1, #2384]	@ 0x950
 8017e24:	429a      	cmp	r2, r3
 8017e26:	f080 80f5 	bcs.w	8018014 <iNemoEngine_API_Update+0x334>
 8017e2a:	abf8      	add	r3, sp, #992	@ 0x3e0
 8017e2c:	9319      	str	r3, [sp, #100]	@ 0x64
 8017e2e:	f501 6313 	add.w	r3, r1, #2352	@ 0x930
 8017e32:	931c      	str	r3, [sp, #112]	@ 0x70
 8017e34:	f601 1334 	addw	r3, r1, #2356	@ 0x934
 8017e38:	931d      	str	r3, [sp, #116]	@ 0x74
 8017e3a:	f601 1338 	addw	r3, r1, #2360	@ 0x938
 8017e3e:	931e      	str	r3, [sp, #120]	@ 0x78
 8017e40:	eddd 9af5 	vldr	s19, [sp, #980]	@ 0x3d4
 8017e44:	f601 133c 	addw	r3, r1, #2364	@ 0x93c
 8017e48:	accc      	add	r4, sp, #816	@ 0x330
 8017e4a:	931f      	str	r3, [sp, #124]	@ 0x7c
 8017e4c:	460d      	mov	r5, r1
 8017e4e:	3701      	adds	r7, #1
 8017e50:	9819      	ldr	r0, [sp, #100]	@ 0x64
 8017e52:	9920      	ldr	r1, [sp, #128]	@ 0x80
 8017e54:	f8c5 794c 	str.w	r7, [r5, #2380]	@ 0x94c
 8017e58:	aaa1      	add	r2, sp, #644	@ 0x284
 8017e5a:	f7fe f80b 	bl	8015e74 <rotVect>
 8017e5e:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 8017e60:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 8017e62:	681b      	ldr	r3, [r3, #0]
 8017e64:	60d3      	str	r3, [r2, #12]
 8017e66:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8017e68:	681b      	ldr	r3, [r3, #0]
 8017e6a:	6113      	str	r3, [r2, #16]
 8017e6c:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8017e6e:	681b      	ldr	r3, [r3, #0]
 8017e70:	6153      	str	r3, [r2, #20]
 8017e72:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 8017e74:	681b      	ldr	r3, [r3, #0]
 8017e76:	6193      	str	r3, [r2, #24]
 8017e78:	f895 3038 	ldrb.w	r3, [r5, #56]	@ 0x38
 8017e7c:	9301      	str	r3, [sp, #4]
 8017e7e:	4601      	mov	r1, r0
 8017e80:	f102 0328 	add.w	r3, r2, #40	@ 0x28
 8017e84:	4610      	mov	r0, r2
 8017e86:	4615      	mov	r5, r2
 8017e88:	300c      	adds	r0, #12
 8017e8a:	9300      	str	r3, [sp, #0]
 8017e8c:	f102 031c 	add.w	r3, r2, #28
 8017e90:	f7ff fb6c 	bl	801756c <output_update>
 8017e94:	ed95 8a00 	vldr	s16, [r5]
 8017e98:	ed95 aa01 	vldr	s20, [r5, #4]
 8017e9c:	eeb0 0a48 	vmov.f32	s0, s16
 8017ea0:	f007 fd58 	bl	801f954 <sinf>
 8017ea4:	eeb0 9a40 	vmov.f32	s18, s0
 8017ea8:	eeb0 0a48 	vmov.f32	s0, s16
 8017eac:	f007 fd06 	bl	801f8bc <cosf>
 8017eb0:	edd4 7a33 	vldr	s15, [r4, #204]	@ 0xcc
 8017eb4:	edd4 6a3d 	vldr	s13, [r4, #244]	@ 0xf4
 8017eb8:	ee60 8a00 	vmul.f32	s17, s0, s0
 8017ebc:	eeb0 7aca 	vabs.f32	s14, s20
 8017ec0:	ee68 8aa7 	vmul.f32	s17, s17, s15
 8017ec4:	eddf 7a46 	vldr	s15, [pc, #280]	@ 8017fe0 <iNemoEngine_API_Update+0x300>
 8017ec8:	ee29 9a09 	vmul.f32	s18, s18, s18
 8017ecc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8017ed0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017ed4:	eee9 8a26 	vfma.f32	s17, s18, s13
 8017ed8:	d579      	bpl.n	8017fce <iNemoEngine_API_Update+0x2ee>
 8017eda:	eeb0 0a4a 	vmov.f32	s0, s20
 8017ede:	f007 fd7f 	bl	801f9e0 <tanf>
 8017ee2:	ee20 0a00 	vmul.f32	s0, s0, s0
 8017ee6:	eeb0 7a69 	vmov.f32	s14, s19
 8017eea:	eea0 7a28 	vfma.f32	s14, s0, s17
 8017eee:	9d14      	ldr	r5, [sp, #80]	@ 0x50
 8017ef0:	9b06      	ldr	r3, [sp, #24]
 8017ef2:	eddf 6a3c 	vldr	s13, [pc, #240]	@ 8017fe4 <iNemoEngine_API_Update+0x304>
 8017ef6:	4c3c      	ldr	r4, [pc, #240]	@ (8017fe8 <iNemoEngine_API_Update+0x308>)
 8017ef8:	eef1 7ac7 	vsqrt.f32	s15, s14
 8017efc:	ed9f 7a42 	vldr	s14, [pc, #264]	@ 8018008 <iNemoEngine_API_Update+0x328>
 8017f00:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8017f04:	eef4 7ae6 	vcmpe.f32	s15, s13
 8017f08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017f0c:	bf88      	it	hi
 8017f0e:	eef0 7a66 	vmovhi.f32	s15, s13
 8017f12:	eef4 7ac7 	vcmpe.f32	s15, s14
 8017f16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017f1a:	bfb8      	it	lt
 8017f1c:	eef0 7a47 	vmovlt.f32	s15, s14
 8017f20:	edc5 7a0e 	vstr	s15, [r5, #56]	@ 0x38
 8017f24:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 8017f28:	bbd3      	cbnz	r3, 8017fa0 <iNemoEngine_API_Update+0x2c0>
 8017f2a:	ed95 1a09 	vldr	s2, [r5, #36]	@ 0x24
 8017f2e:	f8d4 03c0 	ldr.w	r0, [r4, #960]	@ 0x3c0
 8017f32:	edd5 0a08 	vldr	s1, [r5, #32]
 8017f36:	ed95 0a07 	vldr	s0, [r5, #28]
 8017f3a:	f7fe f86d 	bl	8016018 <findDirection>
 8017f3e:	ed95 7a03 	vldr	s14, [r5, #12]
 8017f42:	edd5 6a04 	vldr	s13, [r5, #16]
 8017f46:	edd5 8a05 	vldr	s17, [r5, #20]
 8017f4a:	edd5 7a06 	vldr	s15, [r5, #24]
 8017f4e:	f8c4 03c0 	str.w	r0, [r4, #960]	@ 0x3c0
 8017f52:	2805      	cmp	r0, #5
 8017f54:	f204 822c 	bhi.w	801c3b0 <iNemoEngine_API_Update+0x46d0>
 8017f58:	e8df f010 	tbh	[pc, r0, lsl #1]
 8017f5c:	11d0000a 	.word	0x11d0000a
 8017f60:	11990006 	.word	0x11990006
 8017f64:	000a0006 	.word	0x000a0006
 8017f68:	eddf 7a20 	vldr	s15, [pc, #128]	@ 8017fec <iNemoEngine_API_Update+0x30c>
 8017f6c:	ee38 8a27 	vadd.f32	s16, s16, s15
 8017f70:	eddf 7a1f 	vldr	s15, [pc, #124]	@ 8017ff0 <iNemoEngine_API_Update+0x310>
 8017f74:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8017f78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017f7c:	bfa8      	it	ge
 8017f7e:	ee38 8a67 	vsubge.f32	s16, s16, s15
 8017f82:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8017f86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017f8a:	f100 80d5 	bmi.w	8018138 <iNemoEngine_API_Update+0x458>
 8017f8e:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 8017f90:	ed83 8a0d 	vstr	s16, [r3, #52]	@ 0x34
 8017f94:	f20d 5d94 	addw	sp, sp, #1428	@ 0x594
 8017f98:	ecbd 8b10 	vpop	{d8-d15}
 8017f9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017fa0:	ed95 1a09 	vldr	s2, [r5, #36]	@ 0x24
 8017fa4:	edd5 8a05 	vldr	s17, [r5, #20]
 8017fa8:	f8d4 03c0 	ldr.w	r0, [r4, #960]	@ 0x3c0
 8017fac:	edd5 0a07 	vldr	s1, [r5, #28]
 8017fb0:	ed95 0a08 	vldr	s0, [r5, #32]
 8017fb4:	eeb1 1a41 	vneg.f32	s2, s2
 8017fb8:	f7fe f82e 	bl	8016018 <findDirection>
 8017fbc:	eef1 8a68 	vneg.f32	s17, s17
 8017fc0:	ed95 7a04 	vldr	s14, [r5, #16]
 8017fc4:	edd5 6a03 	vldr	s13, [r5, #12]
 8017fc8:	edd5 7a06 	vldr	s15, [r5, #24]
 8017fcc:	e7bf      	b.n	8017f4e <iNemoEngine_API_Update+0x26e>
 8017fce:	eddf 7a09 	vldr	s15, [pc, #36]	@ 8017ff4 <iNemoEngine_API_Update+0x314>
 8017fd2:	eeb0 7a69 	vmov.f32	s14, s19
 8017fd6:	eea8 7aa7 	vfma.f32	s14, s17, s15
 8017fda:	e788      	b.n	8017eee <iNemoEngine_API_Update+0x20e>
 8017fdc:	3f333333 	.word	0x3f333333
 8017fe0:	3fbc430e 	.word	0x3fbc430e
 8017fe4:	40490fdb 	.word	0x40490fdb
 8017fe8:	2000054c 	.word	0x2000054c
 8017fec:	43340000 	.word	0x43340000
 8017ff0:	43b40000 	.word	0x43b40000
 8017ff4:	42c6ab07 	.word	0x42c6ab07
 8017ff8:	3c03126f 	.word	0x3c03126f
 8017ffc:	3b656042 	.word	0x3b656042
 8018000:	3e4ccccd 	.word	0x3e4ccccd
 8018004:	3fb50481 	.word	0x3fb50481
 8018008:	3c8efa35 	.word	0x3c8efa35
 801800c:	3ed93dd9 	.word	0x3ed93dd9
 8018010:	42c80000 	.word	0x42c80000
 8018014:	ee07 3a90 	vmov	s15, r3
 8018018:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801801c:	ed1f 7a0a 	vldr	s14, [pc, #-40]	@ 8017ff8 <iNemoEngine_API_Update+0x318>
 8018020:	ed5f 6a0a 	vldr	s13, [pc, #-40]	@ 8017ffc <iNemoEngine_API_Update+0x31c>
 8018024:	ed5f ba08 	vldr	s23, [pc, #-32]	@ 8018008 <iNemoEngine_API_Update+0x328>
 8018028:	ed1f 6a0a 	vldr	s12, [pc, #-40]	@ 8018004 <iNemoEngine_API_Update+0x324>
 801802c:	ed5f 4a0c 	vldr	s9, [pc, #-48]	@ 8018000 <iNemoEngine_API_Update+0x320>
 8018030:	ee67 7a88 	vmul.f32	s15, s15, s16
 8018034:	4608      	mov	r0, r1
 8018036:	eec7 5a27 	vdiv.f32	s11, s14, s15
 801803a:	f601 125c 	addw	r2, r1, #2396	@ 0x95c
 801803e:	2300      	movs	r3, #0
 8018040:	2100      	movs	r1, #0
 8018042:	f50d 7cb2 	add.w	ip, sp, #356	@ 0x164
 8018046:	ac56      	add	r4, sp, #344	@ 0x158
 8018048:	edcd 7a07 	vstr	s15, [sp, #28]
 801804c:	eef1 7ae5 	vsqrt.f32	s15, s11
 8018050:	ed1f 7a12 	vldr	s14, [pc, #-72]	@ 801800c <iNemoEngine_API_Update+0x32c>
 8018054:	ee86 4aa7 	vdiv.f32	s8, s13, s15
 8018058:	ee67 6a87 	vmul.f32	s13, s15, s14
 801805c:	ed92 7a00 	vldr	s14, [r2]
 8018060:	f8a0 1950 	strh.w	r1, [r0, #2384]	@ 0x950
 8018064:	6013      	str	r3, [r2, #0]
 8018066:	f500 6216 	add.w	r2, r0, #2400	@ 0x960
 801806a:	ee27 ea2b 	vmul.f32	s28, s14, s23
 801806e:	ed8d 7a1a 	vstr	s14, [sp, #104]	@ 0x68
 8018072:	ed92 7a00 	vldr	s14, [r2]
 8018076:	6013      	str	r3, [r2, #0]
 8018078:	f600 1264 	addw	r2, r0, #2404	@ 0x964
 801807c:	ee67 ea2b 	vmul.f32	s29, s14, s23
 8018080:	ed8d 7a1c 	vstr	s14, [sp, #112]	@ 0x70
 8018084:	ed92 7a00 	vldr	s14, [r2]
 8018088:	6013      	str	r3, [r2, #0]
 801808a:	7947      	ldrb	r7, [r0, #5]
 801808c:	ed8d 7a18 	vstr	s14, [sp, #96]	@ 0x60
 8018090:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8018094:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
 8018098:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801809c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 80180a0:	9a06      	ldr	r2, [sp, #24]
 80180a2:	f8d2 01c8 	ldr.w	r0, [r2, #456]	@ 0x1c8
 80180a6:	f8d2 11cc 	ldr.w	r1, [r2, #460]	@ 0x1cc
 80180aa:	f8d2 21d0 	ldr.w	r2, [r2, #464]	@ 0x1d0
 80180ae:	abd9      	add	r3, sp, #868	@ 0x364
 80180b0:	2f01      	cmp	r7, #1
 80180b2:	c307      	stmia	r3!, {r0, r1, r2}
 80180b4:	ee27 6a86 	vmul.f32	s12, s15, s12
 80180b8:	ee67 4aa4 	vmul.f32	s9, s15, s9
 80180bc:	ee67 ba2b 	vmul.f32	s23, s14, s23
 80180c0:	f002 844a 	beq.w	801a958 <iNemoEngine_API_Update+0x2c78>
 80180c4:	2f02      	cmp	r7, #2
 80180c6:	f002 843c 	beq.w	801a942 <iNemoEngine_API_Update+0x2c62>
 80180ca:	2f00      	cmp	r7, #0
 80180cc:	f002 814d 	beq.w	801a36a <iNemoEngine_API_Update+0x268a>
 80180d0:	9b06      	ldr	r3, [sp, #24]
 80180d2:	ed5f 5a31 	vldr	s11, [pc, #-196]	@ 8018010 <iNemoEngine_API_Update+0x330>
 80180d6:	ed93 ba05 	vldr	s22, [r3, #20]
 80180da:	491b      	ldr	r1, [pc, #108]	@ (8018148 <iNemoEngine_API_Update+0x468>)
 80180dc:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 80180e0:	ee2b ba25 	vmul.f32	s22, s22, s11
 80180e4:	ee67 7a87 	vmul.f32	s15, s15, s14
 80180e8:	4618      	mov	r0, r3
 80180ea:	8842      	ldrh	r2, [r0, #2]
 80180ec:	1e53      	subs	r3, r2, #1
 80180ee:	2b12      	cmp	r3, #18
 80180f0:	d834      	bhi.n	801815c <iNemoEngine_API_Update+0x47c>
 80180f2:	3201      	adds	r2, #1
 80180f4:	b213      	sxth	r3, r2
 80180f6:	b292      	uxth	r2, r2
 80180f8:	2a03      	cmp	r2, #3
 80180fa:	8043      	strh	r3, [r0, #2]
 80180fc:	f242 8401 	bls.w	801a902 <iNemoEngine_API_Update+0x2c22>
 8018100:	ee07 3a10 	vmov	s14, r3
 8018104:	eddf 5a11 	vldr	s11, [pc, #68]	@ 801814c <iNemoEngine_API_Update+0x46c>
 8018108:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 801810c:	4603      	mov	r3, r0
 801810e:	ee27 7a25 	vmul.f32	s14, s14, s11
 8018112:	ee84 4a07 	vdiv.f32	s8, s8, s14
 8018116:	ed93 5a0d 	vldr	s10, [r3, #52]	@ 0x34
 801811a:	ed8d 4a22 	vstr	s8, [sp, #136]	@ 0x88
 801811e:	ee66 5a87 	vmul.f32	s11, s13, s14
 8018122:	ee66 6a05 	vmul.f32	s13, s12, s10
 8018126:	ed9f 6a0c 	vldr	s12, [pc, #48]	@ 8018158 <iNemoEngine_API_Update+0x478>
 801812a:	ee66 6a87 	vmul.f32	s13, s13, s14
 801812e:	ee24 6a86 	vmul.f32	s12, s9, s12
 8018132:	eeb0 7a65 	vmov.f32	s14, s11
 8018136:	e02d      	b.n	8018194 <iNemoEngine_API_Update+0x4b4>
 8018138:	eddf 7a05 	vldr	s15, [pc, #20]	@ 8018150 <iNemoEngine_API_Update+0x470>
 801813c:	ee38 8a27 	vadd.f32	s16, s16, s15
 8018140:	e725      	b.n	8017f8e <iNemoEngine_API_Update+0x2ae>
 8018142:	ab46      	add	r3, sp, #280	@ 0x118
 8018144:	9324      	str	r3, [sp, #144]	@ 0x90
 8018146:	e5da      	b.n	8017cfe <iNemoEngine_API_Update+0x1e>
 8018148:	3a83126f 	.word	0x3a83126f
 801814c:	3d4ccccd 	.word	0x3d4ccccd
 8018150:	43b40000 	.word	0x43b40000
 8018154:	358637bd 	.word	0x358637bd
 8018158:	3f333333 	.word	0x3f333333
 801815c:	ed1f 5a03 	vldr	s10, [pc, #-12]	@ 8018154 <iNemoEngine_API_Update+0x474>
 8018160:	ed90 7a0c 	vldr	s14, [r0, #48]	@ 0x30
 8018164:	edd0 5a0b 	vldr	s11, [r0, #44]	@ 0x2c
 8018168:	ee37 7a05 	vadd.f32	s14, s14, s10
 801816c:	ed90 5a0d 	vldr	s10, [r0, #52]	@ 0x34
 8018170:	ee84 7a07 	vdiv.f32	s14, s8, s14
 8018174:	2300      	movs	r3, #0
 8018176:	8043      	strh	r3, [r0, #2]
 8018178:	ee66 5aa5 	vmul.f32	s11, s13, s11
 801817c:	ed8d 7a22 	vstr	s14, [sp, #136]	@ 0x88
 8018180:	ed90 7a0a 	vldr	s14, [r0, #40]	@ 0x28
 8018184:	ee26 7a87 	vmul.f32	s14, s13, s14
 8018188:	ee66 6a05 	vmul.f32	s13, s12, s10
 801818c:	ed1f 6a0e 	vldr	s12, [pc, #-56]	@ 8018158 <iNemoEngine_API_Update+0x478>
 8018190:	ee24 6a86 	vmul.f32	s12, s9, s12
 8018194:	eef7 4a08 	vmov.f32	s9, #120	@ 0x3fc00000  1.5
 8018198:	ee25 5a24 	vmul.f32	s10, s10, s9
 801819c:	edcd 7a89 	vstr	s15, [sp, #548]	@ 0x224
 80181a0:	edcd 7a8a 	vstr	s15, [sp, #552]	@ 0x228
 80181a4:	edcd 7a8b 	vstr	s15, [sp, #556]	@ 0x22c
 80181a8:	eddd 7a22 	vldr	s15, [sp, #136]	@ 0x88
 80181ac:	4bdd      	ldr	r3, [pc, #884]	@ (8018524 <iNemoEngine_API_Update+0x844>)
 80181ae:	9162      	str	r1, [sp, #392]	@ 0x188
 80181b0:	a8f8      	add	r0, sp, #992	@ 0x3e0
 80181b2:	9163      	str	r1, [sp, #396]	@ 0x18c
 80181b4:	9164      	str	r1, [sp, #400]	@ 0x190
 80181b6:	f44f 72d8 	mov.w	r2, #432	@ 0x1b0
 80181ba:	2100      	movs	r1, #0
 80181bc:	4605      	mov	r5, r0
 80181be:	9367      	str	r3, [sp, #412]	@ 0x19c
 80181c0:	9019      	str	r0, [sp, #100]	@ 0x64
 80181c2:	edcd 5a83 	vstr	s11, [sp, #524]	@ 0x20c
 80181c6:	edcd 5a84 	vstr	s11, [sp, #528]	@ 0x210
 80181ca:	edcd 5a85 	vstr	s11, [sp, #532]	@ 0x214
 80181ce:	ed8d 7a86 	vstr	s14, [sp, #536]	@ 0x218
 80181d2:	ed8d 7a87 	vstr	s14, [sp, #540]	@ 0x21c
 80181d6:	ed8d 7a88 	vstr	s14, [sp, #544]	@ 0x220
 80181da:	edcd 6a8c 	vstr	s13, [sp, #560]	@ 0x230
 80181de:	ed8d 6a8d 	vstr	s12, [sp, #564]	@ 0x234
 80181e2:	ed8d 5a8e 	vstr	s10, [sp, #568]	@ 0x238
 80181e6:	edcd 7a5f 	vstr	s15, [sp, #380]	@ 0x17c
 80181ea:	edcd 7a60 	vstr	s15, [sp, #384]	@ 0x180
 80181ee:	edcd 7a61 	vstr	s15, [sp, #388]	@ 0x184
 80181f2:	f005 fa28 	bl	801d646 <memset>
 80181f6:	9b06      	ldr	r3, [sp, #24]
 80181f8:	7b5a      	ldrb	r2, [r3, #13]
 80181fa:	f04f 537e 	mov.w	r3, #1065353216	@ 0x3f800000
 80181fe:	f8c5 30a8 	str.w	r3, [r5, #168]	@ 0xa8
 8018202:	f8c5 30dc 	str.w	r3, [r5, #220]	@ 0xdc
 8018206:	f8c5 3110 	str.w	r3, [r5, #272]	@ 0x110
 801820a:	f8c5 3144 	str.w	r3, [r5, #324]	@ 0x144
 801820e:	f8c5 3178 	str.w	r3, [r5, #376]	@ 0x178
 8018212:	f8c5 31ac 	str.w	r3, [r5, #428]	@ 0x1ac
 8018216:	2a00      	cmp	r2, #0
 8018218:	f001 8124 	beq.w	8019464 <iNemoEngine_API_Update+0x1784>
 801821c:	ed94 8a01 	vldr	s16, [r4, #4]
 8018220:	edd4 8a00 	vldr	s17, [r4]
 8018224:	ed94 ca02 	vldr	s24, [r4, #8]
 8018228:	ee28 9a08 	vmul.f32	s18, s16, s16
 801822c:	eef8 7a00 	vmov.f32	s15, #128	@ 0xc0000000 -2.0
 8018230:	eea8 9aa8 	vfma.f32	s18, s17, s17
 8018234:	ee68 5a27 	vmul.f32	s11, s16, s15
 8018238:	eeac 9a0c 	vfma.f32	s18, s24, s24
 801823c:	ee6c 6a27 	vmul.f32	s13, s24, s15
 8018240:	eef1 cac9 	vsqrt.f32	s25, s18
 8018244:	ee3c 5a0c 	vadd.f32	s10, s24, s24
 8018248:	ee68 7aa7 	vmul.f32	s15, s17, s15
 801824c:	ee38 6aa8 	vadd.f32	s12, s17, s17
 8018250:	ee38 7a08 	vadd.f32	s14, s16, s16
 8018254:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8018256:	ed94 aa04 	vldr	s20, [r4, #16]
 801825a:	edc3 7a19 	vstr	s15, [r3, #100]	@ 0x64
 801825e:	eef1 7a4a 	vneg.f32	s15, s20
 8018262:	edd4 9a05 	vldr	s19, [r4, #20]
 8018266:	edd4 aa03 	vldr	s21, [r4, #12]
 801826a:	ed83 5a01 	vstr	s10, [r3, #4]
 801826e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8018272:	edc3 5a02 	vstr	s11, [r3, #8]
 8018276:	edc3 7a05 	vstr	s15, [r3, #20]
 801827a:	eef1 7a69 	vneg.f32	s15, s19
 801827e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8018282:	edc3 6a0c 	vstr	s13, [r3, #48]	@ 0x30
 8018286:	edc3 7a0f 	vstr	s15, [r3, #60]	@ 0x3c
 801828a:	eef1 7a6a 	vneg.f32	s15, s21
 801828e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8018292:	ed83 6a0e 	vstr	s12, [r3, #56]	@ 0x38
 8018296:	edc3 7a1c 	vstr	s15, [r3, #112]	@ 0x70
 801829a:	ee79 7aa9 	vadd.f32	s15, s19, s19
 801829e:	ed83 7a18 	vstr	s14, [r3, #96]	@ 0x60
 80182a2:	edc3 7a04 	vstr	s15, [r3, #16]
 80182a6:	ee7a 7aaa 	vadd.f32	s15, s21, s21
 80182aa:	2230      	movs	r2, #48	@ 0x30
 80182ac:	edc3 7a11 	vstr	s15, [r3, #68]	@ 0x44
 80182b0:	ee7a 7a0a 	vadd.f32	s15, s20, s20
 80182b4:	2100      	movs	r1, #0
 80182b6:	edc3 7a1b 	vstr	s15, [r3, #108]	@ 0x6c
 80182ba:	a88f      	add	r0, sp, #572	@ 0x23c
 80182bc:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
 80182c0:	e9cd 333a 	strd	r3, r3, [sp, #232]	@ 0xe8
 80182c4:	933c      	str	r3, [sp, #240]	@ 0xf0
 80182c6:	f005 f9be 	bl	801d646 <memset>
 80182ca:	9a06      	ldr	r2, [sp, #24]
 80182cc:	edd2 7a07 	vldr	s15, [r2, #28]
 80182d0:	ed92 da06 	vldr	s26, [r2, #24]
 80182d4:	f892 31ac 	ldrb.w	r3, [r2, #428]	@ 0x1ac
 80182d8:	ee6b 7a27 	vmul.f32	s15, s22, s15
 80182dc:	ee2b da0d 	vmul.f32	s26, s22, s26
 80182e0:	edcd 7a16 	vstr	s15, [sp, #88]	@ 0x58
 80182e4:	edd2 7a08 	vldr	s15, [r2, #32]
 80182e8:	ee6b 7a27 	vmul.f32	s15, s22, s15
 80182ec:	edcd 7a17 	vstr	s15, [sp, #92]	@ 0x5c
 80182f0:	2b00      	cmp	r3, #0
 80182f2:	f043 8025 	bne.w	801b340 <iNemoEngine_API_Update+0x3660>
 80182f6:	4613      	mov	r3, r2
 80182f8:	f502 6214 	add.w	r2, r2, #2368	@ 0x940
 80182fc:	9225      	str	r2, [sp, #148]	@ 0x94
 80182fe:	f603 1244 	addw	r2, r3, #2372	@ 0x944
 8018302:	f603 1348 	addw	r3, r3, #2376	@ 0x948
 8018306:	9226      	str	r2, [sp, #152]	@ 0x98
 8018308:	9327      	str	r3, [sp, #156]	@ 0x9c
 801830a:	9a06      	ldr	r2, [sp, #24]
 801830c:	f892 3318 	ldrb.w	r3, [r2, #792]	@ 0x318
 8018310:	2b00      	cmp	r3, #0
 8018312:	f042 84db 	bne.w	801accc <iNemoEngine_API_Update+0x2fec>
 8018316:	4613      	mov	r3, r2
 8018318:	f502 6597 	add.w	r5, r2, #1208	@ 0x4b8
 801831c:	f202 47b4 	addw	r7, r2, #1204	@ 0x4b4
 8018320:	f502 66c5 	add.w	r6, r2, #1576	@ 0x628
 8018324:	f202 6824 	addw	r8, r2, #1572	@ 0x624
 8018328:	f203 7394 	addw	r3, r3, #1940	@ 0x794
 801832c:	f502 62f3 	add.w	r2, r2, #1944	@ 0x798
 8018330:	9215      	str	r2, [sp, #84]	@ 0x54
 8018332:	931b      	str	r3, [sp, #108]	@ 0x6c
 8018334:	9b06      	ldr	r3, [sp, #24]
 8018336:	f503 6213 	add.w	r2, r3, #2352	@ 0x930
 801833a:	ed92 6a00 	vldr	s12, [r2]
 801833e:	921c      	str	r2, [sp, #112]	@ 0x70
 8018340:	f603 1134 	addw	r1, r3, #2356	@ 0x934
 8018344:	f603 1038 	addw	r0, r3, #2360	@ 0x938
 8018348:	f603 133c 	addw	r3, r3, #2364	@ 0x93c
 801834c:	edd3 7a00 	vldr	s15, [r3]
 8018350:	edd1 6a00 	vldr	s13, [r1]
 8018354:	ed90 7a00 	vldr	s14, [r0]
 8018358:	931f      	str	r3, [sp, #124]	@ 0x7c
 801835a:	eeb5 6a40 	vcmp.f32	s12, #0.0
 801835e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018362:	911d      	str	r1, [sp, #116]	@ 0x74
 8018364:	901e      	str	r0, [sp, #120]	@ 0x78
 8018366:	ed8d 6a4e 	vstr	s12, [sp, #312]	@ 0x138
 801836a:	edcd 6a4f 	vstr	s13, [sp, #316]	@ 0x13c
 801836e:	ed8d 7a50 	vstr	s14, [sp, #320]	@ 0x140
 8018372:	edcd 7a51 	vstr	s15, [sp, #324]	@ 0x144
 8018376:	f04f 0300 	mov.w	r3, #0
 801837a:	d13a      	bne.n	80183f2 <iNemoEngine_API_Update+0x712>
 801837c:	eef5 6a40 	vcmp.f32	s13, #0.0
 8018380:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018384:	d135      	bne.n	80183f2 <iNemoEngine_API_Update+0x712>
 8018386:	eeb5 7a40 	vcmp.f32	s14, #0.0
 801838a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801838e:	d130      	bne.n	80183f2 <iNemoEngine_API_Update+0x712>
 8018390:	eef5 7a40 	vcmp.f32	s15, #0.0
 8018394:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018398:	d12b      	bne.n	80183f2 <iNemoEngine_API_Update+0x712>
 801839a:	9a06      	ldr	r2, [sp, #24]
 801839c:	934e      	str	r3, [sp, #312]	@ 0x138
 801839e:	934f      	str	r3, [sp, #316]	@ 0x13c
 80183a0:	9350      	str	r3, [sp, #320]	@ 0x140
 80183a2:	4b61      	ldr	r3, [pc, #388]	@ (8018528 <iNemoEngine_API_Update+0x848>)
 80183a4:	f8c2 31c8 	str.w	r3, [r2, #456]	@ 0x1c8
 80183a8:	f04f 537e 	mov.w	r3, #1065353216	@ 0x3f800000
 80183ac:	f8c2 31cc 	str.w	r3, [r2, #460]	@ 0x1cc
 80183b0:	f8c2 31d0 	str.w	r3, [r2, #464]	@ 0x1d0
 80183b4:	9351      	str	r3, [sp, #324]	@ 0x144
 80183b6:	2100      	movs	r1, #0
 80183b8:	4613      	mov	r3, r2
 80183ba:	f882 11ac 	strb.w	r1, [r2, #428]	@ 0x1ac
 80183be:	f503 70ea 	add.w	r0, r3, #468	@ 0x1d4
 80183c2:	f44f 72a2 	mov.w	r2, #324	@ 0x144
 80183c6:	f005 f93e 	bl	801d646 <memset>
 80183ca:	9a06      	ldr	r2, [sp, #24]
 80183cc:	4b57      	ldr	r3, [pc, #348]	@ (801852c <iNemoEngine_API_Update+0x84c>)
 80183ce:	f8c2 31d4 	str.w	r3, [r2, #468]	@ 0x1d4
 80183d2:	f8c2 31fc 	str.w	r3, [r2, #508]	@ 0x1fc
 80183d6:	f8c2 3224 	str.w	r3, [r2, #548]	@ 0x224
 80183da:	f8c2 324c 	str.w	r3, [r2, #588]	@ 0x24c
 80183de:	f8c2 3274 	str.w	r3, [r2, #628]	@ 0x274
 80183e2:	f8c2 329c 	str.w	r3, [r2, #668]	@ 0x29c
 80183e6:	f8c2 32c4 	str.w	r3, [r2, #708]	@ 0x2c4
 80183ea:	f8c2 32ec 	str.w	r3, [r2, #748]	@ 0x2ec
 80183ee:	f8c2 3314 	str.w	r3, [r2, #788]	@ 0x314
 80183f2:	eddf 7a4f 	vldr	s15, [pc, #316]	@ 8018530 <iNemoEngine_API_Update+0x850>
 80183f6:	eeb4 9ae7 	vcmpe.f32	s18, s15
 80183fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80183fe:	f100 87e0 	bmi.w	80193c2 <iNemoEngine_API_Update+0x16e2>
 8018402:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8018406:	ee7c 6ac7 	vsub.f32	s13, s25, s14
 801840a:	eec7 7a2c 	vdiv.f32	s15, s14, s25
 801840e:	eeb0 7ae6 	vabs.f32	s14, s13
 8018412:	eef0 6a47 	vmov.f32	s13, s14
 8018416:	ed8d 7a23 	vstr	s14, [sp, #140]	@ 0x8c
 801841a:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 801841e:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8018422:	ed8d 7a21 	vstr	s14, [sp, #132]	@ 0x84
 8018426:	ee2a 7a0a 	vmul.f32	s14, s20, s20
 801842a:	edd4 6a00 	vldr	s13, [r4]
 801842e:	ed94 6a01 	vldr	s12, [r4, #4]
 8018432:	edcd 6a2c 	vstr	s13, [sp, #176]	@ 0xb0
 8018436:	eeaa 7aaa 	vfma.f32	s14, s21, s21
 801843a:	4628      	mov	r0, r5
 801843c:	ee67 5aa6 	vmul.f32	s11, s15, s13
 8018440:	eea9 7aa9 	vfma.f32	s14, s19, s19
 8018444:	ee67 6a86 	vmul.f32	s13, s15, s12
 8018448:	ed8d 6a2d 	vstr	s12, [sp, #180]	@ 0xb4
 801844c:	ed9f 6a38 	vldr	s12, [pc, #224]	@ 8018530 <iNemoEngine_API_Update+0x850>
 8018450:	edcd 6a3e 	vstr	s13, [sp, #248]	@ 0xf8
 8018454:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8018458:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801845c:	bf54      	ite	pl
 801845e:	eeb1 9ac7 	vsqrtpl.f32	s18, s14
 8018462:	ed9f 9a34 	vldrmi	s18, [pc, #208]	@ 8018534 <iNemoEngine_API_Update+0x854>
 8018466:	ed94 5a02 	vldr	s10, [r4, #8]
 801846a:	edd7 3a00 	vldr	s7, [r7]
 801846e:	ed8d 5a2a 	vstr	s10, [sp, #168]	@ 0xa8
 8018472:	eeb7 3a00 	vmov.f32	s6, #112	@ 0x3f800000  1.0
 8018476:	ee83 7a09 	vdiv.f32	s14, s6, s18
 801847a:	ee65 7a27 	vmul.f32	s15, s10, s15
 801847e:	ee2a 6a07 	vmul.f32	s12, s20, s14
 8018482:	eeb0 0a63 	vmov.f32	s0, s7
 8018486:	ee66 6a26 	vmul.f32	s13, s12, s13
 801848a:	ed8d 6a41 	vstr	s12, [sp, #260]	@ 0x104
 801848e:	ee2a 6a87 	vmul.f32	s12, s21, s14
 8018492:	ee29 7a87 	vmul.f32	s14, s19, s14
 8018496:	eee6 6a25 	vfma.f32	s13, s12, s11
 801849a:	edcd 7a3f 	vstr	s15, [sp, #252]	@ 0xfc
 801849e:	eee7 6a87 	vfma.f32	s13, s15, s14
 80184a2:	ed8d 7a42 	vstr	s14, [sp, #264]	@ 0x108
 80184a6:	edcd 5a3d 	vstr	s11, [sp, #244]	@ 0xf4
 80184aa:	ed8d 6a40 	vstr	s12, [sp, #256]	@ 0x100
 80184ae:	edcd 6a1a 	vstr	s13, [sp, #104]	@ 0x68
 80184b2:	f7fd ffa5 	bl	8016400 <dataDerivative5>
 80184b6:	edd8 fa00 	vldr	s31, [r8]
 80184ba:	ed8d 0a18 	vstr	s0, [sp, #96]	@ 0x60
 80184be:	4630      	mov	r0, r6
 80184c0:	eeb0 0a6f 	vmov.f32	s0, s31
 80184c4:	f7fd ff9c 	bl	8016400 <dataDerivative5>
 80184c8:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 80184ca:	9815      	ldr	r0, [sp, #84]	@ 0x54
 80184cc:	ed93 fa00 	vldr	s30, [r3]
 80184d0:	eeb0 ba40 	vmov.f32	s22, s0
 80184d4:	eeb0 0a4f 	vmov.f32	s0, s30
 80184d8:	f7fd ff92 	bl	8016400 <dataDerivative5>
 80184dc:	eec3 7a23 	vdiv.f32	s15, s6, s7
 80184e0:	eef0 da40 	vmov.f32	s27, s0
 80184e4:	ee68 8aa7 	vmul.f32	s17, s17, s15
 80184e8:	ee27 8a88 	vmul.f32	s16, s15, s16
 80184ec:	ee27 ca8c 	vmul.f32	s24, s15, s24
 80184f0:	eddf 7a11 	vldr	s15, [pc, #68]	@ 8018538 <iNemoEngine_API_Update+0x858>
 80184f4:	eeb0 7ae8 	vabs.f32	s14, s17
 80184f8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80184fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018500:	d52c      	bpl.n	801855c <iNemoEngine_API_Update+0x87c>
 8018502:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8018506:	eef4 8ae7 	vcmpe.f32	s17, s15
 801850a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801850e:	f281 8756 	bge.w	801a3be <iNemoEngine_API_Update+0x26de>
 8018512:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 8018516:	eef4 8ac7 	vcmpe.f32	s17, s14
 801851a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801851e:	f303 80bc 	bgt.w	801b69a <iNemoEngine_API_Update+0x39ba>
 8018522:	e00b      	b.n	801853c <iNemoEngine_API_Update+0x85c>
 8018524:	3a9d4952 	.word	0x3a9d4952
 8018528:	bf666666 	.word	0xbf666666
 801852c:	40a00000 	.word	0x40a00000
 8018530:	3c23d70a 	.word	0x3c23d70a
 8018534:	3dcccccd 	.word	0x3dcccccd
 8018538:	4b000000 	.word	0x4b000000
 801853c:	ee78 7ae7 	vsub.f32	s15, s17, s15
 8018540:	ee17 0a90 	vmov	r0, s15
 8018544:	f7e8 f808 	bl	8000558 <__aeabi_f2d>
 8018548:	ec41 0b10 	vmov	d0, r0, r1
 801854c:	f007 fb68 	bl	801fc20 <ceil>
 8018550:	ec51 0b10 	vmov	r0, r1, d0
 8018554:	f7e8 fb50 	bl	8000bf8 <__aeabi_d2f>
 8018558:	ee08 0a90 	vmov	s17, r0
 801855c:	ed5f 7a0a 	vldr	s15, [pc, #-40]	@ 8018538 <iNemoEngine_API_Update+0x858>
 8018560:	edcd 8a43 	vstr	s17, [sp, #268]	@ 0x10c
 8018564:	eeb0 7ac8 	vabs.f32	s14, s16
 8018568:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801856c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018570:	d51f      	bpl.n	80185b2 <iNemoEngine_API_Update+0x8d2>
 8018572:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8018576:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801857a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801857e:	f281 870c 	bge.w	801a39a <iNemoEngine_API_Update+0x26ba>
 8018582:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 8018586:	eeb4 8ac7 	vcmpe.f32	s16, s14
 801858a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801858e:	f303 8080 	bgt.w	801b692 <iNemoEngine_API_Update+0x39b2>
 8018592:	ee78 7a67 	vsub.f32	s15, s16, s15
 8018596:	ee17 0a90 	vmov	r0, s15
 801859a:	f7e7 ffdd 	bl	8000558 <__aeabi_f2d>
 801859e:	ec41 0b10 	vmov	d0, r0, r1
 80185a2:	f007 fb3d 	bl	801fc20 <ceil>
 80185a6:	ec51 0b10 	vmov	r0, r1, d0
 80185aa:	f7e8 fb25 	bl	8000bf8 <__aeabi_d2f>
 80185ae:	ee08 0a10 	vmov	s16, r0
 80185b2:	ed5f 7a1f 	vldr	s15, [pc, #-124]	@ 8018538 <iNemoEngine_API_Update+0x858>
 80185b6:	ed8d 8a44 	vstr	s16, [sp, #272]	@ 0x110
 80185ba:	eeb0 7acc 	vabs.f32	s14, s24
 80185be:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80185c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80185c6:	d51f      	bpl.n	8018608 <iNemoEngine_API_Update+0x928>
 80185c8:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 80185cc:	eeb4 cae7 	vcmpe.f32	s24, s15
 80185d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80185d4:	f281 86cf 	bge.w	801a376 <iNemoEngine_API_Update+0x2696>
 80185d8:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 80185dc:	eeb4 cac7 	vcmpe.f32	s24, s14
 80185e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80185e4:	f303 8065 	bgt.w	801b6b2 <iNemoEngine_API_Update+0x39d2>
 80185e8:	ee7c 7a67 	vsub.f32	s15, s24, s15
 80185ec:	ee17 0a90 	vmov	r0, s15
 80185f0:	f7e7 ffb2 	bl	8000558 <__aeabi_f2d>
 80185f4:	ec41 0b10 	vmov	d0, r0, r1
 80185f8:	f007 fb12 	bl	801fc20 <ceil>
 80185fc:	ec51 0b10 	vmov	r0, r1, d0
 8018600:	f7e8 fafa 	bl	8000bf8 <__aeabi_d2f>
 8018604:	ee0c 0a10 	vmov	s24, r0
 8018608:	9b06      	ldr	r3, [sp, #24]
 801860a:	ed8d ca45 	vstr	s24, [sp, #276]	@ 0x114
 801860e:	f893 04b1 	ldrb.w	r0, [r3, #1201]	@ 0x4b1
 8018612:	1e43      	subs	r3, r0, #1
 8018614:	b25b      	sxtb	r3, r3
 8018616:	2b00      	cmp	r3, #0
 8018618:	dd18      	ble.n	801864c <iNemoEngine_API_Update+0x96c>
 801861a:	9c06      	ldr	r4, [sp, #24]
 801861c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8018620:	1e81      	subs	r1, r0, #2
 8018622:	009b      	lsls	r3, r3, #2
 8018624:	b2c9      	uxtb	r1, r1
 8018626:	f504 6294 	add.w	r2, r4, #1184	@ 0x4a0
 801862a:	441a      	add	r2, r3
 801862c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8018630:	f203 43ac 	addw	r3, r3, #1196	@ 0x4ac
 8018634:	eba2 0181 	sub.w	r1, r2, r1, lsl #2
 8018638:	4423      	add	r3, r4
 801863a:	681a      	ldr	r2, [r3, #0]
 801863c:	60da      	str	r2, [r3, #12]
 801863e:	685a      	ldr	r2, [r3, #4]
 8018640:	611a      	str	r2, [r3, #16]
 8018642:	689a      	ldr	r2, [r3, #8]
 8018644:	615a      	str	r2, [r3, #20]
 8018646:	3b0c      	subs	r3, #12
 8018648:	428b      	cmp	r3, r1
 801864a:	d1f6      	bne.n	801863a <iNemoEngine_API_Update+0x95a>
 801864c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8018650:	edc5 8a00 	vstr	s17, [r5]
 8018654:	eec7 8aaf 	vdiv.f32	s17, s15, s31
 8018658:	9a06      	ldr	r2, [sp, #24]
 801865a:	f202 43bc 	addw	r3, r2, #1212	@ 0x4bc
 801865e:	ed83 8a00 	vstr	s16, [r3]
 8018662:	f502 6398 	add.w	r3, r2, #1216	@ 0x4c0
 8018666:	ed83 ca00 	vstr	s24, [r3]
 801866a:	f892 34b0 	ldrb.w	r3, [r2, #1200]	@ 0x4b0
 801866e:	ed5f 7a4e 	vldr	s15, [pc, #-312]	@ 8018538 <iNemoEngine_API_Update+0x858>
 8018672:	ee2a 8aa8 	vmul.f32	s16, s21, s17
 8018676:	3301      	adds	r3, #1
 8018678:	b2db      	uxtb	r3, r3
 801867a:	eeb0 7ac8 	vabs.f32	s14, s16
 801867e:	4298      	cmp	r0, r3
 8018680:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018684:	bf28      	it	cs
 8018686:	4618      	movcs	r0, r3
 8018688:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801868c:	ee2a ca28 	vmul.f32	s24, s20, s17
 8018690:	f882 04b0 	strb.w	r0, [r2, #1200]	@ 0x4b0
 8018694:	ee69 8aa8 	vmul.f32	s17, s19, s17
 8018698:	d51f      	bpl.n	80186da <iNemoEngine_API_Update+0x9fa>
 801869a:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 801869e:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80186a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80186a6:	f281 87cb 	bge.w	801a640 <iNemoEngine_API_Update+0x2960>
 80186aa:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 80186ae:	eeb4 8ac7 	vcmpe.f32	s16, s14
 80186b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80186b6:	f303 8000 	bgt.w	801b6ba <iNemoEngine_API_Update+0x39da>
 80186ba:	ee78 7a67 	vsub.f32	s15, s16, s15
 80186be:	ee17 0a90 	vmov	r0, s15
 80186c2:	f7e7 ff49 	bl	8000558 <__aeabi_f2d>
 80186c6:	ec41 0b10 	vmov	d0, r0, r1
 80186ca:	f007 faa9 	bl	801fc20 <ceil>
 80186ce:	ec51 0b10 	vmov	r0, r1, d0
 80186d2:	f7e8 fa91 	bl	8000bf8 <__aeabi_d2f>
 80186d6:	ee08 0a10 	vmov	s16, r0
 80186da:	ed5f 7a69 	vldr	s15, [pc, #-420]	@ 8018538 <iNemoEngine_API_Update+0x858>
 80186de:	ed8d 8a43 	vstr	s16, [sp, #268]	@ 0x10c
 80186e2:	eeb0 7acc 	vabs.f32	s14, s24
 80186e6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80186ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80186ee:	d51f      	bpl.n	8018730 <iNemoEngine_API_Update+0xa50>
 80186f0:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 80186f4:	eeb4 cae7 	vcmpe.f32	s24, s15
 80186f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80186fc:	f281 878e 	bge.w	801a61c <iNemoEngine_API_Update+0x293c>
 8018700:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 8018704:	eeb4 cac7 	vcmpe.f32	s24, s14
 8018708:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801870c:	f302 87cd 	bgt.w	801b6aa <iNemoEngine_API_Update+0x39ca>
 8018710:	ee7c 7a67 	vsub.f32	s15, s24, s15
 8018714:	ee17 0a90 	vmov	r0, s15
 8018718:	f7e7 ff1e 	bl	8000558 <__aeabi_f2d>
 801871c:	ec41 0b10 	vmov	d0, r0, r1
 8018720:	f007 fa7e 	bl	801fc20 <ceil>
 8018724:	ec51 0b10 	vmov	r0, r1, d0
 8018728:	f7e8 fa66 	bl	8000bf8 <__aeabi_d2f>
 801872c:	ee0c 0a10 	vmov	s24, r0
 8018730:	ed5f 7a7f 	vldr	s15, [pc, #-508]	@ 8018538 <iNemoEngine_API_Update+0x858>
 8018734:	ed8d ca44 	vstr	s24, [sp, #272]	@ 0x110
 8018738:	eeb0 7ae8 	vabs.f32	s14, s17
 801873c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018740:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018744:	d51f      	bpl.n	8018786 <iNemoEngine_API_Update+0xaa6>
 8018746:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 801874a:	eef4 8ae7 	vcmpe.f32	s17, s15
 801874e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018752:	f281 8751 	bge.w	801a5f8 <iNemoEngine_API_Update+0x2918>
 8018756:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 801875a:	eef4 8ac7 	vcmpe.f32	s17, s14
 801875e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018762:	f302 878e 	bgt.w	801b682 <iNemoEngine_API_Update+0x39a2>
 8018766:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801876a:	ee17 0a90 	vmov	r0, s15
 801876e:	f7e7 fef3 	bl	8000558 <__aeabi_f2d>
 8018772:	ec41 0b10 	vmov	d0, r0, r1
 8018776:	f007 fa53 	bl	801fc20 <ceil>
 801877a:	ec51 0b10 	vmov	r0, r1, d0
 801877e:	f7e8 fa3b 	bl	8000bf8 <__aeabi_d2f>
 8018782:	ee08 0a90 	vmov	s17, r0
 8018786:	9b06      	ldr	r3, [sp, #24]
 8018788:	edcd 8a45 	vstr	s17, [sp, #276]	@ 0x114
 801878c:	f893 0621 	ldrb.w	r0, [r3, #1569]	@ 0x621
 8018790:	1e43      	subs	r3, r0, #1
 8018792:	b25b      	sxtb	r3, r3
 8018794:	2b00      	cmp	r3, #0
 8018796:	dd18      	ble.n	80187ca <iNemoEngine_API_Update+0xaea>
 8018798:	9c06      	ldr	r4, [sp, #24]
 801879a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801879e:	1e81      	subs	r1, r0, #2
 80187a0:	009b      	lsls	r3, r3, #2
 80187a2:	b2c9      	uxtb	r1, r1
 80187a4:	f504 62c2 	add.w	r2, r4, #1552	@ 0x610
 80187a8:	441a      	add	r2, r3
 80187aa:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80187ae:	f203 631c 	addw	r3, r3, #1564	@ 0x61c
 80187b2:	eba2 0181 	sub.w	r1, r2, r1, lsl #2
 80187b6:	4423      	add	r3, r4
 80187b8:	681a      	ldr	r2, [r3, #0]
 80187ba:	60da      	str	r2, [r3, #12]
 80187bc:	685a      	ldr	r2, [r3, #4]
 80187be:	611a      	str	r2, [r3, #16]
 80187c0:	689a      	ldr	r2, [r3, #8]
 80187c2:	615a      	str	r2, [r3, #20]
 80187c4:	3b0c      	subs	r3, #12
 80187c6:	4299      	cmp	r1, r3
 80187c8:	d1f6      	bne.n	80187b8 <iNemoEngine_API_Update+0xad8>
 80187ca:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80187ce:	ed86 8a00 	vstr	s16, [r6]
 80187d2:	ee87 8a8f 	vdiv.f32	s16, s15, s30
 80187d6:	9a06      	ldr	r2, [sp, #24]
 80187d8:	f202 632c 	addw	r3, r2, #1580	@ 0x62c
 80187dc:	ed83 ca00 	vstr	s24, [r3]
 80187e0:	f502 63c6 	add.w	r3, r2, #1584	@ 0x630
 80187e4:	edc3 8a00 	vstr	s17, [r3]
 80187e8:	f892 3620 	ldrb.w	r3, [r2, #1568]	@ 0x620
 80187ec:	ed5f 7aae 	vldr	s15, [pc, #-696]	@ 8018538 <iNemoEngine_API_Update+0x858>
 80187f0:	ee68 8a0e 	vmul.f32	s17, s16, s28
 80187f4:	3301      	adds	r3, #1
 80187f6:	b2db      	uxtb	r3, r3
 80187f8:	eeb0 7ae8 	vabs.f32	s14, s17
 80187fc:	4298      	cmp	r0, r3
 80187fe:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018802:	bf28      	it	cs
 8018804:	4618      	movcs	r0, r3
 8018806:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801880a:	ee28 ca2e 	vmul.f32	s24, s16, s29
 801880e:	f882 0620 	strb.w	r0, [r2, #1568]	@ 0x620
 8018812:	ee28 8a2b 	vmul.f32	s16, s16, s23
 8018816:	d51f      	bpl.n	8018858 <iNemoEngine_API_Update+0xb78>
 8018818:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 801881c:	eef4 8ae7 	vcmpe.f32	s17, s15
 8018820:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018824:	f281 86d6 	bge.w	801a5d4 <iNemoEngine_API_Update+0x28f4>
 8018828:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 801882c:	eef4 8ac7 	vcmpe.f32	s17, s14
 8018830:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018834:	f302 8745 	bgt.w	801b6c2 <iNemoEngine_API_Update+0x39e2>
 8018838:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801883c:	ee17 0a90 	vmov	r0, s15
 8018840:	f7e7 fe8a 	bl	8000558 <__aeabi_f2d>
 8018844:	ec41 0b10 	vmov	d0, r0, r1
 8018848:	f007 f9ea 	bl	801fc20 <ceil>
 801884c:	ec51 0b10 	vmov	r0, r1, d0
 8018850:	f7e8 f9d2 	bl	8000bf8 <__aeabi_d2f>
 8018854:	ee08 0a90 	vmov	s17, r0
 8018858:	ed5f 7ac9 	vldr	s15, [pc, #-804]	@ 8018538 <iNemoEngine_API_Update+0x858>
 801885c:	edcd 8a43 	vstr	s17, [sp, #268]	@ 0x10c
 8018860:	eeb0 7acc 	vabs.f32	s14, s24
 8018864:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018868:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801886c:	d51f      	bpl.n	80188ae <iNemoEngine_API_Update+0xbce>
 801886e:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8018872:	eeb4 cae7 	vcmpe.f32	s24, s15
 8018876:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801887a:	f281 871d 	bge.w	801a6b8 <iNemoEngine_API_Update+0x29d8>
 801887e:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 8018882:	eeb4 cac7 	vcmpe.f32	s24, s14
 8018886:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801888a:	f302 86fe 	bgt.w	801b68a <iNemoEngine_API_Update+0x39aa>
 801888e:	ee7c 7a67 	vsub.f32	s15, s24, s15
 8018892:	ee17 0a90 	vmov	r0, s15
 8018896:	f7e7 fe5f 	bl	8000558 <__aeabi_f2d>
 801889a:	ec41 0b10 	vmov	d0, r0, r1
 801889e:	f007 f9bf 	bl	801fc20 <ceil>
 80188a2:	ec51 0b10 	vmov	r0, r1, d0
 80188a6:	f7e8 f9a7 	bl	8000bf8 <__aeabi_d2f>
 80188aa:	ee0c 0a10 	vmov	s24, r0
 80188ae:	ed5f 7ade 	vldr	s15, [pc, #-888]	@ 8018538 <iNemoEngine_API_Update+0x858>
 80188b2:	ed8d ca44 	vstr	s24, [sp, #272]	@ 0x110
 80188b6:	eeb0 7ac8 	vabs.f32	s14, s16
 80188ba:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80188be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80188c2:	d51f      	bpl.n	8018904 <iNemoEngine_API_Update+0xc24>
 80188c4:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 80188c8:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80188cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80188d0:	f281 86c8 	bge.w	801a664 <iNemoEngine_API_Update+0x2984>
 80188d4:	eebe 7a00 	vmov.f32	s14, #224	@ 0xbf000000 -0.5
 80188d8:	eeb4 8ac7 	vcmpe.f32	s16, s14
 80188dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80188e0:	f302 86df 	bgt.w	801b6a2 <iNemoEngine_API_Update+0x39c2>
 80188e4:	ee78 7a67 	vsub.f32	s15, s16, s15
 80188e8:	ee17 0a90 	vmov	r0, s15
 80188ec:	f7e7 fe34 	bl	8000558 <__aeabi_f2d>
 80188f0:	ec41 0b10 	vmov	d0, r0, r1
 80188f4:	f007 f994 	bl	801fc20 <ceil>
 80188f8:	ec51 0b10 	vmov	r0, r1, d0
 80188fc:	f7e8 f97c 	bl	8000bf8 <__aeabi_d2f>
 8018900:	ee08 0a10 	vmov	s16, r0
 8018904:	9b06      	ldr	r3, [sp, #24]
 8018906:	ed8d 8a45 	vstr	s16, [sp, #276]	@ 0x114
 801890a:	f893 0791 	ldrb.w	r0, [r3, #1937]	@ 0x791
 801890e:	1e43      	subs	r3, r0, #1
 8018910:	b25b      	sxtb	r3, r3
 8018912:	2b00      	cmp	r3, #0
 8018914:	dd18      	ble.n	8018948 <iNemoEngine_API_Update+0xc68>
 8018916:	9c06      	ldr	r4, [sp, #24]
 8018918:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801891c:	1e81      	subs	r1, r0, #2
 801891e:	009b      	lsls	r3, r3, #2
 8018920:	b2c9      	uxtb	r1, r1
 8018922:	f504 62f0 	add.w	r2, r4, #1920	@ 0x780
 8018926:	441a      	add	r2, r3
 8018928:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 801892c:	f203 738c 	addw	r3, r3, #1932	@ 0x78c
 8018930:	eba2 0181 	sub.w	r1, r2, r1, lsl #2
 8018934:	4423      	add	r3, r4
 8018936:	681a      	ldr	r2, [r3, #0]
 8018938:	60da      	str	r2, [r3, #12]
 801893a:	685a      	ldr	r2, [r3, #4]
 801893c:	611a      	str	r2, [r3, #16]
 801893e:	689a      	ldr	r2, [r3, #8]
 8018940:	615a      	str	r2, [r3, #20]
 8018942:	3b0c      	subs	r3, #12
 8018944:	428b      	cmp	r3, r1
 8018946:	d1f6      	bne.n	8018936 <iNemoEngine_API_Update+0xc56>
 8018948:	9c06      	ldr	r4, [sp, #24]
 801894a:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 801894c:	f204 729c 	addw	r2, r4, #1948	@ 0x79c
 8018950:	edc3 8a00 	vstr	s17, [r3]
 8018954:	922e      	str	r2, [sp, #184]	@ 0xb8
 8018956:	ed82 ca00 	vstr	s24, [r2]
 801895a:	f504 62f4 	add.w	r2, r4, #1952	@ 0x7a0
 801895e:	ed82 8a00 	vstr	s16, [r2]
 8018962:	f894 3790 	ldrb.w	r3, [r4, #1936]	@ 0x790
 8018966:	922f      	str	r2, [sp, #188]	@ 0xbc
 8018968:	3301      	adds	r3, #1
 801896a:	b2db      	uxtb	r3, r3
 801896c:	4298      	cmp	r0, r3
 801896e:	bf28      	it	cs
 8018970:	4618      	movcs	r0, r3
 8018972:	f884 0790 	strb.w	r0, [r4, #1936]	@ 0x790
 8018976:	aa68      	add	r2, sp, #416	@ 0x1a0
 8018978:	a93d      	add	r1, sp, #244	@ 0xf4
 801897a:	a840      	add	r0, sp, #256	@ 0x100
 801897c:	f7fd fe26 	bl	80165cc <getRotationMatrix>
 8018980:	4623      	mov	r3, r4
 8018982:	f504 7247 	add.w	r2, r4, #796	@ 0x31c
 8018986:	9229      	str	r2, [sp, #164]	@ 0xa4
 8018988:	4614      	mov	r4, r2
 801898a:	aeae      	add	r6, sp, #696	@ 0x2b8
 801898c:	f503 774f 	add.w	r7, r3, #828	@ 0x33c
 8018990:	6820      	ldr	r0, [r4, #0]
 8018992:	6861      	ldr	r1, [r4, #4]
 8018994:	68a2      	ldr	r2, [r4, #8]
 8018996:	68e3      	ldr	r3, [r4, #12]
 8018998:	4635      	mov	r5, r6
 801899a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801899c:	3410      	adds	r4, #16
 801899e:	42bc      	cmp	r4, r7
 80189a0:	462e      	mov	r6, r5
 80189a2:	d1f5      	bne.n	8018990 <iNemoEngine_API_Update+0xcb0>
 80189a4:	6820      	ldr	r0, [r4, #0]
 80189a6:	6028      	str	r0, [r5, #0]
 80189a8:	9b06      	ldr	r3, [sp, #24]
 80189aa:	edd3 7ac7 	vldr	s15, [r3, #796]	@ 0x31c
 80189ae:	ed93 7ac8 	vldr	s14, [r3, #800]	@ 0x320
 80189b2:	eef0 7ae7 	vabs.f32	s15, s15
 80189b6:	eeb0 7ac7 	vabs.f32	s14, s14
 80189ba:	eef4 7ac7 	vcmpe.f32	s15, s14
 80189be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80189c2:	f140 8543 	bpl.w	801944c <iNemoEngine_API_Update+0x176c>
 80189c6:	2604      	movs	r6, #4
 80189c8:	2400      	movs	r4, #0
 80189ca:	eef0 7a47 	vmov.f32	s15, s14
 80189ce:	f04f 0c07 	mov.w	ip, #7
 80189d2:	f04f 0e06 	mov.w	lr, #6
 80189d6:	2103      	movs	r1, #3
 80189d8:	4630      	mov	r0, r6
 80189da:	4623      	mov	r3, r4
 80189dc:	2701      	movs	r7, #1
 80189de:	9a06      	ldr	r2, [sp, #24]
 80189e0:	ed92 7ac9 	vldr	s14, [r2, #804]	@ 0x324
 80189e4:	eeb0 7ac7 	vabs.f32	s14, s14
 80189e8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80189ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80189f0:	f340 8525 	ble.w	801943e <iNemoEngine_API_Update+0x175e>
 80189f4:	f04f 0c08 	mov.w	ip, #8
 80189f8:	2104      	movs	r1, #4
 80189fa:	f04f 0906 	mov.w	r9, #6
 80189fe:	f04f 0e07 	mov.w	lr, #7
 8018a02:	f04f 0803 	mov.w	r8, #3
 8018a06:	2605      	movs	r6, #5
 8018a08:	4660      	mov	r0, ip
 8018a0a:	460c      	mov	r4, r1
 8018a0c:	2200      	movs	r2, #0
 8018a0e:	2301      	movs	r3, #1
 8018a10:	2702      	movs	r7, #2
 8018a12:	9d29      	ldr	r5, [sp, #164]	@ 0xa4
 8018a14:	442c      	add	r4, r5
 8018a16:	4428      	add	r0, r5
 8018a18:	ed90 7a00 	vldr	s14, [r0]
 8018a1c:	edd4 6a00 	vldr	s13, [r4]
 8018a20:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8018a24:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8018a26:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8018a2a:	acae      	add	r4, sp, #696	@ 0x2b8
 8018a2c:	adae      	add	r5, sp, #696	@ 0x2b8
 8018a2e:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 8018a32:	eb05 0587 	add.w	r5, r5, r7, lsl #2
 8018a36:	ea4f 0a82 	mov.w	sl, r2, lsl #2
 8018a3a:	ea4f 0b87 	mov.w	fp, r7, lsl #2
 8018a3e:	edc0 7a00 	vstr	s15, [r0]
 8018a42:	edd5 7a00 	vldr	s15, [r5]
 8018a46:	ed94 7a00 	vldr	s14, [r4]
 8018a4a:	eec7 6a27 	vdiv.f32	s13, s14, s15
 8018a4e:	edc4 6a00 	vstr	s13, [r4]
 8018a52:	ed90 6a00 	vldr	s12, [r0]
 8018a56:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8018a58:	eb00 0581 	add.w	r5, r0, r1, lsl #2
 8018a5c:	eb00 0086 	add.w	r0, r0, r6, lsl #2
 8018a60:	ed90 7a00 	vldr	s14, [r0]
 8018a64:	edd5 7a00 	vldr	s15, [r5]
 8018a68:	eee6 7a47 	vfms.f32	s15, s12, s14
 8018a6c:	00b4      	lsls	r4, r6, #2
 8018a6e:	9403      	str	r4, [sp, #12]
 8018a70:	ea4f 048c 	mov.w	r4, ip, lsl #2
 8018a74:	edc5 7a00 	vstr	s15, [r5]
 8018a78:	ed90 7a00 	vldr	s14, [r0]
 8018a7c:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8018a7e:	eb00 0088 	add.w	r0, r0, r8, lsl #2
 8018a82:	edd0 7a00 	vldr	s15, [r0]
 8018a86:	eee6 7ac7 	vfms.f32	s15, s13, s14
 8018a8a:	4626      	mov	r6, r4
 8018a8c:	acae      	add	r4, sp, #696	@ 0x2b8
 8018a8e:	eb04 048e 	add.w	r4, r4, lr, lsl #2
 8018a92:	edc0 7a00 	vstr	s15, [r0]
 8018a96:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8018a98:	eb00 008c 	add.w	r0, r0, ip, lsl #2
 8018a9c:	edd0 5a00 	vldr	s11, [r0]
 8018aa0:	ed94 7a00 	vldr	s14, [r4]
 8018aa4:	eea6 7a65 	vfms.f32	s14, s12, s11
 8018aa8:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8018aac:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8018ab0:	eef0 7ae7 	vabs.f32	s15, s15
 8018ab4:	ed84 7a00 	vstr	s14, [r4]
 8018ab8:	ed90 6a00 	vldr	s12, [r0]
 8018abc:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8018abe:	eb00 0089 	add.w	r0, r0, r9, lsl #2
 8018ac2:	ed90 7a00 	vldr	s14, [r0]
 8018ac6:	eea6 7ac6 	vfms.f32	s14, s13, s12
 8018aca:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8018ace:	ea4f 048e 	mov.w	r4, lr, lsl #2
 8018ad2:	ed80 7a00 	vstr	s14, [r0]
 8018ad6:	ed95 7a00 	vldr	s14, [r5]
 8018ada:	eeb0 7ac7 	vabs.f32	s14, s14
 8018ade:	eef4 7ac7 	vcmpe.f32	s15, s14
 8018ae2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018ae6:	ea4f 0581 	mov.w	r5, r1, lsl #2
 8018aea:	dd0b      	ble.n	8018b04 <iNemoEngine_API_Update+0xe24>
 8018aec:	4618      	mov	r0, r3
 8018aee:	4645      	mov	r5, r8
 8018af0:	4613      	mov	r3, r2
 8018af2:	464c      	mov	r4, r9
 8018af4:	46d4      	mov	ip, sl
 8018af6:	4602      	mov	r2, r0
 8018af8:	ea4f 0881 	mov.w	r8, r1, lsl #2
 8018afc:	ea4f 098e 	mov.w	r9, lr, lsl #2
 8018b00:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 8018b04:	a9ae      	add	r1, sp, #696	@ 0x2b8
 8018b06:	eb01 0008 	add.w	r0, r1, r8
 8018b0a:	440d      	add	r5, r1
 8018b0c:	ed90 7a00 	vldr	s14, [r0]
 8018b10:	edd5 7a00 	vldr	s15, [r5]
 8018b14:	ee87 4a27 	vdiv.f32	s8, s14, s15
 8018b18:	440c      	add	r4, r1
 8018b1a:	eb01 0809 	add.w	r8, r1, r9
 8018b1e:	440e      	add	r6, r1
 8018b20:	46b6      	mov	lr, r6
 8018b22:	460e      	mov	r6, r1
 8018b24:	9903      	ldr	r1, [sp, #12]
 8018b26:	4431      	add	r1, r6
 8018b28:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 8018b2c:	ed80 4a00 	vstr	s8, [r0]
 8018b30:	ed94 7a00 	vldr	s14, [r4]
 8018b34:	edd8 7a00 	vldr	s15, [r8]
 8018b38:	eee4 7a47 	vfms.f32	s15, s8, s14
 8018b3c:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8018b3e:	edc8 7a00 	vstr	s15, [r8]
 8018b42:	edd1 2a00 	vldr	s5, [r1]
 8018b46:	ed95 7a00 	vldr	s14, [r5]
 8018b4a:	ed94 1a00 	vldr	s2, [r4]
 8018b4e:	edde 1a00 	vldr	s3, [lr]
 8018b52:	f50b 61b2 	add.w	r1, fp, #1424	@ 0x590
 8018b56:	4469      	add	r1, sp
 8018b58:	f5a1 717c 	sub.w	r1, r1, #1008	@ 0x3f0
 8018b5c:	ee83 2a87 	vdiv.f32	s4, s7, s14
 8018b60:	ed91 7a00 	vldr	s14, [r1]
 8018b64:	a9ae      	add	r1, sp, #696	@ 0x2b8
 8018b66:	448b      	add	fp, r1
 8018b68:	f50c 61b2 	add.w	r1, ip, #1424	@ 0x590
 8018b6c:	eec3 0aa7 	vdiv.f32	s1, s7, s15
 8018b70:	4469      	add	r1, sp
 8018b72:	f5a1 717c 	sub.w	r1, r1, #1008	@ 0x3f0
 8018b76:	4484      	add	ip, r0
 8018b78:	4450      	add	r0, sl
 8018b7a:	edd1 6a00 	vldr	s13, [r1]
 8018b7e:	eddb 7a00 	vldr	s15, [fp]
 8018b82:	ed90 0a00 	vldr	s0, [r0]
 8018b86:	f50a 61b2 	add.w	r1, sl, #1424	@ 0x590
 8018b8a:	4469      	add	r1, sp
 8018b8c:	f5a1 717c 	sub.w	r1, r1, #1008	@ 0x3f0
 8018b90:	ee83 3aa7 	vdiv.f32	s6, s7, s15
 8018b94:	edd1 4a00 	vldr	s9, [r1]
 8018b98:	eddc 7a00 	vldr	s15, [ip]
 8018b9c:	eee0 4a47 	vfms.f32	s9, s0, s14
 8018ba0:	f50d 61b2 	add.w	r1, sp, #1424	@ 0x590
 8018ba4:	eb01 0087 	add.w	r0, r1, r7, lsl #2
 8018ba8:	eee7 6ac7 	vfms.f32	s13, s15, s14
 8018bac:	4601      	mov	r1, r0
 8018bae:	f5a1 7176 	sub.w	r1, r1, #984	@ 0x3d8
 8018bb2:	f5a0 7079 	sub.w	r0, r0, #996	@ 0x3e4
 8018bb6:	eee4 4a66 	vfms.f32	s9, s8, s13
 8018bba:	ed90 5a00 	vldr	s10, [r0]
 8018bbe:	ee60 4aa4 	vmul.f32	s9, s1, s9
 8018bc2:	f50d 60b2 	add.w	r0, sp, #1424	@ 0x590
 8018bc6:	eee1 6a64 	vfms.f32	s13, s2, s9
 8018bca:	eea1 7ae4 	vfms.f32	s14, s3, s9
 8018bce:	ee62 8a26 	vmul.f32	s17, s4, s13
 8018bd2:	edd1 6a00 	vldr	s13, [r1]
 8018bd6:	f50d 61b2 	add.w	r1, sp, #1424	@ 0x590
 8018bda:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8018bde:	460b      	mov	r3, r1
 8018be0:	f5a3 7376 	sub.w	r3, r3, #984	@ 0x3d8
 8018be4:	f5a1 7179 	sub.w	r1, r1, #996	@ 0x3e4
 8018be8:	edd1 5a00 	vldr	s11, [r1]
 8018bec:	ed93 8a00 	vldr	s16, [r3]
 8018bf0:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 8018bf4:	f5a1 7279 	sub.w	r2, r1, #996	@ 0x3e4
 8018bf8:	f5a1 7376 	sub.w	r3, r1, #984	@ 0x3d8
 8018bfc:	eee7 5ac5 	vfms.f32	s11, s15, s10
 8018c00:	eea6 8ae7 	vfms.f32	s16, s13, s15
 8018c04:	ed92 6a00 	vldr	s12, [r2]
 8018c08:	edd3 7a00 	vldr	s15, [r3]
 8018c0c:	eea0 6a45 	vfms.f32	s12, s0, s10
 8018c10:	eee6 7ac0 	vfms.f32	s15, s13, s0
 8018c14:	eea4 6a65 	vfms.f32	s12, s8, s11
 8018c18:	eee4 7a48 	vfms.f32	s15, s8, s16
 8018c1c:	ee20 6a86 	vmul.f32	s12, s1, s12
 8018c20:	ee67 7aa0 	vmul.f32	s15, s15, s1
 8018c24:	eee1 5a46 	vfms.f32	s11, s2, s12
 8018c28:	eea7 8ac1 	vfms.f32	s16, s15, s2
 8018c2c:	eea1 5ac6 	vfms.f32	s10, s3, s12
 8018c30:	eee7 6ae1 	vfms.f32	s13, s15, s3
 8018c34:	ee62 5a25 	vmul.f32	s11, s4, s11
 8018c38:	ee28 2a02 	vmul.f32	s4, s16, s4
 8018c3c:	eea2 7ae8 	vfms.f32	s14, s5, s17
 8018c40:	eee2 6a62 	vfms.f32	s13, s4, s5
 8018c44:	eea2 5ae5 	vfms.f32	s10, s5, s11
 8018c48:	ee23 7a07 	vmul.f32	s14, s6, s14
 8018c4c:	ee23 5a05 	vmul.f32	s10, s6, s10
 8018c50:	ee26 3a83 	vmul.f32	s6, s13, s6
 8018c54:	ee77 6aa5 	vadd.f32	s13, s15, s11
 8018c58:	eebf 4a00 	vmov.f32	s8, #240	@ 0xbf800000 -1.0
 8018c5c:	ee77 6a66 	vsub.f32	s13, s14, s13
 8018c60:	ee36 6a42 	vsub.f32	s12, s12, s4
 8018c64:	eef4 6ac4 	vcmpe.f32	s13, s8
 8018c68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018c6c:	bfc8      	it	gt
 8018c6e:	ee76 6aa3 	vaddgt.f32	s13, s13, s7
 8018c72:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
 8018c76:	bfcc      	ite	gt
 8018c78:	eeb1 4ae6 	vsqrtgt.f32	s8, s13
 8018c7c:	ed9f 4ad7 	vldrle	s8, [pc, #860]	@ 8018fdc <iNemoEngine_API_Update+0x12fc>
 8018c80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018c84:	f100 8411 	bmi.w	80194aa <iNemoEngine_API_Update+0x17ca>
 8018c88:	bfd8      	it	le
 8018c8a:	ee24 4a06 	vmulle.f32	s8, s8, s12
 8018c8e:	ee77 6a87 	vadd.f32	s13, s15, s14
 8018c92:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 8018c96:	ee75 6ae6 	vsub.f32	s13, s11, s13
 8018c9a:	ee24 6a06 	vmul.f32	s12, s8, s12
 8018c9e:	eebf 4a00 	vmov.f32	s8, #240	@ 0xbf800000 -1.0
 8018ca2:	eef4 6ac4 	vcmpe.f32	s13, s8
 8018ca6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018caa:	bf88      	it	hi
 8018cac:	eeb7 4a00 	vmovhi.f32	s8, #112	@ 0x3f800000  1.0
 8018cb0:	ee33 3a64 	vsub.f32	s6, s6, s9
 8018cb4:	bf88      	it	hi
 8018cb6:	ee36 4a84 	vaddhi.f32	s8, s13, s8
 8018cba:	eeb5 3ac0 	vcmpe.f32	s6, #0.0
 8018cbe:	bf8c      	ite	hi
 8018cc0:	eef1 6ac4 	vsqrthi.f32	s13, s8
 8018cc4:	eddf 6ac5 	vldrls	s13, [pc, #788]	@ 8018fdc <iNemoEngine_API_Update+0x12fc>
 8018cc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018ccc:	f100 83ea 	bmi.w	80194a4 <iNemoEngine_API_Update+0x17c4>
 8018cd0:	bfd8      	it	le
 8018cd2:	ee66 6a83 	vmulle.f32	s13, s13, s6
 8018cd6:	ee37 7a25 	vadd.f32	s14, s14, s11
 8018cda:	ee38 5ac5 	vsub.f32	s10, s17, s10
 8018cde:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8018ce2:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 8018ce6:	ee66 6a87 	vmul.f32	s13, s13, s14
 8018cea:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8018cee:	eef4 7ac7 	vcmpe.f32	s15, s14
 8018cf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018cf6:	bf84      	itt	hi
 8018cf8:	eeb7 7a00 	vmovhi.f32	s14, #112	@ 0x3f800000  1.0
 8018cfc:	ee37 7a87 	vaddhi.f32	s14, s15, s14
 8018d00:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
 8018d04:	bf8c      	ite	hi
 8018d06:	eef1 7ac7 	vsqrthi.f32	s15, s14
 8018d0a:	eddf 7ab4 	vldrls	s15, [pc, #720]	@ 8018fdc <iNemoEngine_API_Update+0x12fc>
 8018d0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018d12:	f100 83ce 	bmi.w	80194b2 <iNemoEngine_API_Update+0x17d2>
 8018d16:	bfd8      	it	le
 8018d18:	ee67 7a85 	vmulle.f32	s15, s15, s10
 8018d1c:	9b06      	ldr	r3, [sp, #24]
 8018d1e:	f893 2341 	ldrb.w	r2, [r3, #833]	@ 0x341
 8018d22:	1e53      	subs	r3, r2, #1
 8018d24:	b25b      	sxtb	r3, r3
 8018d26:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 8018d2a:	2b00      	cmp	r3, #0
 8018d2c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8018d30:	dd1d      	ble.n	8018d6e <iNemoEngine_API_Update+0x108e>
 8018d32:	9806      	ldr	r0, [sp, #24]
 8018d34:	3a02      	subs	r2, #2
 8018d36:	b2d1      	uxtb	r1, r2
 8018d38:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8018d3c:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 8018d40:	f1a0 010c 	sub.w	r1, r0, #12
 8018d44:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8018d48:	eba1 0182 	sub.w	r1, r1, r2, lsl #2
 8018d4c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8018d50:	f8d3 233c 	ldr.w	r2, [r3, #828]	@ 0x33c
 8018d54:	f8c3 2348 	str.w	r2, [r3, #840]	@ 0x348
 8018d58:	f8d3 2340 	ldr.w	r2, [r3, #832]	@ 0x340
 8018d5c:	f8c3 234c 	str.w	r2, [r3, #844]	@ 0x34c
 8018d60:	f8d3 2344 	ldr.w	r2, [r3, #836]	@ 0x344
 8018d64:	f8c3 2350 	str.w	r2, [r3, #848]	@ 0x350
 8018d68:	3b0c      	subs	r3, #12
 8018d6a:	428b      	cmp	r3, r1
 8018d6c:	d1f0      	bne.n	8018d50 <iNemoEngine_API_Update+0x1070>
 8018d6e:	ed9d 7a07 	vldr	s14, [sp, #28]
 8018d72:	9b06      	ldr	r3, [sp, #24]
 8018d74:	9310      	str	r3, [sp, #64]	@ 0x40
 8018d76:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 8018d7a:	ee85 7a87 	vdiv.f32	s14, s11, s14
 8018d7e:	aa3d      	add	r2, sp, #244	@ 0xf4
 8018d80:	922b      	str	r2, [sp, #172]	@ 0xac
 8018d82:	9212      	str	r2, [sp, #72]	@ 0x48
 8018d84:	f50d 7be2 	add.w	fp, sp, #452	@ 0x1c4
 8018d88:	f50d 7af4 	add.w	sl, sp, #488	@ 0x1e8
 8018d8c:	ee36 6a06 	vadd.f32	s12, s12, s12
 8018d90:	ee76 6aa6 	vadd.f32	s13, s13, s13
 8018d94:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8018d98:	ee26 6a07 	vmul.f32	s12, s12, s14
 8018d9c:	ee66 6a87 	vmul.f32	s13, s13, s14
 8018da0:	ee67 7a87 	vmul.f32	s15, s15, s14
 8018da4:	ed83 6ad2 	vstr	s12, [r3, #840]	@ 0x348
 8018da8:	edc3 6ad3 	vstr	s13, [r3, #844]	@ 0x34c
 8018dac:	edc3 7ad4 	vstr	s15, [r3, #848]	@ 0x350
 8018db0:	2300      	movs	r3, #0
 8018db2:	930e      	str	r3, [sp, #56]	@ 0x38
 8018db4:	f20d 13c3 	addw	r3, sp, #451	@ 0x1c3
 8018db8:	f1c3 0301 	rsb	r3, r3, #1
 8018dbc:	9328      	str	r3, [sp, #160]	@ 0xa0
 8018dbe:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8018dc0:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 8018dc2:	9c28      	ldr	r4, [sp, #160]	@ 0xa0
 8018dc4:	3301      	adds	r3, #1
 8018dc6:	930e      	str	r3, [sp, #56]	@ 0x38
 8018dc8:	a9ae      	add	r1, sp, #696	@ 0x2b8
 8018dca:	f20d 13c3 	addw	r3, sp, #451	@ 0x1c3
 8018dce:	18e0      	adds	r0, r4, r3
 8018dd0:	f803 0f01 	strb.w	r0, [r3, #1]!
 8018dd4:	f8d2 0348 	ldr.w	r0, [r2, #840]	@ 0x348
 8018dd8:	f841 0b04 	str.w	r0, [r1], #4
 8018ddc:	f20d 10e1 	addw	r0, sp, #481	@ 0x1e1
 8018de0:	4283      	cmp	r3, r0
 8018de2:	f102 020c 	add.w	r2, r2, #12
 8018de6:	d1f2      	bne.n	8018dce <iNemoEngine_API_Update+0x10ee>
 8018de8:	ed9d 7aae 	vldr	s14, [sp, #696]	@ 0x2b8
 8018dec:	eddd 7aaf 	vldr	s15, [sp, #700]	@ 0x2bc
 8018df0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018df4:	ed9d 7ab0 	vldr	s14, [sp, #704]	@ 0x2c0
 8018df8:	eddd 7ab1 	vldr	s15, [sp, #708]	@ 0x2c4
 8018dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018e00:	bf88      	it	hi
 8018e02:	f44f 7381 	movhi.w	r3, #258	@ 0x102
 8018e06:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018e0a:	ed9d 7ab2 	vldr	s14, [sp, #712]	@ 0x2c8
 8018e0e:	eddd 7ab3 	vldr	s15, [sp, #716]	@ 0x2cc
 8018e12:	bf88      	it	hi
 8018e14:	f8ab 3000 	strhhi.w	r3, [fp]
 8018e18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018e1c:	bf88      	it	hi
 8018e1e:	f44f 7341 	movhi.w	r3, #772	@ 0x304
 8018e22:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018e26:	ed9d 7ab4 	vldr	s14, [sp, #720]	@ 0x2d0
 8018e2a:	eddd 7ab5 	vldr	s15, [sp, #724]	@ 0x2d4
 8018e2e:	bf88      	it	hi
 8018e30:	f8ab 3002 	strhhi.w	r3, [fp, #2]
 8018e34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018e38:	bf88      	it	hi
 8018e3a:	f240 5306 	movwhi	r3, #1286	@ 0x506
 8018e3e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018e42:	ed9d 7ab6 	vldr	s14, [sp, #728]	@ 0x2d8
 8018e46:	eddd 7ab7 	vldr	s15, [sp, #732]	@ 0x2dc
 8018e4a:	bf88      	it	hi
 8018e4c:	f8ab 3004 	strhhi.w	r3, [fp, #4]
 8018e50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018e54:	bf88      	it	hi
 8018e56:	f44f 63e1 	movhi.w	r3, #1800	@ 0x708
 8018e5a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018e5e:	ed9d 7ab8 	vldr	s14, [sp, #736]	@ 0x2e0
 8018e62:	eddd 7ab9 	vldr	s15, [sp, #740]	@ 0x2e4
 8018e66:	bf88      	it	hi
 8018e68:	f8ab 3006 	strhhi.w	r3, [fp, #6]
 8018e6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018e70:	bf88      	it	hi
 8018e72:	f640 130a 	movwhi	r3, #2314	@ 0x90a
 8018e76:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018e7a:	ed9d 7aba 	vldr	s14, [sp, #744]	@ 0x2e8
 8018e7e:	eddd 7abb 	vldr	s15, [sp, #748]	@ 0x2ec
 8018e82:	bf88      	it	hi
 8018e84:	f8ab 3008 	strhhi.w	r3, [fp, #8]
 8018e88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018e8c:	bf88      	it	hi
 8018e8e:	f640 330c 	movwhi	r3, #2828	@ 0xb0c
 8018e92:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018e96:	ed9d 7abc 	vldr	s14, [sp, #752]	@ 0x2f0
 8018e9a:	eddd 7abd 	vldr	s15, [sp, #756]	@ 0x2f4
 8018e9e:	bf88      	it	hi
 8018ea0:	f8ab 300a 	strhhi.w	r3, [fp, #10]
 8018ea4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018ea8:	bf88      	it	hi
 8018eaa:	f640 530e 	movwhi	r3, #3342	@ 0xd0e
 8018eae:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018eb2:	ed9d 7abe 	vldr	s14, [sp, #760]	@ 0x2f8
 8018eb6:	eddd 7abf 	vldr	s15, [sp, #764]	@ 0x2fc
 8018eba:	bf88      	it	hi
 8018ebc:	f8ab 300c 	strhhi.w	r3, [fp, #12]
 8018ec0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018ec4:	bf88      	it	hi
 8018ec6:	f44f 6371 	movhi.w	r3, #3856	@ 0xf10
 8018eca:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018ece:	ed9d 7ac0 	vldr	s14, [sp, #768]	@ 0x300
 8018ed2:	eddd 7ac1 	vldr	s15, [sp, #772]	@ 0x304
 8018ed6:	bf88      	it	hi
 8018ed8:	f8ab 300e 	strhhi.w	r3, [fp, #14]
 8018edc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018ee0:	bf88      	it	hi
 8018ee2:	f241 1312 	movwhi	r3, #4370	@ 0x1112
 8018ee6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018eea:	ed9d 7ac2 	vldr	s14, [sp, #776]	@ 0x308
 8018eee:	eddd 7ac3 	vldr	s15, [sp, #780]	@ 0x30c
 8018ef2:	bf88      	it	hi
 8018ef4:	f8ab 3010 	strhhi.w	r3, [fp, #16]
 8018ef8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018efc:	bf88      	it	hi
 8018efe:	f241 3314 	movwhi	r3, #4884	@ 0x1314
 8018f02:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018f06:	bf88      	it	hi
 8018f08:	f8ab 3012 	strhhi.w	r3, [fp, #18]
 8018f0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018f10:	bf84      	itt	hi
 8018f12:	f241 5316 	movwhi	r3, #5398	@ 0x1516
 8018f16:	f8ab 3014 	strhhi.w	r3, [fp, #20]
 8018f1a:	ed9d 7ac4 	vldr	s14, [sp, #784]	@ 0x310
 8018f1e:	eddd 7ac5 	vldr	s15, [sp, #788]	@ 0x314
 8018f22:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018f26:	ed9d 7ac6 	vldr	s14, [sp, #792]	@ 0x318
 8018f2a:	eddd 7ac7 	vldr	s15, [sp, #796]	@ 0x31c
 8018f2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018f32:	bf88      	it	hi
 8018f34:	f241 7318 	movwhi	r3, #5912	@ 0x1718
 8018f38:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018f3c:	ed9d 7ac8 	vldr	s14, [sp, #800]	@ 0x320
 8018f40:	eddd 7ac9 	vldr	s15, [sp, #804]	@ 0x324
 8018f44:	bf88      	it	hi
 8018f46:	f8ab 3016 	strhhi.w	r3, [fp, #22]
 8018f4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018f4e:	bf88      	it	hi
 8018f50:	f641 131a 	movwhi	r3, #6426	@ 0x191a
 8018f54:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018f58:	ed9d 7aca 	vldr	s14, [sp, #808]	@ 0x328
 8018f5c:	eddd 7acb 	vldr	s15, [sp, #812]	@ 0x32c
 8018f60:	bf88      	it	hi
 8018f62:	f8ab 3018 	strhhi.w	r3, [fp, #24]
 8018f66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018f6a:	bf88      	it	hi
 8018f6c:	f641 331c 	movwhi	r3, #6940	@ 0x1b1c
 8018f70:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8018f74:	bf88      	it	hi
 8018f76:	f8ab 301a 	strhhi.w	r3, [fp, #26]
 8018f7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018f7e:	bf84      	itt	hi
 8018f80:	f641 531e 	movwhi	r3, #7454	@ 0x1d1e
 8018f84:	f8ab 301c 	strhhi.w	r3, [fp, #28]
 8018f88:	221e      	movs	r2, #30
 8018f8a:	2101      	movs	r1, #1
 8018f8c:	4650      	mov	r0, sl
 8018f8e:	f004 fb5a 	bl	801d646 <memset>
 8018f92:	2304      	movs	r3, #4
 8018f94:	930c      	str	r3, [sp, #48]	@ 0x30
 8018f96:	2302      	movs	r3, #2
 8018f98:	9307      	str	r3, [sp, #28]
 8018f9a:	9a07      	ldr	r2, [sp, #28]
 8018f9c:	920a      	str	r2, [sp, #40]	@ 0x28
 8018f9e:	4613      	mov	r3, r2
 8018fa0:	0052      	lsls	r2, r2, #1
 8018fa2:	9207      	str	r2, [sp, #28]
 8018fa4:	f103 0901 	add.w	r9, r3, #1
 8018fa8:	f04f 0801 	mov.w	r8, #1
 8018fac:	9b07      	ldr	r3, [sp, #28]
 8018fae:	f8cd 800c 	str.w	r8, [sp, #12]
 8018fb2:	4443      	add	r3, r8
 8018fb4:	2b1f      	cmp	r3, #31
 8018fb6:	bfa8      	it	ge
 8018fb8:	231f      	movge	r3, #31
 8018fba:	4642      	mov	r2, r8
 8018fbc:	1a9f      	subs	r7, r3, r2
 8018fbe:	2f00      	cmp	r7, #0
 8018fc0:	4698      	mov	r8, r3
 8018fc2:	f109 35ff 	add.w	r5, r9, #4294967295	@ 0xffffffff
 8018fc6:	dd54      	ble.n	8019072 <iNemoEngine_API_Update+0x1392>
 8018fc8:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
 8018fcc:	9304      	str	r3, [sp, #16]
 8018fce:	f1a8 0302 	sub.w	r3, r8, #2
 8018fd2:	4616      	mov	r6, r2
 8018fd4:	2400      	movs	r4, #0
 8018fd6:	9305      	str	r3, [sp, #20]
 8018fd8:	e00f      	b.n	8018ffa <iNemoEngine_API_Update+0x131a>
 8018fda:	bf00      	nop
 8018fdc:	00000000 	.word	0x00000000
 8018fe0:	3f333333 	.word	0x3f333333
 8018fe4:	3f4ccccd 	.word	0x3f4ccccd
 8018fe8:	45f0      	cmp	r8, lr
 8018fea:	f80a 2004 	strb.w	r2, [sl, r4]
 8018fee:	f000 81f6 	beq.w	80193de <iNemoEngine_API_Update+0x16fe>
 8018ff2:	4665      	mov	r5, ip
 8018ff4:	3401      	adds	r4, #1
 8018ff6:	42a7      	cmp	r7, r4
 8018ff8:	dd34      	ble.n	8019064 <iNemoEngine_API_Update+0x1384>
 8018ffa:	1e71      	subs	r1, r6, #1
 8018ffc:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8018ffe:	f91b 3001 	ldrsb.w	r3, [fp, r1]
 8019002:	f91b 2005 	ldrsb.w	r2, [fp, r5]
 8019006:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 801900a:	ed10 7a01 	vldr	s14, [r0, #-4]
 801900e:	a8ae      	add	r0, sp, #696	@ 0x2b8
 8019010:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 8019014:	ed50 7a01 	vldr	s15, [r0, #-4]
 8019018:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801901c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019020:	f105 0e02 	add.w	lr, r5, #2
 8019024:	f105 0c01 	add.w	ip, r5, #1
 8019028:	d8de      	bhi.n	8018fe8 <iNemoEngine_API_Update+0x1308>
 801902a:	3601      	adds	r6, #1
 801902c:	454e      	cmp	r6, r9
 801902e:	f80a 3004 	strb.w	r3, [sl, r4]
 8019032:	d1df      	bne.n	8018ff4 <iNemoEngine_API_Update+0x1314>
 8019034:	1c6b      	adds	r3, r5, #1
 8019036:	9a04      	ldr	r2, [sp, #16]
 8019038:	9308      	str	r3, [sp, #32]
 801903a:	1c60      	adds	r0, r4, #1
 801903c:	4598      	cmp	r8, r3
 801903e:	eba2 0205 	sub.w	r2, r2, r5
 8019042:	4450      	add	r0, sl
 8019044:	ddd6      	ble.n	8018ff4 <iNemoEngine_API_Update+0x1314>
 8019046:	eb0b 0105 	add.w	r1, fp, r5
 801904a:	f004 fb7c 	bl	801d746 <memcpy>
 801904e:	9a04      	ldr	r2, [sp, #16]
 8019050:	9b05      	ldr	r3, [sp, #20]
 8019052:	4414      	add	r4, r2
 8019054:	1b64      	subs	r4, r4, r5
 8019056:	1b5a      	subs	r2, r3, r5
 8019058:	3401      	adds	r4, #1
 801905a:	9b08      	ldr	r3, [sp, #32]
 801905c:	42a7      	cmp	r7, r4
 801905e:	eb02 0503 	add.w	r5, r2, r3
 8019062:	dcca      	bgt.n	8018ffa <iNemoEngine_API_Update+0x131a>
 8019064:	9b03      	ldr	r3, [sp, #12]
 8019066:	1e58      	subs	r0, r3, #1
 8019068:	463a      	mov	r2, r7
 801906a:	4458      	add	r0, fp
 801906c:	4651      	mov	r1, sl
 801906e:	f004 fb6a 	bl	801d746 <memcpy>
 8019072:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8019074:	eb08 0903 	add.w	r9, r8, r3
 8019078:	f1b9 0f1e 	cmp.w	r9, #30
 801907c:	dd96      	ble.n	8018fac <iNemoEngine_API_Update+0x12cc>
 801907e:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8019080:	3b01      	subs	r3, #1
 8019082:	930c      	str	r3, [sp, #48]	@ 0x30
 8019084:	d189      	bne.n	8018f9a <iNemoEngine_API_Update+0x12ba>
 8019086:	f99b 300e 	ldrsb.w	r3, [fp, #14]
 801908a:	aaae      	add	r2, sp, #696	@ 0x2b8
 801908c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8019090:	ed53 7a01 	vldr	s15, [r3, #-4]
 8019094:	f99b 300f 	ldrsb.w	r3, [fp, #15]
 8019098:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 801909c:	ed13 7a01 	vldr	s14, [r3, #-4]
 80190a0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80190a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80190a8:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 80190ac:	bf4c      	ite	mi
 80190ae:	2201      	movmi	r2, #1
 80190b0:	2200      	movpl	r2, #0
 80190b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80190b6:	bf4c      	ite	mi
 80190b8:	2301      	movmi	r3, #1
 80190ba:	2300      	movpl	r3, #0
 80190bc:	429a      	cmp	r2, r3
 80190be:	f000 819d 	beq.w	80193fc <iNemoEngine_API_Update+0x171c>
 80190c2:	ee77 7a87 	vadd.f32	s15, s15, s14
 80190c6:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 80190ca:	ee67 7a87 	vmul.f32	s15, s15, s14
 80190ce:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 80190d0:	ece3 7a01 	vstmia	r3!, {s15}
 80190d4:	9312      	str	r3, [sp, #72]	@ 0x48
 80190d6:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 80190d8:	3304      	adds	r3, #4
 80190da:	9310      	str	r3, [sp, #64]	@ 0x40
 80190dc:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80190de:	2b03      	cmp	r3, #3
 80190e0:	f47f ae6d 	bne.w	8018dbe <iNemoEngine_API_Update+0x10de>
 80190e4:	eddd 7a3e 	vldr	s15, [sp, #248]	@ 0xf8
 80190e8:	ed9d 7a3d 	vldr	s14, [sp, #244]	@ 0xf4
 80190ec:	eddd 6a16 	vldr	s13, [sp, #88]	@ 0x58
 80190f0:	ed1f 1a45 	vldr	s2, [pc, #-276]	@ 8018fe0 <iNemoEngine_API_Update+0x1300>
 80190f4:	9a06      	ldr	r2, [sp, #24]
 80190f6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80190fa:	ee2d 1a81 	vmul.f32	s2, s27, s2
 80190fe:	eee7 7a07 	vfma.f32	s15, s14, s14
 8019102:	f892 3900 	ldrb.w	r3, [r2, #2304]	@ 0x900
 8019106:	ed9d 7a18 	vldr	s14, [sp, #96]	@ 0x60
 801910a:	eeb0 8a67 	vmov.f32	s16, s15
 801910e:	eddd 7a3f 	vldr	s15, [sp, #252]	@ 0xfc
 8019112:	eea7 8aa7 	vfma.f32	s16, s15, s15
 8019116:	f502 6810 	add.w	r8, r2, #2304	@ 0x900
 801911a:	eef5 7a00 	vmov.f32	s15, #80	@ 0x3e800000  0.250
 801911e:	ee27 7a27 	vmul.f32	s14, s14, s15
 8019122:	eeb1 6ac8 	vsqrt.f32	s12, s16
 8019126:	eec7 5a0d 	vdiv.f32	s11, s14, s26
 801912a:	ee2b 7a27 	vmul.f32	s14, s22, s15
 801912e:	ee6d 7aa7 	vmul.f32	s15, s27, s15
 8019132:	eec7 6a26 	vdiv.f32	s13, s14, s13
 8019136:	ed9d 7a17 	vldr	s14, [sp, #92]	@ 0x5c
 801913a:	edcd 5a52 	vstr	s11, [sp, #328]	@ 0x148
 801913e:	ee87 5a87 	vdiv.f32	s10, s15, s14
 8019142:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8019146:	eeb0 7a41 	vmov.f32	s14, s2
 801914a:	eeab 7a27 	vfma.f32	s14, s22, s15
 801914e:	ee26 6a27 	vmul.f32	s12, s12, s15
 8019152:	ed5f 7a5c 	vldr	s15, [pc, #-368]	@ 8018fe4 <iNemoEngine_API_Update+0x1304>
 8019156:	ed8d 7a03 	vstr	s14, [sp, #12]
 801915a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801915e:	edcd 6a53 	vstr	s13, [sp, #332]	@ 0x14c
 8019162:	ed8d 5a54 	vstr	s10, [sp, #336]	@ 0x150
 8019166:	ed8d 6a55 	vstr	s12, [sp, #340]	@ 0x154
 801916a:	2b00      	cmp	r3, #0
 801916c:	f040 8159 	bne.w	8019422 <iNemoEngine_API_Update+0x1742>
 8019170:	f8d8 3028 	ldr.w	r3, [r8, #40]	@ 0x28
 8019174:	f8c8 302c 	str.w	r3, [r8, #44]	@ 0x2c
 8019178:	f8d8 3024 	ldr.w	r3, [r8, #36]	@ 0x24
 801917c:	f8c8 3028 	str.w	r3, [r8, #40]	@ 0x28
 8019180:	f8d8 3020 	ldr.w	r3, [r8, #32]
 8019184:	f8c8 3024 	str.w	r3, [r8, #36]	@ 0x24
 8019188:	f8d8 301c 	ldr.w	r3, [r8, #28]
 801918c:	f8c8 3020 	str.w	r3, [r8, #32]
 8019190:	edc8 7a07 	vstr	s15, [r8, #28]
 8019194:	f602 130c 	addw	r3, r2, #2316	@ 0x90c
 8019198:	edd3 8a00 	vldr	s17, [r3]
 801919c:	edd2 2a02 	vldr	s5, [r2, #8]
 80191a0:	f602 1324 	addw	r3, r2, #2340	@ 0x924
 80191a4:	edd3 7a00 	vldr	s15, [r3]
 80191a8:	f602 1308 	addw	r3, r2, #2312	@ 0x908
 80191ac:	ed93 7a00 	vldr	s14, [r3]
 80191b0:	f502 6312 	add.w	r3, r2, #2336	@ 0x920
 80191b4:	ee68 8aa7 	vmul.f32	s17, s17, s15
 80191b8:	edd3 7a00 	vldr	s15, [r3]
 80191bc:	f502 6311 	add.w	r3, r2, #2320	@ 0x910
 80191c0:	eee7 8a27 	vfma.f32	s17, s14, s15
 80191c4:	ed93 7a00 	vldr	s14, [r3]
 80191c8:	f602 1328 	addw	r3, r2, #2344	@ 0x928
 80191cc:	edd3 7a00 	vldr	s15, [r3]
 80191d0:	f602 1314 	addw	r3, r2, #2324	@ 0x914
 80191d4:	eee7 8a27 	vfma.f32	s17, s14, s15
 80191d8:	ed93 7a00 	vldr	s14, [r3]
 80191dc:	f602 132c 	addw	r3, r2, #2348	@ 0x92c
 80191e0:	edd3 7a00 	vldr	s15, [r3]
 80191e4:	f602 1304 	addw	r3, r2, #2308	@ 0x904
 80191e8:	eee7 8a27 	vfma.f32	s17, s14, s15
 80191ec:	ed93 7a00 	vldr	s14, [r3]
 80191f0:	f602 131c 	addw	r3, r2, #2332	@ 0x91c
 80191f4:	edd3 7a00 	vldr	s15, [r3]
 80191f8:	eef5 2ac0 	vcmpe.f32	s5, #0.0
 80191fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019200:	eee7 8a27 	vfma.f32	s17, s14, s15
 8019204:	f340 8158 	ble.w	80194b8 <iNemoEngine_API_Update+0x17d8>
 8019208:	edd2 7a30 	vldr	s15, [r2, #192]	@ 0xc0
 801920c:	eef4 7ae8 	vcmpe.f32	s15, s17
 8019210:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019214:	f101 8112 	bmi.w	801a43c <iNemoEngine_API_Update+0x275c>
 8019218:	ed92 fa31 	vldr	s30, [r2, #196]	@ 0xc4
 801921c:	4613      	mov	r3, r2
 801921e:	edd3 7a4a 	vldr	s15, [r3, #296]	@ 0x128
 8019222:	eef4 7ae8 	vcmpe.f32	s15, s17
 8019226:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801922a:	f142 8186 	bpl.w	801b53a <iNemoEngine_API_Update+0x385a>
 801922e:	edd3 4a62 	vldr	s9, [r3, #392]	@ 0x188
 8019232:	eef4 4ae8 	vcmpe.f32	s9, s17
 8019236:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801923a:	f342 821e 	ble.w	801b67a <iNemoEngine_API_Update+0x399a>
 801923e:	ed93 7a4c 	vldr	s14, [r3, #304]	@ 0x130
 8019242:	eeb4 7ae8 	vcmpe.f32	s14, s17
 8019246:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801924a:	f302 8555 	bgt.w	801bcf8 <iNemoEngine_API_Update+0x4018>
 801924e:	edd3 7a4e 	vldr	s15, [r3, #312]	@ 0x138
 8019252:	eef4 8ae7 	vcmpe.f32	s17, s15
 8019256:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801925a:	f142 8565 	bpl.w	801bd28 <iNemoEngine_API_Update+0x4048>
 801925e:	edd3 3a4d 	vldr	s7, [r3, #308]	@ 0x134
 8019262:	ed93 4a4f 	vldr	s8, [r3, #316]	@ 0x13c
 8019266:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801926a:	ee34 4a63 	vsub.f32	s8, s8, s7
 801926e:	ee38 7ac7 	vsub.f32	s14, s17, s14
 8019272:	ee24 7a07 	vmul.f32	s14, s8, s14
 8019276:	ee87 ca27 	vdiv.f32	s24, s14, s15
 801927a:	ee3c ca23 	vadd.f32	s24, s24, s7
 801927e:	edd3 7a50 	vldr	s15, [r3, #320]	@ 0x140
 8019282:	eef4 8ae7 	vcmpe.f32	s17, s15
 8019286:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801928a:	f2c2 8566 	blt.w	801bd5a <iNemoEngine_API_Update+0x407a>
 801928e:	9b06      	ldr	r3, [sp, #24]
 8019290:	ed93 7a52 	vldr	s14, [r3, #328]	@ 0x148
 8019294:	eef4 8ac7 	vcmpe.f32	s17, s14
 8019298:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801929c:	f142 87a3 	bpl.w	801c1e6 <iNemoEngine_API_Update+0x4506>
 80192a0:	edd3 3a51 	vldr	s7, [r3, #324]	@ 0x144
 80192a4:	ed93 4a53 	vldr	s8, [r3, #332]	@ 0x14c
 80192a8:	ee37 7a67 	vsub.f32	s14, s14, s15
 80192ac:	ee34 4a63 	vsub.f32	s8, s8, s7
 80192b0:	ee78 7ae7 	vsub.f32	s15, s17, s15
 80192b4:	ee64 7a27 	vmul.f32	s15, s8, s15
 80192b8:	ee87 ca87 	vdiv.f32	s24, s15, s14
 80192bc:	ee3c ca23 	vadd.f32	s24, s24, s7
 80192c0:	9b06      	ldr	r3, [sp, #24]
 80192c2:	edd3 7a54 	vldr	s15, [r3, #336]	@ 0x150
 80192c6:	eef4 8ae7 	vcmpe.f32	s17, s15
 80192ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80192ce:	f2c2 8566 	blt.w	801bd9e <iNemoEngine_API_Update+0x40be>
 80192d2:	9b06      	ldr	r3, [sp, #24]
 80192d4:	ed93 7a56 	vldr	s14, [r3, #344]	@ 0x158
 80192d8:	eef4 8ac7 	vcmpe.f32	s17, s14
 80192dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80192e0:	f142 87dc 	bpl.w	801c29c <iNemoEngine_API_Update+0x45bc>
 80192e4:	edd3 3a55 	vldr	s7, [r3, #340]	@ 0x154
 80192e8:	ed93 4a57 	vldr	s8, [r3, #348]	@ 0x15c
 80192ec:	ee37 7a67 	vsub.f32	s14, s14, s15
 80192f0:	ee34 4a63 	vsub.f32	s8, s8, s7
 80192f4:	ee78 7ae7 	vsub.f32	s15, s17, s15
 80192f8:	ee64 7a27 	vmul.f32	s15, s8, s15
 80192fc:	ee87 ca87 	vdiv.f32	s24, s15, s14
 8019300:	ee3c ca23 	vadd.f32	s24, s24, s7
 8019304:	9b06      	ldr	r3, [sp, #24]
 8019306:	edd3 7a58 	vldr	s15, [r3, #352]	@ 0x160
 801930a:	eef4 8ae7 	vcmpe.f32	s17, s15
 801930e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019312:	f2c2 8566 	blt.w	801bde2 <iNemoEngine_API_Update+0x4102>
 8019316:	9b06      	ldr	r3, [sp, #24]
 8019318:	ed93 7a5a 	vldr	s14, [r3, #360]	@ 0x168
 801931c:	eef4 8ac7 	vcmpe.f32	s17, s14
 8019320:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019324:	f142 87c5 	bpl.w	801c2b2 <iNemoEngine_API_Update+0x45d2>
 8019328:	edd3 3a59 	vldr	s7, [r3, #356]	@ 0x164
 801932c:	ed93 4a5b 	vldr	s8, [r3, #364]	@ 0x16c
 8019330:	ee37 7a67 	vsub.f32	s14, s14, s15
 8019334:	ee34 4a63 	vsub.f32	s8, s8, s7
 8019338:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801933c:	ee64 7a27 	vmul.f32	s15, s8, s15
 8019340:	ee87 ca87 	vdiv.f32	s24, s15, s14
 8019344:	ee3c ca23 	vadd.f32	s24, s24, s7
 8019348:	9b06      	ldr	r3, [sp, #24]
 801934a:	edd3 7a5c 	vldr	s15, [r3, #368]	@ 0x170
 801934e:	eef4 8ae7 	vcmpe.f32	s17, s15
 8019352:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019356:	f2c2 8566 	blt.w	801be26 <iNemoEngine_API_Update+0x4146>
 801935a:	9b06      	ldr	r3, [sp, #24]
 801935c:	ed93 7a5e 	vldr	s14, [r3, #376]	@ 0x178
 8019360:	eef4 8ac7 	vcmpe.f32	s17, s14
 8019364:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019368:	f142 8795 	bpl.w	801c296 <iNemoEngine_API_Update+0x45b6>
 801936c:	edd3 3a5d 	vldr	s7, [r3, #372]	@ 0x174
 8019370:	ed93 4a5f 	vldr	s8, [r3, #380]	@ 0x17c
 8019374:	ee37 7a67 	vsub.f32	s14, s14, s15
 8019378:	ee34 4a63 	vsub.f32	s8, s8, s7
 801937c:	ee78 7ae7 	vsub.f32	s15, s17, s15
 8019380:	ee64 7a27 	vmul.f32	s15, s8, s15
 8019384:	ee87 ca87 	vdiv.f32	s24, s15, s14
 8019388:	ee3c ca23 	vadd.f32	s24, s24, s7
 801938c:	9b06      	ldr	r3, [sp, #24]
 801938e:	edd3 7a60 	vldr	s15, [r3, #384]	@ 0x180
 8019392:	eef4 8ae7 	vcmpe.f32	s17, s15
 8019396:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801939a:	f2c0 8092 	blt.w	80194c2 <iNemoEngine_API_Update+0x17e2>
 801939e:	9b06      	ldr	r3, [sp, #24]
 80193a0:	ed93 4a61 	vldr	s8, [r3, #388]	@ 0x184
 80193a4:	ed93 7a63 	vldr	s14, [r3, #396]	@ 0x18c
 80193a8:	ee74 4ae7 	vsub.f32	s9, s9, s15
 80193ac:	ee37 7a44 	vsub.f32	s14, s14, s8
 80193b0:	ee78 7ae7 	vsub.f32	s15, s17, s15
 80193b4:	ee67 7a27 	vmul.f32	s15, s14, s15
 80193b8:	ee87 caa4 	vdiv.f32	s24, s15, s9
 80193bc:	ee3c ca04 	vadd.f32	s24, s24, s8
 80193c0:	e07f      	b.n	80194c2 <iNemoEngine_API_Update+0x17e2>
 80193c2:	eddf 7ad2 	vldr	s15, [pc, #840]	@ 801970c <iNemoEngine_API_Update+0x1a2c>
 80193c6:	eddf cad2 	vldr	s25, [pc, #840]	@ 8019710 <iNemoEngine_API_Update+0x1a30>
 80193ca:	edcd 7a21 	vstr	s15, [sp, #132]	@ 0x84
 80193ce:	eddf 7ad1 	vldr	s15, [pc, #836]	@ 8019714 <iNemoEngine_API_Update+0x1a34>
 80193d2:	edcd 7a23 	vstr	s15, [sp, #140]	@ 0x8c
 80193d6:	eef2 7a04 	vmov.f32	s15, #36	@ 0x41200000  10.0
 80193da:	f7ff b824 	b.w	8018426 <iNemoEngine_API_Update+0x746>
 80193de:	1c60      	adds	r0, r4, #1
 80193e0:	454e      	cmp	r6, r9
 80193e2:	4459      	add	r1, fp
 80193e4:	4450      	add	r0, sl
 80193e6:	4665      	mov	r5, ip
 80193e8:	f6bf ae04 	bge.w	8018ff4 <iNemoEngine_API_Update+0x1314>
 80193ec:	eba9 0206 	sub.w	r2, r9, r6
 80193f0:	444c      	add	r4, r9
 80193f2:	1ba4      	subs	r4, r4, r6
 80193f4:	f004 f9a7 	bl	801d746 <memcpy>
 80193f8:	464e      	mov	r6, r9
 80193fa:	e5fb      	b.n	8018ff4 <iNemoEngine_API_Update+0x1314>
 80193fc:	eef5 7a40 	vcmp.f32	s15, #0.0
 8019400:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019404:	f43f ae5d 	beq.w	80190c2 <iNemoEngine_API_Update+0x13e2>
 8019408:	eeb5 7a40 	vcmp.f32	s14, #0.0
 801940c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019410:	f43f ae57 	beq.w	80190c2 <iNemoEngine_API_Update+0x13e2>
 8019414:	ee37 7a67 	vsub.f32	s14, s14, s15
 8019418:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
 801941c:	eee7 7a26 	vfma.f32	s15, s14, s13
 8019420:	e655      	b.n	80190ce <iNemoEngine_API_Update+0x13ee>
 8019422:	2300      	movs	r3, #0
 8019424:	f882 3900 	strb.w	r3, [r2, #2304]	@ 0x900
 8019428:	edc8 7a07 	vstr	s15, [r8, #28]
 801942c:	edc8 7a08 	vstr	s15, [r8, #32]
 8019430:	edc8 7a09 	vstr	s15, [r8, #36]	@ 0x24
 8019434:	edc8 7a0a 	vstr	s15, [r8, #40]	@ 0x28
 8019438:	edc8 7a0b 	vstr	s15, [r8, #44]	@ 0x2c
 801943c:	e6aa      	b.n	8019194 <iNemoEngine_API_Update+0x14b4>
 801943e:	f04f 0908 	mov.w	r9, #8
 8019442:	f04f 0805 	mov.w	r8, #5
 8019446:	2202      	movs	r2, #2
 8019448:	f7ff bae3 	b.w	8018a12 <iNemoEngine_API_Update+0xd32>
 801944c:	2104      	movs	r1, #4
 801944e:	2000      	movs	r0, #0
 8019450:	f04f 0c06 	mov.w	ip, #6
 8019454:	f04f 0e07 	mov.w	lr, #7
 8019458:	2603      	movs	r6, #3
 801945a:	460c      	mov	r4, r1
 801945c:	2301      	movs	r3, #1
 801945e:	4607      	mov	r7, r0
 8019460:	f7ff babd 	b.w	80189de <iNemoEngine_API_Update+0xcfe>
 8019464:	ed9f 5aac 	vldr	s10, [pc, #688]	@ 8019718 <iNemoEngine_API_Update+0x1a38>
 8019468:	ed9f 8aac 	vldr	s16, [pc, #688]	@ 801971c <iNemoEngine_API_Update+0x1a3c>
 801946c:	ed9f 7ab7 	vldr	s14, [pc, #732]	@ 801974c <iNemoEngine_API_Update+0x1a6c>
 8019470:	eddf 6aab 	vldr	s13, [pc, #684]	@ 8019720 <iNemoEngine_API_Update+0x1a40>
 8019474:	ed84 5a00 	vstr	s10, [r4]
 8019478:	eef0 7a45 	vmov.f32	s15, s10
 801947c:	eeb0 6a45 	vmov.f32	s12, s10
 8019480:	eddf caa8 	vldr	s25, [pc, #672]	@ 8019724 <iNemoEngine_API_Update+0x1a44>
 8019484:	ed9f 9aa8 	vldr	s18, [pc, #672]	@ 8019728 <iNemoEngine_API_Update+0x1a48>
 8019488:	ed84 8a01 	vstr	s16, [r4, #4]
 801948c:	eef0 5a66 	vmov.f32	s11, s13
 8019490:	ed84 8a02 	vstr	s16, [r4, #8]
 8019494:	eeb0 5a47 	vmov.f32	s10, s14
 8019498:	eef0 8a67 	vmov.f32	s17, s15
 801949c:	eeb0 ca48 	vmov.f32	s24, s16
 80194a0:	f7fe bed8 	b.w	8018254 <iNemoEngine_API_Update+0x574>
 80194a4:	eef1 6a66 	vneg.f32	s13, s13
 80194a8:	e415      	b.n	8018cd6 <iNemoEngine_API_Update+0xff6>
 80194aa:	eeb1 4a44 	vneg.f32	s8, s8
 80194ae:	f7ff bbee 	b.w	8018c8e <iNemoEngine_API_Update+0xfae>
 80194b2:	eef1 7a67 	vneg.f32	s15, s15
 80194b6:	e431      	b.n	8018d1c <iNemoEngine_API_Update+0x103c>
 80194b8:	eeb7 ca00 	vmov.f32	s24, #112	@ 0x3f800000  1.0
 80194bc:	eeb0 fa4c 	vmov.f32	s30, s24
 80194c0:	4613      	mov	r3, r2
 80194c2:	edd3 fa74 	vldr	s31, [r3, #464]	@ 0x1d0
 80194c6:	ed93 7a72 	vldr	s14, [r3, #456]	@ 0x1c8
 80194ca:	eddd 7a1a 	vldr	s15, [sp, #104]	@ 0x68
 80194ce:	eddf 4a90 	vldr	s9, [pc, #576]	@ 8019710 <iNemoEngine_API_Update+0x1a30>
 80194d2:	ee7c faef 	vsub.f32	s31, s25, s31
 80194d6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80194da:	eef0 faef 	vabs.f32	s31, s31
 80194de:	eef0 7ae7 	vabs.f32	s15, s15
 80194e2:	ee77 7aaf 	vadd.f32	s15, s15, s31
 80194e6:	eef4 7ae4 	vcmpe.f32	s15, s9
 80194ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80194ee:	dd0a      	ble.n	8019506 <iNemoEngine_API_Update+0x1826>
 80194f0:	ed9f 4a8e 	vldr	s8, [pc, #568]	@ 801972c <iNemoEngine_API_Update+0x1a4c>
 80194f4:	eef4 7ac4 	vcmpe.f32	s15, s8
 80194f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80194fc:	f340 8790 	ble.w	801a420 <iNemoEngine_API_Update+0x2740>
 8019500:	eef1 4a04 	vmov.f32	s9, #20	@ 0x40a00000  5.0
 8019504:	e001      	b.n	801950a <iNemoEngine_API_Update+0x182a>
 8019506:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 801950a:	eddd 7a21 	vldr	s15, [sp, #132]	@ 0x84
 801950e:	781c      	ldrb	r4, [r3, #0]
 8019510:	eef4 4ae7 	vcmpe.f32	s9, s15
 8019514:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019518:	bfa8      	it	ge
 801951a:	eef0 7a64 	vmovge.f32	s15, s9
 801951e:	edcd 7a04 	vstr	s15, [sp, #16]
 8019522:	b1cc      	cbz	r4, 8019558 <iNemoEngine_API_Update+0x1878>
 8019524:	785c      	ldrb	r4, [r3, #1]
 8019526:	2c00      	cmp	r4, #0
 8019528:	f040 8774 	bne.w	801a414 <iNemoEngine_API_Update+0x2734>
 801952c:	ee75 7aa6 	vadd.f32	s15, s11, s13
 8019530:	edd3 6a05 	vldr	s13, [r3, #20]
 8019534:	ee75 7a27 	vadd.f32	s15, s10, s15
 8019538:	ee76 7a27 	vadd.f32	s15, s12, s15
 801953c:	eeb5 6a00 	vmov.f32	s12, #80	@ 0x3e800000  0.250
 8019540:	ee67 7a86 	vmul.f32	s15, s15, s12
 8019544:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 8019548:	ee66 6a86 	vmul.f32	s13, s13, s12
 801954c:	eef4 7ae6 	vcmpe.f32	s15, s13
 8019550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019554:	f102 848b 	bmi.w	801be6e <iNemoEngine_API_Update+0x418e>
 8019558:	edd3 7a73 	vldr	s15, [r3, #460]	@ 0x1cc
 801955c:	461a      	mov	r2, r3
 801955e:	eddd 6a1a 	vldr	s13, [sp, #104]	@ 0x68
 8019562:	ed9d 6a50 	vldr	s12, [sp, #320]	@ 0x140
 8019566:	edcd 6a98 	vstr	s13, [sp, #608]	@ 0x260
 801956a:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 801956e:	eef0 6a65 	vmov.f32	s13, s11
 8019572:	eee7 6a47 	vfms.f32	s13, s14, s14
 8019576:	2300      	movs	r3, #0
 8019578:	f8c2 31b0 	str.w	r3, [r2, #432]	@ 0x1b0
 801957c:	ed9d 5a4e 	vldr	s10, [sp, #312]	@ 0x138
 8019580:	eddd 4a4f 	vldr	s9, [sp, #316]	@ 0x13c
 8019584:	eddd 0a51 	vldr	s1, [sp, #324]	@ 0x144
 8019588:	ed8d 7a45 	vstr	s14, [sp, #276]	@ 0x114
 801958c:	ee26 4a06 	vmul.f32	s8, s12, s12
 8019590:	ee25 2a05 	vmul.f32	s4, s10, s10
 8019594:	ee34 4a04 	vadd.f32	s8, s8, s8
 8019598:	eeb1 3ae6 	vsqrt.f32	s6, s13
 801959c:	f8c2 31b4 	str.w	r3, [r2, #436]	@ 0x1b4
 80195a0:	f8c2 31b8 	str.w	r3, [r2, #440]	@ 0x1b8
 80195a4:	9343      	str	r3, [sp, #268]	@ 0x10c
 80195a6:	ee64 3a86 	vmul.f32	s7, s9, s12
 80195aa:	ee25 0a24 	vmul.f32	s0, s10, s9
 80195ae:	ee64 1aa4 	vmul.f32	s3, s9, s9
 80195b2:	ee64 6aa0 	vmul.f32	s13, s9, s1
 80195b6:	eef0 4a00 	vmov.f32	s9, #0	@ 0x40000000  2.0
 80195ba:	eea2 4a24 	vfma.f32	s8, s4, s9
 80195be:	ee73 3aa3 	vadd.f32	s7, s7, s7
 80195c2:	ee35 1ac4 	vsub.f32	s2, s11, s8
 80195c6:	ee25 4a06 	vmul.f32	s8, s10, s12
 80195ca:	ee26 6a20 	vmul.f32	s12, s12, s1
 80195ce:	ee71 1aa1 	vadd.f32	s3, s3, s3
 80195d2:	ee30 6a06 	vadd.f32	s12, s0, s12
 80195d6:	ee25 5a20 	vmul.f32	s10, s10, s1
 80195da:	ee76 6aa6 	vadd.f32	s13, s13, s13
 80195de:	eee2 1a24 	vfma.f32	s3, s4, s9
 80195e2:	ee36 2a06 	vadd.f32	s4, s12, s12
 80195e6:	eeb0 6a63 	vmov.f32	s12, s7
 80195ea:	eea5 6a24 	vfma.f32	s12, s10, s9
 80195ee:	eee5 3a64 	vfms.f32	s7, s10, s9
 80195f2:	eeb0 5a66 	vmov.f32	s10, s13
 80195f6:	ee7a 6aa6 	vadd.f32	s13, s21, s13
 80195fa:	ee94 5a24 	vfnms.f32	s10, s8, s9
 80195fe:	eee4 6a64 	vfms.f32	s13, s8, s9
 8019602:	ee25 5a07 	vmul.f32	s10, s10, s14
 8019606:	edcd 6a3d 	vstr	s13, [sp, #244]	@ 0xf4
 801960a:	edcd 6a92 	vstr	s13, [sp, #584]	@ 0x248
 801960e:	ee75 6ae1 	vsub.f32	s13, s11, s3
 8019612:	ee79 5ae5 	vsub.f32	s11, s19, s11
 8019616:	ee66 6a87 	vmul.f32	s13, s13, s14
 801961a:	ee75 1aa1 	vadd.f32	s3, s11, s3
 801961e:	eee3 6a23 	vfma.f32	s13, s6, s7
 8019622:	ee26 7a07 	vmul.f32	s14, s12, s14
 8019626:	eddd 5a2a 	vldr	s11, [sp, #168]	@ 0xa8
 801962a:	eddd 4a2c 	vldr	s9, [sp, #176]	@ 0xb0
 801962e:	ed8d 9a99 	vstr	s18, [sp, #612]	@ 0x264
 8019632:	ee75 6ae6 	vsub.f32	s13, s11, s13
 8019636:	eea3 7a01 	vfma.f32	s14, s6, s2
 801963a:	edcd 6a91 	vstr	s13, [sp, #580]	@ 0x244
 801963e:	eddd 6a2d 	vldr	s13, [sp, #180]	@ 0xb4
 8019642:	edcd ca9a 	vstr	s25, [sp, #616]	@ 0x268
 8019646:	ee36 7ac7 	vsub.f32	s14, s13, s14
 801964a:	eea3 5a02 	vfma.f32	s10, s6, s4
 801964e:	ed8d 7a90 	vstr	s14, [sp, #576]	@ 0x240
 8019652:	ed9f 7a43 	vldr	s14, [pc, #268]	@ 8019760 <iNemoEngine_API_Update+0x1a80>
 8019656:	ed8d 3a44 	vstr	s6, [sp, #272]	@ 0x110
 801965a:	ee3a 6a46 	vsub.f32	s12, s20, s12
 801965e:	ee34 5ac5 	vsub.f32	s10, s9, s10
 8019662:	eef4 7ac7 	vcmpe.f32	s15, s14
 8019666:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801966a:	ed8d 5a8f 	vstr	s10, [sp, #572]	@ 0x23c
 801966e:	edcd 1a3f 	vstr	s3, [sp, #252]	@ 0xfc
 8019672:	edcd 1a94 	vstr	s3, [sp, #592]	@ 0x250
 8019676:	ed8d 6a3e 	vstr	s12, [sp, #248]	@ 0xf8
 801967a:	ed8d 6a93 	vstr	s12, [sp, #588]	@ 0x24c
 801967e:	d541      	bpl.n	8019704 <iNemoEngine_API_Update+0x1a24>
 8019680:	ed9f 7a2b 	vldr	s14, [pc, #172]	@ 8019730 <iNemoEngine_API_Update+0x1a50>
 8019684:	eef4 7ac7 	vcmpe.f32	s15, s14
 8019688:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801968c:	dd3a      	ble.n	8019704 <iNemoEngine_API_Update+0x1a24>
 801968e:	ee79 7a67 	vsub.f32	s15, s18, s15
 8019692:	eef0 7ae7 	vabs.f32	s15, s15
 8019696:	ee77 7a8b 	vadd.f32	s15, s15, s22
 801969a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801969e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80196a2:	dd5f      	ble.n	8019764 <iNemoEngine_API_Update+0x1a84>
 80196a4:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80196a8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80196ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80196b0:	f140 86a4 	bpl.w	801a3fc <iNemoEngine_API_Update+0x271c>
 80196b4:	ed9f 7a1f 	vldr	s14, [pc, #124]	@ 8019734 <iNemoEngine_API_Update+0x1a54>
 80196b8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80196bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80196c0:	f141 8185 	bpl.w	801a9ce <iNemoEngine_API_Update+0x2cee>
 80196c4:	ed9f 7a1f 	vldr	s14, [pc, #124]	@ 8019744 <iNemoEngine_API_Update+0x1a64>
 80196c8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80196cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80196d0:	f2c1 8185 	blt.w	801a9de <iNemoEngine_API_Update+0x2cfe>
 80196d4:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 8019738 <iNemoEngine_API_Update+0x1a58>
 80196d8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80196dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80196e0:	f141 824e 	bpl.w	801ab80 <iNemoEngine_API_Update+0x2ea0>
 80196e4:	eddf 6a17 	vldr	s13, [pc, #92]	@ 8019744 <iNemoEngine_API_Update+0x1a64>
 80196e8:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 801973c <iNemoEngine_API_Update+0x1a5c>
 80196ec:	ed9f 6a14 	vldr	s12, [pc, #80]	@ 8019740 <iNemoEngine_API_Update+0x1a60>
 80196f0:	ee77 6ae6 	vsub.f32	s13, s15, s13
 80196f4:	ee66 6a87 	vmul.f32	s13, s13, s14
 80196f8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80196fc:	eea6 7a86 	vfma.f32	s14, s13, s12
 8019700:	f001 b977 	b.w	801a9f2 <iNemoEngine_API_Update+0x2d12>
 8019704:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8019708:	e7c1      	b.n	801968e <iNemoEngine_API_Update+0x19ae>
 801970a:	bf00      	nop
 801970c:	3ecccccc 	.word	0x3ecccccc
 8019710:	3dcccccd 	.word	0x3dcccccd
 8019714:	3f666666 	.word	0x3f666666
 8019718:	00000000 	.word	0x00000000
 801971c:	3f333333 	.word	0x3f333333
 8019720:	bfb33333 	.word	0xbfb33333
 8019724:	3f7d6d54 	.word	0x3f7d6d54
 8019728:	3f7ae147 	.word	0x3f7ae147
 801972c:	3fb77778 	.word	0x3fb77778
 8019730:	3f4ccccd 	.word	0x3f4ccccd
 8019734:	3ba3d70a 	.word	0x3ba3d70a
 8019738:	3c75c28f 	.word	0x3c75c28f
 801973c:	3f19999a 	.word	0x3f19999a
 8019740:	43480000 	.word	0x43480000
 8019744:	3c23d70a 	.word	0x3c23d70a
 8019748:	3b449ba6 	.word	0x3b449ba6
 801974c:	3fb33333 	.word	0x3fb33333
 8019750:	3ecccccd 	.word	0x3ecccccd
 8019754:	3f8f5c29 	.word	0x3f8f5c29
 8019758:	3f59999a 	.word	0x3f59999a
 801975c:	3e4ccccd 	.word	0x3e4ccccd
 8019760:	3f99999a 	.word	0x3f99999a
 8019764:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 8019768:	ed1f 4a0a 	vldr	s8, [pc, #-40]	@ 8019744 <iNemoEngine_API_Update+0x1a64>
 801976c:	ed1f 6a0a 	vldr	s12, [pc, #-40]	@ 8019748 <iNemoEngine_API_Update+0x1a68>
 8019770:	eeb0 7a65 	vmov.f32	s14, s11
 8019774:	eef0 6a65 	vmov.f32	s13, s11
 8019778:	ed8d 6a65 	vstr	s12, [sp, #404]	@ 0x194
 801977c:	ed9d 6a04 	vldr	s12, [sp, #16]
 8019780:	ed9d 3a84 	vldr	s6, [sp, #528]	@ 0x210
 8019784:	ed9d 5a83 	vldr	s10, [sp, #524]	@ 0x20c
 8019788:	ed9d 2a88 	vldr	s4, [sp, #544]	@ 0x220
 801978c:	eddd 4a8c 	vldr	s9, [sp, #560]	@ 0x230
 8019790:	9a06      	ldr	r2, [sp, #24]
 8019792:	ed8d 4a66 	vstr	s8, [sp, #408]	@ 0x198
 8019796:	ee66 3a0f 	vmul.f32	s7, s12, s30
 801979a:	ed9d 6a8d 	vldr	s12, [sp, #564]	@ 0x234
 801979e:	7b13      	ldrb	r3, [r2, #12]
 80197a0:	ee23 3a23 	vmul.f32	s6, s6, s7
 80197a4:	ee23 5a85 	vmul.f32	s10, s7, s10
 80197a8:	ed8d 3a84 	vstr	s6, [sp, #528]	@ 0x210
 80197ac:	ed9d 3a85 	vldr	s6, [sp, #532]	@ 0x214
 80197b0:	ed8d 5a83 	vstr	s10, [sp, #524]	@ 0x20c
 80197b4:	ee63 3a23 	vmul.f32	s7, s6, s7
 80197b8:	ed9d 3a86 	vldr	s6, [sp, #536]	@ 0x218
 80197bc:	edcd 3a85 	vstr	s7, [sp, #532]	@ 0x214
 80197c0:	eddd 3a87 	vldr	s7, [sp, #540]	@ 0x21c
 80197c4:	ee2c 3a03 	vmul.f32	s6, s24, s6
 80197c8:	ee6c 3a23 	vmul.f32	s7, s24, s7
 80197cc:	ee74 4aa4 	vadd.f32	s9, s9, s9
 80197d0:	ee2c ca02 	vmul.f32	s24, s24, s4
 80197d4:	ee36 6a06 	vadd.f32	s12, s12, s12
 80197d8:	ed9d 2a8e 	vldr	s4, [sp, #568]	@ 0x238
 80197dc:	ed8d 3a86 	vstr	s6, [sp, #536]	@ 0x218
 80197e0:	ee64 4a87 	vmul.f32	s9, s9, s14
 80197e4:	ee26 6a07 	vmul.f32	s12, s12, s14
 80197e8:	ee2f fa02 	vmul.f32	s30, s30, s4
 80197ec:	edcd 4a8c 	vstr	s9, [sp, #560]	@ 0x230
 80197f0:	ed8d 6a8d 	vstr	s12, [sp, #564]	@ 0x234
 80197f4:	edcd 3a87 	vstr	s7, [sp, #540]	@ 0x21c
 80197f8:	ed8d ca88 	vstr	s24, [sp, #544]	@ 0x220
 80197fc:	ed8d fa8e 	vstr	s30, [sp, #568]	@ 0x238
 8019800:	2b00      	cmp	r3, #0
 8019802:	f000 8525 	beq.w	801a250 <iNemoEngine_API_Update+0x2570>
 8019806:	ee27 3a03 	vmul.f32	s6, s14, s6
 801980a:	ee67 3a23 	vmul.f32	s7, s14, s7
 801980e:	ee27 ca0c 	vmul.f32	s24, s14, s24
 8019812:	ed9d 2a22 	vldr	s4, [sp, #136]	@ 0x88
 8019816:	ed8d 3a86 	vstr	s6, [sp, #536]	@ 0x218
 801981a:	ee37 7a07 	vadd.f32	s14, s14, s14
 801981e:	4613      	mov	r3, r2
 8019820:	ee25 2a82 	vmul.f32	s4, s11, s4
 8019824:	7b92      	ldrb	r2, [r2, #14]
 8019826:	7b5b      	ldrb	r3, [r3, #13]
 8019828:	edcd 3a87 	vstr	s7, [sp, #540]	@ 0x21c
 801982c:	ee64 5a25 	vmul.f32	s11, s8, s11
 8019830:	ee26 6a07 	vmul.f32	s12, s12, s14
 8019834:	edcd 5a66 	vstr	s11, [sp, #408]	@ 0x198
 8019838:	ed8d ca88 	vstr	s24, [sp, #544]	@ 0x220
 801983c:	ed8d 2a5f 	vstr	s4, [sp, #380]	@ 0x17c
 8019840:	ed8d 2a60 	vstr	s4, [sp, #384]	@ 0x180
 8019844:	ed8d 2a61 	vstr	s4, [sp, #388]	@ 0x184
 8019848:	ed8d 6a8d 	vstr	s12, [sp, #564]	@ 0x234
 801984c:	f88d 20eb 	strb.w	r2, [sp, #235]	@ 0xeb
 8019850:	f88d 20ec 	strb.w	r2, [sp, #236]	@ 0xec
 8019854:	f88d 20ed 	strb.w	r2, [sp, #237]	@ 0xed
 8019858:	f88d 30e8 	strb.w	r3, [sp, #232]	@ 0xe8
 801985c:	f88d 30e9 	strb.w	r3, [sp, #233]	@ 0xe9
 8019860:	f88d 30ea 	strb.w	r3, [sp, #234]	@ 0xea
 8019864:	b15a      	cbz	r2, 801987e <iNemoEngine_API_Update+0x1b9e>
 8019866:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801986a:	eef4 7ac7 	vcmpe.f32	s15, s14
 801986e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019872:	dd04      	ble.n	801987e <iNemoEngine_API_Update+0x1b9e>
 8019874:	2100      	movs	r1, #0
 8019876:	f8ad 10eb 	strh.w	r1, [sp, #235]	@ 0xeb
 801987a:	f88d 10ed 	strb.w	r1, [sp, #237]	@ 0xed
 801987e:	eef5 2ac0 	vcmpe.f32	s5, #0.0
 8019882:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019886:	dd08      	ble.n	801989a <iNemoEngine_API_Update+0x1bba>
 8019888:	9906      	ldr	r1, [sp, #24]
 801988a:	edd1 7a64 	vldr	s15, [r1, #400]	@ 0x190
 801988e:	eef4 7ae8 	vcmpe.f32	s15, s17
 8019892:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019896:	f280 85a4 	bge.w	801a3e2 <iNemoEngine_API_Update+0x2702>
 801989a:	b133      	cbz	r3, 80198aa <iNemoEngine_API_Update+0x1bca>
 801989c:	f240 1101 	movw	r1, #257	@ 0x101
 80198a0:	f8ad 10e8 	strh.w	r1, [sp, #232]	@ 0xe8
 80198a4:	2101      	movs	r1, #1
 80198a6:	f88d 10ea 	strb.w	r1, [sp, #234]	@ 0xea
 80198aa:	2401      	movs	r4, #1
 80198ac:	f88d 40f1 	strb.w	r4, [sp, #241]	@ 0xf1
 80198b0:	f88d 40f3 	strb.w	r4, [sp, #243]	@ 0xf3
 80198b4:	ed5f 7a5b 	vldr	s15, [pc, #-364]	@ 801974c <iNemoEngine_API_Update+0x1a6c>
 80198b8:	eef4 cae7 	vcmpe.f32	s25, s15
 80198bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80198c0:	dc07      	bgt.n	80198d2 <iNemoEngine_API_Update+0x1bf2>
 80198c2:	ed5f 7a5d 	vldr	s15, [pc, #-372]	@ 8019750 <iNemoEngine_API_Update+0x1a70>
 80198c6:	eef4 cae7 	vcmpe.f32	s25, s15
 80198ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80198ce:	f141 801d 	bpl.w	801a90c <iNemoEngine_API_Update+0x2c2c>
 80198d2:	2300      	movs	r3, #0
 80198d4:	f8ad 30e8 	strh.w	r3, [sp, #232]	@ 0xe8
 80198d8:	f88d 30ea 	strb.w	r3, [sp, #234]	@ 0xea
 80198dc:	f88d 30f1 	strb.w	r3, [sp, #241]	@ 0xf1
 80198e0:	f88d 30f3 	strb.w	r3, [sp, #243]	@ 0xf3
 80198e4:	ed5f 7a65 	vldr	s15, [pc, #-404]	@ 8019754 <iNemoEngine_API_Update+0x1a74>
 80198e8:	eeb4 9ae7 	vcmpe.f32	s18, s15
 80198ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80198f0:	dc07      	bgt.n	8019902 <iNemoEngine_API_Update+0x1c22>
 80198f2:	ed5f 7a67 	vldr	s15, [pc, #-412]	@ 8019758 <iNemoEngine_API_Update+0x1a78>
 80198f6:	eeb4 9ae7 	vcmpe.f32	s18, s15
 80198fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80198fe:	f140 86ed 	bpl.w	801a6dc <iNemoEngine_API_Update+0x29fc>
 8019902:	2300      	movs	r3, #0
 8019904:	f8ad 30eb 	strh.w	r3, [sp, #235]	@ 0xeb
 8019908:	f88d 30ed 	strb.w	r3, [sp, #237]	@ 0xed
 801990c:	f8ad 30f1 	strh.w	r3, [sp, #241]	@ 0xf1
 8019910:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8019914:	eef4 fae7 	vcmpe.f32	s31, s15
 8019918:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801991c:	f340 8486 	ble.w	801a22c <iNemoEngine_API_Update+0x254c>
 8019920:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8019924:	ee7f 7aa7 	vadd.f32	s15, s31, s15
 8019928:	9a06      	ldr	r2, [sp, #24]
 801992a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801992e:	2300      	movs	r3, #0
 8019930:	ee67 4aa4 	vmul.f32	s9, s15, s9
 8019934:	ee27 fa8f 	vmul.f32	s30, s15, s30
 8019938:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
 801993c:	eef4 fae7 	vcmpe.f32	s31, s15
 8019940:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019944:	bfc4      	itt	gt
 8019946:	f88d 30f1 	strbgt.w	r3, [sp, #241]	@ 0xf1
 801994a:	f88d 30f3 	strbgt.w	r3, [sp, #243]	@ 0xf3
 801994e:	f8ad 30e8 	strh.w	r3, [sp, #232]	@ 0xe8
 8019952:	f88d 30ea 	strb.w	r3, [sp, #234]	@ 0xea
 8019956:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8019958:	edcd 4a8c 	vstr	s9, [sp, #560]	@ 0x230
 801995c:	2b0e      	cmp	r3, #14
 801995e:	ed8d fa8e 	vstr	s30, [sp, #568]	@ 0x238
 8019962:	f340 8567 	ble.w	801a434 <iNemoEngine_API_Update+0x2754>
 8019966:	eddd 7a18 	vldr	s15, [sp, #96]	@ 0x60
 801996a:	eeb4 dae7 	vcmpe.f32	s26, s15
 801996e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019972:	f340 82ed 	ble.w	8019f50 <iNemoEngine_API_Update+0x2270>
 8019976:	eddd 7a16 	vldr	s15, [sp, #88]	@ 0x58
 801997a:	eef4 7acb 	vcmpe.f32	s15, s22
 801997e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019982:	f340 82e5 	ble.w	8019f50 <iNemoEngine_API_Update+0x2270>
 8019986:	eddd 7a17 	vldr	s15, [sp, #92]	@ 0x5c
 801998a:	eef4 7aed 	vcmpe.f32	s15, s27
 801998e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019992:	f340 82dd 	ble.w	8019f50 <iNemoEngine_API_Update+0x2270>
 8019996:	ed5f 7a8f 	vldr	s15, [pc, #-572]	@ 801975c <iNemoEngine_API_Update+0x1a7c>
 801999a:	eeb0 7ace 	vabs.f32	s14, s28
 801999e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80199a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80199a6:	f140 82d3 	bpl.w	8019f50 <iNemoEngine_API_Update+0x2270>
 80199aa:	eeb0 7aee 	vabs.f32	s14, s29
 80199ae:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80199b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80199b6:	f140 82cb 	bpl.w	8019f50 <iNemoEngine_API_Update+0x2270>
 80199ba:	eeb0 7aeb 	vabs.f32	s14, s23
 80199be:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80199c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80199c6:	f140 82c3 	bpl.w	8019f50 <iNemoEngine_API_Update+0x2270>
 80199ca:	ed5f 7a9b 	vldr	s15, [pc, #-620]	@ 8019760 <iNemoEngine_API_Update+0x1a80>
 80199ce:	eef0 aaea 	vabs.f32	s21, s21
 80199d2:	eef4 aae7 	vcmpe.f32	s21, s15
 80199d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80199da:	f140 82b9 	bpl.w	8019f50 <iNemoEngine_API_Update+0x2270>
 80199de:	eeb0 aaca 	vabs.f32	s20, s20
 80199e2:	eeb4 aae7 	vcmpe.f32	s20, s15
 80199e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80199ea:	f140 82b1 	bpl.w	8019f50 <iNemoEngine_API_Update+0x2270>
 80199ee:	eef0 9ae9 	vabs.f32	s19, s19
 80199f2:	eef4 9ae7 	vcmpe.f32	s19, s15
 80199f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80199fa:	f140 82a9 	bpl.w	8019f50 <iNemoEngine_API_Update+0x2270>
 80199fe:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8019a00:	9806      	ldr	r0, [sp, #24]
 8019a02:	ed93 6a00 	vldr	s12, [r3]
 8019a06:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8019a08:	f890 11a0 	ldrb.w	r1, [r0, #416]	@ 0x1a0
 8019a0c:	ed93 7a00 	vldr	s14, [r3]
 8019a10:	f200 73a4 	addw	r3, r0, #1956	@ 0x7a4
 8019a14:	edd3 4a00 	vldr	s9, [r3]
 8019a18:	2909      	cmp	r1, #9
 8019a1a:	eeb4 6ae4 	vcmpe.f32	s12, s9
 8019a1e:	f500 63f6 	add.w	r3, r0, #1968	@ 0x7b0
 8019a22:	ed93 5a00 	vldr	s10, [r3]
 8019a26:	bf8c      	ite	hi
 8019a28:	220a      	movhi	r2, #10
 8019a2a:	2205      	movls	r2, #5
 8019a2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019a30:	bfb4      	ite	lt
 8019a32:	eef0 7a64 	vmovlt.f32	s15, s9
 8019a36:	eef0 7a46 	vmovge.f32	s15, s12
 8019a3a:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019a3e:	bf8c      	ite	hi
 8019a40:	eef0 5a64 	vmovhi.f32	s11, s9
 8019a44:	eef0 5a46 	vmovls.f32	s11, s12
 8019a48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019a4c:	ee36 6a24 	vadd.f32	s12, s12, s9
 8019a50:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019a54:	bfb8      	it	lt
 8019a56:	eef0 7a45 	vmovlt.f32	s15, s10
 8019a5a:	f200 73bc 	addw	r3, r0, #1980	@ 0x7bc
 8019a5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019a62:	bf88      	it	hi
 8019a64:	eef0 5a45 	vmovhi.f32	s11, s10
 8019a68:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019a6c:	ed93 5a00 	vldr	s10, [r3]
 8019a70:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019a74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019a78:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019a7c:	bfb8      	it	lt
 8019a7e:	eef0 7a45 	vmovlt.f32	s15, s10
 8019a82:	f500 63f9 	add.w	r3, r0, #1992	@ 0x7c8
 8019a86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019a8a:	bf88      	it	hi
 8019a8c:	eef0 5a45 	vmovhi.f32	s11, s10
 8019a90:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019a94:	ed93 5a00 	vldr	s10, [r3]
 8019a98:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019a9c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019aa0:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019aa4:	bfb8      	it	lt
 8019aa6:	eef0 7a45 	vmovlt.f32	s15, s10
 8019aaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019aae:	bf88      	it	hi
 8019ab0:	eef0 5a45 	vmovhi.f32	s11, s10
 8019ab4:	2a05      	cmp	r2, #5
 8019ab6:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019aba:	d065      	beq.n	8019b88 <iNemoEngine_API_Update+0x1ea8>
 8019abc:	f200 73d4 	addw	r3, r0, #2004	@ 0x7d4
 8019ac0:	ed93 5a00 	vldr	s10, [r3]
 8019ac4:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019ac8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019acc:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019ad0:	bfb8      	it	lt
 8019ad2:	eef0 7a45 	vmovlt.f32	s15, s10
 8019ad6:	f500 63fc 	add.w	r3, r0, #2016	@ 0x7e0
 8019ada:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019ade:	bf88      	it	hi
 8019ae0:	eef0 5a45 	vmovhi.f32	s11, s10
 8019ae4:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019ae8:	ed93 5a00 	vldr	s10, [r3]
 8019aec:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019af0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019af4:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019af8:	bfb8      	it	lt
 8019afa:	eef0 7a45 	vmovlt.f32	s15, s10
 8019afe:	f200 73ec 	addw	r3, r0, #2028	@ 0x7ec
 8019b02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019b06:	bf88      	it	hi
 8019b08:	eef0 5a45 	vmovhi.f32	s11, s10
 8019b0c:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019b10:	ed93 5a00 	vldr	s10, [r3]
 8019b14:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019b18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019b1c:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019b20:	bfb8      	it	lt
 8019b22:	eef0 7a45 	vmovlt.f32	s15, s10
 8019b26:	f500 63ff 	add.w	r3, r0, #2040	@ 0x7f8
 8019b2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019b2e:	bf88      	it	hi
 8019b30:	eef0 5a45 	vmovhi.f32	s11, s10
 8019b34:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019b38:	ed93 5a00 	vldr	s10, [r3]
 8019b3c:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019b40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019b44:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019b48:	bfb8      	it	lt
 8019b4a:	eef0 7a45 	vmovlt.f32	s15, s10
 8019b4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019b52:	bf88      	it	hi
 8019b54:	eef0 5a45 	vmovhi.f32	s11, s10
 8019b58:	2a0a      	cmp	r2, #10
 8019b5a:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019b5e:	d113      	bne.n	8019b88 <iNemoEngine_API_Update+0x1ea8>
 8019b60:	f600 0304 	addw	r3, r0, #2052	@ 0x804
 8019b64:	ed93 5a00 	vldr	s10, [r3]
 8019b68:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019b6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019b70:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019b74:	bfb8      	it	lt
 8019b76:	eef0 7a45 	vmovlt.f32	s15, s10
 8019b7a:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019b7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019b82:	bf88      	it	hi
 8019b84:	eef0 5a45 	vmovhi.f32	s11, s10
 8019b88:	ee77 7ae5 	vsub.f32	s15, s15, s11
 8019b8c:	eddf 5aeb 	vldr	s11, [pc, #940]	@ 8019f3c <iNemoEngine_API_Update+0x225c>
 8019b90:	ed9f 5aeb 	vldr	s10, [pc, #940]	@ 8019f40 <iNemoEngine_API_Update+0x2260>
 8019b94:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019b98:	ee26 6a05 	vmul.f32	s12, s12, s10
 8019b9c:	eef4 7ae5 	vcmpe.f32	s15, s11
 8019ba0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019ba4:	f300 81d4 	bgt.w	8019f50 <iNemoEngine_API_Update+0x2270>
 8019ba8:	eef0 7ac6 	vabs.f32	s15, s12
 8019bac:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019bb0:	ed9f 6ae4 	vldr	s12, [pc, #912]	@ 8019f44 <iNemoEngine_API_Update+0x2264>
 8019bb4:	eef4 7ac6 	vcmpe.f32	s15, s12
 8019bb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019bbc:	f300 81c8 	bgt.w	8019f50 <iNemoEngine_API_Update+0x2270>
 8019bc0:	9806      	ldr	r0, [sp, #24]
 8019bc2:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
 8019bc4:	ed93 6a00 	vldr	s12, [r3]
 8019bc8:	f500 63f5 	add.w	r3, r0, #1960	@ 0x7a8
 8019bcc:	edd3 4a00 	vldr	s9, [r3]
 8019bd0:	f200 73b4 	addw	r3, r0, #1972	@ 0x7b4
 8019bd4:	eeb4 6ae4 	vcmpe.f32	s12, s9
 8019bd8:	ed93 5a00 	vldr	s10, [r3]
 8019bdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019be0:	bfb4      	ite	lt
 8019be2:	eef0 7a64 	vmovlt.f32	s15, s9
 8019be6:	eef0 7a46 	vmovge.f32	s15, s12
 8019bea:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019bee:	bf8c      	ite	hi
 8019bf0:	eef0 5a64 	vmovhi.f32	s11, s9
 8019bf4:	eef0 5a46 	vmovls.f32	s11, s12
 8019bf8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019bfc:	ee36 6a24 	vadd.f32	s12, s12, s9
 8019c00:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019c04:	bfb8      	it	lt
 8019c06:	eef0 7a45 	vmovlt.f32	s15, s10
 8019c0a:	f500 63f8 	add.w	r3, r0, #1984	@ 0x7c0
 8019c0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c12:	bf88      	it	hi
 8019c14:	eef0 5a45 	vmovhi.f32	s11, s10
 8019c18:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019c1c:	ed93 5a00 	vldr	s10, [r3]
 8019c20:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019c24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c28:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019c2c:	bfb8      	it	lt
 8019c2e:	eef0 7a45 	vmovlt.f32	s15, s10
 8019c32:	f200 73cc 	addw	r3, r0, #1996	@ 0x7cc
 8019c36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c3a:	bf88      	it	hi
 8019c3c:	eef0 5a45 	vmovhi.f32	s11, s10
 8019c40:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019c44:	ed93 5a00 	vldr	s10, [r3]
 8019c48:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019c4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c50:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019c54:	bfb8      	it	lt
 8019c56:	eef0 7a45 	vmovlt.f32	s15, s10
 8019c5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c5e:	bf88      	it	hi
 8019c60:	eef0 5a45 	vmovhi.f32	s11, s10
 8019c64:	2a05      	cmp	r2, #5
 8019c66:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019c6a:	d065      	beq.n	8019d38 <iNemoEngine_API_Update+0x2058>
 8019c6c:	f500 63fb 	add.w	r3, r0, #2008	@ 0x7d8
 8019c70:	ed93 5a00 	vldr	s10, [r3]
 8019c74:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019c78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c7c:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019c80:	bfb8      	it	lt
 8019c82:	eef0 7a45 	vmovlt.f32	s15, s10
 8019c86:	f200 73e4 	addw	r3, r0, #2020	@ 0x7e4
 8019c8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c8e:	bf88      	it	hi
 8019c90:	eef0 5a45 	vmovhi.f32	s11, s10
 8019c94:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019c98:	ed93 5a00 	vldr	s10, [r3]
 8019c9c:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019ca0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019ca4:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019ca8:	bfb8      	it	lt
 8019caa:	eef0 7a45 	vmovlt.f32	s15, s10
 8019cae:	f500 63fe 	add.w	r3, r0, #2032	@ 0x7f0
 8019cb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019cb6:	bf88      	it	hi
 8019cb8:	eef0 5a45 	vmovhi.f32	s11, s10
 8019cbc:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019cc0:	ed93 5a00 	vldr	s10, [r3]
 8019cc4:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019cc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019ccc:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019cd0:	bfb8      	it	lt
 8019cd2:	eef0 7a45 	vmovlt.f32	s15, s10
 8019cd6:	f200 73fc 	addw	r3, r0, #2044	@ 0x7fc
 8019cda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019cde:	bf88      	it	hi
 8019ce0:	eef0 5a45 	vmovhi.f32	s11, s10
 8019ce4:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019ce8:	ed93 5a00 	vldr	s10, [r3]
 8019cec:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019cf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019cf4:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019cf8:	bfb8      	it	lt
 8019cfa:	eef0 7a45 	vmovlt.f32	s15, s10
 8019cfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019d02:	bf88      	it	hi
 8019d04:	eef0 5a45 	vmovhi.f32	s11, s10
 8019d08:	2a0a      	cmp	r2, #10
 8019d0a:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019d0e:	d113      	bne.n	8019d38 <iNemoEngine_API_Update+0x2058>
 8019d10:	f600 0308 	addw	r3, r0, #2056	@ 0x808
 8019d14:	ed93 5a00 	vldr	s10, [r3]
 8019d18:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019d1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019d20:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019d24:	bfb8      	it	lt
 8019d26:	eef0 7a45 	vmovlt.f32	s15, s10
 8019d2a:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019d2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019d32:	bf88      	it	hi
 8019d34:	eef0 5a45 	vmovhi.f32	s11, s10
 8019d38:	ee77 7ae5 	vsub.f32	s15, s15, s11
 8019d3c:	eddf 5a7f 	vldr	s11, [pc, #508]	@ 8019f3c <iNemoEngine_API_Update+0x225c>
 8019d40:	ed9f 5a7f 	vldr	s10, [pc, #508]	@ 8019f40 <iNemoEngine_API_Update+0x2260>
 8019d44:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019d48:	ee26 6a05 	vmul.f32	s12, s12, s10
 8019d4c:	eef4 7ae5 	vcmpe.f32	s15, s11
 8019d50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019d54:	f300 80fc 	bgt.w	8019f50 <iNemoEngine_API_Update+0x2270>
 8019d58:	eef0 7ac6 	vabs.f32	s15, s12
 8019d5c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019d60:	ed9f 6a78 	vldr	s12, [pc, #480]	@ 8019f44 <iNemoEngine_API_Update+0x2264>
 8019d64:	eef4 7ac6 	vcmpe.f32	s15, s12
 8019d68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019d6c:	f300 80f0 	bgt.w	8019f50 <iNemoEngine_API_Update+0x2270>
 8019d70:	9806      	ldr	r0, [sp, #24]
 8019d72:	9b2f      	ldr	r3, [sp, #188]	@ 0xbc
 8019d74:	ed93 5a00 	vldr	s10, [r3]
 8019d78:	f200 73ac 	addw	r3, r0, #1964	@ 0x7ac
 8019d7c:	edd3 4a00 	vldr	s9, [r3]
 8019d80:	f500 63f7 	add.w	r3, r0, #1976	@ 0x7b8
 8019d84:	eeb4 5ae4 	vcmpe.f32	s10, s9
 8019d88:	ed93 6a00 	vldr	s12, [r3]
 8019d8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019d90:	bfb4      	ite	lt
 8019d92:	eef0 7a64 	vmovlt.f32	s15, s9
 8019d96:	eef0 7a45 	vmovge.f32	s15, s10
 8019d9a:	bf8c      	ite	hi
 8019d9c:	eef0 5a64 	vmovhi.f32	s11, s9
 8019da0:	eef0 5a45 	vmovls.f32	s11, s10
 8019da4:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8019da8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019dac:	ee35 5a24 	vadd.f32	s10, s10, s9
 8019db0:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8019db4:	bfa8      	it	ge
 8019db6:	eef0 7a46 	vmovge.f32	s15, s12
 8019dba:	f200 73c4 	addw	r3, r0, #1988	@ 0x7c4
 8019dbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019dc2:	bf98      	it	ls
 8019dc4:	eef0 5a46 	vmovls.f32	s11, s12
 8019dc8:	ee76 4a05 	vadd.f32	s9, s12, s10
 8019dcc:	ed93 6a00 	vldr	s12, [r3]
 8019dd0:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8019dd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019dd8:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8019ddc:	bfa8      	it	ge
 8019dde:	eef0 7a46 	vmovge.f32	s15, s12
 8019de2:	f500 63fa 	add.w	r3, r0, #2000	@ 0x7d0
 8019de6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019dea:	bf8c      	ite	hi
 8019dec:	eeb0 5a65 	vmovhi.f32	s10, s11
 8019df0:	eeb0 5a46 	vmovls.f32	s10, s12
 8019df4:	edd3 5a00 	vldr	s11, [r3]
 8019df8:	eef4 5ae7 	vcmpe.f32	s11, s15
 8019dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e00:	ee36 6a24 	vadd.f32	s12, s12, s9
 8019e04:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019e08:	bfa8      	it	ge
 8019e0a:	eef0 7a65 	vmovge.f32	s15, s11
 8019e0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e12:	ee35 6a86 	vadd.f32	s12, s11, s12
 8019e16:	bf88      	it	hi
 8019e18:	eef0 5a45 	vmovhi.f32	s11, s10
 8019e1c:	2a05      	cmp	r2, #5
 8019e1e:	d065      	beq.n	8019eec <iNemoEngine_API_Update+0x220c>
 8019e20:	f200 73dc 	addw	r3, r0, #2012	@ 0x7dc
 8019e24:	ed93 5a00 	vldr	s10, [r3]
 8019e28:	eeb4 5ae7 	vcmpe.f32	s10, s15
 8019e2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e30:	eeb4 5ae5 	vcmpe.f32	s10, s11
 8019e34:	bfa8      	it	ge
 8019e36:	eef0 7a45 	vmovge.f32	s15, s10
 8019e3a:	f500 63fd 	add.w	r3, r0, #2024	@ 0x7e8
 8019e3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e42:	bf98      	it	ls
 8019e44:	eef0 5a45 	vmovls.f32	s11, s10
 8019e48:	ee35 5a06 	vadd.f32	s10, s10, s12
 8019e4c:	ed93 6a00 	vldr	s12, [r3]
 8019e50:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8019e54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e58:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8019e5c:	bfa8      	it	ge
 8019e5e:	eef0 7a46 	vmovge.f32	s15, s12
 8019e62:	f200 73f4 	addw	r3, r0, #2036	@ 0x7f4
 8019e66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e6a:	bf98      	it	ls
 8019e6c:	eef0 5a46 	vmovls.f32	s11, s12
 8019e70:	ee36 5a05 	vadd.f32	s10, s12, s10
 8019e74:	ed93 6a00 	vldr	s12, [r3]
 8019e78:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8019e7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e80:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8019e84:	bfa8      	it	ge
 8019e86:	eef0 7a46 	vmovge.f32	s15, s12
 8019e8a:	f500 6300 	add.w	r3, r0, #2048	@ 0x800
 8019e8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019e92:	bf98      	it	ls
 8019e94:	eef0 5a46 	vmovls.f32	s11, s12
 8019e98:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019e9c:	ed93 5a00 	vldr	s10, [r3]
 8019ea0:	eeb4 5ae7 	vcmpe.f32	s10, s15
 8019ea4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019ea8:	eeb4 5ae5 	vcmpe.f32	s10, s11
 8019eac:	bfa8      	it	ge
 8019eae:	eef0 7a45 	vmovge.f32	s15, s10
 8019eb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019eb6:	bf98      	it	ls
 8019eb8:	eef0 5a45 	vmovls.f32	s11, s10
 8019ebc:	2a0a      	cmp	r2, #10
 8019ebe:	ee35 6a06 	vadd.f32	s12, s10, s12
 8019ec2:	d113      	bne.n	8019eec <iNemoEngine_API_Update+0x220c>
 8019ec4:	f600 030c 	addw	r3, r0, #2060	@ 0x80c
 8019ec8:	ed93 5a00 	vldr	s10, [r3]
 8019ecc:	eef4 7ac5 	vcmpe.f32	s15, s10
 8019ed0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019ed4:	eef4 5ac5 	vcmpe.f32	s11, s10
 8019ed8:	bfb8      	it	lt
 8019eda:	eef0 7a45 	vmovlt.f32	s15, s10
 8019ede:	ee36 6a05 	vadd.f32	s12, s12, s10
 8019ee2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019ee6:	bf88      	it	hi
 8019ee8:	eef0 5a45 	vmovhi.f32	s11, s10
 8019eec:	ee77 7ae5 	vsub.f32	s15, s15, s11
 8019ef0:	eddf 5a12 	vldr	s11, [pc, #72]	@ 8019f3c <iNemoEngine_API_Update+0x225c>
 8019ef4:	ed9f 5a12 	vldr	s10, [pc, #72]	@ 8019f40 <iNemoEngine_API_Update+0x2260>
 8019ef8:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019efc:	ee26 6a05 	vmul.f32	s12, s12, s10
 8019f00:	eef4 7ae5 	vcmpe.f32	s15, s11
 8019f04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019f08:	dc22      	bgt.n	8019f50 <iNemoEngine_API_Update+0x2270>
 8019f0a:	eef0 7ac6 	vabs.f32	s15, s12
 8019f0e:	ee27 7a87 	vmul.f32	s14, s15, s14
 8019f12:	eddf 7a0c 	vldr	s15, [pc, #48]	@ 8019f44 <iNemoEngine_API_Update+0x2264>
 8019f16:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8019f1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019f1e:	dc17      	bgt.n	8019f50 <iNemoEngine_API_Update+0x2270>
 8019f20:	9b06      	ldr	r3, [sp, #24]
 8019f22:	795b      	ldrb	r3, [r3, #5]
 8019f24:	2b00      	cmp	r3, #0
 8019f26:	f002 8117 	beq.w	801c158 <iNemoEngine_API_Update+0x4478>
 8019f2a:	f003 02fd 	and.w	r2, r3, #253	@ 0xfd
 8019f2e:	2a01      	cmp	r2, #1
 8019f30:	f001 87d1 	beq.w	801bed6 <iNemoEngine_API_Update+0x41f6>
 8019f34:	f04f 0901 	mov.w	r9, #1
 8019f38:	f000 bc0b 	b.w	801a752 <iNemoEngine_API_Update+0x2a72>
 8019f3c:	3be56041 	.word	0x3be56041
 8019f40:	3dcccccd 	.word	0x3dcccccd
 8019f44:	3e333333 	.word	0x3e333333
 8019f48:	42480000 	.word	0x42480000
 8019f4c:	00000000 	.word	0x00000000
 8019f50:	9b06      	ldr	r3, [sp, #24]
 8019f52:	795b      	ldrb	r3, [r3, #5]
 8019f54:	f04f 0900 	mov.w	r9, #0
 8019f58:	f8ad 90ee 	strh.w	r9, [sp, #238]	@ 0xee
 8019f5c:	f88d 90f0 	strb.w	r9, [sp, #240]	@ 0xf0
 8019f60:	2b00      	cmp	r3, #0
 8019f62:	f040 83f1 	bne.w	801a748 <iNemoEngine_API_Update+0x2a68>
 8019f66:	9906      	ldr	r1, [sp, #24]
 8019f68:	f8d1 21bc 	ldr.w	r2, [r1, #444]	@ 0x1bc
 8019f6c:	9295      	str	r2, [sp, #596]	@ 0x254
 8019f6e:	f8d1 21c0 	ldr.w	r2, [r1, #448]	@ 0x1c0
 8019f72:	9296      	str	r2, [sp, #600]	@ 0x258
 8019f74:	f8d1 21c4 	ldr.w	r2, [r1, #452]	@ 0x1c4
 8019f78:	9297      	str	r2, [sp, #604]	@ 0x25c
 8019f7a:	2200      	movs	r2, #0
 8019f7c:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 8019f80:	f8ad 20ee 	strh.w	r2, [sp, #238]	@ 0xee
 8019f84:	f88d 20f0 	strb.w	r2, [sp, #240]	@ 0xf0
 8019f88:	f881 21a3 	strb.w	r2, [r1, #419]	@ 0x1a3
 8019f8c:	704a      	strb	r2, [r1, #1]
 8019f8e:	ed5f 7a12 	vldr	s15, [pc, #-72]	@ 8019f48 <iNemoEngine_API_Update+0x2268>
 8019f92:	eef4 6ae7 	vcmpe.f32	s13, s15
 8019f96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019f9a:	f2c0 8138 	blt.w	801a20e <iNemoEngine_API_Update+0x252e>
 8019f9e:	9906      	ldr	r1, [sp, #24]
 8019fa0:	2200      	movs	r2, #0
 8019fa2:	f8ad 20ee 	strh.w	r2, [sp, #238]	@ 0xee
 8019fa6:	f88d 20f0 	strb.w	r2, [sp, #240]	@ 0xf0
 8019faa:	f881 21a2 	strb.w	r2, [r1, #418]	@ 0x1a2
 8019fae:	2b01      	cmp	r3, #1
 8019fb0:	d125      	bne.n	8019ffe <iNemoEngine_API_Update+0x231e>
 8019fb2:	eddd 4a86 	vldr	s9, [sp, #536]	@ 0x218
 8019fb6:	ed9d 6a5f 	vldr	s12, [sp, #380]	@ 0x17c
 8019fba:	ed9d 5a87 	vldr	s10, [sp, #540]	@ 0x21c
 8019fbe:	ed9d 7a60 	vldr	s14, [sp, #384]	@ 0x180
 8019fc2:	eddd 5a88 	vldr	s11, [sp, #544]	@ 0x220
 8019fc6:	eddd 7a61 	vldr	s15, [sp, #388]	@ 0x184
 8019fca:	eeb6 4a08 	vmov.f32	s8, #104	@ 0x3f400000  0.750
 8019fce:	ee64 4a84 	vmul.f32	s9, s9, s8
 8019fd2:	ee36 6a06 	vadd.f32	s12, s12, s12
 8019fd6:	ee25 5a04 	vmul.f32	s10, s10, s8
 8019fda:	ee37 7a07 	vadd.f32	s14, s14, s14
 8019fde:	ee65 5a84 	vmul.f32	s11, s11, s8
 8019fe2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8019fe6:	edcd 4a86 	vstr	s9, [sp, #536]	@ 0x218
 8019fea:	ed8d 6a5f 	vstr	s12, [sp, #380]	@ 0x17c
 8019fee:	ed8d 5a87 	vstr	s10, [sp, #540]	@ 0x21c
 8019ff2:	ed8d 7a60 	vstr	s14, [sp, #384]	@ 0x180
 8019ff6:	edcd 5a88 	vstr	s11, [sp, #544]	@ 0x220
 8019ffa:	edcd 7a61 	vstr	s15, [sp, #388]	@ 0x184
 8019ffe:	9c06      	ldr	r4, [sp, #24]
 801a000:	ed9d 6a60 	vldr	s12, [sp, #384]	@ 0x180
 801a004:	ed94 2a7f 	vldr	s4, [r4, #508]	@ 0x1fc
 801a008:	edd4 1a75 	vldr	s3, [r4, #468]	@ 0x1d4
 801a00c:	edd4 2a89 	vldr	s5, [r4, #548]	@ 0x224
 801a010:	edd4 3a93 	vldr	s7, [r4, #588]	@ 0x24c
 801a014:	eddd 0a5f 	vldr	s1, [sp, #380]	@ 0x17c
 801a018:	ed9d 1a61 	vldr	s2, [sp, #388]	@ 0x184
 801a01c:	ed94 4a9d 	vldr	s8, [r4, #628]	@ 0x274
 801a020:	edd4 4aa7 	vldr	s9, [r4, #668]	@ 0x29c
 801a024:	ed94 5ab1 	vldr	s10, [r4, #708]	@ 0x2c4
 801a028:	ed9d 3a8b 	vldr	s6, [sp, #556]	@ 0x22c
 801a02c:	ed9d 7a89 	vldr	s14, [sp, #548]	@ 0x224
 801a030:	eddd 7a8a 	vldr	s15, [sp, #552]	@ 0x228
 801a034:	edd4 5abb 	vldr	s11, [r4, #748]	@ 0x2ec
 801a038:	eea6 2a06 	vfma.f32	s4, s12, s12
 801a03c:	ab83      	add	r3, sp, #524	@ 0x20c
 801a03e:	aa8f      	add	r2, sp, #572	@ 0x23c
 801a040:	ed9d 6a62 	vldr	s12, [sp, #392]	@ 0x188
 801a044:	ed84 2a7f 	vstr	s4, [r4, #508]	@ 0x1fc
 801a048:	eee0 1aa0 	vfma.f32	s3, s1, s1
 801a04c:	a93a      	add	r1, sp, #232	@ 0xe8
 801a04e:	f504 70d6 	add.w	r0, r4, #428	@ 0x1ac
 801a052:	eee1 2a01 	vfma.f32	s5, s2, s2
 801a056:	eee6 3a06 	vfma.f32	s7, s12, s12
 801a05a:	eddd 0a63 	vldr	s1, [sp, #396]	@ 0x18c
 801a05e:	ed9d 1a64 	vldr	s2, [sp, #400]	@ 0x190
 801a062:	ed9d 6a65 	vldr	s12, [sp, #404]	@ 0x194
 801a066:	edc4 1a75 	vstr	s3, [r4, #468]	@ 0x1d4
 801a06a:	eea0 4aa0 	vfma.f32	s8, s1, s1
 801a06e:	eee1 4a01 	vfma.f32	s9, s2, s2
 801a072:	eea6 5a06 	vfma.f32	s10, s12, s12
 801a076:	eddd 0a66 	vldr	s1, [sp, #408]	@ 0x198
 801a07a:	ed9d 1a67 	vldr	s2, [sp, #412]	@ 0x19c
 801a07e:	ed94 6ac5 	vldr	s12, [r4, #788]	@ 0x314
 801a082:	edc4 2a89 	vstr	s5, [r4, #548]	@ 0x224
 801a086:	eee0 5aa0 	vfma.f32	s11, s1, s1
 801a08a:	eea1 6a01 	vfma.f32	s12, s2, s2
 801a08e:	ee26 7a87 	vmul.f32	s14, s13, s14
 801a092:	ee66 7aa7 	vmul.f32	s15, s13, s15
 801a096:	ee66 6a83 	vmul.f32	s13, s13, s6
 801a09a:	ee27 7a28 	vmul.f32	s14, s14, s17
 801a09e:	ee67 7aa8 	vmul.f32	s15, s15, s17
 801a0a2:	ee66 8aa8 	vmul.f32	s17, s13, s17
 801a0a6:	ed8d 7a89 	vstr	s14, [sp, #548]	@ 0x224
 801a0aa:	edcd 7a8a 	vstr	s15, [sp, #552]	@ 0x228
 801a0ae:	edc4 3a93 	vstr	s7, [r4, #588]	@ 0x24c
 801a0b2:	ed84 4a9d 	vstr	s8, [r4, #628]	@ 0x274
 801a0b6:	edc4 4aa7 	vstr	s9, [r4, #668]	@ 0x29c
 801a0ba:	ed84 5ab1 	vstr	s10, [r4, #708]	@ 0x2c4
 801a0be:	edcd 8a8b 	vstr	s17, [sp, #556]	@ 0x22c
 801a0c2:	edc4 5abb 	vstr	s11, [r4, #748]	@ 0x2ec
 801a0c6:	ed84 6ac5 	vstr	s12, [r4, #788]	@ 0x314
 801a0ca:	9300      	str	r3, [sp, #0]
 801a0cc:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801a0ce:	f7fc fb1d 	bl	801670c <kf_update>
 801a0d2:	edd4 6a6d 	vldr	s13, [r4, #436]	@ 0x1b4
 801a0d6:	ed94 6a6c 	vldr	s12, [r4, #432]	@ 0x1b0
 801a0da:	ed94 7a6e 	vldr	s14, [r4, #440]	@ 0x1b8
 801a0de:	ee66 7aa6 	vmul.f32	s15, s13, s13
 801a0e2:	eef7 5a00 	vmov.f32	s11, #112	@ 0x3f800000  1.0
 801a0e6:	eee6 7a06 	vfma.f32	s15, s12, s12
 801a0ea:	eee7 7a07 	vfma.f32	s15, s14, s14
 801a0ee:	eef4 7ae5 	vcmpe.f32	s15, s11
 801a0f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a0f6:	f100 80bb 	bmi.w	801a270 <iNemoEngine_API_Update+0x2590>
 801a0fa:	ed5f 5a6c 	vldr	s11, [pc, #-432]	@ 8019f4c <iNemoEngine_API_Update+0x226c>
 801a0fe:	ed8d 6a52 	vstr	s12, [sp, #328]	@ 0x148
 801a102:	eee5 7aa5 	vfma.f32	s15, s11, s11
 801a106:	aa4e      	add	r2, sp, #312	@ 0x138
 801a108:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801a10a:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 801a10e:	eeb1 5ae7 	vsqrt.f32	s10, s15
 801a112:	4611      	mov	r1, r2
 801a114:	ae68      	add	r6, sp, #416	@ 0x1a0
 801a116:	af70      	add	r7, sp, #448	@ 0x1c0
 801a118:	edcd 6a53 	vstr	s13, [sp, #332]	@ 0x14c
 801a11c:	eec4 7a85 	vdiv.f32	s15, s9, s10
 801a120:	ed8d 7a54 	vstr	s14, [sp, #336]	@ 0x150
 801a124:	ee27 6a86 	vmul.f32	s12, s15, s12
 801a128:	ee66 6aa7 	vmul.f32	s13, s13, s15
 801a12c:	ee27 7a87 	vmul.f32	s14, s15, s14
 801a130:	ee67 7aa5 	vmul.f32	s15, s15, s11
 801a134:	edcd 5a55 	vstr	s11, [sp, #340]	@ 0x154
 801a138:	ed8d 6aae 	vstr	s12, [sp, #696]	@ 0x2b8
 801a13c:	edcd 6aaf 	vstr	s13, [sp, #700]	@ 0x2bc
 801a140:	ed8d 7ab0 	vstr	s14, [sp, #704]	@ 0x2c0
 801a144:	edcd 7ab1 	vstr	s15, [sp, #708]	@ 0x2c4
 801a148:	f7fc f920 	bl	801638c <qmult>
 801a14c:	ed92 6a01 	vldr	s12, [r2, #4]
 801a150:	edd2 5a00 	vldr	s11, [r2]
 801a154:	edd2 6a02 	vldr	s13, [r2, #8]
 801a158:	ed92 7a03 	vldr	s14, [r2, #12]
 801a15c:	9d29      	ldr	r5, [sp, #164]	@ 0xa4
 801a15e:	ee66 7a06 	vmul.f32	s15, s12, s12
 801a162:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 801a166:	eee5 7aa5 	vfma.f32	s15, s11, s11
 801a16a:	eee6 7aa6 	vfma.f32	s15, s13, s13
 801a16e:	eee7 7a07 	vfma.f32	s15, s14, s14
 801a172:	eeb1 5ae7 	vsqrt.f32	s10, s15
 801a176:	eec4 7a85 	vdiv.f32	s15, s9, s10
 801a17a:	ee65 5aa7 	vmul.f32	s11, s11, s15
 801a17e:	ee26 6a27 	vmul.f32	s12, s12, s15
 801a182:	ee66 6aa7 	vmul.f32	s13, s13, s15
 801a186:	ee27 7a27 	vmul.f32	s14, s14, s15
 801a18a:	edcd 5a4a 	vstr	s11, [sp, #296]	@ 0x128
 801a18e:	ed8d 6a4b 	vstr	s12, [sp, #300]	@ 0x12c
 801a192:	edcd 6a4c 	vstr	s13, [sp, #304]	@ 0x130
 801a196:	ed8d 7a4d 	vstr	s14, [sp, #308]	@ 0x134
 801a19a:	4634      	mov	r4, r6
 801a19c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a19e:	42bc      	cmp	r4, r7
 801a1a0:	f105 0510 	add.w	r5, r5, #16
 801a1a4:	f106 0610 	add.w	r6, r6, #16
 801a1a8:	f845 0c10 	str.w	r0, [r5, #-16]
 801a1ac:	f845 1c0c 	str.w	r1, [r5, #-12]
 801a1b0:	f845 2c08 	str.w	r2, [r5, #-8]
 801a1b4:	f845 3c04 	str.w	r3, [r5, #-4]
 801a1b8:	d1ef      	bne.n	801a19a <iNemoEngine_API_Update+0x24ba>
 801a1ba:	6830      	ldr	r0, [r6, #0]
 801a1bc:	6028      	str	r0, [r5, #0]
 801a1be:	9e06      	ldr	r6, [sp, #24]
 801a1c0:	9a25      	ldr	r2, [sp, #148]	@ 0x94
 801a1c2:	f8d6 31bc 	ldr.w	r3, [r6, #444]	@ 0x1bc
 801a1c6:	6013      	str	r3, [r2, #0]
 801a1c8:	9a26      	ldr	r2, [sp, #152]	@ 0x98
 801a1ca:	f8d6 31c0 	ldr.w	r3, [r6, #448]	@ 0x1c0
 801a1ce:	6013      	str	r3, [r2, #0]
 801a1d0:	9a27      	ldr	r2, [sp, #156]	@ 0x9c
 801a1d2:	f8d6 31c4 	ldr.w	r3, [r6, #452]	@ 0x1c4
 801a1d6:	6013      	str	r3, [r2, #0]
 801a1d8:	ad4a      	add	r5, sp, #296	@ 0x128
 801a1da:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a1dc:	9d24      	ldr	r5, [sp, #144]	@ 0x90
 801a1de:	60eb      	str	r3, [r5, #12]
 801a1e0:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
 801a1e2:	6028      	str	r0, [r5, #0]
 801a1e4:	6069      	str	r1, [r5, #4]
 801a1e6:	60aa      	str	r2, [r5, #8]
 801a1e8:	edd6 9a75 	vldr	s19, [r6, #468]	@ 0x1d4
 801a1ec:	edc3 5a00 	vstr	s11, [r3]
 801a1f0:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 801a1f2:	f8d6 794c 	ldr.w	r7, [r6, #2380]	@ 0x94c
 801a1f6:	ed83 6a00 	vstr	s12, [r3]
 801a1fa:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 801a1fc:	edc3 6a00 	vstr	s13, [r3]
 801a200:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
 801a202:	accc      	add	r4, sp, #816	@ 0x330
 801a204:	ed83 7a00 	vstr	s14, [r3]
 801a208:	4635      	mov	r5, r6
 801a20a:	f7fd be20 	b.w	8017e4e <iNemoEngine_API_Update+0x16e>
 801a20e:	9906      	ldr	r1, [sp, #24]
 801a210:	f891 21a2 	ldrb.w	r2, [r1, #418]	@ 0x1a2
 801a214:	2a31      	cmp	r2, #49	@ 0x31
 801a216:	f63f aeca 	bhi.w	8019fae <iNemoEngine_API_Update+0x22ce>
 801a21a:	3201      	adds	r2, #1
 801a21c:	f881 21a2 	strb.w	r2, [r1, #418]	@ 0x1a2
 801a220:	2200      	movs	r2, #0
 801a222:	f8ad 20ee 	strh.w	r2, [sp, #238]	@ 0xee
 801a226:	f88d 20f0 	strb.w	r2, [sp, #240]	@ 0xf0
 801a22a:	e6c0      	b.n	8019fae <iNemoEngine_API_Update+0x22ce>
 801a22c:	9a06      	ldr	r2, [sp, #24]
 801a22e:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 801a230:	2b00      	cmp	r3, #0
 801a232:	f340 8398 	ble.w	801a966 <iNemoEngine_API_Update+0x2c86>
 801a236:	3b01      	subs	r3, #1
 801a238:	6593      	str	r3, [r2, #88]	@ 0x58
 801a23a:	2300      	movs	r3, #0
 801a23c:	f8ad 30e8 	strh.w	r3, [sp, #232]	@ 0xe8
 801a240:	f88d 30ea 	strb.w	r3, [sp, #234]	@ 0xea
 801a244:	f88d 30f1 	strb.w	r3, [sp, #241]	@ 0xf1
 801a248:	f88d 30f3 	strb.w	r3, [sp, #243]	@ 0xf3
 801a24c:	f7ff bb8b 	b.w	8019966 <iNemoEngine_API_Update+0x1c86>
 801a250:	7b53      	ldrb	r3, [r2, #13]
 801a252:	7b92      	ldrb	r2, [r2, #14]
 801a254:	f88d 30e8 	strb.w	r3, [sp, #232]	@ 0xe8
 801a258:	f88d 30e9 	strb.w	r3, [sp, #233]	@ 0xe9
 801a25c:	f88d 30ea 	strb.w	r3, [sp, #234]	@ 0xea
 801a260:	f88d 20eb 	strb.w	r2, [sp, #235]	@ 0xeb
 801a264:	f88d 20ec 	strb.w	r2, [sp, #236]	@ 0xec
 801a268:	f88d 20ed 	strb.w	r2, [sp, #237]	@ 0xed
 801a26c:	f7ff bb07 	b.w	801987e <iNemoEngine_API_Update+0x1b9e>
 801a270:	ee35 5ae7 	vsub.f32	s10, s11, s15
 801a274:	eef1 5ac5 	vsqrt.f32	s11, s10
 801a278:	e741      	b.n	801a0fe <iNemoEngine_API_Update+0x241e>
 801a27a:	f9b5 3974 	ldrsh.w	r3, [r5, #2420]	@ 0x974
 801a27e:	2b00      	cmp	r3, #0
 801a280:	f341 8173 	ble.w	801b56a <iNemoEngine_API_Update+0x388a>
 801a284:	3b01      	subs	r3, #1
 801a286:	f8a5 3974 	strh.w	r3, [r5, #2420]	@ 0x974
 801a28a:	f7fd bd51 	b.w	8017d30 <iNemoEngine_API_Update+0x50>
 801a28e:	ee27 6aa7 	vmul.f32	s12, s15, s15
 801a292:	ee67 7aa8 	vmul.f32	s15, s15, s17
 801a296:	eea7 6a07 	vfma.f32	s12, s14, s14
 801a29a:	eee6 7a87 	vfma.f32	s15, s13, s14
 801a29e:	eeb0 8a67 	vmov.f32	s16, s15
 801a2a2:	eef0 7a46 	vmov.f32	s15, s12
 801a2a6:	eee6 7ae6 	vfms.f32	s15, s13, s13
 801a2aa:	eee8 7ae8 	vfms.f32	s15, s17, s17
 801a2ae:	ee17 0a90 	vmov	r0, s15
 801a2b2:	f7e6 f951 	bl	8000558 <__aeabi_f2d>
 801a2b6:	ee78 7a08 	vadd.f32	s15, s16, s16
 801a2ba:	4602      	mov	r2, r0
 801a2bc:	460b      	mov	r3, r1
 801a2be:	ee17 0a90 	vmov	r0, s15
 801a2c2:	ec43 2b18 	vmov	d8, r2, r3
 801a2c6:	f7e6 f947 	bl	8000558 <__aeabi_f2d>
 801a2ca:	eeb0 1a48 	vmov.f32	s2, s16
 801a2ce:	eef0 1a68 	vmov.f32	s3, s17
 801a2d2:	ec41 0b10 	vmov	d0, r0, r1
 801a2d6:	f005 f941 	bl	801f55c <atan2>
 801a2da:	a3eb      	add	r3, pc, #940	@ (adr r3, 801a688 <iNemoEngine_API_Update+0x29a8>)
 801a2dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 801a2e0:	ec51 0b10 	vmov	r0, r1, d0
 801a2e4:	f7e6 f990 	bl	8000608 <__aeabi_dmul>
 801a2e8:	4be9      	ldr	r3, [pc, #932]	@ (801a690 <iNemoEngine_API_Update+0x29b0>)
 801a2ea:	2200      	movs	r2, #0
 801a2ec:	f7e5 ffd6 	bl	800029c <__adddf3>
 801a2f0:	f7e6 fc82 	bl	8000bf8 <__aeabi_d2f>
 801a2f4:	ee08 0a10 	vmov	s16, r0
 801a2f8:	f7fd be3a 	b.w	8017f70 <iNemoEngine_API_Update+0x290>
 801a2fc:	ee27 6aa7 	vmul.f32	s12, s15, s15
 801a300:	ee67 7aa8 	vmul.f32	s15, s15, s17
 801a304:	eea7 6a07 	vfma.f32	s12, s14, s14
 801a308:	eee6 7a87 	vfma.f32	s15, s13, s14
 801a30c:	eeb0 8a67 	vmov.f32	s16, s15
 801a310:	eef0 7a46 	vmov.f32	s15, s12
 801a314:	eee6 7ae6 	vfms.f32	s15, s13, s13
 801a318:	eee8 7ae8 	vfms.f32	s15, s17, s17
 801a31c:	ee17 0a90 	vmov	r0, s15
 801a320:	f7e6 f91a 	bl	8000558 <__aeabi_f2d>
 801a324:	ee78 7a08 	vadd.f32	s15, s16, s16
 801a328:	4602      	mov	r2, r0
 801a32a:	460b      	mov	r3, r1
 801a32c:	ee17 0a90 	vmov	r0, s15
 801a330:	ec43 2b18 	vmov	d8, r2, r3
 801a334:	f7e6 f910 	bl	8000558 <__aeabi_f2d>
 801a338:	eeb0 1a48 	vmov.f32	s2, s16
 801a33c:	eef0 1a68 	vmov.f32	s3, s17
 801a340:	ec41 0b10 	vmov	d0, r0, r1
 801a344:	f005 f90a 	bl	801f55c <atan2>
 801a348:	a3cf      	add	r3, pc, #828	@ (adr r3, 801a688 <iNemoEngine_API_Update+0x29a8>)
 801a34a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801a34e:	ec51 0b10 	vmov	r0, r1, d0
 801a352:	f7e6 f959 	bl	8000608 <__aeabi_dmul>
 801a356:	4bce      	ldr	r3, [pc, #824]	@ (801a690 <iNemoEngine_API_Update+0x29b0>)
 801a358:	2200      	movs	r2, #0
 801a35a:	f7e5 ff9d 	bl	8000298 <__aeabi_dsub>
 801a35e:	f7e6 fc4b 	bl	8000bf8 <__aeabi_d2f>
 801a362:	ee08 0a10 	vmov	s16, r0
 801a366:	f7fd be03 	b.w	8017f70 <iNemoEngine_API_Update+0x290>
 801a36a:	ed9f baca 	vldr	s22, [pc, #808]	@ 801a694 <iNemoEngine_API_Update+0x29b4>
 801a36e:	49ca      	ldr	r1, [pc, #808]	@ (801a698 <iNemoEngine_API_Update+0x29b8>)
 801a370:	9806      	ldr	r0, [sp, #24]
 801a372:	f7fd beba 	b.w	80180ea <iNemoEngine_API_Update+0x40a>
 801a376:	ee7c 7a27 	vadd.f32	s15, s24, s15
 801a37a:	ee17 0a90 	vmov	r0, s15
 801a37e:	f7e6 f8eb 	bl	8000558 <__aeabi_f2d>
 801a382:	ec41 0b10 	vmov	d0, r0, r1
 801a386:	f005 fcc7 	bl	801fd18 <floor>
 801a38a:	ec51 0b10 	vmov	r0, r1, d0
 801a38e:	f7e6 fc33 	bl	8000bf8 <__aeabi_d2f>
 801a392:	ee0c 0a10 	vmov	s24, r0
 801a396:	f7fe b937 	b.w	8018608 <iNemoEngine_API_Update+0x928>
 801a39a:	ee78 7a27 	vadd.f32	s15, s16, s15
 801a39e:	ee17 0a90 	vmov	r0, s15
 801a3a2:	f7e6 f8d9 	bl	8000558 <__aeabi_f2d>
 801a3a6:	ec41 0b10 	vmov	d0, r0, r1
 801a3aa:	f005 fcb5 	bl	801fd18 <floor>
 801a3ae:	ec51 0b10 	vmov	r0, r1, d0
 801a3b2:	f7e6 fc21 	bl	8000bf8 <__aeabi_d2f>
 801a3b6:	ee08 0a10 	vmov	s16, r0
 801a3ba:	f7fe b8fa 	b.w	80185b2 <iNemoEngine_API_Update+0x8d2>
 801a3be:	ee78 7aa7 	vadd.f32	s15, s17, s15
 801a3c2:	ee17 0a90 	vmov	r0, s15
 801a3c6:	f7e6 f8c7 	bl	8000558 <__aeabi_f2d>
 801a3ca:	ec41 0b10 	vmov	d0, r0, r1
 801a3ce:	f005 fca3 	bl	801fd18 <floor>
 801a3d2:	ec51 0b10 	vmov	r0, r1, d0
 801a3d6:	f7e6 fc0f 	bl	8000bf8 <__aeabi_d2f>
 801a3da:	ee08 0a90 	vmov	s17, r0
 801a3de:	f7fe b8bd 	b.w	801855c <iNemoEngine_API_Update+0x87c>
 801a3e2:	2c00      	cmp	r4, #0
 801a3e4:	f47f aa59 	bne.w	801989a <iNemoEngine_API_Update+0x1bba>
 801a3e8:	f8ad 40e8 	strh.w	r4, [sp, #232]	@ 0xe8
 801a3ec:	f88d 40ea 	strb.w	r4, [sp, #234]	@ 0xea
 801a3f0:	f88d 40f1 	strb.w	r4, [sp, #241]	@ 0xf1
 801a3f4:	f88d 40f3 	strb.w	r4, [sp, #243]	@ 0xf3
 801a3f8:	f7ff ba5c 	b.w	80198b4 <iNemoEngine_API_Update+0x1bd4>
 801a3fc:	eddf 5aa7 	vldr	s11, [pc, #668]	@ 801a69c <iNemoEngine_API_Update+0x29bc>
 801a400:	ed9f 4aa7 	vldr	s8, [pc, #668]	@ 801a6a0 <iNemoEngine_API_Update+0x29c0>
 801a404:	ed9f 6aa7 	vldr	s12, [pc, #668]	@ 801a6a4 <iNemoEngine_API_Update+0x29c4>
 801a408:	ed9f 7aa7 	vldr	s14, [pc, #668]	@ 801a6a8 <iNemoEngine_API_Update+0x29c8>
 801a40c:	eddf 6aa7 	vldr	s13, [pc, #668]	@ 801a6ac <iNemoEngine_API_Update+0x29cc>
 801a410:	f7ff b9b2 	b.w	8019778 <iNemoEngine_API_Update+0x1a98>
 801a414:	edd3 7a73 	vldr	s15, [r3, #460]	@ 0x1cc
 801a418:	2400      	movs	r4, #0
 801a41a:	461a      	mov	r2, r3
 801a41c:	f7ff b89f 	b.w	801955e <iNemoEngine_API_Update+0x187e>
 801a420:	ee77 7ae4 	vsub.f32	s15, s15, s9
 801a424:	eeb0 4a08 	vmov.f32	s8, #8	@ 0x40400000  3.0
 801a428:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 801a42c:	eee7 4a84 	vfma.f32	s9, s15, s8
 801a430:	f7ff b86b 	b.w	801950a <iNemoEngine_API_Update+0x182a>
 801a434:	3305      	adds	r3, #5
 801a436:	6593      	str	r3, [r2, #88]	@ 0x58
 801a438:	f7ff ba95 	b.w	8019966 <iNemoEngine_API_Update+0x1c86>
 801a43c:	edd2 4a48 	vldr	s9, [r2, #288]	@ 0x120
 801a440:	eef4 4ae8 	vcmpe.f32	s9, s17
 801a444:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a448:	f341 8112 	ble.w	801b670 <iNemoEngine_API_Update+0x3990>
 801a44c:	ed92 7a32 	vldr	s14, [r2, #200]	@ 0xc8
 801a450:	eef4 8ac7 	vcmpe.f32	s17, s14
 801a454:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a458:	4613      	mov	r3, r2
 801a45a:	f101 8392 	bmi.w	801bb82 <iNemoEngine_API_Update+0x3ea2>
 801a45e:	edd2 7a34 	vldr	s15, [r2, #208]	@ 0xd0
 801a462:	eef4 8ae7 	vcmpe.f32	s17, s15
 801a466:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a46a:	f141 83a2 	bpl.w	801bbb2 <iNemoEngine_API_Update+0x3ed2>
 801a46e:	edd3 3a33 	vldr	s7, [r3, #204]	@ 0xcc
 801a472:	ed93 4a35 	vldr	s8, [r3, #212]	@ 0xd4
 801a476:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801a47a:	ee34 4a63 	vsub.f32	s8, s8, s7
 801a47e:	ee38 7ac7 	vsub.f32	s14, s17, s14
 801a482:	ee24 7a07 	vmul.f32	s14, s8, s14
 801a486:	ee87 fa27 	vdiv.f32	s30, s14, s15
 801a48a:	ee3f fa23 	vadd.f32	s30, s30, s7
 801a48e:	edd3 7a36 	vldr	s15, [r3, #216]	@ 0xd8
 801a492:	eef4 8ae7 	vcmpe.f32	s17, s15
 801a496:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a49a:	f2c1 83a3 	blt.w	801bbe4 <iNemoEngine_API_Update+0x3f04>
 801a49e:	9b06      	ldr	r3, [sp, #24]
 801a4a0:	ed93 7a38 	vldr	s14, [r3, #224]	@ 0xe0
 801a4a4:	eef4 8ac7 	vcmpe.f32	s17, s14
 801a4a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a4ac:	f141 86ad 	bpl.w	801c20a <iNemoEngine_API_Update+0x452a>
 801a4b0:	edd3 3a37 	vldr	s7, [r3, #220]	@ 0xdc
 801a4b4:	ed93 4a39 	vldr	s8, [r3, #228]	@ 0xe4
 801a4b8:	ee37 7a67 	vsub.f32	s14, s14, s15
 801a4bc:	ee34 4a63 	vsub.f32	s8, s8, s7
 801a4c0:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801a4c4:	ee64 7a27 	vmul.f32	s15, s8, s15
 801a4c8:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801a4cc:	ee3f fa23 	vadd.f32	s30, s30, s7
 801a4d0:	9b06      	ldr	r3, [sp, #24]
 801a4d2:	edd3 7a3a 	vldr	s15, [r3, #232]	@ 0xe8
 801a4d6:	eef4 8ae7 	vcmpe.f32	s17, s15
 801a4da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a4de:	f2c1 83a3 	blt.w	801bc28 <iNemoEngine_API_Update+0x3f48>
 801a4e2:	9b06      	ldr	r3, [sp, #24]
 801a4e4:	ed93 7a3c 	vldr	s14, [r3, #240]	@ 0xf0
 801a4e8:	eef4 8ac7 	vcmpe.f32	s17, s14
 801a4ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a4f0:	f141 86ca 	bpl.w	801c288 <iNemoEngine_API_Update+0x45a8>
 801a4f4:	edd3 3a3b 	vldr	s7, [r3, #236]	@ 0xec
 801a4f8:	ed93 4a3d 	vldr	s8, [r3, #244]	@ 0xf4
 801a4fc:	ee37 7a67 	vsub.f32	s14, s14, s15
 801a500:	ee34 4a63 	vsub.f32	s8, s8, s7
 801a504:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801a508:	ee64 7a27 	vmul.f32	s15, s8, s15
 801a50c:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801a510:	ee3f fa23 	vadd.f32	s30, s30, s7
 801a514:	9b06      	ldr	r3, [sp, #24]
 801a516:	edd3 7a3e 	vldr	s15, [r3, #248]	@ 0xf8
 801a51a:	eef4 8ae7 	vcmpe.f32	s17, s15
 801a51e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a522:	f2c1 83a3 	blt.w	801bc6c <iNemoEngine_API_Update+0x3f8c>
 801a526:	9b06      	ldr	r3, [sp, #24]
 801a528:	ed93 7a40 	vldr	s14, [r3, #256]	@ 0x100
 801a52c:	eef4 8ac7 	vcmpe.f32	s17, s14
 801a530:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a534:	f141 866c 	bpl.w	801c210 <iNemoEngine_API_Update+0x4530>
 801a538:	edd3 3a3f 	vldr	s7, [r3, #252]	@ 0xfc
 801a53c:	ed93 4a41 	vldr	s8, [r3, #260]	@ 0x104
 801a540:	ee37 7a67 	vsub.f32	s14, s14, s15
 801a544:	ee34 4a63 	vsub.f32	s8, s8, s7
 801a548:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801a54c:	ee64 7a27 	vmul.f32	s15, s8, s15
 801a550:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801a554:	ee3f fa23 	vadd.f32	s30, s30, s7
 801a558:	9b06      	ldr	r3, [sp, #24]
 801a55a:	edd3 7a42 	vldr	s15, [r3, #264]	@ 0x108
 801a55e:	eef4 8ae7 	vcmpe.f32	s17, s15
 801a562:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a566:	f2c1 83a3 	blt.w	801bcb0 <iNemoEngine_API_Update+0x3fd0>
 801a56a:	9b06      	ldr	r3, [sp, #24]
 801a56c:	ed93 7a44 	vldr	s14, [r3, #272]	@ 0x110
 801a570:	eef4 8ac7 	vcmpe.f32	s17, s14
 801a574:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a578:	f141 863c 	bpl.w	801c1f4 <iNemoEngine_API_Update+0x4514>
 801a57c:	edd3 3a43 	vldr	s7, [r3, #268]	@ 0x10c
 801a580:	ed93 4a45 	vldr	s8, [r3, #276]	@ 0x114
 801a584:	ee37 7a67 	vsub.f32	s14, s14, s15
 801a588:	ee34 4a63 	vsub.f32	s8, s8, s7
 801a58c:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801a590:	ee64 7a27 	vmul.f32	s15, s8, s15
 801a594:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801a598:	ee3f fa23 	vadd.f32	s30, s30, s7
 801a59c:	9b06      	ldr	r3, [sp, #24]
 801a59e:	edd3 7a46 	vldr	s15, [r3, #280]	@ 0x118
 801a5a2:	eef4 8ae7 	vcmpe.f32	s17, s15
 801a5a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a5aa:	f6fe ae38 	blt.w	801921e <iNemoEngine_API_Update+0x153e>
 801a5ae:	9b06      	ldr	r3, [sp, #24]
 801a5b0:	ed93 4a47 	vldr	s8, [r3, #284]	@ 0x11c
 801a5b4:	ed93 7a49 	vldr	s14, [r3, #292]	@ 0x124
 801a5b8:	ee74 4ae7 	vsub.f32	s9, s9, s15
 801a5bc:	ee37 7a44 	vsub.f32	s14, s14, s8
 801a5c0:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801a5c4:	ee67 7a27 	vmul.f32	s15, s14, s15
 801a5c8:	ee87 faa4 	vdiv.f32	s30, s15, s9
 801a5cc:	ee3f fa04 	vadd.f32	s30, s30, s8
 801a5d0:	f7fe be25 	b.w	801921e <iNemoEngine_API_Update+0x153e>
 801a5d4:	ee78 7aa7 	vadd.f32	s15, s17, s15
 801a5d8:	ee17 0a90 	vmov	r0, s15
 801a5dc:	f7e5 ffbc 	bl	8000558 <__aeabi_f2d>
 801a5e0:	ec41 0b10 	vmov	d0, r0, r1
 801a5e4:	f005 fb98 	bl	801fd18 <floor>
 801a5e8:	ec51 0b10 	vmov	r0, r1, d0
 801a5ec:	f7e6 fb04 	bl	8000bf8 <__aeabi_d2f>
 801a5f0:	ee08 0a90 	vmov	s17, r0
 801a5f4:	f7fe b930 	b.w	8018858 <iNemoEngine_API_Update+0xb78>
 801a5f8:	ee78 7aa7 	vadd.f32	s15, s17, s15
 801a5fc:	ee17 0a90 	vmov	r0, s15
 801a600:	f7e5 ffaa 	bl	8000558 <__aeabi_f2d>
 801a604:	ec41 0b10 	vmov	d0, r0, r1
 801a608:	f005 fb86 	bl	801fd18 <floor>
 801a60c:	ec51 0b10 	vmov	r0, r1, d0
 801a610:	f7e6 faf2 	bl	8000bf8 <__aeabi_d2f>
 801a614:	ee08 0a90 	vmov	s17, r0
 801a618:	f7fe b8b5 	b.w	8018786 <iNemoEngine_API_Update+0xaa6>
 801a61c:	ee7c 7a27 	vadd.f32	s15, s24, s15
 801a620:	ee17 0a90 	vmov	r0, s15
 801a624:	f7e5 ff98 	bl	8000558 <__aeabi_f2d>
 801a628:	ec41 0b10 	vmov	d0, r0, r1
 801a62c:	f005 fb74 	bl	801fd18 <floor>
 801a630:	ec51 0b10 	vmov	r0, r1, d0
 801a634:	f7e6 fae0 	bl	8000bf8 <__aeabi_d2f>
 801a638:	ee0c 0a10 	vmov	s24, r0
 801a63c:	f7fe b878 	b.w	8018730 <iNemoEngine_API_Update+0xa50>
 801a640:	ee78 7a27 	vadd.f32	s15, s16, s15
 801a644:	ee17 0a90 	vmov	r0, s15
 801a648:	f7e5 ff86 	bl	8000558 <__aeabi_f2d>
 801a64c:	ec41 0b10 	vmov	d0, r0, r1
 801a650:	f005 fb62 	bl	801fd18 <floor>
 801a654:	ec51 0b10 	vmov	r0, r1, d0
 801a658:	f7e6 face 	bl	8000bf8 <__aeabi_d2f>
 801a65c:	ee08 0a10 	vmov	s16, r0
 801a660:	f7fe b83b 	b.w	80186da <iNemoEngine_API_Update+0x9fa>
 801a664:	ee78 7a27 	vadd.f32	s15, s16, s15
 801a668:	ee17 0a90 	vmov	r0, s15
 801a66c:	f7e5 ff74 	bl	8000558 <__aeabi_f2d>
 801a670:	ec41 0b10 	vmov	d0, r0, r1
 801a674:	f005 fb50 	bl	801fd18 <floor>
 801a678:	ec51 0b10 	vmov	r0, r1, d0
 801a67c:	f7e6 fabc 	bl	8000bf8 <__aeabi_d2f>
 801a680:	ee08 0a10 	vmov	s16, r0
 801a684:	f7fe b93e 	b.w	8018904 <iNemoEngine_API_Update+0xc24>
 801a688:	20000000 	.word	0x20000000
 801a68c:	404ca5dc 	.word	0x404ca5dc
 801a690:	40568000 	.word	0x40568000
 801a694:	3dcccccd 	.word	0x3dcccccd
 801a698:	3a83126f 	.word	0x3a83126f
 801a69c:	3c75c28f 	.word	0x3c75c28f
 801a6a0:	391d4951 	.word	0x391d4951
 801a6a4:	383cbe62 	.word	0x383cbe62
 801a6a8:	469c3e00 	.word	0x469c3e00
 801a6ac:	43168000 	.word	0x43168000
 801a6b0:	3d088889 	.word	0x3d088889
 801a6b4:	3e4ccccd 	.word	0x3e4ccccd
 801a6b8:	ee7c 7a27 	vadd.f32	s15, s24, s15
 801a6bc:	ee17 0a90 	vmov	r0, s15
 801a6c0:	f7e5 ff4a 	bl	8000558 <__aeabi_f2d>
 801a6c4:	ec41 0b10 	vmov	d0, r0, r1
 801a6c8:	f005 fb26 	bl	801fd18 <floor>
 801a6cc:	ec51 0b10 	vmov	r0, r1, d0
 801a6d0:	f7e6 fa92 	bl	8000bf8 <__aeabi_d2f>
 801a6d4:	ee0c 0a10 	vmov	s24, r0
 801a6d8:	f7fe b8e9 	b.w	80188ae <iNemoEngine_API_Update+0xbce>
 801a6dc:	2a00      	cmp	r2, #0
 801a6de:	f43f a910 	beq.w	8019902 <iNemoEngine_API_Update+0x1c22>
 801a6e2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801a6e6:	ee39 9a47 	vsub.f32	s18, s18, s14
 801a6ea:	eef0 7ac9 	vabs.f32	s15, s18
 801a6ee:	ee29 9a09 	vmul.f32	s18, s18, s18
 801a6f2:	eef4 7ac6 	vcmpe.f32	s15, s12
 801a6f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a6fa:	eeb4 9ac7 	vcmpe.f32	s18, s14
 801a6fe:	bfb8      	it	lt
 801a700:	eef0 7a46 	vmovlt.f32	s15, s12
 801a704:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a708:	edcd 7a8d 	vstr	s15, [sp, #564]	@ 0x234
 801a70c:	f77f a900 	ble.w	8019910 <iNemoEngine_API_Update+0x1c30>
 801a710:	eddd 7a86 	vldr	s15, [sp, #536]	@ 0x218
 801a714:	ee27 7aa7 	vmul.f32	s14, s15, s15
 801a718:	eeb4 9ac7 	vcmpe.f32	s18, s14
 801a71c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a720:	f77f a8f6 	ble.w	8019910 <iNemoEngine_API_Update+0x1c30>
 801a724:	ee67 7a89 	vmul.f32	s15, s15, s18
 801a728:	edcd 7a86 	vstr	s15, [sp, #536]	@ 0x218
 801a72c:	eddd 7a87 	vldr	s15, [sp, #540]	@ 0x21c
 801a730:	ee67 7a89 	vmul.f32	s15, s15, s18
 801a734:	edcd 7a87 	vstr	s15, [sp, #540]	@ 0x21c
 801a738:	eddd 7a88 	vldr	s15, [sp, #544]	@ 0x220
 801a73c:	ee27 9a89 	vmul.f32	s18, s15, s18
 801a740:	ed8d 9a88 	vstr	s18, [sp, #544]	@ 0x220
 801a744:	f7ff b8e4 	b.w	8019910 <iNemoEngine_API_Update+0x1c30>
 801a748:	f003 02fd 	and.w	r2, r3, #253	@ 0xfd
 801a74c:	2a01      	cmp	r2, #1
 801a74e:	f000 877b 	beq.w	801b648 <iNemoEngine_API_Update+0x3968>
 801a752:	2b02      	cmp	r3, #2
 801a754:	f040 8778 	bne.w	801b648 <iNemoEngine_API_Update+0x3968>
 801a758:	eddd 7a18 	vldr	s15, [sp, #96]	@ 0x60
 801a75c:	9a06      	ldr	r2, [sp, #24]
 801a75e:	ee87 7a8d 	vdiv.f32	s14, s15, s26
 801a762:	f240 1301 	movw	r3, #257	@ 0x101
 801a766:	f8ad 30ee 	strh.w	r3, [sp, #238]	@ 0xee
 801a76a:	2301      	movs	r3, #1
 801a76c:	f88d 30f0 	strb.w	r3, [sp, #240]	@ 0xf0
 801a770:	eddd 7a16 	vldr	s15, [sp, #88]	@ 0x58
 801a774:	ed92 6a64 	vldr	s12, [r2, #400]	@ 0x190
 801a778:	ed8d 7a3d 	vstr	s14, [sp, #244]	@ 0xf4
 801a77c:	eecb 5a27 	vdiv.f32	s11, s22, s15
 801a780:	eddd 7a17 	vldr	s15, [sp, #92]	@ 0x5c
 801a784:	edcd 5a3e 	vstr	s11, [sp, #248]	@ 0xf8
 801a788:	eecd 7aa7 	vdiv.f32	s15, s27, s15
 801a78c:	eeb4 5a00 	vmov.f32	s10, #64	@ 0x3e000000  0.125
 801a790:	ee26 6a05 	vmul.f32	s12, s12, s10
 801a794:	edcd 7a3f 	vstr	s15, [sp, #252]	@ 0xfc
 801a798:	eeb4 6ae8 	vcmpe.f32	s12, s17
 801a79c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a7a0:	f280 87d8 	bge.w	801b754 <iNemoEngine_API_Update+0x3a74>
 801a7a4:	ed9d 6a18 	vldr	s12, [sp, #96]	@ 0x60
 801a7a8:	eeb4 dac6 	vcmpe.f32	s26, s12
 801a7ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a7b0:	f341 83a4 	ble.w	801befc <iNemoEngine_API_Update+0x421c>
 801a7b4:	ed9d 6a16 	vldr	s12, [sp, #88]	@ 0x58
 801a7b8:	eeb4 6acb 	vcmpe.f32	s12, s22
 801a7bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a7c0:	f341 839c 	ble.w	801befc <iNemoEngine_API_Update+0x421c>
 801a7c4:	ed9d 6a17 	vldr	s12, [sp, #92]	@ 0x5c
 801a7c8:	eeb4 6aed 	vcmpe.f32	s12, s27
 801a7cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a7d0:	f341 8394 	ble.w	801befc <iNemoEngine_API_Update+0x421c>
 801a7d4:	eeb5 6a00 	vmov.f32	s12, #80	@ 0x3e800000  0.250
 801a7d8:	eeb4 8ac6 	vcmpe.f32	s16, s12
 801a7dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a7e0:	f141 838c 	bpl.w	801befc <iNemoEngine_API_Update+0x421c>
 801a7e4:	ee37 7a25 	vadd.f32	s14, s14, s11
 801a7e8:	eeb7 6a08 	vmov.f32	s12, #120	@ 0x3fc00000  1.5
 801a7ec:	ee77 7a87 	vadd.f32	s15, s15, s14
 801a7f0:	eef4 7ac6 	vcmpe.f32	s15, s12
 801a7f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a7f8:	f141 8380 	bpl.w	801befc <iNemoEngine_API_Update+0x421c>
 801a7fc:	2300      	movs	r3, #0
 801a7fe:	f8a2 31a6 	strh.w	r3, [r2, #422]	@ 0x1a6
 801a802:	f892 21a4 	ldrb.w	r2, [r2, #420]	@ 0x1a4
 801a806:	eef6 8a00 	vmov.f32	s17, #96	@ 0x3f000000  0.5
 801a80a:	2a00      	cmp	r2, #0
 801a80c:	f040 87c7 	bne.w	801b79e <iNemoEngine_API_Update+0x3abe>
 801a810:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 801a812:	a840      	add	r0, sp, #256	@ 0x100
 801a814:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 801a818:	4613      	mov	r3, r2
 801a81a:	edd2 7a00 	vldr	s15, [r2]
 801a81e:	3101      	adds	r1, #1
 801a820:	330c      	adds	r3, #12
 801a822:	3204      	adds	r2, #4
 801a824:	461c      	mov	r4, r3
 801a826:	ed94 7a00 	vldr	s14, [r4]
 801a82a:	330c      	adds	r3, #12
 801a82c:	4598      	cmp	r8, r3
 801a82e:	ee77 7a87 	vadd.f32	s15, s15, s14
 801a832:	d1f7      	bne.n	801a824 <iNemoEngine_API_Update+0x2b44>
 801a834:	2902      	cmp	r1, #2
 801a836:	ece0 7a01 	vstmia	r0!, {s15}
 801a83a:	f108 0804 	add.w	r8, r8, #4
 801a83e:	d1eb      	bne.n	801a818 <iNemoEngine_API_Update+0x2b38>
 801a840:	ed5f 7a65 	vldr	s15, [pc, #-404]	@ 801a6b0 <iNemoEngine_API_Update+0x29d0>
 801a844:	9b06      	ldr	r3, [sp, #24]
 801a846:	eddd 4a40 	vldr	s9, [sp, #256]	@ 0x100
 801a84a:	ed9d 5a41 	vldr	s10, [sp, #260]	@ 0x104
 801a84e:	eddd 5a42 	vldr	s11, [sp, #264]	@ 0x108
 801a852:	9c2b      	ldr	r4, [sp, #172]	@ 0xac
 801a854:	f503 70ac 	add.w	r0, r3, #344	@ 0x158
 801a858:	ee64 4aa7 	vmul.f32	s9, s9, s15
 801a85c:	ee25 5a27 	vmul.f32	s10, s10, s15
 801a860:	ee65 5aa7 	vmul.f32	s11, s11, s15
 801a864:	f503 71b2 	add.w	r1, r3, #356	@ 0x164
 801a868:	4602      	mov	r2, r0
 801a86a:	edd2 7a7c 	vldr	s15, [r2, #496]	@ 0x1f0
 801a86e:	f5a2 73ae 	sub.w	r3, r2, #348	@ 0x15c
 801a872:	ed93 7ad6 	vldr	s14, [r3, #856]	@ 0x358
 801a876:	eef4 7ac7 	vcmpe.f32	s15, s14
 801a87a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a87e:	f103 030c 	add.w	r3, r3, #12
 801a882:	bf88      	it	hi
 801a884:	eef0 7a47 	vmovhi.f32	s15, s14
 801a888:	4293      	cmp	r3, r2
 801a88a:	d1f2      	bne.n	801a872 <iNemoEngine_API_Update+0x2b92>
 801a88c:	1d1a      	adds	r2, r3, #4
 801a88e:	4291      	cmp	r1, r2
 801a890:	ece4 7a01 	vstmia	r4!, {s15}
 801a894:	d1e9      	bne.n	801a86a <iNemoEngine_API_Update+0x2b8a>
 801a896:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801a898:	ed9d 4a3d 	vldr	s8, [sp, #244]	@ 0xf4
 801a89c:	edd3 7a00 	vldr	s15, [r3]
 801a8a0:	ed9d 7a3e 	vldr	s14, [sp, #248]	@ 0xf8
 801a8a4:	ed9d 6a3f 	vldr	s12, [sp, #252]	@ 0xfc
 801a8a8:	9b06      	ldr	r3, [sp, #24]
 801a8aa:	ee97 4aa4 	vfnms.f32	s8, s15, s9
 801a8ae:	785b      	ldrb	r3, [r3, #1]
 801a8b0:	ee97 7a85 	vfnms.f32	s14, s15, s10
 801a8b4:	ee97 6aa5 	vfnms.f32	s12, s15, s11
 801a8b8:	eef0 4a47 	vmov.f32	s9, s14
 801a8bc:	ed8d 4a40 	vstr	s8, [sp, #256]	@ 0x100
 801a8c0:	ed8d 7a41 	vstr	s14, [sp, #260]	@ 0x104
 801a8c4:	ed8d 6a42 	vstr	s12, [sp, #264]	@ 0x108
 801a8c8:	b13b      	cbz	r3, 801a8da <iNemoEngine_API_Update+0x2bfa>
 801a8ca:	eef1 7a00 	vmov.f32	s15, #16	@ 0x40800000  4.0
 801a8ce:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801a8d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a8d6:	f101 83e1 	bmi.w	801c09c <iNemoEngine_API_Update+0x43bc>
 801a8da:	9b06      	ldr	r3, [sp, #24]
 801a8dc:	f893 21a1 	ldrb.w	r2, [r3, #417]	@ 0x1a1
 801a8e0:	2a1e      	cmp	r2, #30
 801a8e2:	f001 843c 	beq.w	801c15e <iNemoEngine_API_Update+0x447e>
 801a8e6:	1c53      	adds	r3, r2, #1
 801a8e8:	2aff      	cmp	r2, #255	@ 0xff
 801a8ea:	9906      	ldr	r1, [sp, #24]
 801a8ec:	bf14      	ite	ne
 801a8ee:	b2db      	uxtbne	r3, r3
 801a8f0:	23ff      	moveq	r3, #255	@ 0xff
 801a8f2:	2200      	movs	r2, #0
 801a8f4:	f881 31a1 	strb.w	r3, [r1, #417]	@ 0x1a1
 801a8f8:	f881 21a3 	strb.w	r2, [r1, #419]	@ 0x1a3
 801a8fc:	464b      	mov	r3, r9
 801a8fe:	f7ff bb46 	b.w	8019f8e <iNemoEngine_API_Update+0x22ae>
 801a902:	ed1f 7a94 	vldr	s14, [pc, #-592]	@ 801a6b4 <iNemoEngine_API_Update+0x29d4>
 801a906:	4603      	mov	r3, r0
 801a908:	f7fd bc03 	b.w	8018112 <iNemoEngine_API_Update+0x432>
 801a90c:	2b00      	cmp	r3, #0
 801a90e:	f43e afe0 	beq.w	80198d2 <iNemoEngine_API_Update+0x1bf2>
 801a912:	f89d 30e8 	ldrb.w	r3, [sp, #232]	@ 0xe8
 801a916:	2b01      	cmp	r3, #1
 801a918:	d002      	beq.n	801a920 <iNemoEngine_API_Update+0x2c40>
 801a91a:	2c01      	cmp	r4, #1
 801a91c:	f47e afe2 	bne.w	80198e4 <iNemoEngine_API_Update+0x1c04>
 801a920:	eddd 7a23 	vldr	s15, [sp, #140]	@ 0x8c
 801a924:	eeb4 5ae7 	vcmpe.f32	s10, s15
 801a928:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a92c:	bfb8      	it	lt
 801a92e:	eeb0 5a67 	vmovlt.f32	s10, s15
 801a932:	ed8d 5a83 	vstr	s10, [sp, #524]	@ 0x20c
 801a936:	ed8d 5a84 	vstr	s10, [sp, #528]	@ 0x210
 801a93a:	ed8d 5a85 	vstr	s10, [sp, #532]	@ 0x214
 801a93e:	f7fe bfd1 	b.w	80198e4 <iNemoEngine_API_Update+0x1c04>
 801a942:	9b06      	ldr	r3, [sp, #24]
 801a944:	49c6      	ldr	r1, [pc, #792]	@ (801ac60 <iNemoEngine_API_Update+0x2f80>)
 801a946:	ed93 ba05 	vldr	s22, [r3, #20]
 801a94a:	eeb1 7a04 	vmov.f32	s14, #20	@ 0x40a00000  5.0
 801a94e:	ee67 7a87 	vmul.f32	s15, s15, s14
 801a952:	4618      	mov	r0, r3
 801a954:	f7fd bbc9 	b.w	80180ea <iNemoEngine_API_Update+0x40a>
 801a958:	9b06      	ldr	r3, [sp, #24]
 801a95a:	49c2      	ldr	r1, [pc, #776]	@ (801ac64 <iNemoEngine_API_Update+0x2f84>)
 801a95c:	ed93 ba05 	vldr	s22, [r3, #20]
 801a960:	4618      	mov	r0, r3
 801a962:	f7fd bbc2 	b.w	80180ea <iNemoEngine_API_Update+0x40a>
 801a966:	4611      	mov	r1, r2
 801a968:	6dd2      	ldr	r2, [r2, #92]	@ 0x5c
 801a96a:	2a00      	cmp	r2, #0
 801a96c:	dd0c      	ble.n	801a988 <iNemoEngine_API_Update+0x2ca8>
 801a96e:	ed9d 7a03 	vldr	s14, [sp, #12]
 801a972:	eef5 7a08 	vmov.f32	s15, #88	@ 0x3ec00000  0.375
 801a976:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801a97a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a97e:	dd03      	ble.n	801a988 <iNemoEngine_API_Update+0x2ca8>
 801a980:	3a01      	subs	r2, #1
 801a982:	65ca      	str	r2, [r1, #92]	@ 0x5c
 801a984:	f7fe bfef 	b.w	8019966 <iNemoEngine_API_Update+0x1c86>
 801a988:	ed9d 7a16 	vldr	s14, [sp, #88]	@ 0x58
 801a98c:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 801a990:	ee27 7a27 	vmul.f32	s14, s14, s15
 801a994:	eeb4 bac7 	vcmpe.f32	s22, s14
 801a998:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a99c:	f57e afe3 	bpl.w	8019966 <iNemoEngine_API_Update+0x1c86>
 801a9a0:	ed9d 7a17 	vldr	s14, [sp, #92]	@ 0x5c
 801a9a4:	ee67 7a27 	vmul.f32	s15, s14, s15
 801a9a8:	eef4 dae7 	vcmpe.f32	s27, s15
 801a9ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a9b0:	f57e afd9 	bpl.w	8019966 <iNemoEngine_API_Update+0x1c86>
 801a9b4:	ee7d 7a0d 	vadd.f32	s15, s26, s26
 801a9b8:	ed9d 7a18 	vldr	s14, [sp, #96]	@ 0x60
 801a9bc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801a9c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a9c4:	f341 8492 	ble.w	801c2ec <iNemoEngine_API_Update+0x460c>
 801a9c8:	9a06      	ldr	r2, [sp, #24]
 801a9ca:	3303      	adds	r3, #3
 801a9cc:	e434      	b.n	801a238 <iNemoEngine_API_Update+0x2558>
 801a9ce:	ed9f 7aa6 	vldr	s14, [pc, #664]	@ 801ac68 <iNemoEngine_API_Update+0x2f88>
 801a9d2:	eef4 7ac7 	vcmpe.f32	s15, s14
 801a9d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a9da:	f57e ae7b 	bpl.w	80196d4 <iNemoEngine_API_Update+0x19f4>
 801a9de:	ed9f 7aa3 	vldr	s14, [pc, #652]	@ 801ac6c <iNemoEngine_API_Update+0x2f8c>
 801a9e2:	eef4 7ac7 	vcmpe.f32	s15, s14
 801a9e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a9ea:	f280 80c9 	bge.w	801ab80 <iNemoEngine_API_Update+0x2ea0>
 801a9ee:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801a9f2:	eddf 6a9f 	vldr	s13, [pc, #636]	@ 801ac70 <iNemoEngine_API_Update+0x2f90>
 801a9f6:	eef4 7ae6 	vcmpe.f32	s15, s13
 801a9fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a9fe:	f280 80d5 	bge.w	801abac <iNemoEngine_API_Update+0x2ecc>
 801aa02:	eddf 6a9c 	vldr	s13, [pc, #624]	@ 801ac74 <iNemoEngine_API_Update+0x2f94>
 801aa06:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aa0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa0e:	f280 80e3 	bge.w	801abd8 <iNemoEngine_API_Update+0x2ef8>
 801aa12:	eddf 6a99 	vldr	s13, [pc, #612]	@ 801ac78 <iNemoEngine_API_Update+0x2f98>
 801aa16:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aa1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa1e:	f280 80f1 	bge.w	801ac04 <iNemoEngine_API_Update+0x2f24>
 801aa22:	eddf 6a96 	vldr	s13, [pc, #600]	@ 801ac7c <iNemoEngine_API_Update+0x2f9c>
 801aa26:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aa2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa2e:	f280 80ff 	bge.w	801ac30 <iNemoEngine_API_Update+0x2f50>
 801aa32:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
 801aa36:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aa3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa3e:	db0d      	blt.n	801aa5c <iNemoEngine_API_Update+0x2d7c>
 801aa40:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
 801aa44:	ed9f 7a8e 	vldr	s14, [pc, #568]	@ 801ac80 <iNemoEngine_API_Update+0x2fa0>
 801aa48:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801aa4c:	eeb0 6a00 	vmov.f32	s12, #0	@ 0x40000000  2.0
 801aa50:	ee66 6a87 	vmul.f32	s13, s13, s14
 801aa54:	ed9f 7a8b 	vldr	s14, [pc, #556]	@ 801ac84 <iNemoEngine_API_Update+0x2fa4>
 801aa58:	eea6 7a86 	vfma.f32	s14, s13, s12
 801aa5c:	eddf 6a8a 	vldr	s13, [pc, #552]	@ 801ac88 <iNemoEngine_API_Update+0x2fa8>
 801aa60:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aa64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa68:	f141 82fa 	bpl.w	801c060 <iNemoEngine_API_Update+0x4380>
 801aa6c:	eddf 6a7e 	vldr	s13, [pc, #504]	@ 801ac68 <iNemoEngine_API_Update+0x2f88>
 801aa70:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aa74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa78:	f2c1 82fa 	blt.w	801c070 <iNemoEngine_API_Update+0x4390>
 801aa7c:	eddf 6a7b 	vldr	s13, [pc, #492]	@ 801ac6c <iNemoEngine_API_Update+0x2f8c>
 801aa80:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aa84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aa88:	f141 8296 	bpl.w	801bfb8 <iNemoEngine_API_Update+0x42d8>
 801aa8c:	ed9f 6a76 	vldr	s12, [pc, #472]	@ 801ac68 <iNemoEngine_API_Update+0x2f88>
 801aa90:	eddf 6a7e 	vldr	s13, [pc, #504]	@ 801ac8c <iNemoEngine_API_Update+0x2fac>
 801aa94:	eddf 5a7e 	vldr	s11, [pc, #504]	@ 801ac90 <iNemoEngine_API_Update+0x2fb0>
 801aa98:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801aa9c:	ee26 6a26 	vmul.f32	s12, s12, s13
 801aaa0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801aaa4:	eee6 6a25 	vfma.f32	s13, s12, s11
 801aaa8:	ed9f 6a71 	vldr	s12, [pc, #452]	@ 801ac70 <iNemoEngine_API_Update+0x2f90>
 801aaac:	eef4 7ac6 	vcmpe.f32	s15, s12
 801aab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aab4:	f2c1 8296 	blt.w	801bfe4 <iNemoEngine_API_Update+0x4304>
 801aab8:	eddf 6a6e 	vldr	s13, [pc, #440]	@ 801ac74 <iNemoEngine_API_Update+0x2f94>
 801aabc:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aac0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aac4:	f141 8296 	bpl.w	801bff4 <iNemoEngine_API_Update+0x4314>
 801aac8:	ed9f 6a69 	vldr	s12, [pc, #420]	@ 801ac70 <iNemoEngine_API_Update+0x2f90>
 801aacc:	eddf 6a71 	vldr	s13, [pc, #452]	@ 801ac94 <iNemoEngine_API_Update+0x2fb4>
 801aad0:	eddf 5a71 	vldr	s11, [pc, #452]	@ 801ac98 <iNemoEngine_API_Update+0x2fb8>
 801aad4:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801aad8:	ee26 6a26 	vmul.f32	s12, s12, s13
 801aadc:	eddf 6a6f 	vldr	s13, [pc, #444]	@ 801ac9c <iNemoEngine_API_Update+0x2fbc>
 801aae0:	eee6 6a25 	vfma.f32	s13, s12, s11
 801aae4:	ed9f 6a64 	vldr	s12, [pc, #400]	@ 801ac78 <iNemoEngine_API_Update+0x2f98>
 801aae8:	eef4 7ac6 	vcmpe.f32	s15, s12
 801aaec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aaf0:	f2c1 8296 	blt.w	801c020 <iNemoEngine_API_Update+0x4340>
 801aaf4:	eddf 6a61 	vldr	s13, [pc, #388]	@ 801ac7c <iNemoEngine_API_Update+0x2f9c>
 801aaf8:	eef4 7ae6 	vcmpe.f32	s15, s13
 801aafc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ab00:	f141 8296 	bpl.w	801c030 <iNemoEngine_API_Update+0x4350>
 801ab04:	ed9f 6a5c 	vldr	s12, [pc, #368]	@ 801ac78 <iNemoEngine_API_Update+0x2f98>
 801ab08:	eddf 6a65 	vldr	s13, [pc, #404]	@ 801aca0 <iNemoEngine_API_Update+0x2fc0>
 801ab0c:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801ab10:	eef2 5a04 	vmov.f32	s11, #36	@ 0x41200000  10.0
 801ab14:	ee26 6a26 	vmul.f32	s12, s12, s13
 801ab18:	eef7 6a0c 	vmov.f32	s13, #124	@ 0x3fe00000  1.750
 801ab1c:	eee6 6a25 	vfma.f32	s13, s12, s11
 801ab20:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 801ab24:	eef4 7ac6 	vcmpe.f32	s15, s12
 801ab28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ab2c:	db0d      	blt.n	801ab4a <iNemoEngine_API_Update+0x2e6a>
 801ab2e:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 801ab32:	eddf 6a5c 	vldr	s13, [pc, #368]	@ 801aca4 <iNemoEngine_API_Update+0x2fc4>
 801ab36:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801ab3a:	eef0 5a00 	vmov.f32	s11, #0	@ 0x40000000  2.0
 801ab3e:	ee26 6a26 	vmul.f32	s12, s12, s13
 801ab42:	eddf 6a59 	vldr	s13, [pc, #356]	@ 801aca8 <iNemoEngine_API_Update+0x2fc8>
 801ab46:	eee6 6a25 	vfma.f32	s13, s12, s11
 801ab4a:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 801ab4e:	ee37 6a06 	vadd.f32	s12, s14, s12
 801ab52:	eeb0 5a00 	vmov.f32	s10, #0	@ 0x40000000  2.0
 801ab56:	eec5 5a06 	vdiv.f32	s11, s10, s12
 801ab5a:	ed9f 6a44 	vldr	s12, [pc, #272]	@ 801ac6c <iNemoEngine_API_Update+0x2f8c>
 801ab5e:	ed9f 4a42 	vldr	s8, [pc, #264]	@ 801ac68 <iNemoEngine_API_Update+0x2f88>
 801ab62:	eef4 5ac6 	vcmpe.f32	s11, s12
 801ab66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ab6a:	bfb8      	it	lt
 801ab6c:	eef0 5a46 	vmovlt.f32	s11, s12
 801ab70:	ed9f 6a4e 	vldr	s12, [pc, #312]	@ 801acac <iNemoEngine_API_Update+0x2fcc>
 801ab74:	ee25 4a84 	vmul.f32	s8, s11, s8
 801ab78:	ee25 6a86 	vmul.f32	s12, s11, s12
 801ab7c:	f7fe bdfc 	b.w	8019778 <iNemoEngine_API_Update+0x1a98>
 801ab80:	ed9f 7a3b 	vldr	s14, [pc, #236]	@ 801ac70 <iNemoEngine_API_Update+0x2f90>
 801ab84:	eef4 7ac7 	vcmpe.f32	s15, s14
 801ab88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ab8c:	d50e      	bpl.n	801abac <iNemoEngine_API_Update+0x2ecc>
 801ab8e:	eddf 6a37 	vldr	s13, [pc, #220]	@ 801ac6c <iNemoEngine_API_Update+0x2f8c>
 801ab92:	ed9f 7a47 	vldr	s14, [pc, #284]	@ 801acb0 <iNemoEngine_API_Update+0x2fd0>
 801ab96:	ed9f 6a47 	vldr	s12, [pc, #284]	@ 801acb4 <iNemoEngine_API_Update+0x2fd4>
 801ab9a:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801ab9e:	ee66 6a87 	vmul.f32	s13, s13, s14
 801aba2:	ed9f 7a45 	vldr	s14, [pc, #276]	@ 801acb8 <iNemoEngine_API_Update+0x2fd8>
 801aba6:	eea6 7a86 	vfma.f32	s14, s13, s12
 801abaa:	e72a      	b.n	801aa02 <iNemoEngine_API_Update+0x2d22>
 801abac:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 801ac74 <iNemoEngine_API_Update+0x2f94>
 801abb0:	eef4 7ac7 	vcmpe.f32	s15, s14
 801abb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801abb8:	d50e      	bpl.n	801abd8 <iNemoEngine_API_Update+0x2ef8>
 801abba:	eddf 6a2d 	vldr	s13, [pc, #180]	@ 801ac70 <iNemoEngine_API_Update+0x2f90>
 801abbe:	ed9f 6a36 	vldr	s12, [pc, #216]	@ 801ac98 <iNemoEngine_API_Update+0x2fb8>
 801abc2:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801abc6:	eeb0 7a08 	vmov.f32	s14, #8	@ 0x40400000  3.0
 801abca:	ee66 6a87 	vmul.f32	s13, s13, s14
 801abce:	eeb0 7a00 	vmov.f32	s14, #0	@ 0x40000000  2.0
 801abd2:	eea6 7a86 	vfma.f32	s14, s13, s12
 801abd6:	e71c      	b.n	801aa12 <iNemoEngine_API_Update+0x2d32>
 801abd8:	ed9f 7a27 	vldr	s14, [pc, #156]	@ 801ac78 <iNemoEngine_API_Update+0x2f98>
 801abdc:	eef4 7ac7 	vcmpe.f32	s15, s14
 801abe0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801abe4:	d50e      	bpl.n	801ac04 <iNemoEngine_API_Update+0x2f24>
 801abe6:	eddf 6a23 	vldr	s13, [pc, #140]	@ 801ac74 <iNemoEngine_API_Update+0x2f94>
 801abea:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801abee:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
 801abf2:	ee66 6a87 	vmul.f32	s13, s13, s14
 801abf6:	eeb3 6a04 	vmov.f32	s12, #52	@ 0x41a00000  20.0
 801abfa:	eeb1 7a04 	vmov.f32	s14, #20	@ 0x40a00000  5.0
 801abfe:	eea6 7a86 	vfma.f32	s14, s13, s12
 801ac02:	e70e      	b.n	801aa22 <iNemoEngine_API_Update+0x2d42>
 801ac04:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 801ac7c <iNemoEngine_API_Update+0x2f9c>
 801ac08:	eef4 7ac7 	vcmpe.f32	s15, s14
 801ac0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ac10:	d50e      	bpl.n	801ac30 <iNemoEngine_API_Update+0x2f50>
 801ac12:	eddf 6a19 	vldr	s13, [pc, #100]	@ 801ac78 <iNemoEngine_API_Update+0x2f98>
 801ac16:	ed9f 7a29 	vldr	s14, [pc, #164]	@ 801acbc <iNemoEngine_API_Update+0x2fdc>
 801ac1a:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801ac1e:	eeb2 6a04 	vmov.f32	s12, #36	@ 0x41200000  10.0
 801ac22:	ee66 6a87 	vmul.f32	s13, s13, s14
 801ac26:	eeb2 7a0a 	vmov.f32	s14, #42	@ 0x41500000  13.0
 801ac2a:	eea6 7a86 	vfma.f32	s14, s13, s12
 801ac2e:	e700      	b.n	801aa32 <iNemoEngine_API_Update+0x2d52>
 801ac30:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 801ac34:	eef4 7ac7 	vcmpe.f32	s15, s14
 801ac38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ac3c:	f57f af00 	bpl.w	801aa40 <iNemoEngine_API_Update+0x2d60>
 801ac40:	eddf 6a0e 	vldr	s13, [pc, #56]	@ 801ac7c <iNemoEngine_API_Update+0x2f9c>
 801ac44:	ed9f 7a1e 	vldr	s14, [pc, #120]	@ 801acc0 <iNemoEngine_API_Update+0x2fe0>
 801ac48:	ed9f 6a1e 	vldr	s12, [pc, #120]	@ 801acc4 <iNemoEngine_API_Update+0x2fe4>
 801ac4c:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801ac50:	ee66 6a87 	vmul.f32	s13, s13, s14
 801ac54:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 801acc8 <iNemoEngine_API_Update+0x2fe8>
 801ac58:	eea6 7a86 	vfma.f32	s14, s13, s12
 801ac5c:	e6fe      	b.n	801aa5c <iNemoEngine_API_Update+0x2d7c>
 801ac5e:	bf00      	nop
 801ac60:	3727c5ac 	.word	0x3727c5ac
 801ac64:	3ac49ba6 	.word	0x3ac49ba6
 801ac68:	3c23d70a 	.word	0x3c23d70a
 801ac6c:	3c75c28f 	.word	0x3c75c28f
 801ac70:	3cf5c28f 	.word	0x3cf5c28f
 801ac74:	3d4ccccd 	.word	0x3d4ccccd
 801ac78:	3dcccccd 	.word	0x3dcccccd
 801ac7c:	3e4ccccd 	.word	0x3e4ccccd
 801ac80:	46979000 	.word	0x46979000
 801ac84:	4415c000 	.word	0x4415c000
 801ac88:	3ba3d70a 	.word	0x3ba3d70a
 801ac8c:	3d4cccc0 	.word	0x3d4cccc0
 801ac90:	43480000 	.word	0x43480000
 801ac94:	3eb33334 	.word	0x3eb33334
 801ac98:	4247ffff 	.word	0x4247ffff
 801ac9c:	3f933333 	.word	0x3f933333
 801aca0:	410c0000 	.word	0x410c0000
 801aca4:	42c80000 	.word	0x42c80000
 801aca8:	424a0000 	.word	0x424a0000
 801acac:	3b449ba6 	.word	0x3b449ba6
 801acb0:	3ecccccc 	.word	0x3ecccccc
 801acb4:	42855556 	.word	0x42855556
 801acb8:	3fcccccd 	.word	0x3fcccccd
 801acbc:	42d40000 	.word	0x42d40000
 801acc0:	43f00000 	.word	0x43f00000
 801acc4:	40555555 	.word	0x40555555
 801acc8:	42ee0000 	.word	0x42ee0000
 801accc:	4615      	mov	r5, r2
 801acce:	f205 47b4 	addw	r7, r5, #1204	@ 0x4b4
 801acd2:	49d7      	ldr	r1, [pc, #860]	@ (801b030 <iNemoEngine_API_Update+0x3350>)
 801acd4:	4ad7      	ldr	r2, [pc, #860]	@ (801b034 <iNemoEngine_API_Update+0x3354>)
 801acd6:	4bd8      	ldr	r3, [pc, #864]	@ (801b038 <iNemoEngine_API_Update+0x3358>)
 801acd8:	2000      	movs	r0, #0
 801acda:	f885 0318 	strb.w	r0, [r5, #792]	@ 0x318
 801acde:	f205 6824 	addw	r8, r5, #1572	@ 0x624
 801ace2:	6039      	str	r1, [r7, #0]
 801ace4:	f205 7194 	addw	r1, r5, #1940	@ 0x794
 801ace8:	f8c8 2000 	str.w	r2, [r8]
 801acec:	600b      	str	r3, [r1, #0]
 801acee:	f895 64b1 	ldrb.w	r6, [r5, #1201]	@ 0x4b1
 801acf2:	911b      	str	r1, [sp, #108]	@ 0x6c
 801acf4:	2e00      	cmp	r6, #0
 801acf6:	f001 8297 	beq.w	801c228 <iNemoEngine_API_Update+0x4548>
 801acfa:	eddf 7ad0 	vldr	s15, [pc, #832]	@ 801b03c <iNemoEngine_API_Update+0x335c>
 801acfe:	ee68 faa7 	vmul.f32	s31, s17, s15
 801ad02:	eeb6 ba00 	vmov.f32	s22, #96	@ 0x3f000000  0.5
 801ad06:	ee28 fa27 	vmul.f32	s30, s16, s15
 801ad0a:	ee6c da27 	vmul.f32	s27, s24, s15
 801ad0e:	ee7f 7acb 	vsub.f32	s15, s31, s22
 801ad12:	f04f 4900 	mov.w	r9, #2147483648	@ 0x80000000
 801ad16:	ee17 0a90 	vmov	r0, s15
 801ad1a:	f7e5 fc1d 	bl	8000558 <__aeabi_f2d>
 801ad1e:	ee7f 7a8b 	vadd.f32	s15, s31, s22
 801ad22:	e9cd 0108 	strd	r0, r1, [sp, #32]
 801ad26:	ee17 0a90 	vmov	r0, s15
 801ad2a:	f7e5 fc15 	bl	8000558 <__aeabi_f2d>
 801ad2e:	ee7f 7a4b 	vsub.f32	s15, s30, s22
 801ad32:	e9cd 010a 	strd	r0, r1, [sp, #40]	@ 0x28
 801ad36:	ee17 0a90 	vmov	r0, s15
 801ad3a:	f7e5 fc0d 	bl	8000558 <__aeabi_f2d>
 801ad3e:	ee7f 7a0b 	vadd.f32	s15, s30, s22
 801ad42:	e9cd 010c 	strd	r0, r1, [sp, #48]	@ 0x30
 801ad46:	ee17 0a90 	vmov	r0, s15
 801ad4a:	f7e5 fc05 	bl	8000558 <__aeabi_f2d>
 801ad4e:	ee7d 7acb 	vsub.f32	s15, s27, s22
 801ad52:	e9cd 010e 	strd	r0, r1, [sp, #56]	@ 0x38
 801ad56:	ee17 0a90 	vmov	r0, s15
 801ad5a:	f7e5 fbfd 	bl	8000558 <__aeabi_f2d>
 801ad5e:	ee7d 7a8b 	vadd.f32	s15, s27, s22
 801ad62:	4602      	mov	r2, r0
 801ad64:	460b      	mov	r3, r1
 801ad66:	ee17 0a90 	vmov	r0, s15
 801ad6a:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 801ad6e:	f7e5 fbf3 	bl	8000558 <__aeabi_f2d>
 801ad72:	9b06      	ldr	r3, [sp, #24]
 801ad74:	ed9f bab8 	vldr	s22, [pc, #736]	@ 801b058 <iNemoEngine_API_Update+0x3378>
 801ad78:	eef0 7aef 	vabs.f32	s15, s31
 801ad7c:	edcd 7a03 	vstr	s15, [sp, #12]
 801ad80:	eef0 7acf 	vabs.f32	s15, s30
 801ad84:	f503 6597 	add.w	r5, r3, #1208	@ 0x4b8
 801ad88:	edcd 7a04 	vstr	s15, [sp, #16]
 801ad8c:	230c      	movs	r3, #12
 801ad8e:	eef0 7aed 	vabs.f32	s15, s27
 801ad92:	e9cd 0112 	strd	r0, r1, [sp, #72]	@ 0x48
 801ad96:	fb13 5606 	smlabb	r6, r3, r6, r5
 801ad9a:	edcd 7a05 	vstr	s15, [sp, #20]
 801ad9e:	46aa      	mov	sl, r5
 801ada0:	e060      	b.n	801ae64 <iNemoEngine_API_Update+0x3184>
 801ada2:	eddf 7aa7 	vldr	s15, [pc, #668]	@ 801b040 <iNemoEngine_API_Update+0x3360>
 801ada6:	eef4 8ae7 	vcmpe.f32	s17, s15
 801adaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801adae:	f280 8162 	bge.w	801b076 <iNemoEngine_API_Update+0x3396>
 801adb2:	eddf 7aa4 	vldr	s15, [pc, #656]	@ 801b044 <iNemoEngine_API_Update+0x3364>
 801adb6:	eef4 8ae7 	vcmpe.f32	s17, s15
 801adba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801adbe:	f300 816c 	bgt.w	801b09a <iNemoEngine_API_Update+0x33ba>
 801adc2:	ed9d 0b08 	vldr	d0, [sp, #32]
 801adc6:	f004 ff2b 	bl	801fc20 <ceil>
 801adca:	ec51 0b10 	vmov	r0, r1, d0
 801adce:	f7e5 ff13 	bl	8000bf8 <__aeabi_d2f>
 801add2:	eddd 7a04 	vldr	s15, [sp, #16]
 801add6:	f8ca 0000 	str.w	r0, [sl]
 801adda:	eef4 7acb 	vcmpe.f32	s15, s22
 801adde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ade2:	f140 8121 	bpl.w	801b028 <iNemoEngine_API_Update+0x3348>
 801ade6:	eddf 7a96 	vldr	s15, [pc, #600]	@ 801b040 <iNemoEngine_API_Update+0x3360>
 801adea:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801adee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801adf2:	f280 8137 	bge.w	801b064 <iNemoEngine_API_Update+0x3384>
 801adf6:	eddf 7a93 	vldr	s15, [pc, #588]	@ 801b044 <iNemoEngine_API_Update+0x3364>
 801adfa:	eeb4 8ae7 	vcmpe.f32	s16, s15
 801adfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ae02:	f300 8257 	bgt.w	801b2b4 <iNemoEngine_API_Update+0x35d4>
 801ae06:	ed9d 0b0c 	vldr	d0, [sp, #48]	@ 0x30
 801ae0a:	f004 ff09 	bl	801fc20 <ceil>
 801ae0e:	ec51 0b10 	vmov	r0, r1, d0
 801ae12:	f7e5 fef1 	bl	8000bf8 <__aeabi_d2f>
 801ae16:	eddd 7a05 	vldr	s15, [sp, #20]
 801ae1a:	f8ca 0004 	str.w	r0, [sl, #4]
 801ae1e:	eef4 7acb 	vcmpe.f32	s15, s22
 801ae22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ae26:	d527      	bpl.n	801ae78 <iNemoEngine_API_Update+0x3198>
 801ae28:	eddf 7a85 	vldr	s15, [pc, #532]	@ 801b040 <iNemoEngine_API_Update+0x3360>
 801ae2c:	eeb4 cae7 	vcmpe.f32	s24, s15
 801ae30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ae34:	f280 8128 	bge.w	801b088 <iNemoEngine_API_Update+0x33a8>
 801ae38:	eddf 7a82 	vldr	s15, [pc, #520]	@ 801b044 <iNemoEngine_API_Update+0x3364>
 801ae3c:	eeb4 cae7 	vcmpe.f32	s24, s15
 801ae40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ae44:	f300 812b 	bgt.w	801b09e <iNemoEngine_API_Update+0x33be>
 801ae48:	ed9d 0b10 	vldr	d0, [sp, #64]	@ 0x40
 801ae4c:	f004 fee8 	bl	801fc20 <ceil>
 801ae50:	ec51 0b10 	vmov	r0, r1, d0
 801ae54:	f7e5 fed0 	bl	8000bf8 <__aeabi_d2f>
 801ae58:	f8ca 0008 	str.w	r0, [sl, #8]
 801ae5c:	f10a 0a0c 	add.w	sl, sl, #12
 801ae60:	45b2      	cmp	sl, r6
 801ae62:	d011      	beq.n	801ae88 <iNemoEngine_API_Update+0x31a8>
 801ae64:	eddd 7a03 	vldr	s15, [sp, #12]
 801ae68:	eef4 7acb 	vcmpe.f32	s15, s22
 801ae6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801ae70:	d497      	bmi.n	801ada2 <iNemoEngine_API_Update+0x30c2>
 801ae72:	ee1f 0a90 	vmov	r0, s31
 801ae76:	e7ac      	b.n	801add2 <iNemoEngine_API_Update+0x30f2>
 801ae78:	ee1d 0a90 	vmov	r0, s27
 801ae7c:	f10a 0a0c 	add.w	sl, sl, #12
 801ae80:	f84a 0c04 	str.w	r0, [sl, #-4]
 801ae84:	45b2      	cmp	sl, r6
 801ae86:	d1ed      	bne.n	801ae64 <iNemoEngine_API_Update+0x3184>
 801ae88:	9b06      	ldr	r3, [sp, #24]
 801ae8a:	f893 9621 	ldrb.w	r9, [r3, #1569]	@ 0x621
 801ae8e:	f503 66c5 	add.w	r6, r3, #1576	@ 0x628
 801ae92:	f1b9 0f00 	cmp.w	r9, #0
 801ae96:	f000 8114 	beq.w	801b0c2 <iNemoEngine_API_Update+0x33e2>
 801ae9a:	eddf 7a6b 	vldr	s15, [pc, #428]	@ 801b048 <iNemoEngine_API_Update+0x3368>
 801ae9e:	ee6a faa7 	vmul.f32	s31, s21, s15
 801aea2:	eeb6 ba00 	vmov.f32	s22, #96	@ 0x3f000000  0.5
 801aea6:	ee2a fa27 	vmul.f32	s30, s20, s15
 801aeaa:	ee69 daa7 	vmul.f32	s27, s19, s15
 801aeae:	ee7f 7acb 	vsub.f32	s15, s31, s22
 801aeb2:	f04f 4a00 	mov.w	sl, #2147483648	@ 0x80000000
 801aeb6:	ee17 0a90 	vmov	r0, s15
 801aeba:	f7e5 fb4d 	bl	8000558 <__aeabi_f2d>
 801aebe:	ee7f 7a8b 	vadd.f32	s15, s31, s22
 801aec2:	e9cd 0108 	strd	r0, r1, [sp, #32]
 801aec6:	ee17 0a90 	vmov	r0, s15
 801aeca:	f7e5 fb45 	bl	8000558 <__aeabi_f2d>
 801aece:	ee7f 7a4b 	vsub.f32	s15, s30, s22
 801aed2:	e9cd 010a 	strd	r0, r1, [sp, #40]	@ 0x28
 801aed6:	ee17 0a90 	vmov	r0, s15
 801aeda:	f7e5 fb3d 	bl	8000558 <__aeabi_f2d>
 801aede:	ee7f 7a0b 	vadd.f32	s15, s30, s22
 801aee2:	e9cd 010c 	strd	r0, r1, [sp, #48]	@ 0x30
 801aee6:	ee17 0a90 	vmov	r0, s15
 801aeea:	f7e5 fb35 	bl	8000558 <__aeabi_f2d>
 801aeee:	ee7d 7acb 	vsub.f32	s15, s27, s22
 801aef2:	e9cd 010e 	strd	r0, r1, [sp, #56]	@ 0x38
 801aef6:	ee17 0a90 	vmov	r0, s15
 801aefa:	f7e5 fb2d 	bl	8000558 <__aeabi_f2d>
 801aefe:	ee7d 7a8b 	vadd.f32	s15, s27, s22
 801af02:	4602      	mov	r2, r0
 801af04:	460b      	mov	r3, r1
 801af06:	ee17 0a90 	vmov	r0, s15
 801af0a:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 801af0e:	f7e5 fb23 	bl	8000558 <__aeabi_f2d>
 801af12:	eef0 7aef 	vabs.f32	s15, s31
 801af16:	9b06      	ldr	r3, [sp, #24]
 801af18:	edcd 7a03 	vstr	s15, [sp, #12]
 801af1c:	eef0 7acf 	vabs.f32	s15, s30
 801af20:	edcd 7a04 	vstr	s15, [sp, #16]
 801af24:	eef0 7aed 	vabs.f32	s15, s27
 801af28:	f503 66c5 	add.w	r6, r3, #1576	@ 0x628
 801af2c:	edcd 7a05 	vstr	s15, [sp, #20]
 801af30:	230c      	movs	r3, #12
 801af32:	eef0 7a6c 	vmov.f32	s15, s25
 801af36:	e9cd 0112 	strd	r0, r1, [sp, #72]	@ 0x48
 801af3a:	eef0 ca48 	vmov.f32	s25, s16
 801af3e:	ed9f ba46 	vldr	s22, [pc, #280]	@ 801b058 <iNemoEngine_API_Update+0x3378>
 801af42:	eeb0 8a4d 	vmov.f32	s16, s26
 801af46:	fb13 6909 	smlabb	r9, r3, r9, r6
 801af4a:	46b3      	mov	fp, r6
 801af4c:	eeb0 da67 	vmov.f32	s26, s15
 801af50:	e060      	b.n	801b014 <iNemoEngine_API_Update+0x3334>
 801af52:	eddf 7a3e 	vldr	s15, [pc, #248]	@ 801b04c <iNemoEngine_API_Update+0x336c>
 801af56:	eef4 aae7 	vcmpe.f32	s21, s15
 801af5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801af5e:	f280 8197 	bge.w	801b290 <iNemoEngine_API_Update+0x35b0>
 801af62:	eddf 7a3b 	vldr	s15, [pc, #236]	@ 801b050 <iNemoEngine_API_Update+0x3370>
 801af66:	eef4 aae7 	vcmpe.f32	s21, s15
 801af6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801af6e:	f300 81a3 	bgt.w	801b2b8 <iNemoEngine_API_Update+0x35d8>
 801af72:	ed9d 0b08 	vldr	d0, [sp, #32]
 801af76:	f004 fe53 	bl	801fc20 <ceil>
 801af7a:	ec51 0b10 	vmov	r0, r1, d0
 801af7e:	f7e5 fe3b 	bl	8000bf8 <__aeabi_d2f>
 801af82:	eddd 7a04 	vldr	s15, [sp, #16]
 801af86:	f8cb 0000 	str.w	r0, [fp]
 801af8a:	eef4 7acb 	vcmpe.f32	s15, s22
 801af8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801af92:	f140 8171 	bpl.w	801b278 <iNemoEngine_API_Update+0x3598>
 801af96:	eddf 7a2d 	vldr	s15, [pc, #180]	@ 801b04c <iNemoEngine_API_Update+0x336c>
 801af9a:	eeb4 aae7 	vcmpe.f32	s20, s15
 801af9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801afa2:	f280 816c 	bge.w	801b27e <iNemoEngine_API_Update+0x359e>
 801afa6:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 801b050 <iNemoEngine_API_Update+0x3370>
 801afaa:	eeb4 aae7 	vcmpe.f32	s20, s15
 801afae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801afb2:	f300 81bd 	bgt.w	801b330 <iNemoEngine_API_Update+0x3650>
 801afb6:	ed9d 0b0c 	vldr	d0, [sp, #48]	@ 0x30
 801afba:	f004 fe31 	bl	801fc20 <ceil>
 801afbe:	ec51 0b10 	vmov	r0, r1, d0
 801afc2:	f7e5 fe19 	bl	8000bf8 <__aeabi_d2f>
 801afc6:	eddd 7a05 	vldr	s15, [sp, #20]
 801afca:	f8cb 0004 	str.w	r0, [fp, #4]
 801afce:	eef4 7acb 	vcmpe.f32	s15, s22
 801afd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801afd6:	d564      	bpl.n	801b0a2 <iNemoEngine_API_Update+0x33c2>
 801afd8:	eddf 7a1c 	vldr	s15, [pc, #112]	@ 801b04c <iNemoEngine_API_Update+0x336c>
 801afdc:	eef4 9ae7 	vcmpe.f32	s19, s15
 801afe0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801afe4:	f280 815d 	bge.w	801b2a2 <iNemoEngine_API_Update+0x35c2>
 801afe8:	eddf 7a19 	vldr	s15, [pc, #100]	@ 801b050 <iNemoEngine_API_Update+0x3370>
 801afec:	eef4 9ae7 	vcmpe.f32	s19, s15
 801aff0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801aff4:	f300 8162 	bgt.w	801b2bc <iNemoEngine_API_Update+0x35dc>
 801aff8:	ed9d 0b10 	vldr	d0, [sp, #64]	@ 0x40
 801affc:	f004 fe10 	bl	801fc20 <ceil>
 801b000:	ec51 0b10 	vmov	r0, r1, d0
 801b004:	f7e5 fdf8 	bl	8000bf8 <__aeabi_d2f>
 801b008:	f8cb 0008 	str.w	r0, [fp, #8]
 801b00c:	f10b 0b0c 	add.w	fp, fp, #12
 801b010:	45cb      	cmp	fp, r9
 801b012:	d04e      	beq.n	801b0b2 <iNemoEngine_API_Update+0x33d2>
 801b014:	eddd 7a03 	vldr	s15, [sp, #12]
 801b018:	eef4 7acb 	vcmpe.f32	s15, s22
 801b01c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b020:	d497      	bmi.n	801af52 <iNemoEngine_API_Update+0x3272>
 801b022:	ee1f 0a90 	vmov	r0, s31
 801b026:	e7ac      	b.n	801af82 <iNemoEngine_API_Update+0x32a2>
 801b028:	ee1f 0a10 	vmov	r0, s30
 801b02c:	e6f3      	b.n	801ae16 <iNemoEngine_API_Update+0x3136>
 801b02e:	bf00      	nop
 801b030:	3a7001e0 	.word	0x3a7001e0
 801b034:	3a000100 	.word	0x3a000100
 801b038:	3a8c0118 	.word	0x3a8c0118
 801b03c:	44888777 	.word	0x44888777
 801b040:	39f001e1 	.word	0x39f001e1
 801b044:	b9f001e1 	.word	0xb9f001e1
 801b048:	44fffe00 	.word	0x44fffe00
 801b04c:	39800100 	.word	0x39800100
 801b050:	b9800100 	.word	0xb9800100
 801b054:	446a0ccd 	.word	0x446a0ccd
 801b058:	4b000000 	.word	0x4b000000
 801b05c:	3cfaad3b 	.word	0x3cfaad3b
 801b060:	bcfaad3b 	.word	0xbcfaad3b
 801b064:	ed9d 0b0e 	vldr	d0, [sp, #56]	@ 0x38
 801b068:	f004 fe56 	bl	801fd18 <floor>
 801b06c:	ec51 0b10 	vmov	r0, r1, d0
 801b070:	f7e5 fdc2 	bl	8000bf8 <__aeabi_d2f>
 801b074:	e6cf      	b.n	801ae16 <iNemoEngine_API_Update+0x3136>
 801b076:	ed9d 0b0a 	vldr	d0, [sp, #40]	@ 0x28
 801b07a:	f004 fe4d 	bl	801fd18 <floor>
 801b07e:	ec51 0b10 	vmov	r0, r1, d0
 801b082:	f7e5 fdb9 	bl	8000bf8 <__aeabi_d2f>
 801b086:	e6a4      	b.n	801add2 <iNemoEngine_API_Update+0x30f2>
 801b088:	ed9d 0b12 	vldr	d0, [sp, #72]	@ 0x48
 801b08c:	f004 fe44 	bl	801fd18 <floor>
 801b090:	ec51 0b10 	vmov	r0, r1, d0
 801b094:	f7e5 fdb0 	bl	8000bf8 <__aeabi_d2f>
 801b098:	e6de      	b.n	801ae58 <iNemoEngine_API_Update+0x3178>
 801b09a:	4648      	mov	r0, r9
 801b09c:	e699      	b.n	801add2 <iNemoEngine_API_Update+0x30f2>
 801b09e:	4648      	mov	r0, r9
 801b0a0:	e6da      	b.n	801ae58 <iNemoEngine_API_Update+0x3178>
 801b0a2:	ee1d 0a90 	vmov	r0, s27
 801b0a6:	f10b 0b0c 	add.w	fp, fp, #12
 801b0aa:	f84b 0c04 	str.w	r0, [fp, #-4]
 801b0ae:	45cb      	cmp	fp, r9
 801b0b0:	d1b0      	bne.n	801b014 <iNemoEngine_API_Update+0x3334>
 801b0b2:	eef0 7a4d 	vmov.f32	s15, s26
 801b0b6:	eeb0 da48 	vmov.f32	s26, s16
 801b0ba:	eeb0 8a6c 	vmov.f32	s16, s25
 801b0be:	eef0 ca67 	vmov.f32	s25, s15
 801b0c2:	9b06      	ldr	r3, [sp, #24]
 801b0c4:	f893 9791 	ldrb.w	r9, [r3, #1937]	@ 0x791
 801b0c8:	f1b9 0f00 	cmp.w	r9, #0
 801b0cc:	f001 80a7 	beq.w	801c21e <iNemoEngine_API_Update+0x453e>
 801b0d0:	ed5f 7a20 	vldr	s15, [pc, #-128]	@ 801b054 <iNemoEngine_API_Update+0x3374>
 801b0d4:	ee6e fa27 	vmul.f32	s31, s28, s15
 801b0d8:	eeb6 ba00 	vmov.f32	s22, #96	@ 0x3f000000  0.5
 801b0dc:	ee2e faa7 	vmul.f32	s30, s29, s15
 801b0e0:	ee6b daa7 	vmul.f32	s27, s23, s15
 801b0e4:	ee7f 7acb 	vsub.f32	s15, s31, s22
 801b0e8:	f04f 4a00 	mov.w	sl, #2147483648	@ 0x80000000
 801b0ec:	ee17 0a90 	vmov	r0, s15
 801b0f0:	f7e5 fa32 	bl	8000558 <__aeabi_f2d>
 801b0f4:	ee7f 7a8b 	vadd.f32	s15, s31, s22
 801b0f8:	e9cd 0108 	strd	r0, r1, [sp, #32]
 801b0fc:	ee17 0a90 	vmov	r0, s15
 801b100:	f7e5 fa2a 	bl	8000558 <__aeabi_f2d>
 801b104:	ee7f 7a4b 	vsub.f32	s15, s30, s22
 801b108:	e9cd 010a 	strd	r0, r1, [sp, #40]	@ 0x28
 801b10c:	ee17 0a90 	vmov	r0, s15
 801b110:	f7e5 fa22 	bl	8000558 <__aeabi_f2d>
 801b114:	ee7f 7a0b 	vadd.f32	s15, s30, s22
 801b118:	e9cd 010c 	strd	r0, r1, [sp, #48]	@ 0x30
 801b11c:	ee17 0a90 	vmov	r0, s15
 801b120:	f7e5 fa1a 	bl	8000558 <__aeabi_f2d>
 801b124:	ee7d 7acb 	vsub.f32	s15, s27, s22
 801b128:	e9cd 010e 	strd	r0, r1, [sp, #56]	@ 0x38
 801b12c:	ee17 0a90 	vmov	r0, s15
 801b130:	f7e5 fa12 	bl	8000558 <__aeabi_f2d>
 801b134:	ee7d 7a8b 	vadd.f32	s15, s27, s22
 801b138:	4602      	mov	r2, r0
 801b13a:	460b      	mov	r3, r1
 801b13c:	ee17 0a90 	vmov	r0, s15
 801b140:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 801b144:	f7e5 fa08 	bl	8000558 <__aeabi_f2d>
 801b148:	eef0 7aef 	vabs.f32	s15, s31
 801b14c:	9b06      	ldr	r3, [sp, #24]
 801b14e:	edcd 7a03 	vstr	s15, [sp, #12]
 801b152:	eef0 7acf 	vabs.f32	s15, s30
 801b156:	edcd 7a04 	vstr	s15, [sp, #16]
 801b15a:	eef0 7aed 	vabs.f32	s15, s27
 801b15e:	f503 62f3 	add.w	r2, r3, #1944	@ 0x798
 801b162:	eeb0 7a48 	vmov.f32	s14, s16
 801b166:	230c      	movs	r3, #12
 801b168:	edcd 7a05 	vstr	s15, [sp, #20]
 801b16c:	eef0 7a6c 	vmov.f32	s15, s25
 801b170:	eeb0 8a4d 	vmov.f32	s16, s26
 801b174:	eef0 ca4a 	vmov.f32	s25, s20
 801b178:	eeb0 da6a 	vmov.f32	s26, s21
 801b17c:	e9cd 0112 	strd	r0, r1, [sp, #72]	@ 0x48
 801b180:	eef0 aa69 	vmov.f32	s21, s19
 801b184:	ed1f ba4c 	vldr	s22, [pc, #-304]	@ 801b058 <iNemoEngine_API_Update+0x3378>
 801b188:	9215      	str	r2, [sp, #84]	@ 0x54
 801b18a:	fb13 2909 	smlabb	r9, r3, r9, r2
 801b18e:	4693      	mov	fp, r2
 801b190:	eeb0 aa67 	vmov.f32	s20, s15
 801b194:	eef0 9a47 	vmov.f32	s19, s14
 801b198:	e064      	b.n	801b264 <iNemoEngine_API_Update+0x3584>
 801b19a:	eddd 7a1a 	vldr	s15, [sp, #104]	@ 0x68
 801b19e:	ed1f 7a51 	vldr	s14, [pc, #-324]	@ 801b05c <iNemoEngine_API_Update+0x337c>
 801b1a2:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b1a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b1aa:	f280 80af 	bge.w	801b30c <iNemoEngine_API_Update+0x362c>
 801b1ae:	ed1f 7a54 	vldr	s14, [pc, #-336]	@ 801b060 <iNemoEngine_API_Update+0x3380>
 801b1b2:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b1b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b1ba:	f300 80bb 	bgt.w	801b334 <iNemoEngine_API_Update+0x3654>
 801b1be:	ed9d 0b08 	vldr	d0, [sp, #32]
 801b1c2:	f004 fd2d 	bl	801fc20 <ceil>
 801b1c6:	ec51 0b10 	vmov	r0, r1, d0
 801b1ca:	f7e5 fd15 	bl	8000bf8 <__aeabi_d2f>
 801b1ce:	eddd 7a04 	vldr	s15, [sp, #16]
 801b1d2:	f8cb 0000 	str.w	r0, [fp]
 801b1d6:	eef4 7acb 	vcmpe.f32	s15, s22
 801b1da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b1de:	f140 8089 	bpl.w	801b2f4 <iNemoEngine_API_Update+0x3614>
 801b1e2:	eddd 7a1c 	vldr	s15, [sp, #112]	@ 0x70
 801b1e6:	ed1f 7a63 	vldr	s14, [pc, #-396]	@ 801b05c <iNemoEngine_API_Update+0x337c>
 801b1ea:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b1ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b1f2:	f280 8082 	bge.w	801b2fa <iNemoEngine_API_Update+0x361a>
 801b1f6:	ed1f 7a66 	vldr	s14, [pc, #-408]	@ 801b060 <iNemoEngine_API_Update+0x3380>
 801b1fa:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b1fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b202:	f300 809b 	bgt.w	801b33c <iNemoEngine_API_Update+0x365c>
 801b206:	ed9d 0b0c 	vldr	d0, [sp, #48]	@ 0x30
 801b20a:	f004 fd09 	bl	801fc20 <ceil>
 801b20e:	ec51 0b10 	vmov	r0, r1, d0
 801b212:	f7e5 fcf1 	bl	8000bf8 <__aeabi_d2f>
 801b216:	eddd 7a05 	vldr	s15, [sp, #20]
 801b21a:	f8cb 0004 	str.w	r0, [fp, #4]
 801b21e:	eef4 7acb 	vcmpe.f32	s15, s22
 801b222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b226:	d54b      	bpl.n	801b2c0 <iNemoEngine_API_Update+0x35e0>
 801b228:	eddd 7a18 	vldr	s15, [sp, #96]	@ 0x60
 801b22c:	ed1f 7a75 	vldr	s14, [pc, #-468]	@ 801b05c <iNemoEngine_API_Update+0x337c>
 801b230:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b234:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b238:	da71      	bge.n	801b31e <iNemoEngine_API_Update+0x363e>
 801b23a:	ed1f 7a77 	vldr	s14, [pc, #-476]	@ 801b060 <iNemoEngine_API_Update+0x3380>
 801b23e:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b242:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b246:	dc77      	bgt.n	801b338 <iNemoEngine_API_Update+0x3658>
 801b248:	ed9d 0b10 	vldr	d0, [sp, #64]	@ 0x40
 801b24c:	f004 fce8 	bl	801fc20 <ceil>
 801b250:	ec51 0b10 	vmov	r0, r1, d0
 801b254:	f7e5 fcd0 	bl	8000bf8 <__aeabi_d2f>
 801b258:	f8cb 0008 	str.w	r0, [fp, #8]
 801b25c:	f10b 0b0c 	add.w	fp, fp, #12
 801b260:	45cb      	cmp	fp, r9
 801b262:	d035      	beq.n	801b2d0 <iNemoEngine_API_Update+0x35f0>
 801b264:	eddd 7a03 	vldr	s15, [sp, #12]
 801b268:	eef4 7acb 	vcmpe.f32	s15, s22
 801b26c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b270:	d493      	bmi.n	801b19a <iNemoEngine_API_Update+0x34ba>
 801b272:	ee1f 0a90 	vmov	r0, s31
 801b276:	e7aa      	b.n	801b1ce <iNemoEngine_API_Update+0x34ee>
 801b278:	ee1f 0a10 	vmov	r0, s30
 801b27c:	e6a3      	b.n	801afc6 <iNemoEngine_API_Update+0x32e6>
 801b27e:	ed9d 0b0e 	vldr	d0, [sp, #56]	@ 0x38
 801b282:	f004 fd49 	bl	801fd18 <floor>
 801b286:	ec51 0b10 	vmov	r0, r1, d0
 801b28a:	f7e5 fcb5 	bl	8000bf8 <__aeabi_d2f>
 801b28e:	e69a      	b.n	801afc6 <iNemoEngine_API_Update+0x32e6>
 801b290:	ed9d 0b0a 	vldr	d0, [sp, #40]	@ 0x28
 801b294:	f004 fd40 	bl	801fd18 <floor>
 801b298:	ec51 0b10 	vmov	r0, r1, d0
 801b29c:	f7e5 fcac 	bl	8000bf8 <__aeabi_d2f>
 801b2a0:	e66f      	b.n	801af82 <iNemoEngine_API_Update+0x32a2>
 801b2a2:	ed9d 0b12 	vldr	d0, [sp, #72]	@ 0x48
 801b2a6:	f004 fd37 	bl	801fd18 <floor>
 801b2aa:	ec51 0b10 	vmov	r0, r1, d0
 801b2ae:	f7e5 fca3 	bl	8000bf8 <__aeabi_d2f>
 801b2b2:	e6a9      	b.n	801b008 <iNemoEngine_API_Update+0x3328>
 801b2b4:	4648      	mov	r0, r9
 801b2b6:	e5ae      	b.n	801ae16 <iNemoEngine_API_Update+0x3136>
 801b2b8:	4650      	mov	r0, sl
 801b2ba:	e662      	b.n	801af82 <iNemoEngine_API_Update+0x32a2>
 801b2bc:	4650      	mov	r0, sl
 801b2be:	e6a3      	b.n	801b008 <iNemoEngine_API_Update+0x3328>
 801b2c0:	ee1d 0a90 	vmov	r0, s27
 801b2c4:	f10b 0b0c 	add.w	fp, fp, #12
 801b2c8:	f84b 0c04 	str.w	r0, [fp, #-4]
 801b2cc:	45cb      	cmp	fp, r9
 801b2ce:	d1c9      	bne.n	801b264 <iNemoEngine_API_Update+0x3584>
 801b2d0:	eeb0 7a69 	vmov.f32	s14, s19
 801b2d4:	eef0 7a4a 	vmov.f32	s15, s20
 801b2d8:	eef0 9a6a 	vmov.f32	s19, s21
 801b2dc:	eeb0 aa6c 	vmov.f32	s20, s25
 801b2e0:	eef0 aa4d 	vmov.f32	s21, s26
 801b2e4:	eef0 ca67 	vmov.f32	s25, s15
 801b2e8:	eeb0 da48 	vmov.f32	s26, s16
 801b2ec:	eeb0 8a47 	vmov.f32	s16, s14
 801b2f0:	f7fd b820 	b.w	8018334 <iNemoEngine_API_Update+0x654>
 801b2f4:	ee1f 0a10 	vmov	r0, s30
 801b2f8:	e78d      	b.n	801b216 <iNemoEngine_API_Update+0x3536>
 801b2fa:	ed9d 0b0e 	vldr	d0, [sp, #56]	@ 0x38
 801b2fe:	f004 fd0b 	bl	801fd18 <floor>
 801b302:	ec51 0b10 	vmov	r0, r1, d0
 801b306:	f7e5 fc77 	bl	8000bf8 <__aeabi_d2f>
 801b30a:	e784      	b.n	801b216 <iNemoEngine_API_Update+0x3536>
 801b30c:	ed9d 0b0a 	vldr	d0, [sp, #40]	@ 0x28
 801b310:	f004 fd02 	bl	801fd18 <floor>
 801b314:	ec51 0b10 	vmov	r0, r1, d0
 801b318:	f7e5 fc6e 	bl	8000bf8 <__aeabi_d2f>
 801b31c:	e757      	b.n	801b1ce <iNemoEngine_API_Update+0x34ee>
 801b31e:	ed9d 0b12 	vldr	d0, [sp, #72]	@ 0x48
 801b322:	f004 fcf9 	bl	801fd18 <floor>
 801b326:	ec51 0b10 	vmov	r0, r1, d0
 801b32a:	f7e5 fc65 	bl	8000bf8 <__aeabi_d2f>
 801b32e:	e793      	b.n	801b258 <iNemoEngine_API_Update+0x3578>
 801b330:	4650      	mov	r0, sl
 801b332:	e648      	b.n	801afc6 <iNemoEngine_API_Update+0x32e6>
 801b334:	4650      	mov	r0, sl
 801b336:	e74a      	b.n	801b1ce <iNemoEngine_API_Update+0x34ee>
 801b338:	4650      	mov	r0, sl
 801b33a:	e78d      	b.n	801b258 <iNemoEngine_API_Update+0x3578>
 801b33c:	4650      	mov	r0, sl
 801b33e:	e76a      	b.n	801b216 <iNemoEngine_API_Update+0x3536>
 801b340:	4616      	mov	r6, r2
 801b342:	f04f 557e 	mov.w	r5, #1065353216	@ 0x3f800000
 801b346:	4be1      	ldr	r3, [pc, #900]	@ (801b6cc <iNemoEngine_API_Update+0x39ec>)
 801b348:	f8c2 31c8 	str.w	r3, [r2, #456]	@ 0x1c8
 801b34c:	2100      	movs	r1, #0
 801b34e:	f8c2 51cc 	str.w	r5, [r2, #460]	@ 0x1cc
 801b352:	f8c2 51d0 	str.w	r5, [r2, #464]	@ 0x1d0
 801b356:	f882 11ac 	strb.w	r1, [r2, #428]	@ 0x1ac
 801b35a:	f506 70ea 	add.w	r0, r6, #468	@ 0x1d4
 801b35e:	f44f 72a2 	mov.w	r2, #324	@ 0x144
 801b362:	f002 f970 	bl	801d646 <memset>
 801b366:	ed96 6a02 	vldr	s12, [r6, #8]
 801b36a:	eddf 7ad9 	vldr	s15, [pc, #868]	@ 801b6d0 <iNemoEngine_API_Update+0x39f0>
 801b36e:	eddf 5ad9 	vldr	s11, [pc, #868]	@ 801b6d4 <iNemoEngine_API_Update+0x39f4>
 801b372:	ed9f 5ad9 	vldr	s10, [pc, #868]	@ 801b6d8 <iNemoEngine_API_Update+0x39f8>
 801b376:	f8c6 50c4 	str.w	r5, [r6, #196]	@ 0xc4
 801b37a:	ee66 7a27 	vmul.f32	s15, s12, s15
 801b37e:	2300      	movs	r3, #0
 801b380:	edc6 7a34 	vstr	s15, [r6, #208]	@ 0xd0
 801b384:	eddf 7ad5 	vldr	s15, [pc, #852]	@ 801b6dc <iNemoEngine_API_Update+0x39fc>
 801b388:	f8c6 30c0 	str.w	r3, [r6, #192]	@ 0xc0
 801b38c:	ee66 7a27 	vmul.f32	s15, s12, s15
 801b390:	f8c6 3128 	str.w	r3, [r6, #296]	@ 0x128
 801b394:	edc6 7a4e 	vstr	s15, [r6, #312]	@ 0x138
 801b398:	eddf 7ad1 	vldr	s15, [pc, #836]	@ 801b6e0 <iNemoEngine_API_Update+0x3a00>
 801b39c:	4bd1      	ldr	r3, [pc, #836]	@ (801b6e4 <iNemoEngine_API_Update+0x3a04>)
 801b39e:	f8c6 30dc 	str.w	r3, [r6, #220]	@ 0xdc
 801b3a2:	ee66 7a27 	vmul.f32	s15, s12, s15
 801b3a6:	f8c6 30e4 	str.w	r3, [r6, #228]	@ 0xe4
 801b3aa:	edc6 7a50 	vstr	s15, [r6, #320]	@ 0x140
 801b3ae:	eddf 7ace 	vldr	s15, [pc, #824]	@ 801b6e8 <iNemoEngine_API_Update+0x3a08>
 801b3b2:	4bce      	ldr	r3, [pc, #824]	@ (801b6ec <iNemoEngine_API_Update+0x3a0c>)
 801b3b4:	f8c6 30d4 	str.w	r3, [r6, #212]	@ 0xd4
 801b3b8:	ee66 7a27 	vmul.f32	s15, s12, s15
 801b3bc:	4bcc      	ldr	r3, [pc, #816]	@ (801b6f0 <iNemoEngine_API_Update+0x3a10>)
 801b3be:	edc6 7a38 	vstr	s15, [r6, #224]	@ 0xe0
 801b3c2:	eddf 7acc 	vldr	s15, [pc, #816]	@ 801b6f4 <iNemoEngine_API_Update+0x3a14>
 801b3c6:	f8c6 313c 	str.w	r3, [r6, #316]	@ 0x13c
 801b3ca:	ee66 7a27 	vmul.f32	s15, s12, s15
 801b3ce:	4bca      	ldr	r3, [pc, #808]	@ (801b6f8 <iNemoEngine_API_Update+0x3a18>)
 801b3d0:	edc6 7a52 	vstr	s15, [r6, #328]	@ 0x148
 801b3d4:	eddf 7ac9 	vldr	s15, [pc, #804]	@ 801b6fc <iNemoEngine_API_Update+0x3a1c>
 801b3d8:	f8c6 3144 	str.w	r3, [r6, #324]	@ 0x144
 801b3dc:	4bc8      	ldr	r3, [pc, #800]	@ (801b700 <iNemoEngine_API_Update+0x3a20>)
 801b3de:	f8c6 314c 	str.w	r3, [r6, #332]	@ 0x14c
 801b3e2:	4631      	mov	r1, r6
 801b3e4:	ee66 5a25 	vmul.f32	s11, s12, s11
 801b3e8:	ee26 5a05 	vmul.f32	s10, s12, s10
 801b3ec:	ee66 7a27 	vmul.f32	s15, s12, s15
 801b3f0:	4bc4      	ldr	r3, [pc, #784]	@ (801b704 <iNemoEngine_API_Update+0x3a24>)
 801b3f2:	f8c6 30ec 	str.w	r3, [r6, #236]	@ 0xec
 801b3f6:	4bc4      	ldr	r3, [pc, #784]	@ (801b708 <iNemoEngine_API_Update+0x3a28>)
 801b3f8:	f8c6 512c 	str.w	r5, [r6, #300]	@ 0x12c
 801b3fc:	f8c6 50cc 	str.w	r5, [r6, #204]	@ 0xcc
 801b400:	f8c6 5134 	str.w	r5, [r6, #308]	@ 0x134
 801b404:	edc6 7a3a 	vstr	s15, [r6, #232]	@ 0xe8
 801b408:	edc6 5a32 	vstr	s11, [r6, #200]	@ 0xc8
 801b40c:	edc6 5a4c 	vstr	s11, [r6, #304]	@ 0x130
 801b410:	ed86 5a36 	vstr	s10, [r6, #216]	@ 0xd8
 801b414:	f8c1 31d4 	str.w	r3, [r1, #468]	@ 0x1d4
 801b418:	f8c1 31fc 	str.w	r3, [r1, #508]	@ 0x1fc
 801b41c:	f8c1 3224 	str.w	r3, [r1, #548]	@ 0x224
 801b420:	f8c1 324c 	str.w	r3, [r1, #588]	@ 0x24c
 801b424:	f8c1 3274 	str.w	r3, [r1, #628]	@ 0x274
 801b428:	f8c1 329c 	str.w	r3, [r1, #668]	@ 0x29c
 801b42c:	f8c1 32c4 	str.w	r3, [r1, #708]	@ 0x2c4
 801b430:	f8c1 32ec 	str.w	r3, [r1, #748]	@ 0x2ec
 801b434:	f8c1 3314 	str.w	r3, [r1, #788]	@ 0x314
 801b438:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 801b43c:	ed81 5a54 	vstr	s10, [r1, #336]	@ 0x150
 801b440:	eddf 3ab2 	vldr	s7, [pc, #712]	@ 801b70c <iNemoEngine_API_Update+0x3a2c>
 801b444:	ed9f 4ab2 	vldr	s8, [pc, #712]	@ 801b710 <iNemoEngine_API_Update+0x3a30>
 801b448:	f8c1 317c 	str.w	r3, [r1, #380]	@ 0x17c
 801b44c:	f8c1 311c 	str.w	r3, [r1, #284]	@ 0x11c
 801b450:	f8c1 3124 	str.w	r3, [r1, #292]	@ 0x124
 801b454:	eddf 6aaf 	vldr	s13, [pc, #700]	@ 801b714 <iNemoEngine_API_Update+0x3a34>
 801b458:	ed9f 7aaf 	vldr	s14, [pc, #700]	@ 801b718 <iNemoEngine_API_Update+0x3a38>
 801b45c:	eddf 7aaf 	vldr	s15, [pc, #700]	@ 801b71c <iNemoEngine_API_Update+0x3a3c>
 801b460:	eddf 4aaf 	vldr	s9, [pc, #700]	@ 801b720 <iNemoEngine_API_Update+0x3a40>
 801b464:	4aaf      	ldr	r2, [pc, #700]	@ (801b724 <iNemoEngine_API_Update+0x3a44>)
 801b466:	f8df c2dc 	ldr.w	ip, [pc, #732]	@ 801b744 <iNemoEngine_API_Update+0x3a64>
 801b46a:	4faf      	ldr	r7, [pc, #700]	@ (801b728 <iNemoEngine_API_Update+0x3a48>)
 801b46c:	4eaf      	ldr	r6, [pc, #700]	@ (801b72c <iNemoEngine_API_Update+0x3a4c>)
 801b46e:	4db0      	ldr	r5, [pc, #704]	@ (801b730 <iNemoEngine_API_Update+0x3a50>)
 801b470:	48b0      	ldr	r0, [pc, #704]	@ (801b734 <iNemoEngine_API_Update+0x3a54>)
 801b472:	f8df e2d4 	ldr.w	lr, [pc, #724]	@ 801b748 <iNemoEngine_API_Update+0x3a68>
 801b476:	edc1 3a3d 	vstr	s7, [r1, #244]	@ 0xf4
 801b47a:	f04f 537d 	mov.w	r3, #1061158912	@ 0x3f400000
 801b47e:	eeb6 2a00 	vmov.f32	s4, #96	@ 0x3f000000  0.5
 801b482:	f8c1 3104 	str.w	r3, [r1, #260]	@ 0x104
 801b486:	f04f 537f 	mov.w	r3, #1069547520	@ 0x3fc00000
 801b48a:	ee66 6a26 	vmul.f32	s13, s12, s13
 801b48e:	ee26 7a07 	vmul.f32	s14, s12, s14
 801b492:	ee66 7a27 	vmul.f32	s15, s12, s15
 801b496:	ee66 2a23 	vmul.f32	s5, s12, s7
 801b49a:	ee26 3a02 	vmul.f32	s6, s12, s4
 801b49e:	f8c1 3114 	str.w	r3, [r1, #276]	@ 0x114
 801b4a2:	ee66 4a24 	vmul.f32	s9, s12, s9
 801b4a6:	4ba4      	ldr	r3, [pc, #656]	@ (801b738 <iNemoEngine_API_Update+0x3a58>)
 801b4a8:	f8c1 3184 	str.w	r3, [r1, #388]	@ 0x184
 801b4ac:	ee66 1a04 	vmul.f32	s3, s12, s8
 801b4b0:	4ba2      	ldr	r3, [pc, #648]	@ (801b73c <iNemoEngine_API_Update+0x3a5c>)
 801b4b2:	f8c1 318c 	str.w	r3, [r1, #396]	@ 0x18c
 801b4b6:	f8c1 c15c 	str.w	ip, [r1, #348]	@ 0x15c
 801b4ba:	f8c1 70fc 	str.w	r7, [r1, #252]	@ 0xfc
 801b4be:	f8c1 6164 	str.w	r6, [r1, #356]	@ 0x164
 801b4c2:	f8c1 516c 	str.w	r5, [r1, #364]	@ 0x16c
 801b4c6:	f8c1 0174 	str.w	r0, [r1, #372]	@ 0x174
 801b4ca:	edc1 1a46 	vstr	s3, [r1, #280]	@ 0x118
 801b4ce:	edc1 4a60 	vstr	s9, [r1, #384]	@ 0x180
 801b4d2:	f8c1 e19c 	str.w	lr, [r1, #412]	@ 0x19c
 801b4d6:	ed81 2a66 	vstr	s4, [r1, #408]	@ 0x198
 801b4da:	ed81 4a65 	vstr	s8, [r1, #404]	@ 0x194
 801b4de:	f8c1 2154 	str.w	r2, [r1, #340]	@ 0x154
 801b4e2:	f8c1 210c 	str.w	r2, [r1, #268]	@ 0x10c
 801b4e6:	edc1 6a3c 	vstr	s13, [r1, #240]	@ 0xf0
 801b4ea:	edc1 6a56 	vstr	s13, [r1, #344]	@ 0x158
 801b4ee:	ed81 7a3e 	vstr	s14, [r1, #248]	@ 0xf8
 801b4f2:	ed81 7a58 	vstr	s14, [r1, #352]	@ 0x160
 801b4f6:	edc1 7a40 	vstr	s15, [r1, #256]	@ 0x100
 801b4fa:	edc1 7a5a 	vstr	s15, [r1, #360]	@ 0x168
 801b4fe:	edc1 2a42 	vstr	s5, [r1, #264]	@ 0x108
 801b502:	edc1 2a5c 	vstr	s5, [r1, #368]	@ 0x170
 801b506:	ed81 3a44 	vstr	s6, [r1, #272]	@ 0x110
 801b50a:	ed81 3a5e 	vstr	s6, [r1, #376]	@ 0x178
 801b50e:	ed81 6a48 	vstr	s12, [r1, #288]	@ 0x120
 801b512:	ed81 6a62 	vstr	s12, [r1, #392]	@ 0x188
 801b516:	edc1 5a64 	vstr	s11, [r1, #400]	@ 0x190
 801b51a:	784b      	ldrb	r3, [r1, #1]
 801b51c:	b18b      	cbz	r3, 801b542 <iNemoEngine_API_Update+0x3862>
 801b51e:	f501 6214 	add.w	r2, r1, #2368	@ 0x940
 801b522:	9225      	str	r2, [sp, #148]	@ 0x94
 801b524:	f601 1348 	addw	r3, r1, #2376	@ 0x948
 801b528:	f601 1244 	addw	r2, r1, #2372	@ 0x944
 801b52c:	9226      	str	r2, [sp, #152]	@ 0x98
 801b52e:	9327      	str	r3, [sp, #156]	@ 0x9c
 801b530:	9a06      	ldr	r2, [sp, #24]
 801b532:	2300      	movs	r3, #0
 801b534:	7053      	strb	r3, [r2, #1]
 801b536:	f7fc bee8 	b.w	801830a <iNemoEngine_API_Update+0x62a>
 801b53a:	ed93 ca4b 	vldr	s24, [r3, #300]	@ 0x12c
 801b53e:	f7fd bfc0 	b.w	80194c2 <iNemoEngine_API_Update+0x17e2>
 801b542:	9a06      	ldr	r2, [sp, #24]
 801b544:	f502 6314 	add.w	r3, r2, #2368	@ 0x940
 801b548:	f602 1144 	addw	r1, r2, #2372	@ 0x944
 801b54c:	f602 1048 	addw	r0, r2, #2376	@ 0x948
 801b550:	9325      	str	r3, [sp, #148]	@ 0x94
 801b552:	681b      	ldr	r3, [r3, #0]
 801b554:	f8c2 31bc 	str.w	r3, [r2, #444]	@ 0x1bc
 801b558:	680b      	ldr	r3, [r1, #0]
 801b55a:	f8c2 31c0 	str.w	r3, [r2, #448]	@ 0x1c0
 801b55e:	6803      	ldr	r3, [r0, #0]
 801b560:	9126      	str	r1, [sp, #152]	@ 0x98
 801b562:	9027      	str	r0, [sp, #156]	@ 0x9c
 801b564:	f8c2 31c4 	str.w	r3, [r2, #452]	@ 0x1c4
 801b568:	e7e2      	b.n	801b530 <iNemoEngine_API_Update+0x3850>
 801b56a:	f205 47b4 	addw	r7, r5, #1204	@ 0x4b4
 801b56e:	ed97 0a00 	vldr	s0, [r7]
 801b572:	f505 6097 	add.w	r0, r5, #1208	@ 0x4b8
 801b576:	f7fa ff43 	bl	8016400 <dataDerivative5>
 801b57a:	f205 6824 	addw	r8, r5, #1572	@ 0x624
 801b57e:	eef0 3a40 	vmov.f32	s7, s0
 801b582:	f505 60c5 	add.w	r0, r5, #1576	@ 0x628
 801b586:	ed98 0a00 	vldr	s0, [r8]
 801b58a:	f7fa ff39 	bl	8016400 <dataDerivative5>
 801b58e:	f205 7394 	addw	r3, r5, #1940	@ 0x794
 801b592:	eeb0 3a40 	vmov.f32	s6, s0
 801b596:	f505 60f3 	add.w	r0, r5, #1944	@ 0x798
 801b59a:	ed93 0a00 	vldr	s0, [r3]
 801b59e:	f7fa ff2f 	bl	8016400 <dataDerivative5>
 801b5a2:	f9b5 3976 	ldrsh.w	r3, [r5, #2422]	@ 0x976
 801b5a6:	ee07 3a90 	vmov	s15, r3
 801b5aa:	3301      	adds	r3, #1
 801b5ac:	eef8 5ae7 	vcvt.f32.s32	s11, s15
 801b5b0:	ee07 3a90 	vmov	s15, r3
 801b5b4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801b5b8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801b5bc:	ee87 6a27 	vdiv.f32	s12, s14, s15
 801b5c0:	f605 106c 	addw	r0, r5, #2412	@ 0x96c
 801b5c4:	f605 1168 	addw	r1, r5, #2408	@ 0x968
 801b5c8:	f505 6217 	add.w	r2, r5, #2416	@ 0x970
 801b5cc:	b21b      	sxth	r3, r3
 801b5ce:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
 801b5d2:	ed90 7a00 	vldr	s14, [r0]
 801b5d6:	ed91 5a00 	vldr	s10, [r1]
 801b5da:	eef0 7a63 	vmov.f32	s15, s7
 801b5de:	eee7 7a25 	vfma.f32	s15, s14, s11
 801b5e2:	eeb0 7a43 	vmov.f32	s14, s6
 801b5e6:	eea5 7a85 	vfma.f32	s14, s11, s10
 801b5ea:	ed92 5a00 	vldr	s10, [r2]
 801b5ee:	eef0 6a40 	vmov.f32	s13, s0
 801b5f2:	eee5 6a85 	vfma.f32	s13, s11, s10
 801b5f6:	ee67 7a86 	vmul.f32	s15, s15, s12
 801b5fa:	ee27 7a06 	vmul.f32	s14, s14, s12
 801b5fe:	ee66 6a86 	vmul.f32	s13, s13, s12
 801b602:	edc0 7a00 	vstr	s15, [r0]
 801b606:	ed81 7a00 	vstr	s14, [r1]
 801b60a:	edc2 6a00 	vstr	s13, [r2]
 801b60e:	f8a5 3976 	strh.w	r3, [r5, #2422]	@ 0x976
 801b612:	f47c ab8d 	bne.w	8017d30 <iNemoEngine_API_Update+0x50>
 801b616:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 801b61a:	ee27 7a06 	vmul.f32	s14, s14, s12
 801b61e:	ee66 6a86 	vmul.f32	s13, s13, s12
 801b622:	ee67 7a86 	vmul.f32	s15, s15, s12
 801b626:	2300      	movs	r3, #0
 801b628:	ed85 7a07 	vstr	s14, [r5, #28]
 801b62c:	edc5 6a08 	vstr	s13, [r5, #32]
 801b630:	edc5 7a06 	vstr	s15, [r5, #24]
 801b634:	6003      	str	r3, [r0, #0]
 801b636:	600b      	str	r3, [r1, #0]
 801b638:	6013      	str	r3, [r2, #0]
 801b63a:	2300      	movs	r3, #0
 801b63c:	f8a5 3976 	strh.w	r3, [r5, #2422]	@ 0x976
 801b640:	f885 3978 	strb.w	r3, [r5, #2424]	@ 0x978
 801b644:	f7fc bb74 	b.w	8017d30 <iNemoEngine_API_Update+0x50>
 801b648:	9906      	ldr	r1, [sp, #24]
 801b64a:	f8d1 21bc 	ldr.w	r2, [r1, #444]	@ 0x1bc
 801b64e:	9295      	str	r2, [sp, #596]	@ 0x254
 801b650:	f8d1 21c0 	ldr.w	r2, [r1, #448]	@ 0x1c0
 801b654:	9296      	str	r2, [sp, #600]	@ 0x258
 801b656:	f8d1 21c4 	ldr.w	r2, [r1, #452]	@ 0x1c4
 801b65a:	9297      	str	r2, [sp, #604]	@ 0x25c
 801b65c:	2200      	movs	r2, #0
 801b65e:	464b      	mov	r3, r9
 801b660:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 801b664:	f881 21a0 	strb.w	r2, [r1, #416]	@ 0x1a0
 801b668:	f881 21a3 	strb.w	r2, [r1, #419]	@ 0x1a3
 801b66c:	f7fe bc8f 	b.w	8019f8e <iNemoEngine_API_Update+0x22ae>
 801b670:	ed92 fa49 	vldr	s30, [r2, #292]	@ 0x124
 801b674:	4613      	mov	r3, r2
 801b676:	f7fd bdd2 	b.w	801921e <iNemoEngine_API_Update+0x153e>
 801b67a:	ed93 ca63 	vldr	s24, [r3, #396]	@ 0x18c
 801b67e:	f7fd bf20 	b.w	80194c2 <iNemoEngine_API_Update+0x17e2>
 801b682:	eddf 8a2f 	vldr	s17, [pc, #188]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b686:	f7fd b87e 	b.w	8018786 <iNemoEngine_API_Update+0xaa6>
 801b68a:	ed9f ca2d 	vldr	s24, [pc, #180]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b68e:	f7fd b90e 	b.w	80188ae <iNemoEngine_API_Update+0xbce>
 801b692:	ed9f 8a2b 	vldr	s16, [pc, #172]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b696:	f7fc bf8c 	b.w	80185b2 <iNemoEngine_API_Update+0x8d2>
 801b69a:	eddf 8a29 	vldr	s17, [pc, #164]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b69e:	f7fc bf5d 	b.w	801855c <iNemoEngine_API_Update+0x87c>
 801b6a2:	ed9f 8a27 	vldr	s16, [pc, #156]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b6a6:	f7fd b92d 	b.w	8018904 <iNemoEngine_API_Update+0xc24>
 801b6aa:	ed9f ca25 	vldr	s24, [pc, #148]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b6ae:	f7fd b83f 	b.w	8018730 <iNemoEngine_API_Update+0xa50>
 801b6b2:	ed9f ca23 	vldr	s24, [pc, #140]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b6b6:	f7fc bfa7 	b.w	8018608 <iNemoEngine_API_Update+0x928>
 801b6ba:	ed9f 8a21 	vldr	s16, [pc, #132]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b6be:	f7fd b80c 	b.w	80186da <iNemoEngine_API_Update+0x9fa>
 801b6c2:	eddf 8a1f 	vldr	s17, [pc, #124]	@ 801b740 <iNemoEngine_API_Update+0x3a60>
 801b6c6:	f7fd b8c7 	b.w	8018858 <iNemoEngine_API_Update+0xb78>
 801b6ca:	bf00      	nop
 801b6cc:	bf666666 	.word	0xbf666666
 801b6d0:	3d072b02 	.word	0x3d072b02
 801b6d4:	3ca3d70a 	.word	0x3ca3d70a
 801b6d8:	3d4ccccd 	.word	0x3d4ccccd
 801b6dc:	3cb43958 	.word	0x3cb43958
 801b6e0:	3cf5c28f 	.word	0x3cf5c28f
 801b6e4:	3eb33333 	.word	0x3eb33333
 801b6e8:	3d75c28f 	.word	0x3d75c28f
 801b6ec:	3ee66666 	.word	0x3ee66666
 801b6f0:	3f866666 	.word	0x3f866666
 801b6f4:	3d23d70a 	.word	0x3d23d70a
 801b6f8:	3f8ccccd 	.word	0x3f8ccccd
 801b6fc:	3d8f5c29 	.word	0x3d8f5c29
 801b700:	3f933333 	.word	0x3f933333
 801b704:	3ebd70a4 	.word	0x3ebd70a4
 801b708:	40a00000 	.word	0x40a00000
 801b70c:	3ecccccd 	.word	0x3ecccccd
 801b710:	3f4ccccd 	.word	0x3f4ccccd
 801b714:	3dcccccd 	.word	0x3dcccccd
 801b718:	3e4ccccd 	.word	0x3e4ccccd
 801b71c:	3e99999a 	.word	0x3e99999a
 801b720:	3f666666 	.word	0x3f666666
 801b724:	3f99999a 	.word	0x3f99999a
 801b728:	3f19999a 	.word	0x3f19999a
 801b72c:	3fb9999a 	.word	0x3fb9999a
 801b730:	3fcccccd 	.word	0x3fcccccd
 801b734:	3fe66666 	.word	0x3fe66666
 801b738:	40200000 	.word	0x40200000
 801b73c:	40400000 	.word	0x40400000
 801b740:	80000000 	.word	0x80000000
 801b744:	3fa66666 	.word	0x3fa66666
 801b748:	3f333333 	.word	0x3f333333
 801b74c:	3e4cccce 	.word	0x3e4cccce
 801b750:	3eaaaaab 	.word	0x3eaaaaab
 801b754:	f892 21a4 	ldrb.w	r2, [r2, #420]	@ 0x1a4
 801b758:	2a00      	cmp	r2, #0
 801b75a:	f040 85bc 	bne.w	801c2d6 <iNemoEngine_API_Update+0x45f6>
 801b75e:	9906      	ldr	r1, [sp, #24]
 801b760:	ed5f 8a06 	vldr	s17, [pc, #-24]	@ 801b74c <iNemoEngine_API_Update+0x3a6c>
 801b764:	f8b1 31a6 	ldrh.w	r3, [r1, #422]	@ 0x1a6
 801b768:	ed5f 7a07 	vldr	s15, [pc, #-28]	@ 801b750 <iNemoEngine_API_Update+0x3a70>
 801b76c:	3301      	adds	r3, #1
 801b76e:	b29b      	uxth	r3, r3
 801b770:	2b31      	cmp	r3, #49	@ 0x31
 801b772:	f8a1 31a6 	strh.w	r3, [r1, #422]	@ 0x1a6
 801b776:	bf98      	it	ls
 801b778:	eef0 8a67 	vmovls.f32	s17, s15
 801b77c:	460b      	mov	r3, r1
 801b77e:	f8d3 31a4 	ldr.w	r3, [r3, #420]	@ 0x1a4
 801b782:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 801b786:	f5b3 0f8c 	cmp.w	r3, #4587520	@ 0x460000
 801b78a:	f000 8599 	beq.w	801c2c0 <iNemoEngine_API_Update+0x45e0>
 801b78e:	f5b3 0fc8 	cmp.w	r3, #6553600	@ 0x640000
 801b792:	f47f a83a 	bne.w	801a80a <iNemoEngine_API_Update+0x2b2a>
 801b796:	9a06      	ldr	r2, [sp, #24]
 801b798:	2301      	movs	r3, #1
 801b79a:	f882 31a4 	strb.w	r3, [r2, #420]	@ 0x1a4
 801b79e:	9a06      	ldr	r2, [sp, #24]
 801b7a0:	edcd 6a03 	vstr	s13, [sp, #12]
 801b7a4:	f502 63c3 	add.w	r3, r2, #1560	@ 0x618
 801b7a8:	ed93 5a00 	vldr	s10, [r3]
 801b7ac:	f502 63f1 	add.w	r3, r2, #1928	@ 0x788
 801b7b0:	ed93 7a00 	vldr	s14, [r3]
 801b7b4:	f202 6314 	addw	r3, r2, #1556	@ 0x614
 801b7b8:	edd3 4a00 	vldr	s9, [r3]
 801b7bc:	ee25 4a05 	vmul.f32	s8, s10, s10
 801b7c0:	f202 7384 	addw	r3, r2, #1924	@ 0x784
 801b7c4:	eea4 4aa4 	vfma.f32	s8, s9, s9
 801b7c8:	a93d      	add	r1, sp, #244	@ 0xf4
 801b7ca:	a843      	add	r0, sp, #268	@ 0x10c
 801b7cc:	ed93 6a00 	vldr	s12, [r3]
 801b7d0:	f202 631c 	addw	r3, r2, #1564	@ 0x61c
 801b7d4:	edd3 7a00 	vldr	s15, [r3]
 801b7d8:	eea7 4aa7 	vfma.f32	s8, s15, s15
 801b7dc:	f202 738c 	addw	r3, r2, #1932	@ 0x78c
 801b7e0:	465e      	mov	r6, fp
 801b7e2:	eef7 3a00 	vmov.f32	s7, #112	@ 0x3f800000  1.0
 801b7e6:	eeb1 3ac4 	vsqrt.f32	s6, s8
 801b7ea:	465a      	mov	r2, fp
 801b7ec:	4655      	mov	r5, sl
 801b7ee:	4657      	mov	r7, sl
 801b7f0:	acae      	add	r4, sp, #696	@ 0x2b8
 801b7f2:	ee67 5a07 	vmul.f32	s11, s14, s14
 801b7f6:	ee83 4a83 	vdiv.f32	s8, s7, s6
 801b7fa:	eee6 5a06 	vfma.f32	s11, s12, s12
 801b7fe:	ee67 7a84 	vmul.f32	s15, s15, s8
 801b802:	ee25 5a04 	vmul.f32	s10, s10, s8
 801b806:	edcd 7a3f 	vstr	s15, [sp, #252]	@ 0xfc
 801b80a:	edd3 7a00 	vldr	s15, [r3]
 801b80e:	ed8d 5a3e 	vstr	s10, [sp, #248]	@ 0xf8
 801b812:	eee7 5aa7 	vfma.f32	s11, s15, s15
 801b816:	ee64 4a84 	vmul.f32	s9, s9, s8
 801b81a:	eeb1 5ae5 	vsqrt.f32	s10, s11
 801b81e:	edcd 4a3d 	vstr	s9, [sp, #244]	@ 0xf4
 801b822:	eec3 5a85 	vdiv.f32	s11, s7, s10
 801b826:	ee27 7a25 	vmul.f32	s14, s14, s11
 801b82a:	ee67 7aa5 	vmul.f32	s15, s15, s11
 801b82e:	ee26 6a25 	vmul.f32	s12, s12, s11
 801b832:	ed8d 7a44 	vstr	s14, [sp, #272]	@ 0x110
 801b836:	edcd 7a45 	vstr	s15, [sp, #276]	@ 0x114
 801b83a:	ed8d 6a43 	vstr	s12, [sp, #268]	@ 0x10c
 801b83e:	f7fa fec5 	bl	80165cc <getRotationMatrix>
 801b842:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801b844:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801b846:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801b848:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801b84a:	6836      	ldr	r6, [r6, #0]
 801b84c:	602e      	str	r6, [r5, #0]
 801b84e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801b850:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801b852:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801b854:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801b856:	edda 7a00 	vldr	s15, [sl]
 801b85a:	ed9a 7a01 	vldr	s14, [sl, #4]
 801b85e:	eddd 6a03 	vldr	s13, [sp, #12]
 801b862:	6026      	str	r6, [r4, #0]
 801b864:	eef0 7ae7 	vabs.f32	s15, s15
 801b868:	eeb0 7ac7 	vabs.f32	s14, s14
 801b86c:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b870:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b874:	f140 8407 	bpl.w	801c086 <iNemoEngine_API_Update+0x43a6>
 801b878:	2304      	movs	r3, #4
 801b87a:	2000      	movs	r0, #0
 801b87c:	930c      	str	r3, [sp, #48]	@ 0x30
 801b87e:	469e      	mov	lr, r3
 801b880:	eef0 7a47 	vmov.f32	s15, s14
 801b884:	2103      	movs	r1, #3
 801b886:	2707      	movs	r7, #7
 801b888:	f04f 0c06 	mov.w	ip, #6
 801b88c:	4603      	mov	r3, r0
 801b88e:	2601      	movs	r6, #1
 801b890:	ed9a 7a02 	vldr	s14, [sl, #8]
 801b894:	eeb0 7ac7 	vabs.f32	s14, s14
 801b898:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801b89c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b8a0:	f340 8453 	ble.w	801c14a <iNemoEngine_API_Update+0x446a>
 801b8a4:	2306      	movs	r3, #6
 801b8a6:	2708      	movs	r7, #8
 801b8a8:	2104      	movs	r1, #4
 801b8aa:	9303      	str	r3, [sp, #12]
 801b8ac:	f04f 0c07 	mov.w	ip, #7
 801b8b0:	f04f 0e05 	mov.w	lr, #5
 801b8b4:	970c      	str	r7, [sp, #48]	@ 0x30
 801b8b6:	4608      	mov	r0, r1
 801b8b8:	2200      	movs	r2, #0
 801b8ba:	2301      	movs	r3, #1
 801b8bc:	2602      	movs	r6, #2
 801b8be:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 801b8c0:	4450      	add	r0, sl
 801b8c2:	4454      	add	r4, sl
 801b8c4:	ed90 6a00 	vldr	s12, [r0]
 801b8c8:	ed94 7a00 	vldr	s14, [r4]
 801b8cc:	eec6 7a07 	vdiv.f32	s15, s12, s14
 801b8d0:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801b8d2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 801b8d6:	acae      	add	r4, sp, #696	@ 0x2b8
 801b8d8:	adae      	add	r5, sp, #696	@ 0x2b8
 801b8da:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 801b8de:	eb05 0586 	add.w	r5, r5, r6, lsl #2
 801b8e2:	edc0 7a00 	vstr	s15, [r0]
 801b8e6:	ed94 7a00 	vldr	s14, [r4]
 801b8ea:	edd5 7a00 	vldr	s15, [r5]
 801b8ee:	ee87 6a27 	vdiv.f32	s12, s14, s15
 801b8f2:	ed84 6a00 	vstr	s12, [r4]
 801b8f6:	edd0 5a00 	vldr	s11, [r0]
 801b8fa:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801b8fc:	eb00 0581 	add.w	r5, r0, r1, lsl #2
 801b900:	eb00 008e 	add.w	r0, r0, lr, lsl #2
 801b904:	ed90 7a00 	vldr	s14, [r0]
 801b908:	edd5 7a00 	vldr	s15, [r5]
 801b90c:	eee5 7ac7 	vfms.f32	s15, s11, s14
 801b910:	ea4f 048e 	mov.w	r4, lr, lsl #2
 801b914:	9404      	str	r4, [sp, #16]
 801b916:	9c0e      	ldr	r4, [sp, #56]	@ 0x38
 801b918:	edc5 7a00 	vstr	s15, [r5]
 801b91c:	ed90 7a00 	vldr	s14, [r0]
 801b920:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801b922:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 801b926:	edd0 7a00 	vldr	s15, [r0]
 801b92a:	eee6 7a47 	vfms.f32	s15, s12, s14
 801b92e:	ea4f 0e84 	mov.w	lr, r4, lsl #2
 801b932:	00bc      	lsls	r4, r7, #2
 801b934:	9405      	str	r4, [sp, #20]
 801b936:	edc0 7a00 	vstr	s15, [r0]
 801b93a:	acae      	add	r4, sp, #696	@ 0x2b8
 801b93c:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801b93e:	eb00 0087 	add.w	r0, r0, r7, lsl #2
 801b942:	eb04 048c 	add.w	r4, r4, ip, lsl #2
 801b946:	ed90 5a00 	vldr	s10, [r0]
 801b94a:	ed94 7a00 	vldr	s14, [r4]
 801b94e:	eea5 7ac5 	vfms.f32	s14, s11, s10
 801b952:	0097      	lsls	r7, r2, #2
 801b954:	eef0 7ae7 	vabs.f32	s15, s15
 801b958:	ed84 7a00 	vstr	s14, [r4]
 801b95c:	9c03      	ldr	r4, [sp, #12]
 801b95e:	edd0 5a00 	vldr	s11, [r0]
 801b962:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801b964:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 801b968:	ed90 7a00 	vldr	s14, [r0]
 801b96c:	eea6 7a65 	vfms.f32	s14, s12, s11
 801b970:	ea4f 0a84 	mov.w	sl, r4, lsl #2
 801b974:	008c      	lsls	r4, r1, #2
 801b976:	ed80 7a00 	vstr	s14, [r0]
 801b97a:	ed95 7a00 	vldr	s14, [r5]
 801b97e:	eeb0 7ac7 	vabs.f32	s14, s14
 801b982:	eef4 7ac7 	vcmpe.f32	s15, s14
 801b986:	00b0      	lsls	r0, r6, #2
 801b988:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801b98c:	9003      	str	r0, [sp, #12]
 801b98e:	ea4f 0583 	mov.w	r5, r3, lsl #2
 801b992:	ea4f 008c 	mov.w	r0, ip, lsl #2
 801b996:	dd0a      	ble.n	801b9ae <iNemoEngine_API_Update+0x3cce>
 801b998:	4618      	mov	r0, r3
 801b99a:	4613      	mov	r3, r2
 801b99c:	4602      	mov	r2, r0
 801b99e:	4674      	mov	r4, lr
 801b9a0:	4650      	mov	r0, sl
 801b9a2:	463d      	mov	r5, r7
 801b9a4:	ea4f 0e81 	mov.w	lr, r1, lsl #2
 801b9a8:	ea4f 0a8c 	mov.w	sl, ip, lsl #2
 801b9ac:	0097      	lsls	r7, r2, #2
 801b9ae:	a9ae      	add	r1, sp, #696	@ 0x2b8
 801b9b0:	448e      	add	lr, r1
 801b9b2:	440c      	add	r4, r1
 801b9b4:	ed9e 7a00 	vldr	s14, [lr]
 801b9b8:	edd4 7a00 	vldr	s15, [r4]
 801b9bc:	edcd 6a03 	vstr	s13, [sp, #12]
 801b9c0:	ee87 2a27 	vdiv.f32	s4, s14, s15
 801b9c4:	4408      	add	r0, r1
 801b9c6:	4451      	add	r1, sl
 801b9c8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801b9cc:	ed8e 2a00 	vstr	s4, [lr]
 801b9d0:	ed90 6a00 	vldr	s12, [r0]
 801b9d4:	edd1 7a00 	vldr	s15, [r1]
 801b9d8:	eee2 7a46 	vfms.f32	s15, s4, s12
 801b9dc:	edc1 7a00 	vstr	s15, [r1]
 801b9e0:	9905      	ldr	r1, [sp, #20]
 801b9e2:	ed90 3a00 	vldr	s6, [r0]
 801b9e6:	ed94 6a00 	vldr	s12, [r4]
 801b9ea:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801b9ec:	4401      	add	r1, r0
 801b9ee:	edd1 3a00 	vldr	s7, [r1]
 801b9f2:	9904      	ldr	r1, [sp, #16]
 801b9f4:	4401      	add	r1, r0
 801b9f6:	00b0      	lsls	r0, r6, #2
 801b9f8:	edd1 4a00 	vldr	s9, [r1]
 801b9fc:	f500 61b2 	add.w	r1, r0, #1424	@ 0x590
 801ba00:	4469      	add	r1, sp
 801ba02:	f5a1 717c 	sub.w	r1, r1, #1008	@ 0x3f0
 801ba06:	eec7 2a27 	vdiv.f32	s5, s14, s15
 801ba0a:	edd1 7a00 	vldr	s15, [r1]
 801ba0e:	a9ae      	add	r1, sp, #696	@ 0x2b8
 801ba10:	4401      	add	r1, r0
 801ba12:	ee87 4a06 	vdiv.f32	s8, s14, s12
 801ba16:	a8ae      	add	r0, sp, #696	@ 0x2b8
 801ba18:	ed91 6a00 	vldr	s12, [r1]
 801ba1c:	f505 61b2 	add.w	r1, r5, #1424	@ 0x590
 801ba20:	4469      	add	r1, sp
 801ba22:	f5a1 717c 	sub.w	r1, r1, #1008	@ 0x3f0
 801ba26:	ee87 5a06 	vdiv.f32	s10, s14, s12
 801ba2a:	4405      	add	r5, r0
 801ba2c:	ed91 7a00 	vldr	s14, [r1]
 801ba30:	edd5 5a00 	vldr	s11, [r5]
 801ba34:	f507 61b2 	add.w	r1, r7, #1424	@ 0x590
 801ba38:	4469      	add	r1, sp
 801ba3a:	4407      	add	r7, r0
 801ba3c:	f5a1 717c 	sub.w	r1, r1, #1008	@ 0x3f0
 801ba40:	edd7 1a00 	vldr	s3, [r7]
 801ba44:	ed91 6a00 	vldr	s12, [r1]
 801ba48:	eea5 7ae7 	vfms.f32	s14, s11, s15
 801ba4c:	f50d 61b2 	add.w	r1, sp, #1424	@ 0x590
 801ba50:	eb01 0086 	add.w	r0, r1, r6, lsl #2
 801ba54:	eea1 6ae7 	vfms.f32	s12, s3, s15
 801ba58:	4601      	mov	r1, r0
 801ba5a:	f5a1 7176 	sub.w	r1, r1, #984	@ 0x3d8
 801ba5e:	ed91 1a00 	vldr	s2, [r1]
 801ba62:	eea2 6a47 	vfms.f32	s12, s4, s14
 801ba66:	f50d 61b2 	add.w	r1, sp, #1424	@ 0x590
 801ba6a:	f5a0 7079 	sub.w	r0, r0, #996	@ 0x3e4
 801ba6e:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801ba72:	ee22 6a86 	vmul.f32	s12, s5, s12
 801ba76:	460b      	mov	r3, r1
 801ba78:	eea3 7a46 	vfms.f32	s14, s6, s12
 801ba7c:	f5a1 7179 	sub.w	r1, r1, #996	@ 0x3e4
 801ba80:	f5a3 7376 	sub.w	r3, r3, #984	@ 0x3d8
 801ba84:	eee3 7ac6 	vfms.f32	s15, s7, s12
 801ba88:	ee27 7a04 	vmul.f32	s14, s14, s8
 801ba8c:	ed8b 6a02 	vstr	s12, [fp, #8]
 801ba90:	eee4 7ac7 	vfms.f32	s15, s9, s14
 801ba94:	ed8b 7a01 	vstr	s14, [fp, #4]
 801ba98:	ee65 7a27 	vmul.f32	s15, s10, s15
 801ba9c:	ed90 7a00 	vldr	s14, [r0]
 801baa0:	ed91 6a00 	vldr	s12, [r1]
 801baa4:	edcb 7a00 	vstr	s15, [fp]
 801baa8:	f50d 60b2 	add.w	r0, sp, #1424	@ 0x590
 801baac:	eb00 0182 	add.w	r1, r0, r2, lsl #2
 801bab0:	edd3 7a00 	vldr	s15, [r3]
 801bab4:	f5a1 7376 	sub.w	r3, r1, #984	@ 0x3d8
 801bab8:	edd3 0a00 	vldr	s1, [r3]
 801babc:	f5a1 7279 	sub.w	r2, r1, #996	@ 0x3e4
 801bac0:	eea5 6ac7 	vfms.f32	s12, s11, s14
 801bac4:	4658      	mov	r0, fp
 801bac6:	a952      	add	r1, sp, #328	@ 0x148
 801bac8:	eee1 7a65 	vfms.f32	s15, s2, s11
 801bacc:	edd2 5a00 	vldr	s11, [r2]
 801bad0:	eee1 0a61 	vfms.f32	s1, s2, s3
 801bad4:	eee1 5ac7 	vfms.f32	s11, s3, s14
 801bad8:	eef0 1a60 	vmov.f32	s3, s1
 801badc:	eee2 5a46 	vfms.f32	s11, s4, s12
 801bae0:	eee2 1a67 	vfms.f32	s3, s4, s15
 801bae4:	ee62 5aa5 	vmul.f32	s11, s5, s11
 801bae8:	ee62 2aa1 	vmul.f32	s5, s5, s3
 801baec:	eea3 6a65 	vfms.f32	s12, s6, s11
 801baf0:	eee2 7ac3 	vfms.f32	s15, s5, s6
 801baf4:	eea2 1ae3 	vfms.f32	s2, s5, s7
 801baf8:	eea3 7ae5 	vfms.f32	s14, s7, s11
 801bafc:	ee26 6a04 	vmul.f32	s12, s12, s8
 801bb00:	ee67 7a84 	vmul.f32	s15, s15, s8
 801bb04:	edcb 5a05 	vstr	s11, [fp, #20]
 801bb08:	eef0 5a41 	vmov.f32	s11, s2
 801bb0c:	eea4 7ac6 	vfms.f32	s14, s9, s12
 801bb10:	eee7 5ae4 	vfms.f32	s11, s15, s9
 801bb14:	ee25 7a07 	vmul.f32	s14, s10, s14
 801bb18:	ee65 5a25 	vmul.f32	s11, s10, s11
 801bb1c:	ed8b 6a04 	vstr	s12, [fp, #16]
 801bb20:	ed8b 7a03 	vstr	s14, [fp, #12]
 801bb24:	edcb 2a08 	vstr	s5, [fp, #32]
 801bb28:	edcb 7a07 	vstr	s15, [fp, #28]
 801bb2c:	edcb 5a06 	vstr	s11, [fp, #24]
 801bb30:	f7fa fcac 	bl	801648c <b_dcm2q>
 801bb34:	ed9d 7a53 	vldr	s14, [sp, #332]	@ 0x14c
 801bb38:	eddd 7a54 	vldr	s15, [sp, #336]	@ 0x150
 801bb3c:	ed9d 6a52 	vldr	s12, [sp, #328]	@ 0x148
 801bb40:	9b06      	ldr	r3, [sp, #24]
 801bb42:	eddd 6a03 	vldr	s13, [sp, #12]
 801bb46:	f893 31a4 	ldrb.w	r3, [r3, #420]	@ 0x1a4
 801bb4a:	ee37 7a07 	vadd.f32	s14, s14, s14
 801bb4e:	ee36 6a06 	vadd.f32	s12, s12, s12
 801bb52:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801bb56:	ed8d 6a3d 	vstr	s12, [sp, #244]	@ 0xf4
 801bb5a:	ed8d 7a3e 	vstr	s14, [sp, #248]	@ 0xf8
 801bb5e:	edcd 7a3f 	vstr	s15, [sp, #252]	@ 0xfc
 801bb62:	2b00      	cmp	r3, #0
 801bb64:	f43e ae54 	beq.w	801a810 <iNemoEngine_API_Update+0x2b30>
 801bb68:	9906      	ldr	r1, [sp, #24]
 801bb6a:	2200      	movs	r2, #0
 801bb6c:	464b      	mov	r3, r9
 801bb6e:	f881 21a0 	strb.w	r2, [r1, #416]	@ 0x1a0
 801bb72:	f8ad 20ee 	strh.w	r2, [sp, #238]	@ 0xee
 801bb76:	f88d 20f0 	strb.w	r2, [sp, #240]	@ 0xf0
 801bb7a:	f881 21a3 	strb.w	r2, [r1, #419]	@ 0x1a3
 801bb7e:	f7fe ba06 	b.w	8019f8e <iNemoEngine_API_Update+0x22ae>
 801bb82:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bb86:	ee38 4ae7 	vsub.f32	s8, s17, s15
 801bb8a:	edd2 3a31 	vldr	s7, [r2, #196]	@ 0xc4
 801bb8e:	edd2 7a33 	vldr	s15, [r2, #204]	@ 0xcc
 801bb92:	ee77 7ae3 	vsub.f32	s15, s15, s7
 801bb96:	ee67 7a84 	vmul.f32	s15, s15, s8
 801bb9a:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801bb9e:	edd2 7a34 	vldr	s15, [r2, #208]	@ 0xd0
 801bba2:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bba6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bbaa:	ee3f fa23 	vadd.f32	s30, s30, s7
 801bbae:	f6fe ac6e 	blt.w	801a48e <iNemoEngine_API_Update+0x27ae>
 801bbb2:	9b06      	ldr	r3, [sp, #24]
 801bbb4:	ed93 7a36 	vldr	s14, [r3, #216]	@ 0xd8
 801bbb8:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bbbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bbc0:	f140 837a 	bpl.w	801c2b8 <iNemoEngine_API_Update+0x45d8>
 801bbc4:	edd3 3a35 	vldr	s7, [r3, #212]	@ 0xd4
 801bbc8:	ed93 4a37 	vldr	s8, [r3, #220]	@ 0xdc
 801bbcc:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bbd0:	ee34 4a63 	vsub.f32	s8, s8, s7
 801bbd4:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bbd8:	ee64 7a27 	vmul.f32	s15, s8, s15
 801bbdc:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801bbe0:	ee3f fa23 	vadd.f32	s30, s30, s7
 801bbe4:	9b06      	ldr	r3, [sp, #24]
 801bbe6:	edd3 7a38 	vldr	s15, [r3, #224]	@ 0xe0
 801bbea:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bbee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bbf2:	f6fe ac6d 	blt.w	801a4d0 <iNemoEngine_API_Update+0x27f0>
 801bbf6:	9b06      	ldr	r3, [sp, #24]
 801bbf8:	ed93 7a3a 	vldr	s14, [r3, #232]	@ 0xe8
 801bbfc:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bc00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bc04:	f140 82fd 	bpl.w	801c202 <iNemoEngine_API_Update+0x4522>
 801bc08:	edd3 3a39 	vldr	s7, [r3, #228]	@ 0xe4
 801bc0c:	ed93 4a3b 	vldr	s8, [r3, #236]	@ 0xec
 801bc10:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bc14:	ee34 4a63 	vsub.f32	s8, s8, s7
 801bc18:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bc1c:	ee64 7a27 	vmul.f32	s15, s8, s15
 801bc20:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801bc24:	ee3f fa23 	vadd.f32	s30, s30, s7
 801bc28:	9b06      	ldr	r3, [sp, #24]
 801bc2a:	edd3 7a3c 	vldr	s15, [r3, #240]	@ 0xf0
 801bc2e:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bc32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bc36:	f6fe ac6d 	blt.w	801a514 <iNemoEngine_API_Update+0x2834>
 801bc3a:	9b06      	ldr	r3, [sp, #24]
 801bc3c:	ed93 7a3e 	vldr	s14, [r3, #248]	@ 0xf8
 801bc40:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bc44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bc48:	f140 831a 	bpl.w	801c280 <iNemoEngine_API_Update+0x45a0>
 801bc4c:	edd3 3a3d 	vldr	s7, [r3, #244]	@ 0xf4
 801bc50:	ed93 4a3f 	vldr	s8, [r3, #252]	@ 0xfc
 801bc54:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bc58:	ee34 4a63 	vsub.f32	s8, s8, s7
 801bc5c:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bc60:	ee64 7a27 	vmul.f32	s15, s8, s15
 801bc64:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801bc68:	ee3f fa23 	vadd.f32	s30, s30, s7
 801bc6c:	9b06      	ldr	r3, [sp, #24]
 801bc6e:	edd3 7a40 	vldr	s15, [r3, #256]	@ 0x100
 801bc72:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bc76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bc7a:	f6fe ac6d 	blt.w	801a558 <iNemoEngine_API_Update+0x2878>
 801bc7e:	9b06      	ldr	r3, [sp, #24]
 801bc80:	ed93 7a42 	vldr	s14, [r3, #264]	@ 0x108
 801bc84:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bc88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bc8c:	f140 82c3 	bpl.w	801c216 <iNemoEngine_API_Update+0x4536>
 801bc90:	edd3 3a41 	vldr	s7, [r3, #260]	@ 0x104
 801bc94:	ed93 4a43 	vldr	s8, [r3, #268]	@ 0x10c
 801bc98:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bc9c:	ee34 4a63 	vsub.f32	s8, s8, s7
 801bca0:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bca4:	ee64 7a27 	vmul.f32	s15, s8, s15
 801bca8:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801bcac:	ee3f fa23 	vadd.f32	s30, s30, s7
 801bcb0:	9b06      	ldr	r3, [sp, #24]
 801bcb2:	edd3 7a44 	vldr	s15, [r3, #272]	@ 0x110
 801bcb6:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bcba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bcbe:	f6fe ac6d 	blt.w	801a59c <iNemoEngine_API_Update+0x28bc>
 801bcc2:	9b06      	ldr	r3, [sp, #24]
 801bcc4:	ed93 7a46 	vldr	s14, [r3, #280]	@ 0x118
 801bcc8:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bccc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bcd0:	f140 82d2 	bpl.w	801c278 <iNemoEngine_API_Update+0x4598>
 801bcd4:	ed93 4a45 	vldr	s8, [r3, #276]	@ 0x114
 801bcd8:	edd3 4a47 	vldr	s9, [r3, #284]	@ 0x11c
 801bcdc:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bce0:	ee74 4ac4 	vsub.f32	s9, s9, s8
 801bce4:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bce8:	ee64 7aa7 	vmul.f32	s15, s9, s15
 801bcec:	ee87 fa87 	vdiv.f32	s30, s15, s14
 801bcf0:	ee3f fa04 	vadd.f32	s30, s30, s8
 801bcf4:	f7fd ba93 	b.w	801921e <iNemoEngine_API_Update+0x153e>
 801bcf8:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bcfc:	ee38 4ae7 	vsub.f32	s8, s17, s15
 801bd00:	edd3 3a4b 	vldr	s7, [r3, #300]	@ 0x12c
 801bd04:	edd3 7a4d 	vldr	s15, [r3, #308]	@ 0x134
 801bd08:	ee77 7ae3 	vsub.f32	s15, s15, s7
 801bd0c:	ee67 7a84 	vmul.f32	s15, s15, s8
 801bd10:	ee87 ca87 	vdiv.f32	s24, s15, s14
 801bd14:	edd3 7a4e 	vldr	s15, [r3, #312]	@ 0x138
 801bd18:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bd1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bd20:	ee3c ca23 	vadd.f32	s24, s24, s7
 801bd24:	f6fd aaab 	blt.w	801927e <iNemoEngine_API_Update+0x159e>
 801bd28:	9b06      	ldr	r3, [sp, #24]
 801bd2a:	ed93 7a50 	vldr	s14, [r3, #320]	@ 0x140
 801bd2e:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bd32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bd36:	f140 8260 	bpl.w	801c1fa <iNemoEngine_API_Update+0x451a>
 801bd3a:	edd3 3a4f 	vldr	s7, [r3, #316]	@ 0x13c
 801bd3e:	ed93 4a51 	vldr	s8, [r3, #324]	@ 0x144
 801bd42:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bd46:	ee34 4a63 	vsub.f32	s8, s8, s7
 801bd4a:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bd4e:	ee64 7a27 	vmul.f32	s15, s8, s15
 801bd52:	ee87 ca87 	vdiv.f32	s24, s15, s14
 801bd56:	ee3c ca23 	vadd.f32	s24, s24, s7
 801bd5a:	9b06      	ldr	r3, [sp, #24]
 801bd5c:	edd3 7a52 	vldr	s15, [r3, #328]	@ 0x148
 801bd60:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bd64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bd68:	f6fd aaaa 	blt.w	80192c0 <iNemoEngine_API_Update+0x15e0>
 801bd6c:	9b06      	ldr	r3, [sp, #24]
 801bd6e:	ed93 7a54 	vldr	s14, [r3, #336]	@ 0x150
 801bd72:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bd76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bd7a:	f140 8237 	bpl.w	801c1ec <iNemoEngine_API_Update+0x450c>
 801bd7e:	edd3 3a53 	vldr	s7, [r3, #332]	@ 0x14c
 801bd82:	ed93 4a55 	vldr	s8, [r3, #340]	@ 0x154
 801bd86:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bd8a:	ee34 4a63 	vsub.f32	s8, s8, s7
 801bd8e:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bd92:	ee64 7a27 	vmul.f32	s15, s8, s15
 801bd96:	ee87 ca87 	vdiv.f32	s24, s15, s14
 801bd9a:	ee3c ca23 	vadd.f32	s24, s24, s7
 801bd9e:	9b06      	ldr	r3, [sp, #24]
 801bda0:	edd3 7a56 	vldr	s15, [r3, #344]	@ 0x158
 801bda4:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bda8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bdac:	f6fd aaaa 	blt.w	8019304 <iNemoEngine_API_Update+0x1624>
 801bdb0:	9b06      	ldr	r3, [sp, #24]
 801bdb2:	ed93 7a58 	vldr	s14, [r3, #352]	@ 0x160
 801bdb6:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bdba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bdbe:	f140 8270 	bpl.w	801c2a2 <iNemoEngine_API_Update+0x45c2>
 801bdc2:	edd3 3a57 	vldr	s7, [r3, #348]	@ 0x15c
 801bdc6:	ed93 4a59 	vldr	s8, [r3, #356]	@ 0x164
 801bdca:	ee37 7a67 	vsub.f32	s14, s14, s15
 801bdce:	ee34 4a63 	vsub.f32	s8, s8, s7
 801bdd2:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801bdd6:	ee64 7a27 	vmul.f32	s15, s8, s15
 801bdda:	ee87 ca87 	vdiv.f32	s24, s15, s14
 801bdde:	ee3c ca23 	vadd.f32	s24, s24, s7
 801bde2:	9b06      	ldr	r3, [sp, #24]
 801bde4:	edd3 7a5a 	vldr	s15, [r3, #360]	@ 0x168
 801bde8:	eef4 8ae7 	vcmpe.f32	s17, s15
 801bdec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bdf0:	f6fd aaaa 	blt.w	8019348 <iNemoEngine_API_Update+0x1668>
 801bdf4:	9b06      	ldr	r3, [sp, #24]
 801bdf6:	ed93 7a5c 	vldr	s14, [r3, #368]	@ 0x170
 801bdfa:	eef4 8ac7 	vcmpe.f32	s17, s14
 801bdfe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801be02:	f140 8252 	bpl.w	801c2aa <iNemoEngine_API_Update+0x45ca>
 801be06:	edd3 3a5b 	vldr	s7, [r3, #364]	@ 0x16c
 801be0a:	ed93 4a5d 	vldr	s8, [r3, #372]	@ 0x174
 801be0e:	ee37 7a67 	vsub.f32	s14, s14, s15
 801be12:	ee34 4a63 	vsub.f32	s8, s8, s7
 801be16:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801be1a:	ee64 7a27 	vmul.f32	s15, s8, s15
 801be1e:	ee87 ca87 	vdiv.f32	s24, s15, s14
 801be22:	ee3c ca23 	vadd.f32	s24, s24, s7
 801be26:	9b06      	ldr	r3, [sp, #24]
 801be28:	edd3 7a5e 	vldr	s15, [r3, #376]	@ 0x178
 801be2c:	eef4 8ae7 	vcmpe.f32	s17, s15
 801be30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801be34:	f6fd aaaa 	blt.w	801938c <iNemoEngine_API_Update+0x16ac>
 801be38:	9b06      	ldr	r3, [sp, #24]
 801be3a:	ed93 7a60 	vldr	s14, [r3, #384]	@ 0x180
 801be3e:	eef4 8ac7 	vcmpe.f32	s17, s14
 801be42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801be46:	f140 8222 	bpl.w	801c28e <iNemoEngine_API_Update+0x45ae>
 801be4a:	ed93 4a5f 	vldr	s8, [r3, #380]	@ 0x17c
 801be4e:	edd3 4a61 	vldr	s9, [r3, #388]	@ 0x184
 801be52:	ee37 7a67 	vsub.f32	s14, s14, s15
 801be56:	ee74 4ac4 	vsub.f32	s9, s9, s8
 801be5a:	ee78 7ae7 	vsub.f32	s15, s17, s15
 801be5e:	ee64 7aa7 	vmul.f32	s15, s9, s15
 801be62:	ee87 ca87 	vdiv.f32	s24, s15, s14
 801be66:	ee3c ca04 	vadd.f32	s24, s24, s8
 801be6a:	f7fd bb2a 	b.w	80194c2 <iNemoEngine_API_Update+0x17e2>
 801be6e:	a94e      	add	r1, sp, #312	@ 0x138
 801be70:	a868      	add	r0, sp, #416	@ 0x1a0
 801be72:	f7fa fb0b 	bl	801648c <b_dcm2q>
 801be76:	9d06      	ldr	r5, [sp, #24]
 801be78:	eddd 7a1a 	vldr	s15, [sp, #104]	@ 0x68
 801be7c:	edc5 7a72 	vstr	s15, [r5, #456]	@ 0x1c8
 801be80:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 801be84:	edc5 7a73 	vstr	s15, [r5, #460]	@ 0x1cc
 801be88:	4621      	mov	r1, r4
 801be8a:	f44f 72a2 	mov.w	r2, #324	@ 0x144
 801be8e:	f505 70ea 	add.w	r0, r5, #468	@ 0x1d4
 801be92:	edcd 7a05 	vstr	s15, [sp, #20]
 801be96:	f001 fbd6 	bl	801d646 <memset>
 801be9a:	4be5      	ldr	r3, [pc, #916]	@ (801c230 <iNemoEngine_API_Update+0x4550>)
 801be9c:	702c      	strb	r4, [r5, #0]
 801be9e:	eddd 7a05 	vldr	s15, [sp, #20]
 801bea2:	edd5 2a02 	vldr	s5, [r5, #8]
 801bea6:	ed9d 7a1a 	vldr	s14, [sp, #104]	@ 0x68
 801beaa:	9a06      	ldr	r2, [sp, #24]
 801beac:	f8c5 31d4 	str.w	r3, [r5, #468]	@ 0x1d4
 801beb0:	f8c5 31fc 	str.w	r3, [r5, #508]	@ 0x1fc
 801beb4:	f8c5 3224 	str.w	r3, [r5, #548]	@ 0x224
 801beb8:	f8c5 324c 	str.w	r3, [r5, #588]	@ 0x24c
 801bebc:	f8c5 3274 	str.w	r3, [r5, #628]	@ 0x274
 801bec0:	f8c5 329c 	str.w	r3, [r5, #668]	@ 0x29c
 801bec4:	f8c5 32c4 	str.w	r3, [r5, #708]	@ 0x2c4
 801bec8:	f8c5 32ec 	str.w	r3, [r5, #748]	@ 0x2ec
 801becc:	f8c5 3314 	str.w	r3, [r5, #788]	@ 0x314
 801bed0:	2401      	movs	r4, #1
 801bed2:	f7fd bb44 	b.w	801955e <iNemoEngine_API_Update+0x187e>
 801bed6:	290a      	cmp	r1, #10
 801bed8:	f000 815d 	beq.w	801c196 <iNemoEngine_API_Update+0x44b6>
 801bedc:	1c4b      	adds	r3, r1, #1
 801bede:	9906      	ldr	r1, [sp, #24]
 801bee0:	f881 31a0 	strb.w	r3, [r1, #416]	@ 0x1a0
 801bee4:	4613      	mov	r3, r2
 801bee6:	2200      	movs	r2, #0
 801bee8:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 801beec:	f8ad 20ee 	strh.w	r2, [sp, #238]	@ 0xee
 801bef0:	f88d 20f0 	strb.w	r2, [sp, #240]	@ 0xf0
 801bef4:	f881 21a3 	strb.w	r2, [r1, #419]	@ 0x1a3
 801bef8:	f7fe b849 	b.w	8019f8e <iNemoEngine_API_Update+0x22ae>
 801befc:	ed9d 7a55 	vldr	s14, [sp, #340]	@ 0x154
 801bf00:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 801bf04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bf08:	f340 824f 	ble.w	801c3aa <iNemoEngine_API_Update+0x46ca>
 801bf0c:	eef2 7a04 	vmov.f32	s15, #36	@ 0x41200000  10.0
 801bf10:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801bf14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bf18:	f140 8244 	bpl.w	801c3a4 <iNemoEngine_API_Update+0x46c4>
 801bf1c:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 801bf20:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801bf24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bf28:	f140 81f9 	bpl.w	801c31e <iNemoEngine_API_Update+0x463e>
 801bf2c:	eddf 7ace 	vldr	s15, [pc, #824]	@ 801c268 <iNemoEngine_API_Update+0x4588>
 801bf30:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 801bf34:	ee67 7a27 	vmul.f32	s15, s14, s15
 801bf38:	eeb4 7ac6 	vcmpe.f32	s14, s12
 801bf3c:	eef0 5a00 	vmov.f32	s11, #0	@ 0x40000000  2.0
 801bf40:	eef0 8a46 	vmov.f32	s17, s12
 801bf44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bf48:	eee7 8aa5 	vfma.f32	s17, s15, s11
 801bf4c:	f2c0 81fb 	blt.w	801c346 <iNemoEngine_API_Update+0x4666>
 801bf50:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 801bf54:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801bf58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bf5c:	f140 81fb 	bpl.w	801c356 <iNemoEngine_API_Update+0x4676>
 801bf60:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 801bf64:	ee77 7a67 	vsub.f32	s15, s14, s15
 801bf68:	ed9f 6ab2 	vldr	s12, [pc, #712]	@ 801c234 <iNemoEngine_API_Update+0x4554>
 801bf6c:	eddf 8ab2 	vldr	s17, [pc, #712]	@ 801c238 <iNemoEngine_API_Update+0x4558>
 801bf70:	eee7 8a86 	vfma.f32	s17, s15, s12
 801bf74:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
 801bf78:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801bf7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bf80:	f2c0 81fb 	blt.w	801c37a <iNemoEngine_API_Update+0x469a>
 801bf84:	eef1 7a04 	vmov.f32	s15, #20	@ 0x40a00000  5.0
 801bf88:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801bf8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bf90:	f140 81fb 	bpl.w	801c38a <iNemoEngine_API_Update+0x46aa>
 801bf94:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
 801bf98:	ee77 7a67 	vsub.f32	s15, s14, s15
 801bf9c:	eef0 8a00 	vmov.f32	s17, #0	@ 0x40000000  2.0
 801bfa0:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 801bfa4:	eee7 8a87 	vfma.f32	s17, s15, s14
 801bfa8:	9a06      	ldr	r2, [sp, #24]
 801bfaa:	2300      	movs	r3, #0
 801bfac:	f8a2 31a6 	strh.w	r3, [r2, #422]	@ 0x1a6
 801bfb0:	f892 21a4 	ldrb.w	r2, [r2, #420]	@ 0x1a4
 801bfb4:	f7fe bc29 	b.w	801a80a <iNemoEngine_API_Update+0x2b2a>
 801bfb8:	eddf 6aa0 	vldr	s13, [pc, #640]	@ 801c23c <iNemoEngine_API_Update+0x455c>
 801bfbc:	eef4 7ae6 	vcmpe.f32	s15, s13
 801bfc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bfc4:	f57e ad78 	bpl.w	801aab8 <iNemoEngine_API_Update+0x2dd8>
 801bfc8:	ed9f 6a9d 	vldr	s12, [pc, #628]	@ 801c240 <iNemoEngine_API_Update+0x4560>
 801bfcc:	eddf 6aa6 	vldr	s13, [pc, #664]	@ 801c268 <iNemoEngine_API_Update+0x4588>
 801bfd0:	eddf 5a9c 	vldr	s11, [pc, #624]	@ 801c244 <iNemoEngine_API_Update+0x4564>
 801bfd4:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801bfd8:	ee26 6a26 	vmul.f32	s12, s12, s13
 801bfdc:	eddf 6a9a 	vldr	s13, [pc, #616]	@ 801c248 <iNemoEngine_API_Update+0x4568>
 801bfe0:	eee6 6a25 	vfma.f32	s13, s12, s11
 801bfe4:	ed9f 6a99 	vldr	s12, [pc, #612]	@ 801c24c <iNemoEngine_API_Update+0x456c>
 801bfe8:	eef4 7ac6 	vcmpe.f32	s15, s12
 801bfec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801bff0:	f6fe ad78 	blt.w	801aae4 <iNemoEngine_API_Update+0x2e04>
 801bff4:	eddf 6a96 	vldr	s13, [pc, #600]	@ 801c250 <iNemoEngine_API_Update+0x4570>
 801bff8:	eef4 7ae6 	vcmpe.f32	s15, s13
 801bffc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c000:	f57e ad78 	bpl.w	801aaf4 <iNemoEngine_API_Update+0x2e14>
 801c004:	ed9f 6a91 	vldr	s12, [pc, #580]	@ 801c24c <iNemoEngine_API_Update+0x456c>
 801c008:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801c00c:	eef5 6a00 	vmov.f32	s13, #80	@ 0x3e800000  0.250
 801c010:	ee26 6a26 	vmul.f32	s12, s12, s13
 801c014:	eef3 5a04 	vmov.f32	s11, #52	@ 0x41a00000  20.0
 801c018:	eef7 6a08 	vmov.f32	s13, #120	@ 0x3fc00000  1.5
 801c01c:	eee6 6a25 	vfma.f32	s13, s12, s11
 801c020:	ed9f 6a93 	vldr	s12, [pc, #588]	@ 801c270 <iNemoEngine_API_Update+0x4590>
 801c024:	eef4 7ac6 	vcmpe.f32	s15, s12
 801c028:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c02c:	f6fe ad78 	blt.w	801ab20 <iNemoEngine_API_Update+0x2e40>
 801c030:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
 801c034:	eef4 7ae6 	vcmpe.f32	s15, s13
 801c038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c03c:	f57e ad77 	bpl.w	801ab2e <iNemoEngine_API_Update+0x2e4e>
 801c040:	ed9f 6a8b 	vldr	s12, [pc, #556]	@ 801c270 <iNemoEngine_API_Update+0x4590>
 801c044:	eddf 6a83 	vldr	s13, [pc, #524]	@ 801c254 <iNemoEngine_API_Update+0x4574>
 801c048:	eddf 5a83 	vldr	s11, [pc, #524]	@ 801c258 <iNemoEngine_API_Update+0x4578>
 801c04c:	ee37 6ac6 	vsub.f32	s12, s15, s12
 801c050:	ee26 6a26 	vmul.f32	s12, s12, s13
 801c054:	eef2 6a05 	vmov.f32	s13, #37	@ 0x41280000  10.5
 801c058:	eee6 6a25 	vfma.f32	s13, s12, s11
 801c05c:	f7fe bd75 	b.w	801ab4a <iNemoEngine_API_Update+0x2e6a>
 801c060:	eddf 6a7e 	vldr	s13, [pc, #504]	@ 801c25c <iNemoEngine_API_Update+0x457c>
 801c064:	eef4 7ae6 	vcmpe.f32	s15, s13
 801c068:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c06c:	f57e ad06 	bpl.w	801aa7c <iNemoEngine_API_Update+0x2d9c>
 801c070:	eddf 6a73 	vldr	s13, [pc, #460]	@ 801c240 <iNemoEngine_API_Update+0x4560>
 801c074:	eef4 7ae6 	vcmpe.f32	s15, s13
 801c078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c07c:	da9c      	bge.n	801bfb8 <iNemoEngine_API_Update+0x42d8>
 801c07e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801c082:	f7fe bd11 	b.w	801aaa8 <iNemoEngine_API_Update+0x2dc8>
 801c086:	2104      	movs	r1, #4
 801c088:	f04f 0e03 	mov.w	lr, #3
 801c08c:	2706      	movs	r7, #6
 801c08e:	f04f 0c07 	mov.w	ip, #7
 801c092:	4608      	mov	r0, r1
 801c094:	2301      	movs	r3, #1
 801c096:	2600      	movs	r6, #0
 801c098:	f7ff bbfa 	b.w	801b890 <iNemoEngine_API_Update+0x3bb0>
 801c09c:	eddf 3a70 	vldr	s7, [pc, #448]	@ 801c260 <iNemoEngine_API_Update+0x4580>
 801c0a0:	ed9f 5a70 	vldr	s10, [pc, #448]	@ 801c264 <iNemoEngine_API_Update+0x4584>
 801c0a4:	ac43      	add	r4, sp, #268	@ 0x10c
 801c0a6:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
 801c0aa:	edd0 7a7c 	vldr	s15, [r0, #496]	@ 0x1f0
 801c0ae:	f5a0 73ae 	sub.w	r3, r0, #348	@ 0x15c
 801c0b2:	3101      	adds	r1, #1
 801c0b4:	eeb0 7a67 	vmov.f32	s14, s15
 801c0b8:	461a      	mov	r2, r3
 801c0ba:	edd2 5ad6 	vldr	s11, [r2, #856]	@ 0x358
 801c0be:	320c      	adds	r2, #12
 801c0c0:	4290      	cmp	r0, r2
 801c0c2:	ee37 7a25 	vadd.f32	s14, s14, s11
 801c0c6:	d1f8      	bne.n	801c0ba <iNemoEngine_API_Update+0x43da>
 801c0c8:	ee27 7a23 	vmul.f32	s14, s14, s7
 801c0cc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801c0d0:	ee67 7aa7 	vmul.f32	s15, s15, s15
 801c0d4:	edd3 5ad6 	vldr	s11, [r3, #856]	@ 0x358
 801c0d8:	330c      	adds	r3, #12
 801c0da:	ee75 5ac7 	vsub.f32	s11, s11, s14
 801c0de:	4298      	cmp	r0, r3
 801c0e0:	eee5 7aa5 	vfma.f32	s15, s11, s11
 801c0e4:	d1f6      	bne.n	801c0d4 <iNemoEngine_API_Update+0x43f4>
 801c0e6:	ee67 7a85 	vmul.f32	s15, s15, s10
 801c0ea:	2902      	cmp	r1, #2
 801c0ec:	f100 0004 	add.w	r0, r0, #4
 801c0f0:	ece4 7a01 	vstmia	r4!, {s15}
 801c0f4:	d1d9      	bne.n	801c0aa <iNemoEngine_API_Update+0x43ca>
 801c0f6:	eddd 5a43 	vldr	s11, [sp, #268]	@ 0x10c
 801c0fa:	eddd 7a44 	vldr	s15, [sp, #272]	@ 0x110
 801c0fe:	ed9d 7a45 	vldr	s14, [sp, #276]	@ 0x114
 801c102:	eeb1 3ae5 	vsqrt.f32	s6, s11
 801c106:	eef1 3ae7 	vsqrt.f32	s7, s15
 801c10a:	eeb1 5ac7 	vsqrt.f32	s10, s14
 801c10e:	ee77 7aa5 	vadd.f32	s15, s15, s11
 801c112:	eef3 5a00 	vmov.f32	s11, #48	@ 0x41800000  16.0
 801c116:	ee77 7a87 	vadd.f32	s15, s15, s14
 801c11a:	ed8d 3a43 	vstr	s6, [sp, #268]	@ 0x10c
 801c11e:	eef4 7ae5 	vcmpe.f32	s15, s11
 801c122:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c126:	edcd 3a44 	vstr	s7, [sp, #272]	@ 0x110
 801c12a:	ed8d 5a45 	vstr	s10, [sp, #276]	@ 0x114
 801c12e:	f57e abd4 	bpl.w	801a8da <iNemoEngine_API_Update+0x2bfa>
 801c132:	9906      	ldr	r1, [sp, #24]
 801c134:	ed8d 4a95 	vstr	s8, [sp, #596]	@ 0x254
 801c138:	2200      	movs	r2, #0
 801c13a:	edcd 4a96 	vstr	s9, [sp, #600]	@ 0x258
 801c13e:	ed8d 6a97 	vstr	s12, [sp, #604]	@ 0x25c
 801c142:	464b      	mov	r3, r9
 801c144:	704a      	strb	r2, [r1, #1]
 801c146:	f7fd bf22 	b.w	8019f8e <iNemoEngine_API_Update+0x22ae>
 801c14a:	2208      	movs	r2, #8
 801c14c:	9203      	str	r2, [sp, #12]
 801c14e:	2205      	movs	r2, #5
 801c150:	920e      	str	r2, [sp, #56]	@ 0x38
 801c152:	2202      	movs	r2, #2
 801c154:	f7ff bbb3 	b.w	801b8be <iNemoEngine_API_Update+0x3bde>
 801c158:	2301      	movs	r3, #1
 801c15a:	f7fd bf04 	b.w	8019f66 <iNemoEngine_API_Update+0x2286>
 801c15e:	f8b3 31a6 	ldrh.w	r3, [r3, #422]	@ 0x1a6
 801c162:	2b27      	cmp	r3, #39	@ 0x27
 801c164:	d838      	bhi.n	801c1d8 <iNemoEngine_API_Update+0x44f8>
 801c166:	ed8d 4a95 	vstr	s8, [sp, #596]	@ 0x254
 801c16a:	edcd 4a96 	vstr	s9, [sp, #600]	@ 0x258
 801c16e:	ed8d 6a97 	vstr	s12, [sp, #604]	@ 0x25c
 801c172:	9906      	ldr	r1, [sp, #24]
 801c174:	f8b1 31a8 	ldrh.w	r3, [r1, #424]	@ 0x1a8
 801c178:	3301      	adds	r3, #1
 801c17a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 801c17e:	bf14      	ite	ne
 801c180:	b29b      	uxthne	r3, r3
 801c182:	f64f 73ff 	movweq	r3, #65535	@ 0xffff
 801c186:	2201      	movs	r2, #1
 801c188:	f8a1 31a8 	strh.w	r3, [r1, #424]	@ 0x1a8
 801c18c:	f881 21a3 	strb.w	r2, [r1, #419]	@ 0x1a3
 801c190:	464b      	mov	r3, r9
 801c192:	f7fd befc 	b.w	8019f8e <iNemoEngine_API_Update+0x22ae>
 801c196:	9906      	ldr	r1, [sp, #24]
 801c198:	f88d 20f0 	strb.w	r2, [sp, #240]	@ 0xf0
 801c19c:	f891 31a3 	ldrb.w	r3, [r1, #419]	@ 0x1a3
 801c1a0:	ed8d ea95 	vstr	s28, [sp, #596]	@ 0x254
 801c1a4:	3301      	adds	r3, #1
 801c1a6:	f881 31a3 	strb.w	r3, [r1, #419]	@ 0x1a3
 801c1aa:	784b      	ldrb	r3, [r1, #1]
 801c1ac:	edcd ea96 	vstr	s29, [sp, #600]	@ 0x258
 801c1b0:	f240 1201 	movw	r2, #257	@ 0x101
 801c1b4:	edcd ba97 	vstr	s23, [sp, #604]	@ 0x25c
 801c1b8:	f8ad 20ee 	strh.w	r2, [sp, #238]	@ 0xee
 801c1bc:	b13b      	cbz	r3, 801c1ce <iNemoEngine_API_Update+0x44ee>
 801c1be:	2300      	movs	r3, #0
 801c1c0:	ed81 ea6f 	vstr	s28, [r1, #444]	@ 0x1bc
 801c1c4:	edc1 ea70 	vstr	s29, [r1, #448]	@ 0x1c0
 801c1c8:	edc1 ba71 	vstr	s23, [r1, #452]	@ 0x1c4
 801c1cc:	704b      	strb	r3, [r1, #1]
 801c1ce:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 801c1d2:	2301      	movs	r3, #1
 801c1d4:	f7fd bedb 	b.w	8019f8e <iNemoEngine_API_Update+0x22ae>
 801c1d8:	ed8d ea95 	vstr	s28, [sp, #596]	@ 0x254
 801c1dc:	edcd ea96 	vstr	s29, [sp, #600]	@ 0x258
 801c1e0:	edcd ba97 	vstr	s23, [sp, #604]	@ 0x25c
 801c1e4:	e7c5      	b.n	801c172 <iNemoEngine_API_Update+0x4492>
 801c1e6:	eef0 7a47 	vmov.f32	s15, s14
 801c1ea:	e5bf      	b.n	801bd6c <iNemoEngine_API_Update+0x408c>
 801c1ec:	eef0 7a47 	vmov.f32	s15, s14
 801c1f0:	f7fd b86f 	b.w	80192d2 <iNemoEngine_API_Update+0x15f2>
 801c1f4:	eef0 7a47 	vmov.f32	s15, s14
 801c1f8:	e563      	b.n	801bcc2 <iNemoEngine_API_Update+0x3fe2>
 801c1fa:	eef0 7a47 	vmov.f32	s15, s14
 801c1fe:	f7fd b846 	b.w	801928e <iNemoEngine_API_Update+0x15ae>
 801c202:	eef0 7a47 	vmov.f32	s15, s14
 801c206:	f7fe b96c 	b.w	801a4e2 <iNemoEngine_API_Update+0x2802>
 801c20a:	eef0 7a47 	vmov.f32	s15, s14
 801c20e:	e4f2      	b.n	801bbf6 <iNemoEngine_API_Update+0x3f16>
 801c210:	eef0 7a47 	vmov.f32	s15, s14
 801c214:	e533      	b.n	801bc7e <iNemoEngine_API_Update+0x3f9e>
 801c216:	eef0 7a47 	vmov.f32	s15, s14
 801c21a:	f7fe b9a6 	b.w	801a56a <iNemoEngine_API_Update+0x288a>
 801c21e:	f503 63f3 	add.w	r3, r3, #1944	@ 0x798
 801c222:	9315      	str	r3, [sp, #84]	@ 0x54
 801c224:	f7fc b886 	b.w	8018334 <iNemoEngine_API_Update+0x654>
 801c228:	f505 6597 	add.w	r5, r5, #1208	@ 0x4b8
 801c22c:	f7fe be2c 	b.w	801ae88 <iNemoEngine_API_Update+0x31a8>
 801c230:	40a00000 	.word	0x40a00000
 801c234:	3e999998 	.word	0x3e999998
 801c238:	3f99999a 	.word	0x3f99999a
 801c23c:	3cf5c28f 	.word	0x3cf5c28f
 801c240:	3c75c28f 	.word	0x3c75c28f
 801c244:	42855556 	.word	0x42855556
 801c248:	3f866666 	.word	0x3f866666
 801c24c:	3d4ccccd 	.word	0x3d4ccccd
 801c250:	3dcccccd 	.word	0x3dcccccd
 801c254:	42200000 	.word	0x42200000
 801c258:	40555555 	.word	0x40555555
 801c25c:	3c23d70a 	.word	0x3c23d70a
 801c260:	3d088889 	.word	0x3d088889
 801c264:	3d0d3dcb 	.word	0x3d0d3dcb
 801c268:	3dccccd0 	.word	0x3dccccd0
 801c26c:	3f8ccccd 	.word	0x3f8ccccd
 801c270:	3e4ccccd 	.word	0x3e4ccccd
 801c274:	00000000 	.word	0x00000000
 801c278:	eef0 7a47 	vmov.f32	s15, s14
 801c27c:	f7fe b997 	b.w	801a5ae <iNemoEngine_API_Update+0x28ce>
 801c280:	eef0 7a47 	vmov.f32	s15, s14
 801c284:	f7fe b94f 	b.w	801a526 <iNemoEngine_API_Update+0x2846>
 801c288:	eef0 7a47 	vmov.f32	s15, s14
 801c28c:	e4d5      	b.n	801bc3a <iNemoEngine_API_Update+0x3f5a>
 801c28e:	eef0 7a47 	vmov.f32	s15, s14
 801c292:	f7fd b884 	b.w	801939e <iNemoEngine_API_Update+0x16be>
 801c296:	eef0 7a47 	vmov.f32	s15, s14
 801c29a:	e5cd      	b.n	801be38 <iNemoEngine_API_Update+0x4158>
 801c29c:	eef0 7a47 	vmov.f32	s15, s14
 801c2a0:	e586      	b.n	801bdb0 <iNemoEngine_API_Update+0x40d0>
 801c2a2:	eef0 7a47 	vmov.f32	s15, s14
 801c2a6:	f7fd b836 	b.w	8019316 <iNemoEngine_API_Update+0x1636>
 801c2aa:	eef0 7a47 	vmov.f32	s15, s14
 801c2ae:	f7fd b854 	b.w	801935a <iNemoEngine_API_Update+0x167a>
 801c2b2:	eef0 7a47 	vmov.f32	s15, s14
 801c2b6:	e59d      	b.n	801bdf4 <iNemoEngine_API_Update+0x4114>
 801c2b8:	eef0 7a47 	vmov.f32	s15, s14
 801c2bc:	f7fe b8ef 	b.w	801a49e <iNemoEngine_API_Update+0x27be>
 801c2c0:	9906      	ldr	r1, [sp, #24]
 801c2c2:	f04f 537e 	mov.w	r3, #1065353216	@ 0x3f800000
 801c2c6:	f8c1 324c 	str.w	r3, [r1, #588]	@ 0x24c
 801c2ca:	f8c1 3274 	str.w	r3, [r1, #628]	@ 0x274
 801c2ce:	f8c1 329c 	str.w	r3, [r1, #668]	@ 0x29c
 801c2d2:	f7fe ba9a 	b.w	801a80a <iNemoEngine_API_Update+0x2b2a>
 801c2d6:	9906      	ldr	r1, [sp, #24]
 801c2d8:	f8b1 31a6 	ldrh.w	r3, [r1, #422]	@ 0x1a6
 801c2dc:	3301      	adds	r3, #1
 801c2de:	f8a1 31a6 	strh.w	r3, [r1, #422]	@ 0x1a6
 801c2e2:	eef6 8a00 	vmov.f32	s17, #96	@ 0x3f000000  0.5
 801c2e6:	460b      	mov	r3, r1
 801c2e8:	f7ff ba49 	b.w	801b77e <iNemoEngine_API_Update+0x3a9e>
 801c2ec:	2a00      	cmp	r2, #0
 801c2ee:	f73d afa4 	bgt.w	801a23a <iNemoEngine_API_Update+0x255a>
 801c2f2:	eddd 5a83 	vldr	s11, [sp, #524]	@ 0x20c
 801c2f6:	ed9d 7a84 	vldr	s14, [sp, #528]	@ 0x210
 801c2fa:	eddd 7a85 	vldr	s15, [sp, #532]	@ 0x214
 801c2fe:	eeb1 6a00 	vmov.f32	s12, #16	@ 0x40800000  4.0
 801c302:	ee65 5a86 	vmul.f32	s11, s11, s12
 801c306:	ee27 7a06 	vmul.f32	s14, s14, s12
 801c30a:	ee67 7a86 	vmul.f32	s15, s15, s12
 801c30e:	edcd 5a83 	vstr	s11, [sp, #524]	@ 0x20c
 801c312:	ed8d 7a84 	vstr	s14, [sp, #528]	@ 0x210
 801c316:	edcd 7a85 	vstr	s15, [sp, #532]	@ 0x214
 801c31a:	f7fd bb24 	b.w	8019966 <iNemoEngine_API_Update+0x1c86>
 801c31e:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
 801c322:	eeb4 7ac6 	vcmpe.f32	s14, s12
 801c326:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c32a:	f57f ae11 	bpl.w	801bf50 <iNemoEngine_API_Update+0x4270>
 801c32e:	ed1f 6a32 	vldr	s12, [pc, #-200]	@ 801c268 <iNemoEngine_API_Update+0x4588>
 801c332:	ed5f 8a32 	vldr	s17, [pc, #-200]	@ 801c26c <iNemoEngine_API_Update+0x458c>
 801c336:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c33a:	ee67 7a86 	vmul.f32	s15, s15, s12
 801c33e:	eeb0 6a00 	vmov.f32	s12, #0	@ 0x40000000  2.0
 801c342:	eee7 8a86 	vfma.f32	s17, s15, s12
 801c346:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 801c34a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c34e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c352:	f6ff ae0f 	blt.w	801bf74 <iNemoEngine_API_Update+0x4294>
 801c356:	eef0 7a08 	vmov.f32	s15, #8	@ 0x40400000  3.0
 801c35a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c35e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c362:	f57f ae0f 	bpl.w	801bf84 <iNemoEngine_API_Update+0x42a4>
 801c366:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 801c36a:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c36e:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 801c372:	eef7 8a08 	vmov.f32	s17, #120	@ 0x3fc00000  1.5
 801c376:	eee7 8a86 	vfma.f32	s17, s15, s12
 801c37a:	eef1 7a04 	vmov.f32	s15, #20	@ 0x40a00000  5.0
 801c37e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801c382:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c386:	f6ff ae0f 	blt.w	801bfa8 <iNemoEngine_API_Update+0x42c8>
 801c38a:	eef1 7a04 	vmov.f32	s15, #20	@ 0x40a00000  5.0
 801c38e:	ee77 7a67 	vsub.f32	s15, s14, s15
 801c392:	ed1f 7a49 	vldr	s14, [pc, #-292]	@ 801c270 <iNemoEngine_API_Update+0x4590>
 801c396:	ee77 7aa7 	vadd.f32	s15, s15, s15
 801c39a:	eef0 8a08 	vmov.f32	s17, #8	@ 0x40400000  3.0
 801c39e:	eee7 8a87 	vfma.f32	s17, s15, s14
 801c3a2:	e601      	b.n	801bfa8 <iNemoEngine_API_Update+0x42c8>
 801c3a4:	eef1 8a04 	vmov.f32	s17, #20	@ 0x40a00000  5.0
 801c3a8:	e5fe      	b.n	801bfa8 <iNemoEngine_API_Update+0x42c8>
 801c3aa:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 801c3ae:	e5fb      	b.n	801bfa8 <iNemoEngine_API_Update+0x42c8>
 801c3b0:	ed1f 8a50 	vldr	s16, [pc, #-320]	@ 801c274 <iNemoEngine_API_Update+0x4594>
 801c3b4:	f7fb bdeb 	b.w	8017f8e <iNemoEngine_API_Update+0x2ae>

0801c3b8 <MotionFX_GetStateSize>:
 801c3b8:	f44f 6018 	mov.w	r0, #2432	@ 0x980
 801c3bc:	4770      	bx	lr
 801c3be:	bf00      	nop

0801c3c0 <MotionFX_initialize>:
 801c3c0:	4a4c      	ldr	r2, [pc, #304]	@ (801c4f4 <MotionFX_initialize+0x134>)
 801c3c2:	6813      	ldr	r3, [r2, #0]
 801c3c4:	f04f 2ce0 	mov.w	ip, #3758153728	@ 0xe000e000
 801c3c8:	f023 0301 	bic.w	r3, r3, #1
 801c3cc:	b530      	push	{r4, r5, lr}
 801c3ce:	6013      	str	r3, [r2, #0]
 801c3d0:	f8dc 3d00 	ldr.w	r3, [ip, #3328]	@ 0xd00
 801c3d4:	f64f 71f0 	movw	r1, #65520	@ 0xfff0
 801c3d8:	400b      	ands	r3, r1
 801c3da:	f24c 2240 	movw	r2, #49728	@ 0xc240
 801c3de:	4293      	cmp	r3, r2
 801c3e0:	b085      	sub	sp, #20
 801c3e2:	4604      	mov	r4, r0
 801c3e4:	d013      	beq.n	801c40e <MotionFX_initialize+0x4e>
 801c3e6:	f8dc 3d00 	ldr.w	r3, [ip, #3328]	@ 0xd00
 801c3ea:	f24c 2270 	movw	r2, #49776	@ 0xc270
 801c3ee:	4019      	ands	r1, r3
 801c3f0:	4291      	cmp	r1, r2
 801c3f2:	d00c      	beq.n	801c40e <MotionFX_initialize+0x4e>
 801c3f4:	4a40      	ldr	r2, [pc, #256]	@ (801c4f8 <MotionFX_initialize+0x138>)
 801c3f6:	2301      	movs	r3, #1
 801c3f8:	6093      	str	r3, [r2, #8]
 801c3fa:	6893      	ldr	r3, [r2, #8]
 801c3fc:	2b00      	cmp	r3, #0
 801c3fe:	d1fc      	bne.n	801c3fa <MotionFX_initialize+0x3a>
 801c400:	4b3e      	ldr	r3, [pc, #248]	@ (801c4fc <MotionFX_initialize+0x13c>)
 801c402:	6013      	str	r3, [r2, #0]
 801c404:	6812      	ldr	r2, [r2, #0]
 801c406:	4b3e      	ldr	r3, [pc, #248]	@ (801c500 <MotionFX_initialize+0x140>)
 801c408:	429a      	cmp	r2, r3
 801c40a:	d02c      	beq.n	801c466 <MotionFX_initialize+0xa6>
 801c40c:	e7fe      	b.n	801c40c <MotionFX_initialize+0x4c>
 801c40e:	4b3d      	ldr	r3, [pc, #244]	@ (801c504 <MotionFX_initialize+0x144>)
 801c410:	681b      	ldr	r3, [r3, #0]
 801c412:	2b00      	cmp	r3, #0
 801c414:	d1ee      	bne.n	801c3f4 <MotionFX_initialize+0x34>
 801c416:	4a3c      	ldr	r2, [pc, #240]	@ (801c508 <MotionFX_initialize+0x148>)
 801c418:	6813      	ldr	r3, [r2, #0]
 801c41a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 801c41e:	f5b3 6f8a 	cmp.w	r3, #1104	@ 0x450
 801c422:	d056      	beq.n	801c4d2 <MotionFX_initialize+0x112>
 801c424:	6813      	ldr	r3, [r2, #0]
 801c426:	f240 4183 	movw	r1, #1155	@ 0x483
 801c42a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 801c42e:	428b      	cmp	r3, r1
 801c430:	d04f      	beq.n	801c4d2 <MotionFX_initialize+0x112>
 801c432:	6813      	ldr	r3, [r2, #0]
 801c434:	f240 4285 	movw	r2, #1157	@ 0x485
 801c438:	f3c3 030b 	ubfx	r3, r3, #0, #12
 801c43c:	4293      	cmp	r3, r2
 801c43e:	d048      	beq.n	801c4d2 <MotionFX_initialize+0x112>
 801c440:	4b32      	ldr	r3, [pc, #200]	@ (801c50c <MotionFX_initialize+0x14c>)
 801c442:	681b      	ldr	r3, [r3, #0]
 801c444:	f3c3 030b 	ubfx	r3, r3, #0, #12
 801c448:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
 801c44c:	d1d2      	bne.n	801c3f4 <MotionFX_initialize+0x34>
 801c44e:	4a30      	ldr	r2, [pc, #192]	@ (801c510 <MotionFX_initialize+0x150>)
 801c450:	2301      	movs	r3, #1
 801c452:	6093      	str	r3, [r2, #8]
 801c454:	6893      	ldr	r3, [r2, #8]
 801c456:	2b00      	cmp	r3, #0
 801c458:	d1fc      	bne.n	801c454 <MotionFX_initialize+0x94>
 801c45a:	4b28      	ldr	r3, [pc, #160]	@ (801c4fc <MotionFX_initialize+0x13c>)
 801c45c:	6013      	str	r3, [r2, #0]
 801c45e:	6812      	ldr	r2, [r2, #0]
 801c460:	4b27      	ldr	r3, [pc, #156]	@ (801c500 <MotionFX_initialize+0x140>)
 801c462:	429a      	cmp	r2, r3
 801c464:	d1d2      	bne.n	801c40c <MotionFX_initialize+0x4c>
 801c466:	4b2b      	ldr	r3, [pc, #172]	@ (801c514 <MotionFX_initialize+0x154>)
 801c468:	4a2b      	ldr	r2, [pc, #172]	@ (801c518 <MotionFX_initialize+0x158>)
 801c46a:	9303      	str	r3, [sp, #12]
 801c46c:	2501      	movs	r5, #1
 801c46e:	4620      	mov	r0, r4
 801c470:	e9cd 3301 	strd	r3, r3, [sp, #4]
 801c474:	f882 53c4 	strb.w	r5, [r2, #964]	@ 0x3c4
 801c478:	f7fb f942 	bl	8017700 <MFX_emptyAttitude>
 801c47c:	a901      	add	r1, sp, #4
 801c47e:	f104 003a 	add.w	r0, r4, #58	@ 0x3a
 801c482:	f884 5039 	strb.w	r5, [r4, #57]	@ 0x39
 801c486:	f7f9 feff 	bl	8016288 <updateOrientation>
 801c48a:	a903      	add	r1, sp, #12
 801c48c:	f104 0043 	add.w	r0, r4, #67	@ 0x43
 801c490:	f7f9 fefa 	bl	8016288 <updateOrientation>
 801c494:	a902      	add	r1, sp, #8
 801c496:	f104 004c 	add.w	r0, r4, #76	@ 0x4c
 801c49a:	f7f9 fef5 	bl	8016288 <updateOrientation>
 801c49e:	4b1f      	ldr	r3, [pc, #124]	@ (801c51c <MotionFX_initialize+0x15c>)
 801c4a0:	491f      	ldr	r1, [pc, #124]	@ (801c520 <MotionFX_initialize+0x160>)
 801c4a2:	6363      	str	r3, [r4, #52]	@ 0x34
 801c4a4:	4b1f      	ldr	r3, [pc, #124]	@ (801c524 <MotionFX_initialize+0x164>)
 801c4a6:	4a20      	ldr	r2, [pc, #128]	@ (801c528 <MotionFX_initialize+0x168>)
 801c4a8:	62a1      	str	r1, [r4, #40]	@ 0x28
 801c4aa:	61e3      	str	r3, [r4, #28]
 801c4ac:	491f      	ldr	r1, [pc, #124]	@ (801c52c <MotionFX_initialize+0x16c>)
 801c4ae:	61a2      	str	r2, [r4, #24]
 801c4b0:	2300      	movs	r3, #0
 801c4b2:	f04f 507f 	mov.w	r0, #1069547520	@ 0x3fc00000
 801c4b6:	f44f 7281 	mov.w	r2, #258	@ 0x102
 801c4ba:	f884 3038 	strb.w	r3, [r4, #56]	@ 0x38
 801c4be:	f240 1301 	movw	r3, #257	@ 0x101
 801c4c2:	62e0      	str	r0, [r4, #44]	@ 0x2c
 801c4c4:	6221      	str	r1, [r4, #32]
 801c4c6:	80a2      	strh	r2, [r4, #4]
 801c4c8:	f8a4 300d 	strh.w	r3, [r4, #13]
 801c4cc:	73e5      	strb	r5, [r4, #15]
 801c4ce:	b005      	add	sp, #20
 801c4d0:	bd30      	pop	{r4, r5, pc}
 801c4d2:	4a17      	ldr	r2, [pc, #92]	@ (801c530 <MotionFX_initialize+0x170>)
 801c4d4:	2301      	movs	r3, #1
 801c4d6:	f8c2 3c08 	str.w	r3, [r2, #3080]	@ 0xc08
 801c4da:	f8d2 3c08 	ldr.w	r3, [r2, #3080]	@ 0xc08
 801c4de:	2b00      	cmp	r3, #0
 801c4e0:	d1fb      	bne.n	801c4da <MotionFX_initialize+0x11a>
 801c4e2:	4b06      	ldr	r3, [pc, #24]	@ (801c4fc <MotionFX_initialize+0x13c>)
 801c4e4:	f8c2 3c00 	str.w	r3, [r2, #3072]	@ 0xc00
 801c4e8:	f8d2 2c00 	ldr.w	r2, [r2, #3072]	@ 0xc00
 801c4ec:	4b04      	ldr	r3, [pc, #16]	@ (801c500 <MotionFX_initialize+0x140>)
 801c4ee:	429a      	cmp	r2, r3
 801c4f0:	d0b9      	beq.n	801c466 <MotionFX_initialize+0xa6>
 801c4f2:	e78b      	b.n	801c40c <MotionFX_initialize+0x4c>
 801c4f4:	e0002000 	.word	0xe0002000
 801c4f8:	40023000 	.word	0x40023000
 801c4fc:	f407a5c2 	.word	0xf407a5c2
 801c500:	b5e8b5cd 	.word	0xb5e8b5cd
 801c504:	e0042000 	.word	0xe0042000
 801c508:	5c001000 	.word	0x5c001000
 801c50c:	50081000 	.word	0x50081000
 801c510:	4c004000 	.word	0x4c004000
 801c514:	00756e65 	.word	0x00756e65
 801c518:	2000054c 	.word	0x2000054c
 801c51c:	3f2ac083 	.word	0x3f2ac083
 801c520:	3f666666 	.word	0x3f666666
 801c524:	3a378034 	.word	0x3a378034
 801c528:	3a51b717 	.word	0x3a51b717
 801c52c:	3b378034 	.word	0x3b378034
 801c530:	58024000 	.word	0x58024000

0801c534 <MotionFX_setKnobs>:
 801c534:	4b24      	ldr	r3, [pc, #144]	@ (801c5c8 <MotionFX_setKnobs+0x94>)
 801c536:	f893 23c4 	ldrb.w	r2, [r3, #964]	@ 0x3c4
 801c53a:	b902      	cbnz	r2, 801c53e <MotionFX_setKnobs+0xa>
 801c53c:	4770      	bx	lr
 801c53e:	460b      	mov	r3, r1
 801c540:	2900      	cmp	r1, #0
 801c542:	d0fb      	beq.n	801c53c <MotionFX_setKnobs+0x8>
 801c544:	b510      	push	{r4, lr}
 801c546:	4604      	mov	r4, r0
 801c548:	689a      	ldr	r2, [r3, #8]
 801c54a:	6808      	ldr	r0, [r1, #0]
 801c54c:	6849      	ldr	r1, [r1, #4]
 801c54e:	62e1      	str	r1, [r4, #44]	@ 0x2c
 801c550:	62a0      	str	r0, [r4, #40]	@ 0x28
 801c552:	6362      	str	r2, [r4, #52]	@ 0x34
 801c554:	7b1a      	ldrb	r2, [r3, #12]
 801c556:	7162      	strb	r2, [r4, #5]
 801c558:	6918      	ldr	r0, [r3, #16]
 801c55a:	6959      	ldr	r1, [r3, #20]
 801c55c:	699a      	ldr	r2, [r3, #24]
 801c55e:	6222      	str	r2, [r4, #32]
 801c560:	61a0      	str	r0, [r4, #24]
 801c562:	61e1      	str	r1, [r4, #28]
 801c564:	7f1a      	ldrb	r2, [r3, #28]
 801c566:	7122      	strb	r2, [r4, #4]
 801c568:	f893 2029 	ldrb.w	r2, [r3, #41]	@ 0x29
 801c56c:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
 801c570:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801c572:	f884 2978 	strb.w	r2, [r4, #2424]	@ 0x978
 801c576:	b084      	sub	sp, #16
 801c578:	f8b3 101d 	ldrh.w	r1, [r3, #29]
 801c57c:	7fda      	ldrb	r2, [r3, #31]
 801c57e:	f88d 2006 	strb.w	r2, [sp, #6]
 801c582:	f8ad 1004 	strh.w	r1, [sp, #4]
 801c586:	f8b3 2021 	ldrh.w	r2, [r3, #33]	@ 0x21
 801c58a:	f8ad 2008 	strh.w	r2, [sp, #8]
 801c58e:	f893 2023 	ldrb.w	r2, [r3, #35]	@ 0x23
 801c592:	f88d 200a 	strb.w	r2, [sp, #10]
 801c596:	f8b3 2025 	ldrh.w	r2, [r3, #37]	@ 0x25
 801c59a:	f8ad 200c 	strh.w	r2, [sp, #12]
 801c59e:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
 801c5a2:	f88d 300e 	strb.w	r3, [sp, #14]
 801c5a6:	a901      	add	r1, sp, #4
 801c5a8:	f104 003a 	add.w	r0, r4, #58	@ 0x3a
 801c5ac:	f7f9 fe6c 	bl	8016288 <updateOrientation>
 801c5b0:	a903      	add	r1, sp, #12
 801c5b2:	f104 0043 	add.w	r0, r4, #67	@ 0x43
 801c5b6:	f7f9 fe67 	bl	8016288 <updateOrientation>
 801c5ba:	a902      	add	r1, sp, #8
 801c5bc:	f104 004c 	add.w	r0, r4, #76	@ 0x4c
 801c5c0:	f7f9 fe62 	bl	8016288 <updateOrientation>
 801c5c4:	b004      	add	sp, #16
 801c5c6:	bd10      	pop	{r4, pc}
 801c5c8:	2000054c 	.word	0x2000054c

0801c5cc <MotionFX_getKnobs>:
 801c5cc:	4b1d      	ldr	r3, [pc, #116]	@ (801c644 <MotionFX_getKnobs+0x78>)
 801c5ce:	f893 33c4 	ldrb.w	r3, [r3, #964]	@ 0x3c4
 801c5d2:	b903      	cbnz	r3, 801c5d6 <MotionFX_getKnobs+0xa>
 801c5d4:	4770      	bx	lr
 801c5d6:	460a      	mov	r2, r1
 801c5d8:	2900      	cmp	r1, #0
 801c5da:	d0fb      	beq.n	801c5d4 <MotionFX_getKnobs+0x8>
 801c5dc:	b510      	push	{r4, lr}
 801c5de:	4604      	mov	r4, r0
 801c5e0:	6a80      	ldr	r0, [r0, #40]	@ 0x28
 801c5e2:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 801c5e4:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 801c5e6:	6093      	str	r3, [r2, #8]
 801c5e8:	6010      	str	r0, [r2, #0]
 801c5ea:	6051      	str	r1, [r2, #4]
 801c5ec:	7963      	ldrb	r3, [r4, #5]
 801c5ee:	7313      	strb	r3, [r2, #12]
 801c5f0:	69a0      	ldr	r0, [r4, #24]
 801c5f2:	69e1      	ldr	r1, [r4, #28]
 801c5f4:	6a23      	ldr	r3, [r4, #32]
 801c5f6:	6193      	str	r3, [r2, #24]
 801c5f8:	6110      	str	r0, [r2, #16]
 801c5fa:	6151      	str	r1, [r2, #20]
 801c5fc:	7923      	ldrb	r3, [r4, #4]
 801c5fe:	7713      	strb	r3, [r2, #28]
 801c600:	f894 3038 	ldrb.w	r3, [r4, #56]	@ 0x38
 801c604:	f882 3029 	strb.w	r3, [r2, #41]	@ 0x29
 801c608:	f894 3978 	ldrb.w	r3, [r4, #2424]	@ 0x978
 801c60c:	62d3      	str	r3, [r2, #44]	@ 0x2c
 801c60e:	f102 011d 	add.w	r1, r2, #29
 801c612:	f104 003a 	add.w	r0, r4, #58	@ 0x3a
 801c616:	f7f9 fc8f 	bl	8015f38 <findAxis>
 801c61a:	f102 0121 	add.w	r1, r2, #33	@ 0x21
 801c61e:	f104 004c 	add.w	r0, r4, #76	@ 0x4c
 801c622:	f7f9 fc89 	bl	8015f38 <findAxis>
 801c626:	f102 0125 	add.w	r1, r2, #37	@ 0x25
 801c62a:	f104 0043 	add.w	r0, r4, #67	@ 0x43
 801c62e:	f7f9 fc83 	bl	8015f38 <findAxis>
 801c632:	2300      	movs	r3, #0
 801c634:	f882 3020 	strb.w	r3, [r2, #32]
 801c638:	f882 3024 	strb.w	r3, [r2, #36]	@ 0x24
 801c63c:	f882 3028 	strb.w	r3, [r2, #40]	@ 0x28
 801c640:	bd10      	pop	{r4, pc}
 801c642:	bf00      	nop
 801c644:	2000054c 	.word	0x2000054c

0801c648 <MotionFX_enable_6X>:
 801c648:	4b0e      	ldr	r3, [pc, #56]	@ (801c684 <MotionFX_enable_6X+0x3c>)
 801c64a:	f893 33c4 	ldrb.w	r3, [r3, #964]	@ 0x3c4
 801c64e:	b903      	cbnz	r3, 801c652 <MotionFX_enable_6X+0xa>
 801c650:	4770      	bx	lr
 801c652:	2900      	cmp	r1, #0
 801c654:	d0fc      	beq.n	801c650 <MotionFX_enable_6X+0x8>
 801c656:	b530      	push	{r4, r5, lr}
 801c658:	1d05      	adds	r5, r0, #4
 801c65a:	b099      	sub	sp, #100	@ 0x64
 801c65c:	4604      	mov	r4, r0
 801c65e:	4629      	mov	r1, r5
 801c660:	225c      	movs	r2, #92	@ 0x5c
 801c662:	a801      	add	r0, sp, #4
 801c664:	f001 f86f 	bl	801d746 <memcpy>
 801c668:	4620      	mov	r0, r4
 801c66a:	f7fb f849 	bl	8017700 <MFX_emptyAttitude>
 801c66e:	225c      	movs	r2, #92	@ 0x5c
 801c670:	a901      	add	r1, sp, #4
 801c672:	4628      	mov	r0, r5
 801c674:	f001 f867 	bl	801d746 <memcpy>
 801c678:	2300      	movs	r3, #0
 801c67a:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
 801c67e:	7363      	strb	r3, [r4, #13]
 801c680:	b019      	add	sp, #100	@ 0x64
 801c682:	bd30      	pop	{r4, r5, pc}
 801c684:	2000054c 	.word	0x2000054c

0801c688 <MotionFX_enable_9X>:
 801c688:	4b0e      	ldr	r3, [pc, #56]	@ (801c6c4 <MotionFX_enable_9X+0x3c>)
 801c68a:	f893 33c4 	ldrb.w	r3, [r3, #964]	@ 0x3c4
 801c68e:	b903      	cbnz	r3, 801c692 <MotionFX_enable_9X+0xa>
 801c690:	4770      	bx	lr
 801c692:	2900      	cmp	r1, #0
 801c694:	d0fc      	beq.n	801c690 <MotionFX_enable_9X+0x8>
 801c696:	b530      	push	{r4, r5, lr}
 801c698:	1d05      	adds	r5, r0, #4
 801c69a:	b099      	sub	sp, #100	@ 0x64
 801c69c:	4604      	mov	r4, r0
 801c69e:	4629      	mov	r1, r5
 801c6a0:	225c      	movs	r2, #92	@ 0x5c
 801c6a2:	a801      	add	r0, sp, #4
 801c6a4:	f001 f84f 	bl	801d746 <memcpy>
 801c6a8:	4620      	mov	r0, r4
 801c6aa:	f7fb f829 	bl	8017700 <MFX_emptyAttitude>
 801c6ae:	225c      	movs	r2, #92	@ 0x5c
 801c6b0:	a901      	add	r1, sp, #4
 801c6b2:	4628      	mov	r0, r5
 801c6b4:	f001 f847 	bl	801d746 <memcpy>
 801c6b8:	2301      	movs	r3, #1
 801c6ba:	f884 3039 	strb.w	r3, [r4, #57]	@ 0x39
 801c6be:	7363      	strb	r3, [r4, #13]
 801c6c0:	b019      	add	sp, #100	@ 0x64
 801c6c2:	bd30      	pop	{r4, r5, pc}
 801c6c4:	2000054c 	.word	0x2000054c

0801c6c8 <MotionFX_update>:
 801c6c8:	b430      	push	{r4, r5}
 801c6ca:	4c06      	ldr	r4, [pc, #24]	@ (801c6e4 <MotionFX_update+0x1c>)
 801c6cc:	9d02      	ldr	r5, [sp, #8]
 801c6ce:	f894 43c4 	ldrb.w	r4, [r4, #964]	@ 0x3c4
 801c6d2:	b90c      	cbnz	r4, 801c6d8 <MotionFX_update+0x10>
 801c6d4:	bc30      	pop	{r4, r5}
 801c6d6:	4770      	bx	lr
 801c6d8:	ed93 0a00 	vldr	s0, [r3]
 801c6dc:	462b      	mov	r3, r5
 801c6de:	bc30      	pop	{r4, r5}
 801c6e0:	f7fb bafe 	b.w	8017ce0 <iNemoEngine_API_Update>
 801c6e4:	2000054c 	.word	0x2000054c

0801c6e8 <MotionFX_propagate>:
 801c6e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801c6ec:	ed2d 8b06 	vpush	{d8-d10}
 801c6f0:	4ca2      	ldr	r4, [pc, #648]	@ (801c97c <MotionFX_propagate+0x294>)
 801c6f2:	f894 63c4 	ldrb.w	r6, [r4, #964]	@ 0x3c4
 801c6f6:	b0a1      	sub	sp, #132	@ 0x84
 801c6f8:	b926      	cbnz	r6, 801c704 <MotionFX_propagate+0x1c>
 801c6fa:	b021      	add	sp, #132	@ 0x84
 801c6fc:	ecbd 8b06 	vpop	{d8-d10}
 801c700:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801c704:	4694      	mov	ip, r2
 801c706:	4604      	mov	r4, r0
 801c708:	460d      	mov	r5, r1
 801c70a:	68d0      	ldr	r0, [r2, #12]
 801c70c:	6911      	ldr	r1, [r2, #16]
 801c70e:	6952      	ldr	r2, [r2, #20]
 801c710:	edd3 9a00 	vldr	s19, [r3]
 801c714:	ab13      	add	r3, sp, #76	@ 0x4c
 801c716:	c307      	stmia	r3!, {r0, r1, r2}
 801c718:	f8dc 0000 	ldr.w	r0, [ip]
 801c71c:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801c720:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801c724:	ab10      	add	r3, sp, #64	@ 0x40
 801c726:	c307      	stmia	r3!, {r0, r1, r2}
 801c728:	f8dc 0018 	ldr.w	r0, [ip, #24]
 801c72c:	f8dc 101c 	ldr.w	r1, [ip, #28]
 801c730:	f8dc 2020 	ldr.w	r2, [ip, #32]
 801c734:	ab16      	add	r3, sp, #88	@ 0x58
 801c736:	f104 073a 	add.w	r7, r4, #58	@ 0x3a
 801c73a:	c307      	stmia	r3!, {r0, r1, r2}
 801c73c:	4639      	mov	r1, r7
 801c73e:	a803      	add	r0, sp, #12
 801c740:	aa13      	add	r2, sp, #76	@ 0x4c
 801c742:	f7f9 fb97 	bl	8015e74 <rotVect>
 801c746:	aa16      	add	r2, sp, #88	@ 0x58
 801c748:	f104 014c 	add.w	r1, r4, #76	@ 0x4c
 801c74c:	a806      	add	r0, sp, #24
 801c74e:	f7f9 fb91 	bl	8015e74 <rotVect>
 801c752:	f8d4 394c 	ldr.w	r3, [r4, #2380]	@ 0x94c
 801c756:	2b09      	cmp	r3, #9
 801c758:	d829      	bhi.n	801c7ae <MotionFX_propagate+0xc6>
 801c75a:	eddd 8a04 	vldr	s17, [sp, #16]
 801c75e:	ed9d 9a03 	vldr	s18, [sp, #12]
 801c762:	ed9d 8a05 	vldr	s16, [sp, #20]
 801c766:	ee68 7aa8 	vmul.f32	s15, s17, s17
 801c76a:	eee9 7a09 	vfma.f32	s15, s18, s18
 801c76e:	eee8 7a08 	vfma.f32	s15, s16, s16
 801c772:	ee17 0a90 	vmov	r0, s15
 801c776:	f7e3 feef 	bl	8000558 <__aeabi_f2d>
 801c77a:	ec41 0b10 	vmov	d0, r0, r1
 801c77e:	f002 ff5f 	bl	801f640 <sqrt>
 801c782:	ec51 0b10 	vmov	r0, r1, d0
 801c786:	f7e4 fa37 	bl	8000bf8 <__aeabi_d2f>
 801c78a:	ee07 0a90 	vmov	s15, r0
 801c78e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801c792:	eec7 7a27 	vdiv.f32	s15, s14, s15
 801c796:	ee29 9a27 	vmul.f32	s18, s18, s15
 801c79a:	ee68 8aa7 	vmul.f32	s17, s17, s15
 801c79e:	ee28 8a27 	vmul.f32	s16, s16, s15
 801c7a2:	ed8d 9a03 	vstr	s18, [sp, #12]
 801c7a6:	edcd 8a04 	vstr	s17, [sp, #16]
 801c7aa:	ed8d 8a05 	vstr	s16, [sp, #20]
 801c7ae:	7923      	ldrb	r3, [r4, #4]
 801c7b0:	2b00      	cmp	r3, #0
 801c7b2:	f000 80ce 	beq.w	801c952 <MotionFX_propagate+0x26a>
 801c7b6:	ee07 3a90 	vmov	s15, r3
 801c7ba:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c7be:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801c7c2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 801c7c6:	f604 135c 	addw	r3, r4, #2396	@ 0x95c
 801c7ca:	f504 6613 	add.w	r6, r4, #2352	@ 0x930
 801c7ce:	edd3 7a00 	vldr	s15, [r3]
 801c7d2:	eddd 8a06 	vldr	s17, [sp, #24]
 801c7d6:	ed9d 6a07 	vldr	s12, [sp, #28]
 801c7da:	eddd 6a08 	vldr	s13, [sp, #32]
 801c7de:	ed9f 8a68 	vldr	s16, [pc, #416]	@ 801c980 <MotionFX_propagate+0x298>
 801c7e2:	eddf 5a68 	vldr	s11, [pc, #416]	@ 801c984 <MotionFX_propagate+0x29c>
 801c7e6:	eee7 7a28 	vfma.f32	s15, s14, s17
 801c7ea:	ee26 9a08 	vmul.f32	s18, s12, s16
 801c7ee:	edc3 7a00 	vstr	s15, [r3]
 801c7f2:	f504 6316 	add.w	r3, r4, #2400	@ 0x960
 801c7f6:	edd3 7a00 	vldr	s15, [r3]
 801c7fa:	ed8d 9a07 	vstr	s18, [sp, #28]
 801c7fe:	eee7 7a06 	vfma.f32	s15, s14, s12
 801c802:	ee68 8a88 	vmul.f32	s17, s17, s16
 801c806:	edc3 7a00 	vstr	s15, [r3]
 801c80a:	f604 1364 	addw	r3, r4, #2404	@ 0x964
 801c80e:	edd3 7a00 	vldr	s15, [r3]
 801c812:	edcd 8a06 	vstr	s17, [sp, #24]
 801c816:	eee7 7a26 	vfma.f32	s15, s14, s13
 801c81a:	ee26 8a88 	vmul.f32	s16, s13, s16
 801c81e:	edc3 7a00 	vstr	s15, [r3]
 801c822:	f604 1344 	addw	r3, r4, #2372	@ 0x944
 801c826:	edd3 7a00 	vldr	s15, [r3]
 801c82a:	ed8d 8a08 	vstr	s16, [sp, #32]
 801c82e:	f504 6314 	add.w	r3, r4, #2368	@ 0x940
 801c832:	ed93 7a00 	vldr	s14, [r3]
 801c836:	ee39 9a67 	vsub.f32	s18, s18, s15
 801c83a:	ee78 8ac7 	vsub.f32	s17, s17, s14
 801c83e:	ee69 7a09 	vmul.f32	s15, s18, s18
 801c842:	f604 1348 	addw	r3, r4, #2376	@ 0x948
 801c846:	eee8 7aa8 	vfma.f32	s15, s17, s17
 801c84a:	ed93 7a00 	vldr	s14, [r3]
 801c84e:	ee38 8a47 	vsub.f32	s16, s16, s14
 801c852:	eeb6 0a00 	vmov.f32	s0, #96	@ 0x3f000000  0.5
 801c856:	eee8 7a08 	vfma.f32	s15, s16, s16
 801c85a:	ee29 0a80 	vmul.f32	s0, s19, s0
 801c85e:	eef4 7ae5 	vcmpe.f32	s15, s11
 801c862:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c866:	dd79      	ble.n	801c95c <MotionFX_propagate+0x274>
 801c868:	eeb1 aae7 	vsqrt.f32	s20, s15
 801c86c:	ee6a 9a00 	vmul.f32	s19, s20, s0
 801c870:	eeb0 0a69 	vmov.f32	s0, s19
 801c874:	f003 f86e 	bl	801f954 <sinf>
 801c878:	eeb0 7a40 	vmov.f32	s14, s0
 801c87c:	eec7 7a0a 	vdiv.f32	s15, s14, s20
 801c880:	eeb0 0a69 	vmov.f32	s0, s19
 801c884:	ee68 8aa7 	vmul.f32	s17, s17, s15
 801c888:	ee29 9a27 	vmul.f32	s18, s18, s15
 801c88c:	ee28 8a27 	vmul.f32	s16, s16, s15
 801c890:	edcd 8a09 	vstr	s17, [sp, #36]	@ 0x24
 801c894:	ed8d 9a0a 	vstr	s18, [sp, #40]	@ 0x28
 801c898:	ed8d 8a0b 	vstr	s16, [sp, #44]	@ 0x2c
 801c89c:	f003 f80e 	bl	801f8bc <cosf>
 801c8a0:	ed8d 0a0c 	vstr	s0, [sp, #48]	@ 0x30
 801c8a4:	a809      	add	r0, sp, #36	@ 0x24
 801c8a6:	f604 1838 	addw	r8, r4, #2360	@ 0x938
 801c8aa:	4632      	mov	r2, r6
 801c8ac:	4631      	mov	r1, r6
 801c8ae:	f7f9 fd6d 	bl	801638c <qmult>
 801c8b2:	edd8 6a00 	vldr	s13, [r8]
 801c8b6:	edd6 5a00 	vldr	s11, [r6]
 801c8ba:	f8b4 3950 	ldrh.w	r3, [r4, #2384]	@ 0x950
 801c8be:	f604 1934 	addw	r9, r4, #2356	@ 0x934
 801c8c2:	ed99 6a00 	vldr	s12, [r9]
 801c8c6:	ee66 7aa6 	vmul.f32	s15, s13, s13
 801c8ca:	4639      	mov	r1, r7
 801c8cc:	eee6 7a06 	vfma.f32	s15, s12, s12
 801c8d0:	f604 173c 	addw	r7, r4, #2364	@ 0x93c
 801c8d4:	3301      	adds	r3, #1
 801c8d6:	ed97 7a00 	vldr	s14, [r7]
 801c8da:	eee7 7a07 	vfma.f32	s15, s14, s14
 801c8de:	aa13      	add	r2, sp, #76	@ 0x4c
 801c8e0:	eef7 4a00 	vmov.f32	s9, #112	@ 0x3f800000  1.0
 801c8e4:	eee5 7aa5 	vfma.f32	s15, s11, s11
 801c8e8:	eeb1 5ae7 	vsqrt.f32	s10, s15
 801c8ec:	eec4 7a85 	vdiv.f32	s15, s9, s10
 801c8f0:	ee65 5aa7 	vmul.f32	s11, s11, s15
 801c8f4:	ee27 6a86 	vmul.f32	s12, s15, s12
 801c8f8:	ee67 6aa6 	vmul.f32	s13, s15, s13
 801c8fc:	ee27 7a27 	vmul.f32	s14, s14, s15
 801c900:	edc6 5a00 	vstr	s11, [r6]
 801c904:	ed89 6a00 	vstr	s12, [r9]
 801c908:	edc8 6a00 	vstr	s13, [r8]
 801c90c:	ed87 7a00 	vstr	s14, [r7]
 801c910:	f8a4 3950 	strh.w	r3, [r4, #2384]	@ 0x950
 801c914:	f7f9 faae 	bl	8015e74 <rotVect>
 801c918:	6833      	ldr	r3, [r6, #0]
 801c91a:	60eb      	str	r3, [r5, #12]
 801c91c:	f8d9 3000 	ldr.w	r3, [r9]
 801c920:	f8d8 2000 	ldr.w	r2, [r8]
 801c924:	612b      	str	r3, [r5, #16]
 801c926:	683b      	ldr	r3, [r7, #0]
 801c928:	61ab      	str	r3, [r5, #24]
 801c92a:	616a      	str	r2, [r5, #20]
 801c92c:	f894 2038 	ldrb.w	r2, [r4, #56]	@ 0x38
 801c930:	f105 0328 	add.w	r3, r5, #40	@ 0x28
 801c934:	e9cd 3200 	strd	r3, r2, [sp]
 801c938:	4601      	mov	r1, r0
 801c93a:	f105 031c 	add.w	r3, r5, #28
 801c93e:	462a      	mov	r2, r5
 801c940:	f105 000c 	add.w	r0, r5, #12
 801c944:	f7fa fe12 	bl	801756c <output_update>
 801c948:	b021      	add	sp, #132	@ 0x84
 801c94a:	ecbd 8b06 	vpop	{d8-d10}
 801c94e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801c952:	2301      	movs	r3, #1
 801c954:	7123      	strb	r3, [r4, #4]
 801c956:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801c95a:	e734      	b.n	801c7c6 <MotionFX_propagate+0xde>
 801c95c:	ee68 8a80 	vmul.f32	s17, s17, s0
 801c960:	ee29 9a00 	vmul.f32	s18, s18, s0
 801c964:	ee28 8a00 	vmul.f32	s16, s16, s0
 801c968:	f04f 537e 	mov.w	r3, #1065353216	@ 0x3f800000
 801c96c:	edcd 8a09 	vstr	s17, [sp, #36]	@ 0x24
 801c970:	ed8d 9a0a 	vstr	s18, [sp, #40]	@ 0x28
 801c974:	ed8d 8a0b 	vstr	s16, [sp, #44]	@ 0x2c
 801c978:	930c      	str	r3, [sp, #48]	@ 0x30
 801c97a:	e793      	b.n	801c8a4 <MotionFX_propagate+0x1bc>
 801c97c:	2000054c 	.word	0x2000054c
 801c980:	3c8efa35 	.word	0x3c8efa35
 801c984:	38d1b718 	.word	0x38d1b718

0801c988 <MotionFX_MagCal_init>:
 801c988:	b570      	push	{r4, r5, r6, lr}
 801c98a:	4c42      	ldr	r4, [pc, #264]	@ (801ca94 <MotionFX_MagCal_init+0x10c>)
 801c98c:	f894 33c4 	ldrb.w	r3, [r4, #964]	@ 0x3c4
 801c990:	b903      	cbnz	r3, 801c994 <MotionFX_MagCal_init+0xc>
 801c992:	bd70      	pop	{r4, r5, r6, pc}
 801c994:	1e43      	subs	r3, r0, #1
 801c996:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 801c99a:	4605      	mov	r5, r0
 801c99c:	d2f9      	bcs.n	801c992 <MotionFX_MagCal_init+0xa>
 801c99e:	2900      	cmp	r1, #0
 801c9a0:	d139      	bne.n	801ca16 <MotionFX_MagCal_init+0x8e>
 801c9a2:	f884 1048 	strb.w	r1, [r4, #72]	@ 0x48
 801c9a6:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 801c9aa:	4a3b      	ldr	r2, [pc, #236]	@ (801ca98 <MotionFX_MagCal_init+0x110>)
 801c9ac:	1b5b      	subs	r3, r3, r5
 801c9ae:	ee07 3a90 	vmov	s15, r3
 801c9b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801c9b6:	23c8      	movs	r3, #200	@ 0xc8
 801c9b8:	eef0 7ae7 	vabs.f32	s15, s15
 801c9bc:	fb93 f3f5 	sdiv	r3, r3, r5
 801c9c0:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 801c9c4:	b2db      	uxtb	r3, r3
 801c9c6:	2b0f      	cmp	r3, #15
 801c9c8:	eef4 7ac7 	vcmpe.f32	s15, s14
 801c9cc:	bf28      	it	cs
 801c9ce:	230f      	movcs	r3, #15
 801c9d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c9d4:	6015      	str	r5, [r2, #0]
 801c9d6:	f884 37de 	strb.w	r3, [r4, #2014]	@ 0x7de
 801c9da:	b22d      	sxth	r5, r5
 801c9dc:	dc0e      	bgt.n	801c9fc <MotionFX_MagCal_init+0x74>
 801c9de:	edd4 7a01 	vldr	s15, [r4, #4]
 801c9e2:	eddf 6a2e 	vldr	s13, [pc, #184]	@ 801ca9c <MotionFX_MagCal_init+0x114>
 801c9e6:	ed9f 7a2e 	vldr	s14, [pc, #184]	@ 801caa0 <MotionFX_MagCal_init+0x118>
 801c9ea:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801c9ee:	eef0 7ae7 	vabs.f32	s15, s15
 801c9f2:	eef4 7ac7 	vcmpe.f32	s15, s14
 801c9f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801c9fa:	dd08      	ble.n	801ca0e <MotionFX_MagCal_init+0x86>
 801c9fc:	2300      	movs	r3, #0
 801c9fe:	4a29      	ldr	r2, [pc, #164]	@ (801caa4 <MotionFX_MagCal_init+0x11c>)
 801ca00:	8123      	strh	r3, [r4, #8]
 801ca02:	f44f 6196 	mov.w	r1, #1200	@ 0x4b0
 801ca06:	60e3      	str	r3, [r4, #12]
 801ca08:	8021      	strh	r1, [r4, #0]
 801ca0a:	8065      	strh	r5, [r4, #2]
 801ca0c:	6062      	str	r2, [r4, #4]
 801ca0e:	2300      	movs	r3, #0
 801ca10:	f884 3858 	strb.w	r3, [r4, #2136]	@ 0x858
 801ca14:	bd70      	pop	{r4, r5, r6, pc}
 801ca16:	2600      	movs	r6, #0
 801ca18:	f44f 0302 	mov.w	r3, #8519680	@ 0x820000
 801ca1c:	e9c4 3602 	strd	r3, r6, [r4, #8]
 801ca20:	f504 7372 	add.w	r3, r4, #968	@ 0x3c8
 801ca24:	f44f 7248 	mov.w	r2, #800	@ 0x320
 801ca28:	4631      	mov	r1, r6
 801ca2a:	6123      	str	r3, [r4, #16]
 801ca2c:	f104 00a0 	add.w	r0, r4, #160	@ 0xa0
 801ca30:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 801ca34:	f8a4 3050 	strh.w	r3, [r4, #80]	@ 0x50
 801ca38:	f884 6048 	strb.w	r6, [r4, #72]	@ 0x48
 801ca3c:	64e6      	str	r6, [r4, #76]	@ 0x4c
 801ca3e:	82a6      	strh	r6, [r4, #20]
 801ca40:	f000 fe01 	bl	801d646 <memset>
 801ca44:	225f      	movs	r2, #95	@ 0x5f
 801ca46:	f884 20a1 	strb.w	r2, [r4, #161]	@ 0xa1
 801ca4a:	f44f 6270 	mov.w	r2, #3840	@ 0xf00
 801ca4e:	84a2      	strh	r2, [r4, #36]	@ 0x24
 801ca50:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801ca54:	23ff      	movs	r3, #255	@ 0xff
 801ca56:	f8a4 2054 	strh.w	r2, [r4, #84]	@ 0x54
 801ca5a:	4631      	mov	r1, r6
 801ca5c:	2230      	movs	r2, #48	@ 0x30
 801ca5e:	f104 006c 	add.w	r0, r4, #108	@ 0x6c
 801ca62:	f884 30a2 	strb.w	r3, [r4, #162]	@ 0xa2
 801ca66:	f884 3026 	strb.w	r3, [r4, #38]	@ 0x26
 801ca6a:	e9c4 6606 	strd	r6, r6, [r4, #24]
 801ca6e:	6226      	str	r6, [r4, #32]
 801ca70:	f000 fde9 	bl	801d646 <memset>
 801ca74:	f1a5 030a 	sub.w	r3, r5, #10
 801ca78:	b29b      	uxth	r3, r3
 801ca7a:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 801ca7e:	2101      	movs	r1, #1
 801ca80:	2b32      	cmp	r3, #50	@ 0x32
 801ca82:	f884 106d 	strb.w	r1, [r4, #109]	@ 0x6d
 801ca86:	67e2      	str	r2, [r4, #124]	@ 0x7c
 801ca88:	f8c4 208c 	str.w	r2, [r4, #140]	@ 0x8c
 801ca8c:	f8c4 209c 	str.w	r2, [r4, #156]	@ 0x9c
 801ca90:	d889      	bhi.n	801c9a6 <MotionFX_MagCal_init+0x1e>
 801ca92:	e786      	b.n	801c9a2 <MotionFX_MagCal_init+0x1a>
 801ca94:	2000054c 	.word	0x2000054c
 801ca98:	20000000 	.word	0x20000000
 801ca9c:	3dcccccd 	.word	0x3dcccccd
 801caa0:	3c23d70a 	.word	0x3c23d70a
 801caa4:	3dcccccd 	.word	0x3dcccccd

0801caa8 <MotionFX_MagCal_getParams>:
 801caa8:	4b20      	ldr	r3, [pc, #128]	@ (801cb2c <MotionFX_MagCal_getParams+0x84>)
 801caaa:	f893 23c4 	ldrb.w	r2, [r3, #964]	@ 0x3c4
 801caae:	b902      	cbnz	r2, 801cab2 <MotionFX_MagCal_getParams+0xa>
 801cab0:	4770      	bx	lr
 801cab2:	b530      	push	{r4, r5, lr}
 801cab4:	f103 0e6c 	add.w	lr, r3, #108	@ 0x6c
 801cab8:	4604      	mov	r4, r0
 801caba:	f893 506c 	ldrb.w	r5, [r3, #108]	@ 0x6c
 801cabe:	ed9f 6a1c 	vldr	s12, [pc, #112]	@ 801cb30 <MotionFX_MagCal_getParams+0x88>
 801cac2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801cac6:	b08f      	sub	sp, #60	@ 0x3c
 801cac8:	f10d 0c04 	add.w	ip, sp, #4
 801cacc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cad0:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801cad4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cad8:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801cadc:	eddd 6a02 	vldr	s13, [sp, #8]
 801cae0:	ed9d 7a03 	vldr	s14, [sp, #12]
 801cae4:	eddd 7a04 	vldr	s15, [sp, #16]
 801cae8:	eefd 6ae6 	vcvt.s32.f32	s13, s13
 801caec:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 801caf0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801caf4:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801caf8:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801cafc:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 801cb00:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801cb04:	f8de 3000 	ldr.w	r3, [lr]
 801cb08:	7325      	strb	r5, [r4, #12]
 801cb0a:	ee66 6a86 	vmul.f32	s13, s13, s12
 801cb0e:	ee27 7a06 	vmul.f32	s14, s14, s12
 801cb12:	ee67 7a86 	vmul.f32	s15, s15, s12
 801cb16:	edc4 6a00 	vstr	s13, [r4]
 801cb1a:	f8cc 3000 	str.w	r3, [ip]
 801cb1e:	ed84 7a01 	vstr	s14, [r4, #4]
 801cb22:	edc4 7a02 	vstr	s15, [r4, #8]
 801cb26:	b00f      	add	sp, #60	@ 0x3c
 801cb28:	bd30      	pop	{r4, r5, pc}
 801cb2a:	bf00      	nop
 801cb2c:	2000054c 	.word	0x2000054c
 801cb30:	3b03126f 	.word	0x3b03126f

0801cb34 <MotionFX_GetLibVersion>:
 801cb34:	b570      	push	{r4, r5, r6, lr}
 801cb36:	4b13      	ldr	r3, [pc, #76]	@ (801cb84 <MotionFX_GetLibVersion+0x50>)
 801cb38:	f893 63c4 	ldrb.w	r6, [r3, #964]	@ 0x3c4
 801cb3c:	b08a      	sub	sp, #40	@ 0x28
 801cb3e:	b1ee      	cbz	r6, 801cb7c <MotionFX_GetLibVersion+0x48>
 801cb40:	4d11      	ldr	r5, [pc, #68]	@ (801cb88 <MotionFX_GetLibVersion+0x54>)
 801cb42:	4684      	mov	ip, r0
 801cb44:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801cb46:	f10d 0e04 	add.w	lr, sp, #4
 801cb4a:	4674      	mov	r4, lr
 801cb4c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801cb50:	682b      	ldr	r3, [r5, #0]
 801cb52:	f82e 3b02 	strh.w	r3, [lr], #2
 801cb56:	0c1b      	lsrs	r3, r3, #16
 801cb58:	f88e 3000 	strb.w	r3, [lr]
 801cb5c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801cb5e:	f8cc 2008 	str.w	r2, [ip, #8]
 801cb62:	8822      	ldrh	r2, [r4, #0]
 801cb64:	f8ac 2010 	strh.w	r2, [ip, #16]
 801cb68:	78a2      	ldrb	r2, [r4, #2]
 801cb6a:	f8cc 0000 	str.w	r0, [ip]
 801cb6e:	2612      	movs	r6, #18
 801cb70:	f8cc 1004 	str.w	r1, [ip, #4]
 801cb74:	f8cc 300c 	str.w	r3, [ip, #12]
 801cb78:	f88c 2012 	strb.w	r2, [ip, #18]
 801cb7c:	4630      	mov	r0, r6
 801cb7e:	b00a      	add	sp, #40	@ 0x28
 801cb80:	bd70      	pop	{r4, r5, r6, pc}
 801cb82:	bf00      	nop
 801cb84:	2000054c 	.word	0x2000054c
 801cb88:	080239f8 	.word	0x080239f8

0801cb8c <__cvt>:
 801cb8c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801cb90:	ec57 6b10 	vmov	r6, r7, d0
 801cb94:	2f00      	cmp	r7, #0
 801cb96:	460c      	mov	r4, r1
 801cb98:	4619      	mov	r1, r3
 801cb9a:	463b      	mov	r3, r7
 801cb9c:	bfbb      	ittet	lt
 801cb9e:	f107 4300 	addlt.w	r3, r7, #2147483648	@ 0x80000000
 801cba2:	461f      	movlt	r7, r3
 801cba4:	2300      	movge	r3, #0
 801cba6:	232d      	movlt	r3, #45	@ 0x2d
 801cba8:	700b      	strb	r3, [r1, #0]
 801cbaa:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 801cbac:	f8dd a030 	ldr.w	sl, [sp, #48]	@ 0x30
 801cbb0:	4691      	mov	r9, r2
 801cbb2:	f023 0820 	bic.w	r8, r3, #32
 801cbb6:	bfbc      	itt	lt
 801cbb8:	4632      	movlt	r2, r6
 801cbba:	4616      	movlt	r6, r2
 801cbbc:	f1b8 0f46 	cmp.w	r8, #70	@ 0x46
 801cbc0:	d005      	beq.n	801cbce <__cvt+0x42>
 801cbc2:	f1b8 0f45 	cmp.w	r8, #69	@ 0x45
 801cbc6:	d100      	bne.n	801cbca <__cvt+0x3e>
 801cbc8:	3401      	adds	r4, #1
 801cbca:	2102      	movs	r1, #2
 801cbcc:	e000      	b.n	801cbd0 <__cvt+0x44>
 801cbce:	2103      	movs	r1, #3
 801cbd0:	ab03      	add	r3, sp, #12
 801cbd2:	9301      	str	r3, [sp, #4]
 801cbd4:	ab02      	add	r3, sp, #8
 801cbd6:	9300      	str	r3, [sp, #0]
 801cbd8:	ec47 6b10 	vmov	d0, r6, r7
 801cbdc:	4653      	mov	r3, sl
 801cbde:	4622      	mov	r2, r4
 801cbe0:	f000 fe4a 	bl	801d878 <_dtoa_r>
 801cbe4:	f1b8 0f47 	cmp.w	r8, #71	@ 0x47
 801cbe8:	4605      	mov	r5, r0
 801cbea:	d119      	bne.n	801cc20 <__cvt+0x94>
 801cbec:	f019 0f01 	tst.w	r9, #1
 801cbf0:	d00e      	beq.n	801cc10 <__cvt+0x84>
 801cbf2:	eb00 0904 	add.w	r9, r0, r4
 801cbf6:	2200      	movs	r2, #0
 801cbf8:	2300      	movs	r3, #0
 801cbfa:	4630      	mov	r0, r6
 801cbfc:	4639      	mov	r1, r7
 801cbfe:	f7e3 ff6b 	bl	8000ad8 <__aeabi_dcmpeq>
 801cc02:	b108      	cbz	r0, 801cc08 <__cvt+0x7c>
 801cc04:	f8cd 900c 	str.w	r9, [sp, #12]
 801cc08:	2230      	movs	r2, #48	@ 0x30
 801cc0a:	9b03      	ldr	r3, [sp, #12]
 801cc0c:	454b      	cmp	r3, r9
 801cc0e:	d31e      	bcc.n	801cc4e <__cvt+0xc2>
 801cc10:	9b03      	ldr	r3, [sp, #12]
 801cc12:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 801cc14:	1b5b      	subs	r3, r3, r5
 801cc16:	4628      	mov	r0, r5
 801cc18:	6013      	str	r3, [r2, #0]
 801cc1a:	b004      	add	sp, #16
 801cc1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801cc20:	f1b8 0f46 	cmp.w	r8, #70	@ 0x46
 801cc24:	eb00 0904 	add.w	r9, r0, r4
 801cc28:	d1e5      	bne.n	801cbf6 <__cvt+0x6a>
 801cc2a:	7803      	ldrb	r3, [r0, #0]
 801cc2c:	2b30      	cmp	r3, #48	@ 0x30
 801cc2e:	d10a      	bne.n	801cc46 <__cvt+0xba>
 801cc30:	2200      	movs	r2, #0
 801cc32:	2300      	movs	r3, #0
 801cc34:	4630      	mov	r0, r6
 801cc36:	4639      	mov	r1, r7
 801cc38:	f7e3 ff4e 	bl	8000ad8 <__aeabi_dcmpeq>
 801cc3c:	b918      	cbnz	r0, 801cc46 <__cvt+0xba>
 801cc3e:	f1c4 0401 	rsb	r4, r4, #1
 801cc42:	f8ca 4000 	str.w	r4, [sl]
 801cc46:	f8da 3000 	ldr.w	r3, [sl]
 801cc4a:	4499      	add	r9, r3
 801cc4c:	e7d3      	b.n	801cbf6 <__cvt+0x6a>
 801cc4e:	1c59      	adds	r1, r3, #1
 801cc50:	9103      	str	r1, [sp, #12]
 801cc52:	701a      	strb	r2, [r3, #0]
 801cc54:	e7d9      	b.n	801cc0a <__cvt+0x7e>

0801cc56 <__exponent>:
 801cc56:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801cc58:	2900      	cmp	r1, #0
 801cc5a:	bfba      	itte	lt
 801cc5c:	4249      	neglt	r1, r1
 801cc5e:	232d      	movlt	r3, #45	@ 0x2d
 801cc60:	232b      	movge	r3, #43	@ 0x2b
 801cc62:	2909      	cmp	r1, #9
 801cc64:	7002      	strb	r2, [r0, #0]
 801cc66:	7043      	strb	r3, [r0, #1]
 801cc68:	dd29      	ble.n	801ccbe <__exponent+0x68>
 801cc6a:	f10d 0307 	add.w	r3, sp, #7
 801cc6e:	461d      	mov	r5, r3
 801cc70:	270a      	movs	r7, #10
 801cc72:	461a      	mov	r2, r3
 801cc74:	fbb1 f6f7 	udiv	r6, r1, r7
 801cc78:	fb07 1416 	mls	r4, r7, r6, r1
 801cc7c:	3430      	adds	r4, #48	@ 0x30
 801cc7e:	f802 4c01 	strb.w	r4, [r2, #-1]
 801cc82:	460c      	mov	r4, r1
 801cc84:	2c63      	cmp	r4, #99	@ 0x63
 801cc86:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
 801cc8a:	4631      	mov	r1, r6
 801cc8c:	dcf1      	bgt.n	801cc72 <__exponent+0x1c>
 801cc8e:	3130      	adds	r1, #48	@ 0x30
 801cc90:	1e94      	subs	r4, r2, #2
 801cc92:	f803 1c01 	strb.w	r1, [r3, #-1]
 801cc96:	1c41      	adds	r1, r0, #1
 801cc98:	4623      	mov	r3, r4
 801cc9a:	42ab      	cmp	r3, r5
 801cc9c:	d30a      	bcc.n	801ccb4 <__exponent+0x5e>
 801cc9e:	f10d 0309 	add.w	r3, sp, #9
 801cca2:	1a9b      	subs	r3, r3, r2
 801cca4:	42ac      	cmp	r4, r5
 801cca6:	bf88      	it	hi
 801cca8:	2300      	movhi	r3, #0
 801ccaa:	3302      	adds	r3, #2
 801ccac:	4403      	add	r3, r0
 801ccae:	1a18      	subs	r0, r3, r0
 801ccb0:	b003      	add	sp, #12
 801ccb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801ccb4:	f813 6b01 	ldrb.w	r6, [r3], #1
 801ccb8:	f801 6f01 	strb.w	r6, [r1, #1]!
 801ccbc:	e7ed      	b.n	801cc9a <__exponent+0x44>
 801ccbe:	2330      	movs	r3, #48	@ 0x30
 801ccc0:	3130      	adds	r1, #48	@ 0x30
 801ccc2:	7083      	strb	r3, [r0, #2]
 801ccc4:	70c1      	strb	r1, [r0, #3]
 801ccc6:	1d03      	adds	r3, r0, #4
 801ccc8:	e7f1      	b.n	801ccae <__exponent+0x58>
	...

0801cccc <_printf_float>:
 801cccc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ccd0:	b08d      	sub	sp, #52	@ 0x34
 801ccd2:	460c      	mov	r4, r1
 801ccd4:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
 801ccd8:	4616      	mov	r6, r2
 801ccda:	461f      	mov	r7, r3
 801ccdc:	4605      	mov	r5, r0
 801ccde:	f000 fcbb 	bl	801d658 <_localeconv_r>
 801cce2:	6803      	ldr	r3, [r0, #0]
 801cce4:	9304      	str	r3, [sp, #16]
 801cce6:	4618      	mov	r0, r3
 801cce8:	f7e3 faca 	bl	8000280 <strlen>
 801ccec:	2300      	movs	r3, #0
 801ccee:	930a      	str	r3, [sp, #40]	@ 0x28
 801ccf0:	f8d8 3000 	ldr.w	r3, [r8]
 801ccf4:	9005      	str	r0, [sp, #20]
 801ccf6:	3307      	adds	r3, #7
 801ccf8:	f023 0307 	bic.w	r3, r3, #7
 801ccfc:	f103 0208 	add.w	r2, r3, #8
 801cd00:	f894 a018 	ldrb.w	sl, [r4, #24]
 801cd04:	f8d4 b000 	ldr.w	fp, [r4]
 801cd08:	f8c8 2000 	str.w	r2, [r8]
 801cd0c:	e9d3 8900 	ldrd	r8, r9, [r3]
 801cd10:	f029 4300 	bic.w	r3, r9, #2147483648	@ 0x80000000
 801cd14:	9307      	str	r3, [sp, #28]
 801cd16:	f8cd 8018 	str.w	r8, [sp, #24]
 801cd1a:	e9c4 8912 	strd	r8, r9, [r4, #72]	@ 0x48
 801cd1e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801cd22:	4b9c      	ldr	r3, [pc, #624]	@ (801cf94 <_printf_float+0x2c8>)
 801cd24:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801cd28:	f7e3 ff08 	bl	8000b3c <__aeabi_dcmpun>
 801cd2c:	bb70      	cbnz	r0, 801cd8c <_printf_float+0xc0>
 801cd2e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801cd32:	4b98      	ldr	r3, [pc, #608]	@ (801cf94 <_printf_float+0x2c8>)
 801cd34:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801cd38:	f7e3 fee2 	bl	8000b00 <__aeabi_dcmple>
 801cd3c:	bb30      	cbnz	r0, 801cd8c <_printf_float+0xc0>
 801cd3e:	2200      	movs	r2, #0
 801cd40:	2300      	movs	r3, #0
 801cd42:	4640      	mov	r0, r8
 801cd44:	4649      	mov	r1, r9
 801cd46:	f7e3 fed1 	bl	8000aec <__aeabi_dcmplt>
 801cd4a:	b110      	cbz	r0, 801cd52 <_printf_float+0x86>
 801cd4c:	232d      	movs	r3, #45	@ 0x2d
 801cd4e:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 801cd52:	4a91      	ldr	r2, [pc, #580]	@ (801cf98 <_printf_float+0x2cc>)
 801cd54:	4b91      	ldr	r3, [pc, #580]	@ (801cf9c <_printf_float+0x2d0>)
 801cd56:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
 801cd5a:	bf94      	ite	ls
 801cd5c:	4690      	movls	r8, r2
 801cd5e:	4698      	movhi	r8, r3
 801cd60:	2303      	movs	r3, #3
 801cd62:	6123      	str	r3, [r4, #16]
 801cd64:	f02b 0304 	bic.w	r3, fp, #4
 801cd68:	6023      	str	r3, [r4, #0]
 801cd6a:	f04f 0900 	mov.w	r9, #0
 801cd6e:	9700      	str	r7, [sp, #0]
 801cd70:	4633      	mov	r3, r6
 801cd72:	aa0b      	add	r2, sp, #44	@ 0x2c
 801cd74:	4621      	mov	r1, r4
 801cd76:	4628      	mov	r0, r5
 801cd78:	f000 f9d2 	bl	801d120 <_printf_common>
 801cd7c:	3001      	adds	r0, #1
 801cd7e:	f040 808d 	bne.w	801ce9c <_printf_float+0x1d0>
 801cd82:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801cd86:	b00d      	add	sp, #52	@ 0x34
 801cd88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801cd8c:	4642      	mov	r2, r8
 801cd8e:	464b      	mov	r3, r9
 801cd90:	4640      	mov	r0, r8
 801cd92:	4649      	mov	r1, r9
 801cd94:	f7e3 fed2 	bl	8000b3c <__aeabi_dcmpun>
 801cd98:	b140      	cbz	r0, 801cdac <_printf_float+0xe0>
 801cd9a:	464b      	mov	r3, r9
 801cd9c:	2b00      	cmp	r3, #0
 801cd9e:	bfbc      	itt	lt
 801cda0:	232d      	movlt	r3, #45	@ 0x2d
 801cda2:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
 801cda6:	4a7e      	ldr	r2, [pc, #504]	@ (801cfa0 <_printf_float+0x2d4>)
 801cda8:	4b7e      	ldr	r3, [pc, #504]	@ (801cfa4 <_printf_float+0x2d8>)
 801cdaa:	e7d4      	b.n	801cd56 <_printf_float+0x8a>
 801cdac:	6863      	ldr	r3, [r4, #4]
 801cdae:	f00a 02df 	and.w	r2, sl, #223	@ 0xdf
 801cdb2:	9206      	str	r2, [sp, #24]
 801cdb4:	1c5a      	adds	r2, r3, #1
 801cdb6:	d13b      	bne.n	801ce30 <_printf_float+0x164>
 801cdb8:	2306      	movs	r3, #6
 801cdba:	6063      	str	r3, [r4, #4]
 801cdbc:	f44b 6280 	orr.w	r2, fp, #1024	@ 0x400
 801cdc0:	2300      	movs	r3, #0
 801cdc2:	6022      	str	r2, [r4, #0]
 801cdc4:	9303      	str	r3, [sp, #12]
 801cdc6:	ab0a      	add	r3, sp, #40	@ 0x28
 801cdc8:	e9cd a301 	strd	sl, r3, [sp, #4]
 801cdcc:	ab09      	add	r3, sp, #36	@ 0x24
 801cdce:	9300      	str	r3, [sp, #0]
 801cdd0:	6861      	ldr	r1, [r4, #4]
 801cdd2:	ec49 8b10 	vmov	d0, r8, r9
 801cdd6:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
 801cdda:	4628      	mov	r0, r5
 801cddc:	f7ff fed6 	bl	801cb8c <__cvt>
 801cde0:	9b06      	ldr	r3, [sp, #24]
 801cde2:	9909      	ldr	r1, [sp, #36]	@ 0x24
 801cde4:	2b47      	cmp	r3, #71	@ 0x47
 801cde6:	4680      	mov	r8, r0
 801cde8:	d129      	bne.n	801ce3e <_printf_float+0x172>
 801cdea:	1cc8      	adds	r0, r1, #3
 801cdec:	db02      	blt.n	801cdf4 <_printf_float+0x128>
 801cdee:	6863      	ldr	r3, [r4, #4]
 801cdf0:	4299      	cmp	r1, r3
 801cdf2:	dd41      	ble.n	801ce78 <_printf_float+0x1ac>
 801cdf4:	f1aa 0a02 	sub.w	sl, sl, #2
 801cdf8:	fa5f fa8a 	uxtb.w	sl, sl
 801cdfc:	3901      	subs	r1, #1
 801cdfe:	4652      	mov	r2, sl
 801ce00:	f104 0050 	add.w	r0, r4, #80	@ 0x50
 801ce04:	9109      	str	r1, [sp, #36]	@ 0x24
 801ce06:	f7ff ff26 	bl	801cc56 <__exponent>
 801ce0a:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 801ce0c:	1813      	adds	r3, r2, r0
 801ce0e:	2a01      	cmp	r2, #1
 801ce10:	4681      	mov	r9, r0
 801ce12:	6123      	str	r3, [r4, #16]
 801ce14:	dc02      	bgt.n	801ce1c <_printf_float+0x150>
 801ce16:	6822      	ldr	r2, [r4, #0]
 801ce18:	07d2      	lsls	r2, r2, #31
 801ce1a:	d501      	bpl.n	801ce20 <_printf_float+0x154>
 801ce1c:	3301      	adds	r3, #1
 801ce1e:	6123      	str	r3, [r4, #16]
 801ce20:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
 801ce24:	2b00      	cmp	r3, #0
 801ce26:	d0a2      	beq.n	801cd6e <_printf_float+0xa2>
 801ce28:	232d      	movs	r3, #45	@ 0x2d
 801ce2a:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 801ce2e:	e79e      	b.n	801cd6e <_printf_float+0xa2>
 801ce30:	9a06      	ldr	r2, [sp, #24]
 801ce32:	2a47      	cmp	r2, #71	@ 0x47
 801ce34:	d1c2      	bne.n	801cdbc <_printf_float+0xf0>
 801ce36:	2b00      	cmp	r3, #0
 801ce38:	d1c0      	bne.n	801cdbc <_printf_float+0xf0>
 801ce3a:	2301      	movs	r3, #1
 801ce3c:	e7bd      	b.n	801cdba <_printf_float+0xee>
 801ce3e:	f1ba 0f65 	cmp.w	sl, #101	@ 0x65
 801ce42:	d9db      	bls.n	801cdfc <_printf_float+0x130>
 801ce44:	f1ba 0f66 	cmp.w	sl, #102	@ 0x66
 801ce48:	d118      	bne.n	801ce7c <_printf_float+0x1b0>
 801ce4a:	2900      	cmp	r1, #0
 801ce4c:	6863      	ldr	r3, [r4, #4]
 801ce4e:	dd0b      	ble.n	801ce68 <_printf_float+0x19c>
 801ce50:	6121      	str	r1, [r4, #16]
 801ce52:	b913      	cbnz	r3, 801ce5a <_printf_float+0x18e>
 801ce54:	6822      	ldr	r2, [r4, #0]
 801ce56:	07d0      	lsls	r0, r2, #31
 801ce58:	d502      	bpl.n	801ce60 <_printf_float+0x194>
 801ce5a:	3301      	adds	r3, #1
 801ce5c:	440b      	add	r3, r1
 801ce5e:	6123      	str	r3, [r4, #16]
 801ce60:	65a1      	str	r1, [r4, #88]	@ 0x58
 801ce62:	f04f 0900 	mov.w	r9, #0
 801ce66:	e7db      	b.n	801ce20 <_printf_float+0x154>
 801ce68:	b913      	cbnz	r3, 801ce70 <_printf_float+0x1a4>
 801ce6a:	6822      	ldr	r2, [r4, #0]
 801ce6c:	07d2      	lsls	r2, r2, #31
 801ce6e:	d501      	bpl.n	801ce74 <_printf_float+0x1a8>
 801ce70:	3302      	adds	r3, #2
 801ce72:	e7f4      	b.n	801ce5e <_printf_float+0x192>
 801ce74:	2301      	movs	r3, #1
 801ce76:	e7f2      	b.n	801ce5e <_printf_float+0x192>
 801ce78:	f04f 0a67 	mov.w	sl, #103	@ 0x67
 801ce7c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801ce7e:	4299      	cmp	r1, r3
 801ce80:	db05      	blt.n	801ce8e <_printf_float+0x1c2>
 801ce82:	6823      	ldr	r3, [r4, #0]
 801ce84:	6121      	str	r1, [r4, #16]
 801ce86:	07d8      	lsls	r0, r3, #31
 801ce88:	d5ea      	bpl.n	801ce60 <_printf_float+0x194>
 801ce8a:	1c4b      	adds	r3, r1, #1
 801ce8c:	e7e7      	b.n	801ce5e <_printf_float+0x192>
 801ce8e:	2900      	cmp	r1, #0
 801ce90:	bfd4      	ite	le
 801ce92:	f1c1 0202 	rsble	r2, r1, #2
 801ce96:	2201      	movgt	r2, #1
 801ce98:	4413      	add	r3, r2
 801ce9a:	e7e0      	b.n	801ce5e <_printf_float+0x192>
 801ce9c:	6823      	ldr	r3, [r4, #0]
 801ce9e:	055a      	lsls	r2, r3, #21
 801cea0:	d407      	bmi.n	801ceb2 <_printf_float+0x1e6>
 801cea2:	6923      	ldr	r3, [r4, #16]
 801cea4:	4642      	mov	r2, r8
 801cea6:	4631      	mov	r1, r6
 801cea8:	4628      	mov	r0, r5
 801ceaa:	47b8      	blx	r7
 801ceac:	3001      	adds	r0, #1
 801ceae:	d12b      	bne.n	801cf08 <_printf_float+0x23c>
 801ceb0:	e767      	b.n	801cd82 <_printf_float+0xb6>
 801ceb2:	f1ba 0f65 	cmp.w	sl, #101	@ 0x65
 801ceb6:	f240 80dd 	bls.w	801d074 <_printf_float+0x3a8>
 801ceba:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	@ 0x48
 801cebe:	2200      	movs	r2, #0
 801cec0:	2300      	movs	r3, #0
 801cec2:	f7e3 fe09 	bl	8000ad8 <__aeabi_dcmpeq>
 801cec6:	2800      	cmp	r0, #0
 801cec8:	d033      	beq.n	801cf32 <_printf_float+0x266>
 801ceca:	4a37      	ldr	r2, [pc, #220]	@ (801cfa8 <_printf_float+0x2dc>)
 801cecc:	2301      	movs	r3, #1
 801cece:	4631      	mov	r1, r6
 801ced0:	4628      	mov	r0, r5
 801ced2:	47b8      	blx	r7
 801ced4:	3001      	adds	r0, #1
 801ced6:	f43f af54 	beq.w	801cd82 <_printf_float+0xb6>
 801ceda:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
 801cede:	4543      	cmp	r3, r8
 801cee0:	db02      	blt.n	801cee8 <_printf_float+0x21c>
 801cee2:	6823      	ldr	r3, [r4, #0]
 801cee4:	07d8      	lsls	r0, r3, #31
 801cee6:	d50f      	bpl.n	801cf08 <_printf_float+0x23c>
 801cee8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801ceec:	4631      	mov	r1, r6
 801ceee:	4628      	mov	r0, r5
 801cef0:	47b8      	blx	r7
 801cef2:	3001      	adds	r0, #1
 801cef4:	f43f af45 	beq.w	801cd82 <_printf_float+0xb6>
 801cef8:	f04f 0900 	mov.w	r9, #0
 801cefc:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
 801cf00:	f104 0a1a 	add.w	sl, r4, #26
 801cf04:	45c8      	cmp	r8, r9
 801cf06:	dc09      	bgt.n	801cf1c <_printf_float+0x250>
 801cf08:	6823      	ldr	r3, [r4, #0]
 801cf0a:	079b      	lsls	r3, r3, #30
 801cf0c:	f100 8103 	bmi.w	801d116 <_printf_float+0x44a>
 801cf10:	68e0      	ldr	r0, [r4, #12]
 801cf12:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801cf14:	4298      	cmp	r0, r3
 801cf16:	bfb8      	it	lt
 801cf18:	4618      	movlt	r0, r3
 801cf1a:	e734      	b.n	801cd86 <_printf_float+0xba>
 801cf1c:	2301      	movs	r3, #1
 801cf1e:	4652      	mov	r2, sl
 801cf20:	4631      	mov	r1, r6
 801cf22:	4628      	mov	r0, r5
 801cf24:	47b8      	blx	r7
 801cf26:	3001      	adds	r0, #1
 801cf28:	f43f af2b 	beq.w	801cd82 <_printf_float+0xb6>
 801cf2c:	f109 0901 	add.w	r9, r9, #1
 801cf30:	e7e8      	b.n	801cf04 <_printf_float+0x238>
 801cf32:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801cf34:	2b00      	cmp	r3, #0
 801cf36:	dc39      	bgt.n	801cfac <_printf_float+0x2e0>
 801cf38:	4a1b      	ldr	r2, [pc, #108]	@ (801cfa8 <_printf_float+0x2dc>)
 801cf3a:	2301      	movs	r3, #1
 801cf3c:	4631      	mov	r1, r6
 801cf3e:	4628      	mov	r0, r5
 801cf40:	47b8      	blx	r7
 801cf42:	3001      	adds	r0, #1
 801cf44:	f43f af1d 	beq.w	801cd82 <_printf_float+0xb6>
 801cf48:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
 801cf4c:	ea59 0303 	orrs.w	r3, r9, r3
 801cf50:	d102      	bne.n	801cf58 <_printf_float+0x28c>
 801cf52:	6823      	ldr	r3, [r4, #0]
 801cf54:	07d9      	lsls	r1, r3, #31
 801cf56:	d5d7      	bpl.n	801cf08 <_printf_float+0x23c>
 801cf58:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801cf5c:	4631      	mov	r1, r6
 801cf5e:	4628      	mov	r0, r5
 801cf60:	47b8      	blx	r7
 801cf62:	3001      	adds	r0, #1
 801cf64:	f43f af0d 	beq.w	801cd82 <_printf_float+0xb6>
 801cf68:	f04f 0a00 	mov.w	sl, #0
 801cf6c:	f104 0b1a 	add.w	fp, r4, #26
 801cf70:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801cf72:	425b      	negs	r3, r3
 801cf74:	4553      	cmp	r3, sl
 801cf76:	dc01      	bgt.n	801cf7c <_printf_float+0x2b0>
 801cf78:	464b      	mov	r3, r9
 801cf7a:	e793      	b.n	801cea4 <_printf_float+0x1d8>
 801cf7c:	2301      	movs	r3, #1
 801cf7e:	465a      	mov	r2, fp
 801cf80:	4631      	mov	r1, r6
 801cf82:	4628      	mov	r0, r5
 801cf84:	47b8      	blx	r7
 801cf86:	3001      	adds	r0, #1
 801cf88:	f43f aefb 	beq.w	801cd82 <_printf_float+0xb6>
 801cf8c:	f10a 0a01 	add.w	sl, sl, #1
 801cf90:	e7ee      	b.n	801cf70 <_printf_float+0x2a4>
 801cf92:	bf00      	nop
 801cf94:	7fefffff 	.word	0x7fefffff
 801cf98:	08023a48 	.word	0x08023a48
 801cf9c:	08023a4c 	.word	0x08023a4c
 801cfa0:	08023a50 	.word	0x08023a50
 801cfa4:	08023a54 	.word	0x08023a54
 801cfa8:	08023a58 	.word	0x08023a58
 801cfac:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 801cfae:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
 801cfb2:	4553      	cmp	r3, sl
 801cfb4:	bfa8      	it	ge
 801cfb6:	4653      	movge	r3, sl
 801cfb8:	2b00      	cmp	r3, #0
 801cfba:	4699      	mov	r9, r3
 801cfbc:	dc36      	bgt.n	801d02c <_printf_float+0x360>
 801cfbe:	f04f 0b00 	mov.w	fp, #0
 801cfc2:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 801cfc6:	f104 021a 	add.w	r2, r4, #26
 801cfca:	6da3      	ldr	r3, [r4, #88]	@ 0x58
 801cfcc:	9306      	str	r3, [sp, #24]
 801cfce:	eba3 0309 	sub.w	r3, r3, r9
 801cfd2:	455b      	cmp	r3, fp
 801cfd4:	dc31      	bgt.n	801d03a <_printf_float+0x36e>
 801cfd6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801cfd8:	459a      	cmp	sl, r3
 801cfda:	dc3a      	bgt.n	801d052 <_printf_float+0x386>
 801cfdc:	6823      	ldr	r3, [r4, #0]
 801cfde:	07da      	lsls	r2, r3, #31
 801cfe0:	d437      	bmi.n	801d052 <_printf_float+0x386>
 801cfe2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801cfe4:	ebaa 0903 	sub.w	r9, sl, r3
 801cfe8:	9b06      	ldr	r3, [sp, #24]
 801cfea:	ebaa 0303 	sub.w	r3, sl, r3
 801cfee:	4599      	cmp	r9, r3
 801cff0:	bfa8      	it	ge
 801cff2:	4699      	movge	r9, r3
 801cff4:	f1b9 0f00 	cmp.w	r9, #0
 801cff8:	dc33      	bgt.n	801d062 <_printf_float+0x396>
 801cffa:	f04f 0800 	mov.w	r8, #0
 801cffe:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 801d002:	f104 0b1a 	add.w	fp, r4, #26
 801d006:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801d008:	ebaa 0303 	sub.w	r3, sl, r3
 801d00c:	eba3 0309 	sub.w	r3, r3, r9
 801d010:	4543      	cmp	r3, r8
 801d012:	f77f af79 	ble.w	801cf08 <_printf_float+0x23c>
 801d016:	2301      	movs	r3, #1
 801d018:	465a      	mov	r2, fp
 801d01a:	4631      	mov	r1, r6
 801d01c:	4628      	mov	r0, r5
 801d01e:	47b8      	blx	r7
 801d020:	3001      	adds	r0, #1
 801d022:	f43f aeae 	beq.w	801cd82 <_printf_float+0xb6>
 801d026:	f108 0801 	add.w	r8, r8, #1
 801d02a:	e7ec      	b.n	801d006 <_printf_float+0x33a>
 801d02c:	4642      	mov	r2, r8
 801d02e:	4631      	mov	r1, r6
 801d030:	4628      	mov	r0, r5
 801d032:	47b8      	blx	r7
 801d034:	3001      	adds	r0, #1
 801d036:	d1c2      	bne.n	801cfbe <_printf_float+0x2f2>
 801d038:	e6a3      	b.n	801cd82 <_printf_float+0xb6>
 801d03a:	2301      	movs	r3, #1
 801d03c:	4631      	mov	r1, r6
 801d03e:	4628      	mov	r0, r5
 801d040:	9206      	str	r2, [sp, #24]
 801d042:	47b8      	blx	r7
 801d044:	3001      	adds	r0, #1
 801d046:	f43f ae9c 	beq.w	801cd82 <_printf_float+0xb6>
 801d04a:	9a06      	ldr	r2, [sp, #24]
 801d04c:	f10b 0b01 	add.w	fp, fp, #1
 801d050:	e7bb      	b.n	801cfca <_printf_float+0x2fe>
 801d052:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801d056:	4631      	mov	r1, r6
 801d058:	4628      	mov	r0, r5
 801d05a:	47b8      	blx	r7
 801d05c:	3001      	adds	r0, #1
 801d05e:	d1c0      	bne.n	801cfe2 <_printf_float+0x316>
 801d060:	e68f      	b.n	801cd82 <_printf_float+0xb6>
 801d062:	9a06      	ldr	r2, [sp, #24]
 801d064:	464b      	mov	r3, r9
 801d066:	4442      	add	r2, r8
 801d068:	4631      	mov	r1, r6
 801d06a:	4628      	mov	r0, r5
 801d06c:	47b8      	blx	r7
 801d06e:	3001      	adds	r0, #1
 801d070:	d1c3      	bne.n	801cffa <_printf_float+0x32e>
 801d072:	e686      	b.n	801cd82 <_printf_float+0xb6>
 801d074:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
 801d078:	f1ba 0f01 	cmp.w	sl, #1
 801d07c:	dc01      	bgt.n	801d082 <_printf_float+0x3b6>
 801d07e:	07db      	lsls	r3, r3, #31
 801d080:	d536      	bpl.n	801d0f0 <_printf_float+0x424>
 801d082:	2301      	movs	r3, #1
 801d084:	4642      	mov	r2, r8
 801d086:	4631      	mov	r1, r6
 801d088:	4628      	mov	r0, r5
 801d08a:	47b8      	blx	r7
 801d08c:	3001      	adds	r0, #1
 801d08e:	f43f ae78 	beq.w	801cd82 <_printf_float+0xb6>
 801d092:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801d096:	4631      	mov	r1, r6
 801d098:	4628      	mov	r0, r5
 801d09a:	47b8      	blx	r7
 801d09c:	3001      	adds	r0, #1
 801d09e:	f43f ae70 	beq.w	801cd82 <_printf_float+0xb6>
 801d0a2:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	@ 0x48
 801d0a6:	2200      	movs	r2, #0
 801d0a8:	2300      	movs	r3, #0
 801d0aa:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
 801d0ae:	f7e3 fd13 	bl	8000ad8 <__aeabi_dcmpeq>
 801d0b2:	b9c0      	cbnz	r0, 801d0e6 <_printf_float+0x41a>
 801d0b4:	4653      	mov	r3, sl
 801d0b6:	f108 0201 	add.w	r2, r8, #1
 801d0ba:	4631      	mov	r1, r6
 801d0bc:	4628      	mov	r0, r5
 801d0be:	47b8      	blx	r7
 801d0c0:	3001      	adds	r0, #1
 801d0c2:	d10c      	bne.n	801d0de <_printf_float+0x412>
 801d0c4:	e65d      	b.n	801cd82 <_printf_float+0xb6>
 801d0c6:	2301      	movs	r3, #1
 801d0c8:	465a      	mov	r2, fp
 801d0ca:	4631      	mov	r1, r6
 801d0cc:	4628      	mov	r0, r5
 801d0ce:	47b8      	blx	r7
 801d0d0:	3001      	adds	r0, #1
 801d0d2:	f43f ae56 	beq.w	801cd82 <_printf_float+0xb6>
 801d0d6:	f108 0801 	add.w	r8, r8, #1
 801d0da:	45d0      	cmp	r8, sl
 801d0dc:	dbf3      	blt.n	801d0c6 <_printf_float+0x3fa>
 801d0de:	464b      	mov	r3, r9
 801d0e0:	f104 0250 	add.w	r2, r4, #80	@ 0x50
 801d0e4:	e6df      	b.n	801cea6 <_printf_float+0x1da>
 801d0e6:	f04f 0800 	mov.w	r8, #0
 801d0ea:	f104 0b1a 	add.w	fp, r4, #26
 801d0ee:	e7f4      	b.n	801d0da <_printf_float+0x40e>
 801d0f0:	2301      	movs	r3, #1
 801d0f2:	4642      	mov	r2, r8
 801d0f4:	e7e1      	b.n	801d0ba <_printf_float+0x3ee>
 801d0f6:	2301      	movs	r3, #1
 801d0f8:	464a      	mov	r2, r9
 801d0fa:	4631      	mov	r1, r6
 801d0fc:	4628      	mov	r0, r5
 801d0fe:	47b8      	blx	r7
 801d100:	3001      	adds	r0, #1
 801d102:	f43f ae3e 	beq.w	801cd82 <_printf_float+0xb6>
 801d106:	f108 0801 	add.w	r8, r8, #1
 801d10a:	68e3      	ldr	r3, [r4, #12]
 801d10c:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 801d10e:	1a5b      	subs	r3, r3, r1
 801d110:	4543      	cmp	r3, r8
 801d112:	dcf0      	bgt.n	801d0f6 <_printf_float+0x42a>
 801d114:	e6fc      	b.n	801cf10 <_printf_float+0x244>
 801d116:	f04f 0800 	mov.w	r8, #0
 801d11a:	f104 0919 	add.w	r9, r4, #25
 801d11e:	e7f4      	b.n	801d10a <_printf_float+0x43e>

0801d120 <_printf_common>:
 801d120:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801d124:	4616      	mov	r6, r2
 801d126:	4698      	mov	r8, r3
 801d128:	688a      	ldr	r2, [r1, #8]
 801d12a:	690b      	ldr	r3, [r1, #16]
 801d12c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 801d130:	4293      	cmp	r3, r2
 801d132:	bfb8      	it	lt
 801d134:	4613      	movlt	r3, r2
 801d136:	6033      	str	r3, [r6, #0]
 801d138:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 801d13c:	4607      	mov	r7, r0
 801d13e:	460c      	mov	r4, r1
 801d140:	b10a      	cbz	r2, 801d146 <_printf_common+0x26>
 801d142:	3301      	adds	r3, #1
 801d144:	6033      	str	r3, [r6, #0]
 801d146:	6823      	ldr	r3, [r4, #0]
 801d148:	0699      	lsls	r1, r3, #26
 801d14a:	bf42      	ittt	mi
 801d14c:	6833      	ldrmi	r3, [r6, #0]
 801d14e:	3302      	addmi	r3, #2
 801d150:	6033      	strmi	r3, [r6, #0]
 801d152:	6825      	ldr	r5, [r4, #0]
 801d154:	f015 0506 	ands.w	r5, r5, #6
 801d158:	d106      	bne.n	801d168 <_printf_common+0x48>
 801d15a:	f104 0a19 	add.w	sl, r4, #25
 801d15e:	68e3      	ldr	r3, [r4, #12]
 801d160:	6832      	ldr	r2, [r6, #0]
 801d162:	1a9b      	subs	r3, r3, r2
 801d164:	42ab      	cmp	r3, r5
 801d166:	dc26      	bgt.n	801d1b6 <_printf_common+0x96>
 801d168:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 801d16c:	6822      	ldr	r2, [r4, #0]
 801d16e:	3b00      	subs	r3, #0
 801d170:	bf18      	it	ne
 801d172:	2301      	movne	r3, #1
 801d174:	0692      	lsls	r2, r2, #26
 801d176:	d42b      	bmi.n	801d1d0 <_printf_common+0xb0>
 801d178:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 801d17c:	4641      	mov	r1, r8
 801d17e:	4638      	mov	r0, r7
 801d180:	47c8      	blx	r9
 801d182:	3001      	adds	r0, #1
 801d184:	d01e      	beq.n	801d1c4 <_printf_common+0xa4>
 801d186:	6823      	ldr	r3, [r4, #0]
 801d188:	6922      	ldr	r2, [r4, #16]
 801d18a:	f003 0306 	and.w	r3, r3, #6
 801d18e:	2b04      	cmp	r3, #4
 801d190:	bf02      	ittt	eq
 801d192:	68e5      	ldreq	r5, [r4, #12]
 801d194:	6833      	ldreq	r3, [r6, #0]
 801d196:	1aed      	subeq	r5, r5, r3
 801d198:	68a3      	ldr	r3, [r4, #8]
 801d19a:	bf0c      	ite	eq
 801d19c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 801d1a0:	2500      	movne	r5, #0
 801d1a2:	4293      	cmp	r3, r2
 801d1a4:	bfc4      	itt	gt
 801d1a6:	1a9b      	subgt	r3, r3, r2
 801d1a8:	18ed      	addgt	r5, r5, r3
 801d1aa:	2600      	movs	r6, #0
 801d1ac:	341a      	adds	r4, #26
 801d1ae:	42b5      	cmp	r5, r6
 801d1b0:	d11a      	bne.n	801d1e8 <_printf_common+0xc8>
 801d1b2:	2000      	movs	r0, #0
 801d1b4:	e008      	b.n	801d1c8 <_printf_common+0xa8>
 801d1b6:	2301      	movs	r3, #1
 801d1b8:	4652      	mov	r2, sl
 801d1ba:	4641      	mov	r1, r8
 801d1bc:	4638      	mov	r0, r7
 801d1be:	47c8      	blx	r9
 801d1c0:	3001      	adds	r0, #1
 801d1c2:	d103      	bne.n	801d1cc <_printf_common+0xac>
 801d1c4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801d1c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801d1cc:	3501      	adds	r5, #1
 801d1ce:	e7c6      	b.n	801d15e <_printf_common+0x3e>
 801d1d0:	18e1      	adds	r1, r4, r3
 801d1d2:	1c5a      	adds	r2, r3, #1
 801d1d4:	2030      	movs	r0, #48	@ 0x30
 801d1d6:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 801d1da:	4422      	add	r2, r4
 801d1dc:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 801d1e0:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 801d1e4:	3302      	adds	r3, #2
 801d1e6:	e7c7      	b.n	801d178 <_printf_common+0x58>
 801d1e8:	2301      	movs	r3, #1
 801d1ea:	4622      	mov	r2, r4
 801d1ec:	4641      	mov	r1, r8
 801d1ee:	4638      	mov	r0, r7
 801d1f0:	47c8      	blx	r9
 801d1f2:	3001      	adds	r0, #1
 801d1f4:	d0e6      	beq.n	801d1c4 <_printf_common+0xa4>
 801d1f6:	3601      	adds	r6, #1
 801d1f8:	e7d9      	b.n	801d1ae <_printf_common+0x8e>
	...

0801d1fc <_printf_i>:
 801d1fc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801d200:	7e0f      	ldrb	r7, [r1, #24]
 801d202:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 801d204:	2f78      	cmp	r7, #120	@ 0x78
 801d206:	4691      	mov	r9, r2
 801d208:	4680      	mov	r8, r0
 801d20a:	460c      	mov	r4, r1
 801d20c:	469a      	mov	sl, r3
 801d20e:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 801d212:	d807      	bhi.n	801d224 <_printf_i+0x28>
 801d214:	2f62      	cmp	r7, #98	@ 0x62
 801d216:	d80a      	bhi.n	801d22e <_printf_i+0x32>
 801d218:	2f00      	cmp	r7, #0
 801d21a:	f000 80d2 	beq.w	801d3c2 <_printf_i+0x1c6>
 801d21e:	2f58      	cmp	r7, #88	@ 0x58
 801d220:	f000 80b9 	beq.w	801d396 <_printf_i+0x19a>
 801d224:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 801d228:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 801d22c:	e03a      	b.n	801d2a4 <_printf_i+0xa8>
 801d22e:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 801d232:	2b15      	cmp	r3, #21
 801d234:	d8f6      	bhi.n	801d224 <_printf_i+0x28>
 801d236:	a101      	add	r1, pc, #4	@ (adr r1, 801d23c <_printf_i+0x40>)
 801d238:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 801d23c:	0801d295 	.word	0x0801d295
 801d240:	0801d2a9 	.word	0x0801d2a9
 801d244:	0801d225 	.word	0x0801d225
 801d248:	0801d225 	.word	0x0801d225
 801d24c:	0801d225 	.word	0x0801d225
 801d250:	0801d225 	.word	0x0801d225
 801d254:	0801d2a9 	.word	0x0801d2a9
 801d258:	0801d225 	.word	0x0801d225
 801d25c:	0801d225 	.word	0x0801d225
 801d260:	0801d225 	.word	0x0801d225
 801d264:	0801d225 	.word	0x0801d225
 801d268:	0801d3a9 	.word	0x0801d3a9
 801d26c:	0801d2d3 	.word	0x0801d2d3
 801d270:	0801d363 	.word	0x0801d363
 801d274:	0801d225 	.word	0x0801d225
 801d278:	0801d225 	.word	0x0801d225
 801d27c:	0801d3cb 	.word	0x0801d3cb
 801d280:	0801d225 	.word	0x0801d225
 801d284:	0801d2d3 	.word	0x0801d2d3
 801d288:	0801d225 	.word	0x0801d225
 801d28c:	0801d225 	.word	0x0801d225
 801d290:	0801d36b 	.word	0x0801d36b
 801d294:	6833      	ldr	r3, [r6, #0]
 801d296:	1d1a      	adds	r2, r3, #4
 801d298:	681b      	ldr	r3, [r3, #0]
 801d29a:	6032      	str	r2, [r6, #0]
 801d29c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 801d2a0:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 801d2a4:	2301      	movs	r3, #1
 801d2a6:	e09d      	b.n	801d3e4 <_printf_i+0x1e8>
 801d2a8:	6833      	ldr	r3, [r6, #0]
 801d2aa:	6820      	ldr	r0, [r4, #0]
 801d2ac:	1d19      	adds	r1, r3, #4
 801d2ae:	6031      	str	r1, [r6, #0]
 801d2b0:	0606      	lsls	r6, r0, #24
 801d2b2:	d501      	bpl.n	801d2b8 <_printf_i+0xbc>
 801d2b4:	681d      	ldr	r5, [r3, #0]
 801d2b6:	e003      	b.n	801d2c0 <_printf_i+0xc4>
 801d2b8:	0645      	lsls	r5, r0, #25
 801d2ba:	d5fb      	bpl.n	801d2b4 <_printf_i+0xb8>
 801d2bc:	f9b3 5000 	ldrsh.w	r5, [r3]
 801d2c0:	2d00      	cmp	r5, #0
 801d2c2:	da03      	bge.n	801d2cc <_printf_i+0xd0>
 801d2c4:	232d      	movs	r3, #45	@ 0x2d
 801d2c6:	426d      	negs	r5, r5
 801d2c8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 801d2cc:	4859      	ldr	r0, [pc, #356]	@ (801d434 <_printf_i+0x238>)
 801d2ce:	230a      	movs	r3, #10
 801d2d0:	e011      	b.n	801d2f6 <_printf_i+0xfa>
 801d2d2:	6821      	ldr	r1, [r4, #0]
 801d2d4:	6833      	ldr	r3, [r6, #0]
 801d2d6:	0608      	lsls	r0, r1, #24
 801d2d8:	f853 5b04 	ldr.w	r5, [r3], #4
 801d2dc:	d402      	bmi.n	801d2e4 <_printf_i+0xe8>
 801d2de:	0649      	lsls	r1, r1, #25
 801d2e0:	bf48      	it	mi
 801d2e2:	b2ad      	uxthmi	r5, r5
 801d2e4:	2f6f      	cmp	r7, #111	@ 0x6f
 801d2e6:	4853      	ldr	r0, [pc, #332]	@ (801d434 <_printf_i+0x238>)
 801d2e8:	6033      	str	r3, [r6, #0]
 801d2ea:	bf14      	ite	ne
 801d2ec:	230a      	movne	r3, #10
 801d2ee:	2308      	moveq	r3, #8
 801d2f0:	2100      	movs	r1, #0
 801d2f2:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 801d2f6:	6866      	ldr	r6, [r4, #4]
 801d2f8:	60a6      	str	r6, [r4, #8]
 801d2fa:	2e00      	cmp	r6, #0
 801d2fc:	bfa2      	ittt	ge
 801d2fe:	6821      	ldrge	r1, [r4, #0]
 801d300:	f021 0104 	bicge.w	r1, r1, #4
 801d304:	6021      	strge	r1, [r4, #0]
 801d306:	b90d      	cbnz	r5, 801d30c <_printf_i+0x110>
 801d308:	2e00      	cmp	r6, #0
 801d30a:	d04b      	beq.n	801d3a4 <_printf_i+0x1a8>
 801d30c:	4616      	mov	r6, r2
 801d30e:	fbb5 f1f3 	udiv	r1, r5, r3
 801d312:	fb03 5711 	mls	r7, r3, r1, r5
 801d316:	5dc7      	ldrb	r7, [r0, r7]
 801d318:	f806 7d01 	strb.w	r7, [r6, #-1]!
 801d31c:	462f      	mov	r7, r5
 801d31e:	42bb      	cmp	r3, r7
 801d320:	460d      	mov	r5, r1
 801d322:	d9f4      	bls.n	801d30e <_printf_i+0x112>
 801d324:	2b08      	cmp	r3, #8
 801d326:	d10b      	bne.n	801d340 <_printf_i+0x144>
 801d328:	6823      	ldr	r3, [r4, #0]
 801d32a:	07df      	lsls	r7, r3, #31
 801d32c:	d508      	bpl.n	801d340 <_printf_i+0x144>
 801d32e:	6923      	ldr	r3, [r4, #16]
 801d330:	6861      	ldr	r1, [r4, #4]
 801d332:	4299      	cmp	r1, r3
 801d334:	bfde      	ittt	le
 801d336:	2330      	movle	r3, #48	@ 0x30
 801d338:	f806 3c01 	strble.w	r3, [r6, #-1]
 801d33c:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
 801d340:	1b92      	subs	r2, r2, r6
 801d342:	6122      	str	r2, [r4, #16]
 801d344:	f8cd a000 	str.w	sl, [sp]
 801d348:	464b      	mov	r3, r9
 801d34a:	aa03      	add	r2, sp, #12
 801d34c:	4621      	mov	r1, r4
 801d34e:	4640      	mov	r0, r8
 801d350:	f7ff fee6 	bl	801d120 <_printf_common>
 801d354:	3001      	adds	r0, #1
 801d356:	d14a      	bne.n	801d3ee <_printf_i+0x1f2>
 801d358:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801d35c:	b004      	add	sp, #16
 801d35e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801d362:	6823      	ldr	r3, [r4, #0]
 801d364:	f043 0320 	orr.w	r3, r3, #32
 801d368:	6023      	str	r3, [r4, #0]
 801d36a:	4833      	ldr	r0, [pc, #204]	@ (801d438 <_printf_i+0x23c>)
 801d36c:	2778      	movs	r7, #120	@ 0x78
 801d36e:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 801d372:	6823      	ldr	r3, [r4, #0]
 801d374:	6831      	ldr	r1, [r6, #0]
 801d376:	061f      	lsls	r7, r3, #24
 801d378:	f851 5b04 	ldr.w	r5, [r1], #4
 801d37c:	d402      	bmi.n	801d384 <_printf_i+0x188>
 801d37e:	065f      	lsls	r7, r3, #25
 801d380:	bf48      	it	mi
 801d382:	b2ad      	uxthmi	r5, r5
 801d384:	6031      	str	r1, [r6, #0]
 801d386:	07d9      	lsls	r1, r3, #31
 801d388:	bf44      	itt	mi
 801d38a:	f043 0320 	orrmi.w	r3, r3, #32
 801d38e:	6023      	strmi	r3, [r4, #0]
 801d390:	b11d      	cbz	r5, 801d39a <_printf_i+0x19e>
 801d392:	2310      	movs	r3, #16
 801d394:	e7ac      	b.n	801d2f0 <_printf_i+0xf4>
 801d396:	4827      	ldr	r0, [pc, #156]	@ (801d434 <_printf_i+0x238>)
 801d398:	e7e9      	b.n	801d36e <_printf_i+0x172>
 801d39a:	6823      	ldr	r3, [r4, #0]
 801d39c:	f023 0320 	bic.w	r3, r3, #32
 801d3a0:	6023      	str	r3, [r4, #0]
 801d3a2:	e7f6      	b.n	801d392 <_printf_i+0x196>
 801d3a4:	4616      	mov	r6, r2
 801d3a6:	e7bd      	b.n	801d324 <_printf_i+0x128>
 801d3a8:	6833      	ldr	r3, [r6, #0]
 801d3aa:	6825      	ldr	r5, [r4, #0]
 801d3ac:	6961      	ldr	r1, [r4, #20]
 801d3ae:	1d18      	adds	r0, r3, #4
 801d3b0:	6030      	str	r0, [r6, #0]
 801d3b2:	062e      	lsls	r6, r5, #24
 801d3b4:	681b      	ldr	r3, [r3, #0]
 801d3b6:	d501      	bpl.n	801d3bc <_printf_i+0x1c0>
 801d3b8:	6019      	str	r1, [r3, #0]
 801d3ba:	e002      	b.n	801d3c2 <_printf_i+0x1c6>
 801d3bc:	0668      	lsls	r0, r5, #25
 801d3be:	d5fb      	bpl.n	801d3b8 <_printf_i+0x1bc>
 801d3c0:	8019      	strh	r1, [r3, #0]
 801d3c2:	2300      	movs	r3, #0
 801d3c4:	6123      	str	r3, [r4, #16]
 801d3c6:	4616      	mov	r6, r2
 801d3c8:	e7bc      	b.n	801d344 <_printf_i+0x148>
 801d3ca:	6833      	ldr	r3, [r6, #0]
 801d3cc:	1d1a      	adds	r2, r3, #4
 801d3ce:	6032      	str	r2, [r6, #0]
 801d3d0:	681e      	ldr	r6, [r3, #0]
 801d3d2:	6862      	ldr	r2, [r4, #4]
 801d3d4:	2100      	movs	r1, #0
 801d3d6:	4630      	mov	r0, r6
 801d3d8:	f7e2 ff02 	bl	80001e0 <memchr>
 801d3dc:	b108      	cbz	r0, 801d3e2 <_printf_i+0x1e6>
 801d3de:	1b80      	subs	r0, r0, r6
 801d3e0:	6060      	str	r0, [r4, #4]
 801d3e2:	6863      	ldr	r3, [r4, #4]
 801d3e4:	6123      	str	r3, [r4, #16]
 801d3e6:	2300      	movs	r3, #0
 801d3e8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 801d3ec:	e7aa      	b.n	801d344 <_printf_i+0x148>
 801d3ee:	6923      	ldr	r3, [r4, #16]
 801d3f0:	4632      	mov	r2, r6
 801d3f2:	4649      	mov	r1, r9
 801d3f4:	4640      	mov	r0, r8
 801d3f6:	47d0      	blx	sl
 801d3f8:	3001      	adds	r0, #1
 801d3fa:	d0ad      	beq.n	801d358 <_printf_i+0x15c>
 801d3fc:	6823      	ldr	r3, [r4, #0]
 801d3fe:	079b      	lsls	r3, r3, #30
 801d400:	d413      	bmi.n	801d42a <_printf_i+0x22e>
 801d402:	68e0      	ldr	r0, [r4, #12]
 801d404:	9b03      	ldr	r3, [sp, #12]
 801d406:	4298      	cmp	r0, r3
 801d408:	bfb8      	it	lt
 801d40a:	4618      	movlt	r0, r3
 801d40c:	e7a6      	b.n	801d35c <_printf_i+0x160>
 801d40e:	2301      	movs	r3, #1
 801d410:	4632      	mov	r2, r6
 801d412:	4649      	mov	r1, r9
 801d414:	4640      	mov	r0, r8
 801d416:	47d0      	blx	sl
 801d418:	3001      	adds	r0, #1
 801d41a:	d09d      	beq.n	801d358 <_printf_i+0x15c>
 801d41c:	3501      	adds	r5, #1
 801d41e:	68e3      	ldr	r3, [r4, #12]
 801d420:	9903      	ldr	r1, [sp, #12]
 801d422:	1a5b      	subs	r3, r3, r1
 801d424:	42ab      	cmp	r3, r5
 801d426:	dcf2      	bgt.n	801d40e <_printf_i+0x212>
 801d428:	e7eb      	b.n	801d402 <_printf_i+0x206>
 801d42a:	2500      	movs	r5, #0
 801d42c:	f104 0619 	add.w	r6, r4, #25
 801d430:	e7f5      	b.n	801d41e <_printf_i+0x222>
 801d432:	bf00      	nop
 801d434:	08023a5a 	.word	0x08023a5a
 801d438:	08023a6b 	.word	0x08023a6b

0801d43c <std>:
 801d43c:	2300      	movs	r3, #0
 801d43e:	b510      	push	{r4, lr}
 801d440:	4604      	mov	r4, r0
 801d442:	e9c0 3300 	strd	r3, r3, [r0]
 801d446:	e9c0 3304 	strd	r3, r3, [r0, #16]
 801d44a:	6083      	str	r3, [r0, #8]
 801d44c:	8181      	strh	r1, [r0, #12]
 801d44e:	6643      	str	r3, [r0, #100]	@ 0x64
 801d450:	81c2      	strh	r2, [r0, #14]
 801d452:	6183      	str	r3, [r0, #24]
 801d454:	4619      	mov	r1, r3
 801d456:	2208      	movs	r2, #8
 801d458:	305c      	adds	r0, #92	@ 0x5c
 801d45a:	f000 f8f4 	bl	801d646 <memset>
 801d45e:	4b0d      	ldr	r3, [pc, #52]	@ (801d494 <std+0x58>)
 801d460:	6263      	str	r3, [r4, #36]	@ 0x24
 801d462:	4b0d      	ldr	r3, [pc, #52]	@ (801d498 <std+0x5c>)
 801d464:	62a3      	str	r3, [r4, #40]	@ 0x28
 801d466:	4b0d      	ldr	r3, [pc, #52]	@ (801d49c <std+0x60>)
 801d468:	62e3      	str	r3, [r4, #44]	@ 0x2c
 801d46a:	4b0d      	ldr	r3, [pc, #52]	@ (801d4a0 <std+0x64>)
 801d46c:	6323      	str	r3, [r4, #48]	@ 0x30
 801d46e:	4b0d      	ldr	r3, [pc, #52]	@ (801d4a4 <std+0x68>)
 801d470:	6224      	str	r4, [r4, #32]
 801d472:	429c      	cmp	r4, r3
 801d474:	d006      	beq.n	801d484 <std+0x48>
 801d476:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 801d47a:	4294      	cmp	r4, r2
 801d47c:	d002      	beq.n	801d484 <std+0x48>
 801d47e:	33d0      	adds	r3, #208	@ 0xd0
 801d480:	429c      	cmp	r4, r3
 801d482:	d105      	bne.n	801d490 <std+0x54>
 801d484:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 801d488:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801d48c:	f000 b958 	b.w	801d740 <__retarget_lock_init_recursive>
 801d490:	bd10      	pop	{r4, pc}
 801d492:	bf00      	nop
 801d494:	0801d5c1 	.word	0x0801d5c1
 801d498:	0801d5e3 	.word	0x0801d5e3
 801d49c:	0801d61b 	.word	0x0801d61b
 801d4a0:	0801d63f 	.word	0x0801d63f
 801d4a4:	20002314 	.word	0x20002314

0801d4a8 <stdio_exit_handler>:
 801d4a8:	4a02      	ldr	r2, [pc, #8]	@ (801d4b4 <stdio_exit_handler+0xc>)
 801d4aa:	4903      	ldr	r1, [pc, #12]	@ (801d4b8 <stdio_exit_handler+0x10>)
 801d4ac:	4803      	ldr	r0, [pc, #12]	@ (801d4bc <stdio_exit_handler+0x14>)
 801d4ae:	f000 b869 	b.w	801d584 <_fwalk_sglue>
 801d4b2:	bf00      	nop
 801d4b4:	20000354 	.word	0x20000354
 801d4b8:	0801ee0d 	.word	0x0801ee0d
 801d4bc:	20000364 	.word	0x20000364

0801d4c0 <cleanup_stdio>:
 801d4c0:	6841      	ldr	r1, [r0, #4]
 801d4c2:	4b0c      	ldr	r3, [pc, #48]	@ (801d4f4 <cleanup_stdio+0x34>)
 801d4c4:	4299      	cmp	r1, r3
 801d4c6:	b510      	push	{r4, lr}
 801d4c8:	4604      	mov	r4, r0
 801d4ca:	d001      	beq.n	801d4d0 <cleanup_stdio+0x10>
 801d4cc:	f001 fc9e 	bl	801ee0c <_fflush_r>
 801d4d0:	68a1      	ldr	r1, [r4, #8]
 801d4d2:	4b09      	ldr	r3, [pc, #36]	@ (801d4f8 <cleanup_stdio+0x38>)
 801d4d4:	4299      	cmp	r1, r3
 801d4d6:	d002      	beq.n	801d4de <cleanup_stdio+0x1e>
 801d4d8:	4620      	mov	r0, r4
 801d4da:	f001 fc97 	bl	801ee0c <_fflush_r>
 801d4de:	68e1      	ldr	r1, [r4, #12]
 801d4e0:	4b06      	ldr	r3, [pc, #24]	@ (801d4fc <cleanup_stdio+0x3c>)
 801d4e2:	4299      	cmp	r1, r3
 801d4e4:	d004      	beq.n	801d4f0 <cleanup_stdio+0x30>
 801d4e6:	4620      	mov	r0, r4
 801d4e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801d4ec:	f001 bc8e 	b.w	801ee0c <_fflush_r>
 801d4f0:	bd10      	pop	{r4, pc}
 801d4f2:	bf00      	nop
 801d4f4:	20002314 	.word	0x20002314
 801d4f8:	2000237c 	.word	0x2000237c
 801d4fc:	200023e4 	.word	0x200023e4

0801d500 <global_stdio_init.part.0>:
 801d500:	b510      	push	{r4, lr}
 801d502:	4b0b      	ldr	r3, [pc, #44]	@ (801d530 <global_stdio_init.part.0+0x30>)
 801d504:	4c0b      	ldr	r4, [pc, #44]	@ (801d534 <global_stdio_init.part.0+0x34>)
 801d506:	4a0c      	ldr	r2, [pc, #48]	@ (801d538 <global_stdio_init.part.0+0x38>)
 801d508:	601a      	str	r2, [r3, #0]
 801d50a:	4620      	mov	r0, r4
 801d50c:	2200      	movs	r2, #0
 801d50e:	2104      	movs	r1, #4
 801d510:	f7ff ff94 	bl	801d43c <std>
 801d514:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 801d518:	2201      	movs	r2, #1
 801d51a:	2109      	movs	r1, #9
 801d51c:	f7ff ff8e 	bl	801d43c <std>
 801d520:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 801d524:	2202      	movs	r2, #2
 801d526:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801d52a:	2112      	movs	r1, #18
 801d52c:	f7ff bf86 	b.w	801d43c <std>
 801d530:	2000244c 	.word	0x2000244c
 801d534:	20002314 	.word	0x20002314
 801d538:	0801d4a9 	.word	0x0801d4a9

0801d53c <__sfp_lock_acquire>:
 801d53c:	4801      	ldr	r0, [pc, #4]	@ (801d544 <__sfp_lock_acquire+0x8>)
 801d53e:	f000 b900 	b.w	801d742 <__retarget_lock_acquire_recursive>
 801d542:	bf00      	nop
 801d544:	20002455 	.word	0x20002455

0801d548 <__sfp_lock_release>:
 801d548:	4801      	ldr	r0, [pc, #4]	@ (801d550 <__sfp_lock_release+0x8>)
 801d54a:	f000 b8fb 	b.w	801d744 <__retarget_lock_release_recursive>
 801d54e:	bf00      	nop
 801d550:	20002455 	.word	0x20002455

0801d554 <__sinit>:
 801d554:	b510      	push	{r4, lr}
 801d556:	4604      	mov	r4, r0
 801d558:	f7ff fff0 	bl	801d53c <__sfp_lock_acquire>
 801d55c:	6a23      	ldr	r3, [r4, #32]
 801d55e:	b11b      	cbz	r3, 801d568 <__sinit+0x14>
 801d560:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801d564:	f7ff bff0 	b.w	801d548 <__sfp_lock_release>
 801d568:	4b04      	ldr	r3, [pc, #16]	@ (801d57c <__sinit+0x28>)
 801d56a:	6223      	str	r3, [r4, #32]
 801d56c:	4b04      	ldr	r3, [pc, #16]	@ (801d580 <__sinit+0x2c>)
 801d56e:	681b      	ldr	r3, [r3, #0]
 801d570:	2b00      	cmp	r3, #0
 801d572:	d1f5      	bne.n	801d560 <__sinit+0xc>
 801d574:	f7ff ffc4 	bl	801d500 <global_stdio_init.part.0>
 801d578:	e7f2      	b.n	801d560 <__sinit+0xc>
 801d57a:	bf00      	nop
 801d57c:	0801d4c1 	.word	0x0801d4c1
 801d580:	2000244c 	.word	0x2000244c

0801d584 <_fwalk_sglue>:
 801d584:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801d588:	4607      	mov	r7, r0
 801d58a:	4688      	mov	r8, r1
 801d58c:	4614      	mov	r4, r2
 801d58e:	2600      	movs	r6, #0
 801d590:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 801d594:	f1b9 0901 	subs.w	r9, r9, #1
 801d598:	d505      	bpl.n	801d5a6 <_fwalk_sglue+0x22>
 801d59a:	6824      	ldr	r4, [r4, #0]
 801d59c:	2c00      	cmp	r4, #0
 801d59e:	d1f7      	bne.n	801d590 <_fwalk_sglue+0xc>
 801d5a0:	4630      	mov	r0, r6
 801d5a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801d5a6:	89ab      	ldrh	r3, [r5, #12]
 801d5a8:	2b01      	cmp	r3, #1
 801d5aa:	d907      	bls.n	801d5bc <_fwalk_sglue+0x38>
 801d5ac:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 801d5b0:	3301      	adds	r3, #1
 801d5b2:	d003      	beq.n	801d5bc <_fwalk_sglue+0x38>
 801d5b4:	4629      	mov	r1, r5
 801d5b6:	4638      	mov	r0, r7
 801d5b8:	47c0      	blx	r8
 801d5ba:	4306      	orrs	r6, r0
 801d5bc:	3568      	adds	r5, #104	@ 0x68
 801d5be:	e7e9      	b.n	801d594 <_fwalk_sglue+0x10>

0801d5c0 <__sread>:
 801d5c0:	b510      	push	{r4, lr}
 801d5c2:	460c      	mov	r4, r1
 801d5c4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801d5c8:	f000 f86c 	bl	801d6a4 <_read_r>
 801d5cc:	2800      	cmp	r0, #0
 801d5ce:	bfab      	itete	ge
 801d5d0:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 801d5d2:	89a3      	ldrhlt	r3, [r4, #12]
 801d5d4:	181b      	addge	r3, r3, r0
 801d5d6:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 801d5da:	bfac      	ite	ge
 801d5dc:	6563      	strge	r3, [r4, #84]	@ 0x54
 801d5de:	81a3      	strhlt	r3, [r4, #12]
 801d5e0:	bd10      	pop	{r4, pc}

0801d5e2 <__swrite>:
 801d5e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d5e6:	461f      	mov	r7, r3
 801d5e8:	898b      	ldrh	r3, [r1, #12]
 801d5ea:	05db      	lsls	r3, r3, #23
 801d5ec:	4605      	mov	r5, r0
 801d5ee:	460c      	mov	r4, r1
 801d5f0:	4616      	mov	r6, r2
 801d5f2:	d505      	bpl.n	801d600 <__swrite+0x1e>
 801d5f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801d5f8:	2302      	movs	r3, #2
 801d5fa:	2200      	movs	r2, #0
 801d5fc:	f000 f840 	bl	801d680 <_lseek_r>
 801d600:	89a3      	ldrh	r3, [r4, #12]
 801d602:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801d606:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 801d60a:	81a3      	strh	r3, [r4, #12]
 801d60c:	4632      	mov	r2, r6
 801d60e:	463b      	mov	r3, r7
 801d610:	4628      	mov	r0, r5
 801d612:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801d616:	f000 b857 	b.w	801d6c8 <_write_r>

0801d61a <__sseek>:
 801d61a:	b510      	push	{r4, lr}
 801d61c:	460c      	mov	r4, r1
 801d61e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801d622:	f000 f82d 	bl	801d680 <_lseek_r>
 801d626:	1c43      	adds	r3, r0, #1
 801d628:	89a3      	ldrh	r3, [r4, #12]
 801d62a:	bf15      	itete	ne
 801d62c:	6560      	strne	r0, [r4, #84]	@ 0x54
 801d62e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 801d632:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 801d636:	81a3      	strheq	r3, [r4, #12]
 801d638:	bf18      	it	ne
 801d63a:	81a3      	strhne	r3, [r4, #12]
 801d63c:	bd10      	pop	{r4, pc}

0801d63e <__sclose>:
 801d63e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801d642:	f000 b80d 	b.w	801d660 <_close_r>

0801d646 <memset>:
 801d646:	4402      	add	r2, r0
 801d648:	4603      	mov	r3, r0
 801d64a:	4293      	cmp	r3, r2
 801d64c:	d100      	bne.n	801d650 <memset+0xa>
 801d64e:	4770      	bx	lr
 801d650:	f803 1b01 	strb.w	r1, [r3], #1
 801d654:	e7f9      	b.n	801d64a <memset+0x4>
	...

0801d658 <_localeconv_r>:
 801d658:	4800      	ldr	r0, [pc, #0]	@ (801d65c <_localeconv_r+0x4>)
 801d65a:	4770      	bx	lr
 801d65c:	200004a0 	.word	0x200004a0

0801d660 <_close_r>:
 801d660:	b538      	push	{r3, r4, r5, lr}
 801d662:	4d06      	ldr	r5, [pc, #24]	@ (801d67c <_close_r+0x1c>)
 801d664:	2300      	movs	r3, #0
 801d666:	4604      	mov	r4, r0
 801d668:	4608      	mov	r0, r1
 801d66a:	602b      	str	r3, [r5, #0]
 801d66c:	f7e8 fcd8 	bl	8006020 <_close>
 801d670:	1c43      	adds	r3, r0, #1
 801d672:	d102      	bne.n	801d67a <_close_r+0x1a>
 801d674:	682b      	ldr	r3, [r5, #0]
 801d676:	b103      	cbz	r3, 801d67a <_close_r+0x1a>
 801d678:	6023      	str	r3, [r4, #0]
 801d67a:	bd38      	pop	{r3, r4, r5, pc}
 801d67c:	20002450 	.word	0x20002450

0801d680 <_lseek_r>:
 801d680:	b538      	push	{r3, r4, r5, lr}
 801d682:	4d07      	ldr	r5, [pc, #28]	@ (801d6a0 <_lseek_r+0x20>)
 801d684:	4604      	mov	r4, r0
 801d686:	4608      	mov	r0, r1
 801d688:	4611      	mov	r1, r2
 801d68a:	2200      	movs	r2, #0
 801d68c:	602a      	str	r2, [r5, #0]
 801d68e:	461a      	mov	r2, r3
 801d690:	f7e8 fced 	bl	800606e <_lseek>
 801d694:	1c43      	adds	r3, r0, #1
 801d696:	d102      	bne.n	801d69e <_lseek_r+0x1e>
 801d698:	682b      	ldr	r3, [r5, #0]
 801d69a:	b103      	cbz	r3, 801d69e <_lseek_r+0x1e>
 801d69c:	6023      	str	r3, [r4, #0]
 801d69e:	bd38      	pop	{r3, r4, r5, pc}
 801d6a0:	20002450 	.word	0x20002450

0801d6a4 <_read_r>:
 801d6a4:	b538      	push	{r3, r4, r5, lr}
 801d6a6:	4d07      	ldr	r5, [pc, #28]	@ (801d6c4 <_read_r+0x20>)
 801d6a8:	4604      	mov	r4, r0
 801d6aa:	4608      	mov	r0, r1
 801d6ac:	4611      	mov	r1, r2
 801d6ae:	2200      	movs	r2, #0
 801d6b0:	602a      	str	r2, [r5, #0]
 801d6b2:	461a      	mov	r2, r3
 801d6b4:	f7e8 fc7b 	bl	8005fae <_read>
 801d6b8:	1c43      	adds	r3, r0, #1
 801d6ba:	d102      	bne.n	801d6c2 <_read_r+0x1e>
 801d6bc:	682b      	ldr	r3, [r5, #0]
 801d6be:	b103      	cbz	r3, 801d6c2 <_read_r+0x1e>
 801d6c0:	6023      	str	r3, [r4, #0]
 801d6c2:	bd38      	pop	{r3, r4, r5, pc}
 801d6c4:	20002450 	.word	0x20002450

0801d6c8 <_write_r>:
 801d6c8:	b538      	push	{r3, r4, r5, lr}
 801d6ca:	4d07      	ldr	r5, [pc, #28]	@ (801d6e8 <_write_r+0x20>)
 801d6cc:	4604      	mov	r4, r0
 801d6ce:	4608      	mov	r0, r1
 801d6d0:	4611      	mov	r1, r2
 801d6d2:	2200      	movs	r2, #0
 801d6d4:	602a      	str	r2, [r5, #0]
 801d6d6:	461a      	mov	r2, r3
 801d6d8:	f7e8 fc86 	bl	8005fe8 <_write>
 801d6dc:	1c43      	adds	r3, r0, #1
 801d6de:	d102      	bne.n	801d6e6 <_write_r+0x1e>
 801d6e0:	682b      	ldr	r3, [r5, #0]
 801d6e2:	b103      	cbz	r3, 801d6e6 <_write_r+0x1e>
 801d6e4:	6023      	str	r3, [r4, #0]
 801d6e6:	bd38      	pop	{r3, r4, r5, pc}
 801d6e8:	20002450 	.word	0x20002450

0801d6ec <__errno>:
 801d6ec:	4b01      	ldr	r3, [pc, #4]	@ (801d6f4 <__errno+0x8>)
 801d6ee:	6818      	ldr	r0, [r3, #0]
 801d6f0:	4770      	bx	lr
 801d6f2:	bf00      	nop
 801d6f4:	20000360 	.word	0x20000360

0801d6f8 <__libc_init_array>:
 801d6f8:	b570      	push	{r4, r5, r6, lr}
 801d6fa:	4d0d      	ldr	r5, [pc, #52]	@ (801d730 <__libc_init_array+0x38>)
 801d6fc:	4c0d      	ldr	r4, [pc, #52]	@ (801d734 <__libc_init_array+0x3c>)
 801d6fe:	1b64      	subs	r4, r4, r5
 801d700:	10a4      	asrs	r4, r4, #2
 801d702:	2600      	movs	r6, #0
 801d704:	42a6      	cmp	r6, r4
 801d706:	d109      	bne.n	801d71c <__libc_init_array+0x24>
 801d708:	4d0b      	ldr	r5, [pc, #44]	@ (801d738 <__libc_init_array+0x40>)
 801d70a:	4c0c      	ldr	r4, [pc, #48]	@ (801d73c <__libc_init_array+0x44>)
 801d70c:	f006 f948 	bl	80239a0 <_init>
 801d710:	1b64      	subs	r4, r4, r5
 801d712:	10a4      	asrs	r4, r4, #2
 801d714:	2600      	movs	r6, #0
 801d716:	42a6      	cmp	r6, r4
 801d718:	d105      	bne.n	801d726 <__libc_init_array+0x2e>
 801d71a:	bd70      	pop	{r4, r5, r6, pc}
 801d71c:	f855 3b04 	ldr.w	r3, [r5], #4
 801d720:	4798      	blx	r3
 801d722:	3601      	adds	r6, #1
 801d724:	e7ee      	b.n	801d704 <__libc_init_array+0xc>
 801d726:	f855 3b04 	ldr.w	r3, [r5], #4
 801d72a:	4798      	blx	r3
 801d72c:	3601      	adds	r6, #1
 801d72e:	e7f2      	b.n	801d716 <__libc_init_array+0x1e>
 801d730:	08024440 	.word	0x08024440
 801d734:	08024440 	.word	0x08024440
 801d738:	08024440 	.word	0x08024440
 801d73c:	08024444 	.word	0x08024444

0801d740 <__retarget_lock_init_recursive>:
 801d740:	4770      	bx	lr

0801d742 <__retarget_lock_acquire_recursive>:
 801d742:	4770      	bx	lr

0801d744 <__retarget_lock_release_recursive>:
 801d744:	4770      	bx	lr

0801d746 <memcpy>:
 801d746:	440a      	add	r2, r1
 801d748:	4291      	cmp	r1, r2
 801d74a:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
 801d74e:	d100      	bne.n	801d752 <memcpy+0xc>
 801d750:	4770      	bx	lr
 801d752:	b510      	push	{r4, lr}
 801d754:	f811 4b01 	ldrb.w	r4, [r1], #1
 801d758:	f803 4f01 	strb.w	r4, [r3, #1]!
 801d75c:	4291      	cmp	r1, r2
 801d75e:	d1f9      	bne.n	801d754 <memcpy+0xe>
 801d760:	bd10      	pop	{r4, pc}

0801d762 <quorem>:
 801d762:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d766:	6903      	ldr	r3, [r0, #16]
 801d768:	690c      	ldr	r4, [r1, #16]
 801d76a:	42a3      	cmp	r3, r4
 801d76c:	4607      	mov	r7, r0
 801d76e:	db7e      	blt.n	801d86e <quorem+0x10c>
 801d770:	3c01      	subs	r4, #1
 801d772:	f101 0814 	add.w	r8, r1, #20
 801d776:	00a3      	lsls	r3, r4, #2
 801d778:	f100 0514 	add.w	r5, r0, #20
 801d77c:	9300      	str	r3, [sp, #0]
 801d77e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 801d782:	9301      	str	r3, [sp, #4]
 801d784:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 801d788:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 801d78c:	3301      	adds	r3, #1
 801d78e:	429a      	cmp	r2, r3
 801d790:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 801d794:	fbb2 f6f3 	udiv	r6, r2, r3
 801d798:	d32e      	bcc.n	801d7f8 <quorem+0x96>
 801d79a:	f04f 0a00 	mov.w	sl, #0
 801d79e:	46c4      	mov	ip, r8
 801d7a0:	46ae      	mov	lr, r5
 801d7a2:	46d3      	mov	fp, sl
 801d7a4:	f85c 3b04 	ldr.w	r3, [ip], #4
 801d7a8:	b298      	uxth	r0, r3
 801d7aa:	fb06 a000 	mla	r0, r6, r0, sl
 801d7ae:	0c02      	lsrs	r2, r0, #16
 801d7b0:	0c1b      	lsrs	r3, r3, #16
 801d7b2:	fb06 2303 	mla	r3, r6, r3, r2
 801d7b6:	f8de 2000 	ldr.w	r2, [lr]
 801d7ba:	b280      	uxth	r0, r0
 801d7bc:	b292      	uxth	r2, r2
 801d7be:	1a12      	subs	r2, r2, r0
 801d7c0:	445a      	add	r2, fp
 801d7c2:	f8de 0000 	ldr.w	r0, [lr]
 801d7c6:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 801d7ca:	b29b      	uxth	r3, r3
 801d7cc:	ebc3 4322 	rsb	r3, r3, r2, asr #16
 801d7d0:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 801d7d4:	b292      	uxth	r2, r2
 801d7d6:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 801d7da:	45e1      	cmp	r9, ip
 801d7dc:	f84e 2b04 	str.w	r2, [lr], #4
 801d7e0:	ea4f 4b23 	mov.w	fp, r3, asr #16
 801d7e4:	d2de      	bcs.n	801d7a4 <quorem+0x42>
 801d7e6:	9b00      	ldr	r3, [sp, #0]
 801d7e8:	58eb      	ldr	r3, [r5, r3]
 801d7ea:	b92b      	cbnz	r3, 801d7f8 <quorem+0x96>
 801d7ec:	9b01      	ldr	r3, [sp, #4]
 801d7ee:	3b04      	subs	r3, #4
 801d7f0:	429d      	cmp	r5, r3
 801d7f2:	461a      	mov	r2, r3
 801d7f4:	d32f      	bcc.n	801d856 <quorem+0xf4>
 801d7f6:	613c      	str	r4, [r7, #16]
 801d7f8:	4638      	mov	r0, r7
 801d7fa:	f001 f97b 	bl	801eaf4 <__mcmp>
 801d7fe:	2800      	cmp	r0, #0
 801d800:	db25      	blt.n	801d84e <quorem+0xec>
 801d802:	4629      	mov	r1, r5
 801d804:	2000      	movs	r0, #0
 801d806:	f858 2b04 	ldr.w	r2, [r8], #4
 801d80a:	f8d1 c000 	ldr.w	ip, [r1]
 801d80e:	fa1f fe82 	uxth.w	lr, r2
 801d812:	fa1f f38c 	uxth.w	r3, ip
 801d816:	eba3 030e 	sub.w	r3, r3, lr
 801d81a:	4403      	add	r3, r0
 801d81c:	0c12      	lsrs	r2, r2, #16
 801d81e:	ebc2 4223 	rsb	r2, r2, r3, asr #16
 801d822:	eb02 421c 	add.w	r2, r2, ip, lsr #16
 801d826:	b29b      	uxth	r3, r3
 801d828:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 801d82c:	45c1      	cmp	r9, r8
 801d82e:	f841 3b04 	str.w	r3, [r1], #4
 801d832:	ea4f 4022 	mov.w	r0, r2, asr #16
 801d836:	d2e6      	bcs.n	801d806 <quorem+0xa4>
 801d838:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 801d83c:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 801d840:	b922      	cbnz	r2, 801d84c <quorem+0xea>
 801d842:	3b04      	subs	r3, #4
 801d844:	429d      	cmp	r5, r3
 801d846:	461a      	mov	r2, r3
 801d848:	d30b      	bcc.n	801d862 <quorem+0x100>
 801d84a:	613c      	str	r4, [r7, #16]
 801d84c:	3601      	adds	r6, #1
 801d84e:	4630      	mov	r0, r6
 801d850:	b003      	add	sp, #12
 801d852:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d856:	6812      	ldr	r2, [r2, #0]
 801d858:	3b04      	subs	r3, #4
 801d85a:	2a00      	cmp	r2, #0
 801d85c:	d1cb      	bne.n	801d7f6 <quorem+0x94>
 801d85e:	3c01      	subs	r4, #1
 801d860:	e7c6      	b.n	801d7f0 <quorem+0x8e>
 801d862:	6812      	ldr	r2, [r2, #0]
 801d864:	3b04      	subs	r3, #4
 801d866:	2a00      	cmp	r2, #0
 801d868:	d1ef      	bne.n	801d84a <quorem+0xe8>
 801d86a:	3c01      	subs	r4, #1
 801d86c:	e7ea      	b.n	801d844 <quorem+0xe2>
 801d86e:	2000      	movs	r0, #0
 801d870:	e7ee      	b.n	801d850 <quorem+0xee>
 801d872:	0000      	movs	r0, r0
 801d874:	0000      	movs	r0, r0
	...

0801d878 <_dtoa_r>:
 801d878:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d87c:	69c7      	ldr	r7, [r0, #28]
 801d87e:	b099      	sub	sp, #100	@ 0x64
 801d880:	ed8d 0b02 	vstr	d0, [sp, #8]
 801d884:	ec55 4b10 	vmov	r4, r5, d0
 801d888:	9e22      	ldr	r6, [sp, #136]	@ 0x88
 801d88a:	9109      	str	r1, [sp, #36]	@ 0x24
 801d88c:	4683      	mov	fp, r0
 801d88e:	920e      	str	r2, [sp, #56]	@ 0x38
 801d890:	9313      	str	r3, [sp, #76]	@ 0x4c
 801d892:	b97f      	cbnz	r7, 801d8b4 <_dtoa_r+0x3c>
 801d894:	2010      	movs	r0, #16
 801d896:	f000 fdfd 	bl	801e494 <malloc>
 801d89a:	4602      	mov	r2, r0
 801d89c:	f8cb 001c 	str.w	r0, [fp, #28]
 801d8a0:	b920      	cbnz	r0, 801d8ac <_dtoa_r+0x34>
 801d8a2:	4ba7      	ldr	r3, [pc, #668]	@ (801db40 <_dtoa_r+0x2c8>)
 801d8a4:	21ef      	movs	r1, #239	@ 0xef
 801d8a6:	48a7      	ldr	r0, [pc, #668]	@ (801db44 <_dtoa_r+0x2cc>)
 801d8a8:	f001 fae8 	bl	801ee7c <__assert_func>
 801d8ac:	e9c0 7701 	strd	r7, r7, [r0, #4]
 801d8b0:	6007      	str	r7, [r0, #0]
 801d8b2:	60c7      	str	r7, [r0, #12]
 801d8b4:	f8db 301c 	ldr.w	r3, [fp, #28]
 801d8b8:	6819      	ldr	r1, [r3, #0]
 801d8ba:	b159      	cbz	r1, 801d8d4 <_dtoa_r+0x5c>
 801d8bc:	685a      	ldr	r2, [r3, #4]
 801d8be:	604a      	str	r2, [r1, #4]
 801d8c0:	2301      	movs	r3, #1
 801d8c2:	4093      	lsls	r3, r2
 801d8c4:	608b      	str	r3, [r1, #8]
 801d8c6:	4658      	mov	r0, fp
 801d8c8:	f000 feda 	bl	801e680 <_Bfree>
 801d8cc:	f8db 301c 	ldr.w	r3, [fp, #28]
 801d8d0:	2200      	movs	r2, #0
 801d8d2:	601a      	str	r2, [r3, #0]
 801d8d4:	1e2b      	subs	r3, r5, #0
 801d8d6:	bfb9      	ittee	lt
 801d8d8:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
 801d8dc:	9303      	strlt	r3, [sp, #12]
 801d8de:	2300      	movge	r3, #0
 801d8e0:	6033      	strge	r3, [r6, #0]
 801d8e2:	9f03      	ldr	r7, [sp, #12]
 801d8e4:	4b98      	ldr	r3, [pc, #608]	@ (801db48 <_dtoa_r+0x2d0>)
 801d8e6:	bfbc      	itt	lt
 801d8e8:	2201      	movlt	r2, #1
 801d8ea:	6032      	strlt	r2, [r6, #0]
 801d8ec:	43bb      	bics	r3, r7
 801d8ee:	d112      	bne.n	801d916 <_dtoa_r+0x9e>
 801d8f0:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 801d8f2:	f242 730f 	movw	r3, #9999	@ 0x270f
 801d8f6:	6013      	str	r3, [r2, #0]
 801d8f8:	f3c7 0313 	ubfx	r3, r7, #0, #20
 801d8fc:	4323      	orrs	r3, r4
 801d8fe:	f000 854d 	beq.w	801e39c <_dtoa_r+0xb24>
 801d902:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 801d904:	f8df a254 	ldr.w	sl, [pc, #596]	@ 801db5c <_dtoa_r+0x2e4>
 801d908:	2b00      	cmp	r3, #0
 801d90a:	f000 854f 	beq.w	801e3ac <_dtoa_r+0xb34>
 801d90e:	f10a 0303 	add.w	r3, sl, #3
 801d912:	f000 bd49 	b.w	801e3a8 <_dtoa_r+0xb30>
 801d916:	ed9d 7b02 	vldr	d7, [sp, #8]
 801d91a:	2200      	movs	r2, #0
 801d91c:	ec51 0b17 	vmov	r0, r1, d7
 801d920:	2300      	movs	r3, #0
 801d922:	ed8d 7b0c 	vstr	d7, [sp, #48]	@ 0x30
 801d926:	f7e3 f8d7 	bl	8000ad8 <__aeabi_dcmpeq>
 801d92a:	4680      	mov	r8, r0
 801d92c:	b158      	cbz	r0, 801d946 <_dtoa_r+0xce>
 801d92e:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 801d930:	2301      	movs	r3, #1
 801d932:	6013      	str	r3, [r2, #0]
 801d934:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 801d936:	b113      	cbz	r3, 801d93e <_dtoa_r+0xc6>
 801d938:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 801d93a:	4b84      	ldr	r3, [pc, #528]	@ (801db4c <_dtoa_r+0x2d4>)
 801d93c:	6013      	str	r3, [r2, #0]
 801d93e:	f8df a220 	ldr.w	sl, [pc, #544]	@ 801db60 <_dtoa_r+0x2e8>
 801d942:	f000 bd33 	b.w	801e3ac <_dtoa_r+0xb34>
 801d946:	ed9d 0b0c 	vldr	d0, [sp, #48]	@ 0x30
 801d94a:	aa16      	add	r2, sp, #88	@ 0x58
 801d94c:	a917      	add	r1, sp, #92	@ 0x5c
 801d94e:	4658      	mov	r0, fp
 801d950:	f001 f980 	bl	801ec54 <__d2b>
 801d954:	f3c7 560a 	ubfx	r6, r7, #20, #11
 801d958:	4681      	mov	r9, r0
 801d95a:	2e00      	cmp	r6, #0
 801d95c:	d077      	beq.n	801da4e <_dtoa_r+0x1d6>
 801d95e:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 801d960:	f8cd 8050 	str.w	r8, [sp, #80]	@ 0x50
 801d964:	f3c3 0313 	ubfx	r3, r3, #0, #20
 801d968:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 801d96c:	f043 537f 	orr.w	r3, r3, #1069547520	@ 0x3fc00000
 801d970:	f443 1340 	orr.w	r3, r3, #3145728	@ 0x300000
 801d974:	f2a6 36ff 	subw	r6, r6, #1023	@ 0x3ff
 801d978:	4619      	mov	r1, r3
 801d97a:	2200      	movs	r2, #0
 801d97c:	4b74      	ldr	r3, [pc, #464]	@ (801db50 <_dtoa_r+0x2d8>)
 801d97e:	f7e2 fc8b 	bl	8000298 <__aeabi_dsub>
 801d982:	a369      	add	r3, pc, #420	@ (adr r3, 801db28 <_dtoa_r+0x2b0>)
 801d984:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d988:	f7e2 fe3e 	bl	8000608 <__aeabi_dmul>
 801d98c:	a368      	add	r3, pc, #416	@ (adr r3, 801db30 <_dtoa_r+0x2b8>)
 801d98e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d992:	f7e2 fc83 	bl	800029c <__adddf3>
 801d996:	4604      	mov	r4, r0
 801d998:	4630      	mov	r0, r6
 801d99a:	460d      	mov	r5, r1
 801d99c:	f7e2 fdca 	bl	8000534 <__aeabi_i2d>
 801d9a0:	a365      	add	r3, pc, #404	@ (adr r3, 801db38 <_dtoa_r+0x2c0>)
 801d9a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d9a6:	f7e2 fe2f 	bl	8000608 <__aeabi_dmul>
 801d9aa:	4602      	mov	r2, r0
 801d9ac:	460b      	mov	r3, r1
 801d9ae:	4620      	mov	r0, r4
 801d9b0:	4629      	mov	r1, r5
 801d9b2:	f7e2 fc73 	bl	800029c <__adddf3>
 801d9b6:	4604      	mov	r4, r0
 801d9b8:	460d      	mov	r5, r1
 801d9ba:	f7e3 f8d5 	bl	8000b68 <__aeabi_d2iz>
 801d9be:	2200      	movs	r2, #0
 801d9c0:	4607      	mov	r7, r0
 801d9c2:	2300      	movs	r3, #0
 801d9c4:	4620      	mov	r0, r4
 801d9c6:	4629      	mov	r1, r5
 801d9c8:	f7e3 f890 	bl	8000aec <__aeabi_dcmplt>
 801d9cc:	b140      	cbz	r0, 801d9e0 <_dtoa_r+0x168>
 801d9ce:	4638      	mov	r0, r7
 801d9d0:	f7e2 fdb0 	bl	8000534 <__aeabi_i2d>
 801d9d4:	4622      	mov	r2, r4
 801d9d6:	462b      	mov	r3, r5
 801d9d8:	f7e3 f87e 	bl	8000ad8 <__aeabi_dcmpeq>
 801d9dc:	b900      	cbnz	r0, 801d9e0 <_dtoa_r+0x168>
 801d9de:	3f01      	subs	r7, #1
 801d9e0:	2f16      	cmp	r7, #22
 801d9e2:	d851      	bhi.n	801da88 <_dtoa_r+0x210>
 801d9e4:	4b5b      	ldr	r3, [pc, #364]	@ (801db54 <_dtoa_r+0x2dc>)
 801d9e6:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 801d9ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 801d9ee:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 801d9f2:	f7e3 f87b 	bl	8000aec <__aeabi_dcmplt>
 801d9f6:	2800      	cmp	r0, #0
 801d9f8:	d048      	beq.n	801da8c <_dtoa_r+0x214>
 801d9fa:	3f01      	subs	r7, #1
 801d9fc:	2300      	movs	r3, #0
 801d9fe:	9312      	str	r3, [sp, #72]	@ 0x48
 801da00:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 801da02:	1b9b      	subs	r3, r3, r6
 801da04:	1e5a      	subs	r2, r3, #1
 801da06:	bf44      	itt	mi
 801da08:	f1c3 0801 	rsbmi	r8, r3, #1
 801da0c:	2300      	movmi	r3, #0
 801da0e:	9208      	str	r2, [sp, #32]
 801da10:	bf54      	ite	pl
 801da12:	f04f 0800 	movpl.w	r8, #0
 801da16:	9308      	strmi	r3, [sp, #32]
 801da18:	2f00      	cmp	r7, #0
 801da1a:	db39      	blt.n	801da90 <_dtoa_r+0x218>
 801da1c:	9b08      	ldr	r3, [sp, #32]
 801da1e:	970f      	str	r7, [sp, #60]	@ 0x3c
 801da20:	443b      	add	r3, r7
 801da22:	9308      	str	r3, [sp, #32]
 801da24:	2300      	movs	r3, #0
 801da26:	930a      	str	r3, [sp, #40]	@ 0x28
 801da28:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801da2a:	2b09      	cmp	r3, #9
 801da2c:	d864      	bhi.n	801daf8 <_dtoa_r+0x280>
 801da2e:	2b05      	cmp	r3, #5
 801da30:	bfc4      	itt	gt
 801da32:	3b04      	subgt	r3, #4
 801da34:	9309      	strgt	r3, [sp, #36]	@ 0x24
 801da36:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801da38:	f1a3 0302 	sub.w	r3, r3, #2
 801da3c:	bfcc      	ite	gt
 801da3e:	2400      	movgt	r4, #0
 801da40:	2401      	movle	r4, #1
 801da42:	2b03      	cmp	r3, #3
 801da44:	d863      	bhi.n	801db0e <_dtoa_r+0x296>
 801da46:	e8df f003 	tbb	[pc, r3]
 801da4a:	372a      	.short	0x372a
 801da4c:	5535      	.short	0x5535
 801da4e:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	@ 0x58
 801da52:	441e      	add	r6, r3
 801da54:	f206 4332 	addw	r3, r6, #1074	@ 0x432
 801da58:	2b20      	cmp	r3, #32
 801da5a:	bfc1      	itttt	gt
 801da5c:	f1c3 0340 	rsbgt	r3, r3, #64	@ 0x40
 801da60:	409f      	lslgt	r7, r3
 801da62:	f206 4312 	addwgt	r3, r6, #1042	@ 0x412
 801da66:	fa24 f303 	lsrgt.w	r3, r4, r3
 801da6a:	bfd6      	itet	le
 801da6c:	f1c3 0320 	rsble	r3, r3, #32
 801da70:	ea47 0003 	orrgt.w	r0, r7, r3
 801da74:	fa04 f003 	lslle.w	r0, r4, r3
 801da78:	f7e2 fd4c 	bl	8000514 <__aeabi_ui2d>
 801da7c:	2201      	movs	r2, #1
 801da7e:	f1a1 73f8 	sub.w	r3, r1, #32505856	@ 0x1f00000
 801da82:	3e01      	subs	r6, #1
 801da84:	9214      	str	r2, [sp, #80]	@ 0x50
 801da86:	e777      	b.n	801d978 <_dtoa_r+0x100>
 801da88:	2301      	movs	r3, #1
 801da8a:	e7b8      	b.n	801d9fe <_dtoa_r+0x186>
 801da8c:	9012      	str	r0, [sp, #72]	@ 0x48
 801da8e:	e7b7      	b.n	801da00 <_dtoa_r+0x188>
 801da90:	427b      	negs	r3, r7
 801da92:	930a      	str	r3, [sp, #40]	@ 0x28
 801da94:	2300      	movs	r3, #0
 801da96:	eba8 0807 	sub.w	r8, r8, r7
 801da9a:	930f      	str	r3, [sp, #60]	@ 0x3c
 801da9c:	e7c4      	b.n	801da28 <_dtoa_r+0x1b0>
 801da9e:	2300      	movs	r3, #0
 801daa0:	930b      	str	r3, [sp, #44]	@ 0x2c
 801daa2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 801daa4:	2b00      	cmp	r3, #0
 801daa6:	dc35      	bgt.n	801db14 <_dtoa_r+0x29c>
 801daa8:	2301      	movs	r3, #1
 801daaa:	9300      	str	r3, [sp, #0]
 801daac:	9307      	str	r3, [sp, #28]
 801daae:	461a      	mov	r2, r3
 801dab0:	920e      	str	r2, [sp, #56]	@ 0x38
 801dab2:	e00b      	b.n	801dacc <_dtoa_r+0x254>
 801dab4:	2301      	movs	r3, #1
 801dab6:	e7f3      	b.n	801daa0 <_dtoa_r+0x228>
 801dab8:	2300      	movs	r3, #0
 801daba:	930b      	str	r3, [sp, #44]	@ 0x2c
 801dabc:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 801dabe:	18fb      	adds	r3, r7, r3
 801dac0:	9300      	str	r3, [sp, #0]
 801dac2:	3301      	adds	r3, #1
 801dac4:	2b01      	cmp	r3, #1
 801dac6:	9307      	str	r3, [sp, #28]
 801dac8:	bfb8      	it	lt
 801daca:	2301      	movlt	r3, #1
 801dacc:	f8db 001c 	ldr.w	r0, [fp, #28]
 801dad0:	2100      	movs	r1, #0
 801dad2:	2204      	movs	r2, #4
 801dad4:	f102 0514 	add.w	r5, r2, #20
 801dad8:	429d      	cmp	r5, r3
 801dada:	d91f      	bls.n	801db1c <_dtoa_r+0x2a4>
 801dadc:	6041      	str	r1, [r0, #4]
 801dade:	4658      	mov	r0, fp
 801dae0:	f000 fd8e 	bl	801e600 <_Balloc>
 801dae4:	4682      	mov	sl, r0
 801dae6:	2800      	cmp	r0, #0
 801dae8:	d13c      	bne.n	801db64 <_dtoa_r+0x2ec>
 801daea:	4b1b      	ldr	r3, [pc, #108]	@ (801db58 <_dtoa_r+0x2e0>)
 801daec:	4602      	mov	r2, r0
 801daee:	f240 11af 	movw	r1, #431	@ 0x1af
 801daf2:	e6d8      	b.n	801d8a6 <_dtoa_r+0x2e>
 801daf4:	2301      	movs	r3, #1
 801daf6:	e7e0      	b.n	801daba <_dtoa_r+0x242>
 801daf8:	2401      	movs	r4, #1
 801dafa:	2300      	movs	r3, #0
 801dafc:	9309      	str	r3, [sp, #36]	@ 0x24
 801dafe:	940b      	str	r4, [sp, #44]	@ 0x2c
 801db00:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 801db04:	9300      	str	r3, [sp, #0]
 801db06:	9307      	str	r3, [sp, #28]
 801db08:	2200      	movs	r2, #0
 801db0a:	2312      	movs	r3, #18
 801db0c:	e7d0      	b.n	801dab0 <_dtoa_r+0x238>
 801db0e:	2301      	movs	r3, #1
 801db10:	930b      	str	r3, [sp, #44]	@ 0x2c
 801db12:	e7f5      	b.n	801db00 <_dtoa_r+0x288>
 801db14:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 801db16:	9300      	str	r3, [sp, #0]
 801db18:	9307      	str	r3, [sp, #28]
 801db1a:	e7d7      	b.n	801dacc <_dtoa_r+0x254>
 801db1c:	3101      	adds	r1, #1
 801db1e:	0052      	lsls	r2, r2, #1
 801db20:	e7d8      	b.n	801dad4 <_dtoa_r+0x25c>
 801db22:	bf00      	nop
 801db24:	f3af 8000 	nop.w
 801db28:	636f4361 	.word	0x636f4361
 801db2c:	3fd287a7 	.word	0x3fd287a7
 801db30:	8b60c8b3 	.word	0x8b60c8b3
 801db34:	3fc68a28 	.word	0x3fc68a28
 801db38:	509f79fb 	.word	0x509f79fb
 801db3c:	3fd34413 	.word	0x3fd34413
 801db40:	08023a89 	.word	0x08023a89
 801db44:	08023aa0 	.word	0x08023aa0
 801db48:	7ff00000 	.word	0x7ff00000
 801db4c:	08023a59 	.word	0x08023a59
 801db50:	3ff80000 	.word	0x3ff80000
 801db54:	08023b98 	.word	0x08023b98
 801db58:	08023af8 	.word	0x08023af8
 801db5c:	08023a85 	.word	0x08023a85
 801db60:	08023a58 	.word	0x08023a58
 801db64:	f8db 301c 	ldr.w	r3, [fp, #28]
 801db68:	6018      	str	r0, [r3, #0]
 801db6a:	9b07      	ldr	r3, [sp, #28]
 801db6c:	2b0e      	cmp	r3, #14
 801db6e:	f200 80a4 	bhi.w	801dcba <_dtoa_r+0x442>
 801db72:	2c00      	cmp	r4, #0
 801db74:	f000 80a1 	beq.w	801dcba <_dtoa_r+0x442>
 801db78:	2f00      	cmp	r7, #0
 801db7a:	dd33      	ble.n	801dbe4 <_dtoa_r+0x36c>
 801db7c:	4bad      	ldr	r3, [pc, #692]	@ (801de34 <_dtoa_r+0x5bc>)
 801db7e:	f007 020f 	and.w	r2, r7, #15
 801db82:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801db86:	ed93 7b00 	vldr	d7, [r3]
 801db8a:	05f8      	lsls	r0, r7, #23
 801db8c:	ed8d 7b04 	vstr	d7, [sp, #16]
 801db90:	ea4f 1427 	mov.w	r4, r7, asr #4
 801db94:	d516      	bpl.n	801dbc4 <_dtoa_r+0x34c>
 801db96:	4ba8      	ldr	r3, [pc, #672]	@ (801de38 <_dtoa_r+0x5c0>)
 801db98:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 801db9c:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 801dba0:	f7e2 fe5c 	bl	800085c <__aeabi_ddiv>
 801dba4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801dba8:	f004 040f 	and.w	r4, r4, #15
 801dbac:	2603      	movs	r6, #3
 801dbae:	4da2      	ldr	r5, [pc, #648]	@ (801de38 <_dtoa_r+0x5c0>)
 801dbb0:	b954      	cbnz	r4, 801dbc8 <_dtoa_r+0x350>
 801dbb2:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801dbb6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801dbba:	f7e2 fe4f 	bl	800085c <__aeabi_ddiv>
 801dbbe:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801dbc2:	e028      	b.n	801dc16 <_dtoa_r+0x39e>
 801dbc4:	2602      	movs	r6, #2
 801dbc6:	e7f2      	b.n	801dbae <_dtoa_r+0x336>
 801dbc8:	07e1      	lsls	r1, r4, #31
 801dbca:	d508      	bpl.n	801dbde <_dtoa_r+0x366>
 801dbcc:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 801dbd0:	e9d5 2300 	ldrd	r2, r3, [r5]
 801dbd4:	f7e2 fd18 	bl	8000608 <__aeabi_dmul>
 801dbd8:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801dbdc:	3601      	adds	r6, #1
 801dbde:	1064      	asrs	r4, r4, #1
 801dbe0:	3508      	adds	r5, #8
 801dbe2:	e7e5      	b.n	801dbb0 <_dtoa_r+0x338>
 801dbe4:	f000 80d2 	beq.w	801dd8c <_dtoa_r+0x514>
 801dbe8:	427c      	negs	r4, r7
 801dbea:	4b92      	ldr	r3, [pc, #584]	@ (801de34 <_dtoa_r+0x5bc>)
 801dbec:	4d92      	ldr	r5, [pc, #584]	@ (801de38 <_dtoa_r+0x5c0>)
 801dbee:	f004 020f 	and.w	r2, r4, #15
 801dbf2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801dbf6:	e9d3 2300 	ldrd	r2, r3, [r3]
 801dbfa:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 801dbfe:	f7e2 fd03 	bl	8000608 <__aeabi_dmul>
 801dc02:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801dc06:	1124      	asrs	r4, r4, #4
 801dc08:	2300      	movs	r3, #0
 801dc0a:	2602      	movs	r6, #2
 801dc0c:	2c00      	cmp	r4, #0
 801dc0e:	f040 80b2 	bne.w	801dd76 <_dtoa_r+0x4fe>
 801dc12:	2b00      	cmp	r3, #0
 801dc14:	d1d3      	bne.n	801dbbe <_dtoa_r+0x346>
 801dc16:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 801dc18:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 801dc1c:	2b00      	cmp	r3, #0
 801dc1e:	f000 80b7 	beq.w	801dd90 <_dtoa_r+0x518>
 801dc22:	4b86      	ldr	r3, [pc, #536]	@ (801de3c <_dtoa_r+0x5c4>)
 801dc24:	2200      	movs	r2, #0
 801dc26:	4620      	mov	r0, r4
 801dc28:	4629      	mov	r1, r5
 801dc2a:	f7e2 ff5f 	bl	8000aec <__aeabi_dcmplt>
 801dc2e:	2800      	cmp	r0, #0
 801dc30:	f000 80ae 	beq.w	801dd90 <_dtoa_r+0x518>
 801dc34:	9b07      	ldr	r3, [sp, #28]
 801dc36:	2b00      	cmp	r3, #0
 801dc38:	f000 80aa 	beq.w	801dd90 <_dtoa_r+0x518>
 801dc3c:	9b00      	ldr	r3, [sp, #0]
 801dc3e:	2b00      	cmp	r3, #0
 801dc40:	dd37      	ble.n	801dcb2 <_dtoa_r+0x43a>
 801dc42:	1e7b      	subs	r3, r7, #1
 801dc44:	9304      	str	r3, [sp, #16]
 801dc46:	4620      	mov	r0, r4
 801dc48:	4b7d      	ldr	r3, [pc, #500]	@ (801de40 <_dtoa_r+0x5c8>)
 801dc4a:	2200      	movs	r2, #0
 801dc4c:	4629      	mov	r1, r5
 801dc4e:	f7e2 fcdb 	bl	8000608 <__aeabi_dmul>
 801dc52:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801dc56:	9c00      	ldr	r4, [sp, #0]
 801dc58:	3601      	adds	r6, #1
 801dc5a:	4630      	mov	r0, r6
 801dc5c:	f7e2 fc6a 	bl	8000534 <__aeabi_i2d>
 801dc60:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801dc64:	f7e2 fcd0 	bl	8000608 <__aeabi_dmul>
 801dc68:	4b76      	ldr	r3, [pc, #472]	@ (801de44 <_dtoa_r+0x5cc>)
 801dc6a:	2200      	movs	r2, #0
 801dc6c:	f7e2 fb16 	bl	800029c <__adddf3>
 801dc70:	4605      	mov	r5, r0
 801dc72:	f1a1 7650 	sub.w	r6, r1, #54525952	@ 0x3400000
 801dc76:	2c00      	cmp	r4, #0
 801dc78:	f040 808d 	bne.w	801dd96 <_dtoa_r+0x51e>
 801dc7c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801dc80:	4b71      	ldr	r3, [pc, #452]	@ (801de48 <_dtoa_r+0x5d0>)
 801dc82:	2200      	movs	r2, #0
 801dc84:	f7e2 fb08 	bl	8000298 <__aeabi_dsub>
 801dc88:	4602      	mov	r2, r0
 801dc8a:	460b      	mov	r3, r1
 801dc8c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 801dc90:	462a      	mov	r2, r5
 801dc92:	4633      	mov	r3, r6
 801dc94:	f7e2 ff48 	bl	8000b28 <__aeabi_dcmpgt>
 801dc98:	2800      	cmp	r0, #0
 801dc9a:	f040 828b 	bne.w	801e1b4 <_dtoa_r+0x93c>
 801dc9e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801dca2:	462a      	mov	r2, r5
 801dca4:	f106 4300 	add.w	r3, r6, #2147483648	@ 0x80000000
 801dca8:	f7e2 ff20 	bl	8000aec <__aeabi_dcmplt>
 801dcac:	2800      	cmp	r0, #0
 801dcae:	f040 8128 	bne.w	801df02 <_dtoa_r+0x68a>
 801dcb2:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	@ 0x30
 801dcb6:	e9cd 3402 	strd	r3, r4, [sp, #8]
 801dcba:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 801dcbc:	2b00      	cmp	r3, #0
 801dcbe:	f2c0 815a 	blt.w	801df76 <_dtoa_r+0x6fe>
 801dcc2:	2f0e      	cmp	r7, #14
 801dcc4:	f300 8157 	bgt.w	801df76 <_dtoa_r+0x6fe>
 801dcc8:	4b5a      	ldr	r3, [pc, #360]	@ (801de34 <_dtoa_r+0x5bc>)
 801dcca:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 801dcce:	ed93 7b00 	vldr	d7, [r3]
 801dcd2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 801dcd4:	2b00      	cmp	r3, #0
 801dcd6:	ed8d 7b00 	vstr	d7, [sp]
 801dcda:	da03      	bge.n	801dce4 <_dtoa_r+0x46c>
 801dcdc:	9b07      	ldr	r3, [sp, #28]
 801dcde:	2b00      	cmp	r3, #0
 801dce0:	f340 8101 	ble.w	801dee6 <_dtoa_r+0x66e>
 801dce4:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 801dce8:	4656      	mov	r6, sl
 801dcea:	e9dd 2300 	ldrd	r2, r3, [sp]
 801dcee:	4620      	mov	r0, r4
 801dcf0:	4629      	mov	r1, r5
 801dcf2:	f7e2 fdb3 	bl	800085c <__aeabi_ddiv>
 801dcf6:	f7e2 ff37 	bl	8000b68 <__aeabi_d2iz>
 801dcfa:	4680      	mov	r8, r0
 801dcfc:	f7e2 fc1a 	bl	8000534 <__aeabi_i2d>
 801dd00:	e9dd 2300 	ldrd	r2, r3, [sp]
 801dd04:	f7e2 fc80 	bl	8000608 <__aeabi_dmul>
 801dd08:	4602      	mov	r2, r0
 801dd0a:	460b      	mov	r3, r1
 801dd0c:	4620      	mov	r0, r4
 801dd0e:	4629      	mov	r1, r5
 801dd10:	f108 0430 	add.w	r4, r8, #48	@ 0x30
 801dd14:	f7e2 fac0 	bl	8000298 <__aeabi_dsub>
 801dd18:	f806 4b01 	strb.w	r4, [r6], #1
 801dd1c:	9d07      	ldr	r5, [sp, #28]
 801dd1e:	eba6 040a 	sub.w	r4, r6, sl
 801dd22:	42a5      	cmp	r5, r4
 801dd24:	4602      	mov	r2, r0
 801dd26:	460b      	mov	r3, r1
 801dd28:	f040 8117 	bne.w	801df5a <_dtoa_r+0x6e2>
 801dd2c:	f7e2 fab6 	bl	800029c <__adddf3>
 801dd30:	e9dd 2300 	ldrd	r2, r3, [sp]
 801dd34:	4604      	mov	r4, r0
 801dd36:	460d      	mov	r5, r1
 801dd38:	f7e2 fef6 	bl	8000b28 <__aeabi_dcmpgt>
 801dd3c:	2800      	cmp	r0, #0
 801dd3e:	f040 80f9 	bne.w	801df34 <_dtoa_r+0x6bc>
 801dd42:	e9dd 2300 	ldrd	r2, r3, [sp]
 801dd46:	4620      	mov	r0, r4
 801dd48:	4629      	mov	r1, r5
 801dd4a:	f7e2 fec5 	bl	8000ad8 <__aeabi_dcmpeq>
 801dd4e:	b118      	cbz	r0, 801dd58 <_dtoa_r+0x4e0>
 801dd50:	f018 0f01 	tst.w	r8, #1
 801dd54:	f040 80ee 	bne.w	801df34 <_dtoa_r+0x6bc>
 801dd58:	4649      	mov	r1, r9
 801dd5a:	4658      	mov	r0, fp
 801dd5c:	f000 fc90 	bl	801e680 <_Bfree>
 801dd60:	2300      	movs	r3, #0
 801dd62:	7033      	strb	r3, [r6, #0]
 801dd64:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 801dd66:	3701      	adds	r7, #1
 801dd68:	601f      	str	r7, [r3, #0]
 801dd6a:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 801dd6c:	2b00      	cmp	r3, #0
 801dd6e:	f000 831d 	beq.w	801e3ac <_dtoa_r+0xb34>
 801dd72:	601e      	str	r6, [r3, #0]
 801dd74:	e31a      	b.n	801e3ac <_dtoa_r+0xb34>
 801dd76:	07e2      	lsls	r2, r4, #31
 801dd78:	d505      	bpl.n	801dd86 <_dtoa_r+0x50e>
 801dd7a:	e9d5 2300 	ldrd	r2, r3, [r5]
 801dd7e:	f7e2 fc43 	bl	8000608 <__aeabi_dmul>
 801dd82:	3601      	adds	r6, #1
 801dd84:	2301      	movs	r3, #1
 801dd86:	1064      	asrs	r4, r4, #1
 801dd88:	3508      	adds	r5, #8
 801dd8a:	e73f      	b.n	801dc0c <_dtoa_r+0x394>
 801dd8c:	2602      	movs	r6, #2
 801dd8e:	e742      	b.n	801dc16 <_dtoa_r+0x39e>
 801dd90:	9c07      	ldr	r4, [sp, #28]
 801dd92:	9704      	str	r7, [sp, #16]
 801dd94:	e761      	b.n	801dc5a <_dtoa_r+0x3e2>
 801dd96:	4b27      	ldr	r3, [pc, #156]	@ (801de34 <_dtoa_r+0x5bc>)
 801dd98:	990b      	ldr	r1, [sp, #44]	@ 0x2c
 801dd9a:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 801dd9e:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 801dda2:	4454      	add	r4, sl
 801dda4:	2900      	cmp	r1, #0
 801dda6:	d053      	beq.n	801de50 <_dtoa_r+0x5d8>
 801dda8:	4928      	ldr	r1, [pc, #160]	@ (801de4c <_dtoa_r+0x5d4>)
 801ddaa:	2000      	movs	r0, #0
 801ddac:	f7e2 fd56 	bl	800085c <__aeabi_ddiv>
 801ddb0:	4633      	mov	r3, r6
 801ddb2:	462a      	mov	r2, r5
 801ddb4:	f7e2 fa70 	bl	8000298 <__aeabi_dsub>
 801ddb8:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 801ddbc:	4656      	mov	r6, sl
 801ddbe:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801ddc2:	f7e2 fed1 	bl	8000b68 <__aeabi_d2iz>
 801ddc6:	4605      	mov	r5, r0
 801ddc8:	f7e2 fbb4 	bl	8000534 <__aeabi_i2d>
 801ddcc:	4602      	mov	r2, r0
 801ddce:	460b      	mov	r3, r1
 801ddd0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801ddd4:	f7e2 fa60 	bl	8000298 <__aeabi_dsub>
 801ddd8:	3530      	adds	r5, #48	@ 0x30
 801ddda:	4602      	mov	r2, r0
 801dddc:	460b      	mov	r3, r1
 801ddde:	e9cd 2302 	strd	r2, r3, [sp, #8]
 801dde2:	f806 5b01 	strb.w	r5, [r6], #1
 801dde6:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 801ddea:	f7e2 fe7f 	bl	8000aec <__aeabi_dcmplt>
 801ddee:	2800      	cmp	r0, #0
 801ddf0:	d171      	bne.n	801ded6 <_dtoa_r+0x65e>
 801ddf2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801ddf6:	4911      	ldr	r1, [pc, #68]	@ (801de3c <_dtoa_r+0x5c4>)
 801ddf8:	2000      	movs	r0, #0
 801ddfa:	f7e2 fa4d 	bl	8000298 <__aeabi_dsub>
 801ddfe:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 801de02:	f7e2 fe73 	bl	8000aec <__aeabi_dcmplt>
 801de06:	2800      	cmp	r0, #0
 801de08:	f040 8095 	bne.w	801df36 <_dtoa_r+0x6be>
 801de0c:	42a6      	cmp	r6, r4
 801de0e:	f43f af50 	beq.w	801dcb2 <_dtoa_r+0x43a>
 801de12:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	@ 0x40
 801de16:	4b0a      	ldr	r3, [pc, #40]	@ (801de40 <_dtoa_r+0x5c8>)
 801de18:	2200      	movs	r2, #0
 801de1a:	f7e2 fbf5 	bl	8000608 <__aeabi_dmul>
 801de1e:	4b08      	ldr	r3, [pc, #32]	@ (801de40 <_dtoa_r+0x5c8>)
 801de20:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 801de24:	2200      	movs	r2, #0
 801de26:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801de2a:	f7e2 fbed 	bl	8000608 <__aeabi_dmul>
 801de2e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801de32:	e7c4      	b.n	801ddbe <_dtoa_r+0x546>
 801de34:	08023b98 	.word	0x08023b98
 801de38:	08023b70 	.word	0x08023b70
 801de3c:	3ff00000 	.word	0x3ff00000
 801de40:	40240000 	.word	0x40240000
 801de44:	401c0000 	.word	0x401c0000
 801de48:	40140000 	.word	0x40140000
 801de4c:	3fe00000 	.word	0x3fe00000
 801de50:	4631      	mov	r1, r6
 801de52:	4628      	mov	r0, r5
 801de54:	f7e2 fbd8 	bl	8000608 <__aeabi_dmul>
 801de58:	e9cd 0110 	strd	r0, r1, [sp, #64]	@ 0x40
 801de5c:	9415      	str	r4, [sp, #84]	@ 0x54
 801de5e:	4656      	mov	r6, sl
 801de60:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801de64:	f7e2 fe80 	bl	8000b68 <__aeabi_d2iz>
 801de68:	4605      	mov	r5, r0
 801de6a:	f7e2 fb63 	bl	8000534 <__aeabi_i2d>
 801de6e:	4602      	mov	r2, r0
 801de70:	460b      	mov	r3, r1
 801de72:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801de76:	f7e2 fa0f 	bl	8000298 <__aeabi_dsub>
 801de7a:	3530      	adds	r5, #48	@ 0x30
 801de7c:	f806 5b01 	strb.w	r5, [r6], #1
 801de80:	4602      	mov	r2, r0
 801de82:	460b      	mov	r3, r1
 801de84:	42a6      	cmp	r6, r4
 801de86:	e9cd 2302 	strd	r2, r3, [sp, #8]
 801de8a:	f04f 0200 	mov.w	r2, #0
 801de8e:	d124      	bne.n	801deda <_dtoa_r+0x662>
 801de90:	4bac      	ldr	r3, [pc, #688]	@ (801e144 <_dtoa_r+0x8cc>)
 801de92:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	@ 0x40
 801de96:	f7e2 fa01 	bl	800029c <__adddf3>
 801de9a:	4602      	mov	r2, r0
 801de9c:	460b      	mov	r3, r1
 801de9e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801dea2:	f7e2 fe41 	bl	8000b28 <__aeabi_dcmpgt>
 801dea6:	2800      	cmp	r0, #0
 801dea8:	d145      	bne.n	801df36 <_dtoa_r+0x6be>
 801deaa:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	@ 0x40
 801deae:	49a5      	ldr	r1, [pc, #660]	@ (801e144 <_dtoa_r+0x8cc>)
 801deb0:	2000      	movs	r0, #0
 801deb2:	f7e2 f9f1 	bl	8000298 <__aeabi_dsub>
 801deb6:	4602      	mov	r2, r0
 801deb8:	460b      	mov	r3, r1
 801deba:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801debe:	f7e2 fe15 	bl	8000aec <__aeabi_dcmplt>
 801dec2:	2800      	cmp	r0, #0
 801dec4:	f43f aef5 	beq.w	801dcb2 <_dtoa_r+0x43a>
 801dec8:	9e15      	ldr	r6, [sp, #84]	@ 0x54
 801deca:	1e73      	subs	r3, r6, #1
 801decc:	9315      	str	r3, [sp, #84]	@ 0x54
 801dece:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 801ded2:	2b30      	cmp	r3, #48	@ 0x30
 801ded4:	d0f8      	beq.n	801dec8 <_dtoa_r+0x650>
 801ded6:	9f04      	ldr	r7, [sp, #16]
 801ded8:	e73e      	b.n	801dd58 <_dtoa_r+0x4e0>
 801deda:	4b9b      	ldr	r3, [pc, #620]	@ (801e148 <_dtoa_r+0x8d0>)
 801dedc:	f7e2 fb94 	bl	8000608 <__aeabi_dmul>
 801dee0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 801dee4:	e7bc      	b.n	801de60 <_dtoa_r+0x5e8>
 801dee6:	d10c      	bne.n	801df02 <_dtoa_r+0x68a>
 801dee8:	4b98      	ldr	r3, [pc, #608]	@ (801e14c <_dtoa_r+0x8d4>)
 801deea:	2200      	movs	r2, #0
 801deec:	e9dd 0100 	ldrd	r0, r1, [sp]
 801def0:	f7e2 fb8a 	bl	8000608 <__aeabi_dmul>
 801def4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801def8:	f7e2 fe0c 	bl	8000b14 <__aeabi_dcmpge>
 801defc:	2800      	cmp	r0, #0
 801defe:	f000 8157 	beq.w	801e1b0 <_dtoa_r+0x938>
 801df02:	2400      	movs	r4, #0
 801df04:	4625      	mov	r5, r4
 801df06:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 801df08:	43db      	mvns	r3, r3
 801df0a:	9304      	str	r3, [sp, #16]
 801df0c:	4656      	mov	r6, sl
 801df0e:	2700      	movs	r7, #0
 801df10:	4621      	mov	r1, r4
 801df12:	4658      	mov	r0, fp
 801df14:	f000 fbb4 	bl	801e680 <_Bfree>
 801df18:	2d00      	cmp	r5, #0
 801df1a:	d0dc      	beq.n	801ded6 <_dtoa_r+0x65e>
 801df1c:	b12f      	cbz	r7, 801df2a <_dtoa_r+0x6b2>
 801df1e:	42af      	cmp	r7, r5
 801df20:	d003      	beq.n	801df2a <_dtoa_r+0x6b2>
 801df22:	4639      	mov	r1, r7
 801df24:	4658      	mov	r0, fp
 801df26:	f000 fbab 	bl	801e680 <_Bfree>
 801df2a:	4629      	mov	r1, r5
 801df2c:	4658      	mov	r0, fp
 801df2e:	f000 fba7 	bl	801e680 <_Bfree>
 801df32:	e7d0      	b.n	801ded6 <_dtoa_r+0x65e>
 801df34:	9704      	str	r7, [sp, #16]
 801df36:	4633      	mov	r3, r6
 801df38:	461e      	mov	r6, r3
 801df3a:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 801df3e:	2a39      	cmp	r2, #57	@ 0x39
 801df40:	d107      	bne.n	801df52 <_dtoa_r+0x6da>
 801df42:	459a      	cmp	sl, r3
 801df44:	d1f8      	bne.n	801df38 <_dtoa_r+0x6c0>
 801df46:	9a04      	ldr	r2, [sp, #16]
 801df48:	3201      	adds	r2, #1
 801df4a:	9204      	str	r2, [sp, #16]
 801df4c:	2230      	movs	r2, #48	@ 0x30
 801df4e:	f88a 2000 	strb.w	r2, [sl]
 801df52:	781a      	ldrb	r2, [r3, #0]
 801df54:	3201      	adds	r2, #1
 801df56:	701a      	strb	r2, [r3, #0]
 801df58:	e7bd      	b.n	801ded6 <_dtoa_r+0x65e>
 801df5a:	4b7b      	ldr	r3, [pc, #492]	@ (801e148 <_dtoa_r+0x8d0>)
 801df5c:	2200      	movs	r2, #0
 801df5e:	f7e2 fb53 	bl	8000608 <__aeabi_dmul>
 801df62:	2200      	movs	r2, #0
 801df64:	2300      	movs	r3, #0
 801df66:	4604      	mov	r4, r0
 801df68:	460d      	mov	r5, r1
 801df6a:	f7e2 fdb5 	bl	8000ad8 <__aeabi_dcmpeq>
 801df6e:	2800      	cmp	r0, #0
 801df70:	f43f aebb 	beq.w	801dcea <_dtoa_r+0x472>
 801df74:	e6f0      	b.n	801dd58 <_dtoa_r+0x4e0>
 801df76:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 801df78:	2a00      	cmp	r2, #0
 801df7a:	f000 80db 	beq.w	801e134 <_dtoa_r+0x8bc>
 801df7e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801df80:	2a01      	cmp	r2, #1
 801df82:	f300 80bf 	bgt.w	801e104 <_dtoa_r+0x88c>
 801df86:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 801df88:	2a00      	cmp	r2, #0
 801df8a:	f000 80b7 	beq.w	801e0fc <_dtoa_r+0x884>
 801df8e:	f203 4333 	addw	r3, r3, #1075	@ 0x433
 801df92:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 801df94:	4646      	mov	r6, r8
 801df96:	9a08      	ldr	r2, [sp, #32]
 801df98:	2101      	movs	r1, #1
 801df9a:	441a      	add	r2, r3
 801df9c:	4658      	mov	r0, fp
 801df9e:	4498      	add	r8, r3
 801dfa0:	9208      	str	r2, [sp, #32]
 801dfa2:	f000 fc21 	bl	801e7e8 <__i2b>
 801dfa6:	4605      	mov	r5, r0
 801dfa8:	b15e      	cbz	r6, 801dfc2 <_dtoa_r+0x74a>
 801dfaa:	9b08      	ldr	r3, [sp, #32]
 801dfac:	2b00      	cmp	r3, #0
 801dfae:	dd08      	ble.n	801dfc2 <_dtoa_r+0x74a>
 801dfb0:	42b3      	cmp	r3, r6
 801dfb2:	9a08      	ldr	r2, [sp, #32]
 801dfb4:	bfa8      	it	ge
 801dfb6:	4633      	movge	r3, r6
 801dfb8:	eba8 0803 	sub.w	r8, r8, r3
 801dfbc:	1af6      	subs	r6, r6, r3
 801dfbe:	1ad3      	subs	r3, r2, r3
 801dfc0:	9308      	str	r3, [sp, #32]
 801dfc2:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801dfc4:	b1f3      	cbz	r3, 801e004 <_dtoa_r+0x78c>
 801dfc6:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801dfc8:	2b00      	cmp	r3, #0
 801dfca:	f000 80b7 	beq.w	801e13c <_dtoa_r+0x8c4>
 801dfce:	b18c      	cbz	r4, 801dff4 <_dtoa_r+0x77c>
 801dfd0:	4629      	mov	r1, r5
 801dfd2:	4622      	mov	r2, r4
 801dfd4:	4658      	mov	r0, fp
 801dfd6:	f000 fcc7 	bl	801e968 <__pow5mult>
 801dfda:	464a      	mov	r2, r9
 801dfdc:	4601      	mov	r1, r0
 801dfde:	4605      	mov	r5, r0
 801dfe0:	4658      	mov	r0, fp
 801dfe2:	f000 fc17 	bl	801e814 <__multiply>
 801dfe6:	4649      	mov	r1, r9
 801dfe8:	9004      	str	r0, [sp, #16]
 801dfea:	4658      	mov	r0, fp
 801dfec:	f000 fb48 	bl	801e680 <_Bfree>
 801dff0:	9b04      	ldr	r3, [sp, #16]
 801dff2:	4699      	mov	r9, r3
 801dff4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801dff6:	1b1a      	subs	r2, r3, r4
 801dff8:	d004      	beq.n	801e004 <_dtoa_r+0x78c>
 801dffa:	4649      	mov	r1, r9
 801dffc:	4658      	mov	r0, fp
 801dffe:	f000 fcb3 	bl	801e968 <__pow5mult>
 801e002:	4681      	mov	r9, r0
 801e004:	2101      	movs	r1, #1
 801e006:	4658      	mov	r0, fp
 801e008:	f000 fbee 	bl	801e7e8 <__i2b>
 801e00c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 801e00e:	4604      	mov	r4, r0
 801e010:	2b00      	cmp	r3, #0
 801e012:	f000 81cf 	beq.w	801e3b4 <_dtoa_r+0xb3c>
 801e016:	461a      	mov	r2, r3
 801e018:	4601      	mov	r1, r0
 801e01a:	4658      	mov	r0, fp
 801e01c:	f000 fca4 	bl	801e968 <__pow5mult>
 801e020:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801e022:	2b01      	cmp	r3, #1
 801e024:	4604      	mov	r4, r0
 801e026:	f300 8095 	bgt.w	801e154 <_dtoa_r+0x8dc>
 801e02a:	9b02      	ldr	r3, [sp, #8]
 801e02c:	2b00      	cmp	r3, #0
 801e02e:	f040 8087 	bne.w	801e140 <_dtoa_r+0x8c8>
 801e032:	9b03      	ldr	r3, [sp, #12]
 801e034:	f3c3 0313 	ubfx	r3, r3, #0, #20
 801e038:	2b00      	cmp	r3, #0
 801e03a:	f040 8089 	bne.w	801e150 <_dtoa_r+0x8d8>
 801e03e:	9b03      	ldr	r3, [sp, #12]
 801e040:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 801e044:	0d1b      	lsrs	r3, r3, #20
 801e046:	051b      	lsls	r3, r3, #20
 801e048:	b12b      	cbz	r3, 801e056 <_dtoa_r+0x7de>
 801e04a:	9b08      	ldr	r3, [sp, #32]
 801e04c:	3301      	adds	r3, #1
 801e04e:	9308      	str	r3, [sp, #32]
 801e050:	f108 0801 	add.w	r8, r8, #1
 801e054:	2301      	movs	r3, #1
 801e056:	930a      	str	r3, [sp, #40]	@ 0x28
 801e058:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 801e05a:	2b00      	cmp	r3, #0
 801e05c:	f000 81b0 	beq.w	801e3c0 <_dtoa_r+0xb48>
 801e060:	6923      	ldr	r3, [r4, #16]
 801e062:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801e066:	6918      	ldr	r0, [r3, #16]
 801e068:	f000 fb72 	bl	801e750 <__hi0bits>
 801e06c:	f1c0 0020 	rsb	r0, r0, #32
 801e070:	9b08      	ldr	r3, [sp, #32]
 801e072:	4418      	add	r0, r3
 801e074:	f010 001f 	ands.w	r0, r0, #31
 801e078:	d077      	beq.n	801e16a <_dtoa_r+0x8f2>
 801e07a:	f1c0 0320 	rsb	r3, r0, #32
 801e07e:	2b04      	cmp	r3, #4
 801e080:	dd6b      	ble.n	801e15a <_dtoa_r+0x8e2>
 801e082:	9b08      	ldr	r3, [sp, #32]
 801e084:	f1c0 001c 	rsb	r0, r0, #28
 801e088:	4403      	add	r3, r0
 801e08a:	4480      	add	r8, r0
 801e08c:	4406      	add	r6, r0
 801e08e:	9308      	str	r3, [sp, #32]
 801e090:	f1b8 0f00 	cmp.w	r8, #0
 801e094:	dd05      	ble.n	801e0a2 <_dtoa_r+0x82a>
 801e096:	4649      	mov	r1, r9
 801e098:	4642      	mov	r2, r8
 801e09a:	4658      	mov	r0, fp
 801e09c:	f000 fcbe 	bl	801ea1c <__lshift>
 801e0a0:	4681      	mov	r9, r0
 801e0a2:	9b08      	ldr	r3, [sp, #32]
 801e0a4:	2b00      	cmp	r3, #0
 801e0a6:	dd05      	ble.n	801e0b4 <_dtoa_r+0x83c>
 801e0a8:	4621      	mov	r1, r4
 801e0aa:	461a      	mov	r2, r3
 801e0ac:	4658      	mov	r0, fp
 801e0ae:	f000 fcb5 	bl	801ea1c <__lshift>
 801e0b2:	4604      	mov	r4, r0
 801e0b4:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 801e0b6:	2b00      	cmp	r3, #0
 801e0b8:	d059      	beq.n	801e16e <_dtoa_r+0x8f6>
 801e0ba:	4621      	mov	r1, r4
 801e0bc:	4648      	mov	r0, r9
 801e0be:	f000 fd19 	bl	801eaf4 <__mcmp>
 801e0c2:	2800      	cmp	r0, #0
 801e0c4:	da53      	bge.n	801e16e <_dtoa_r+0x8f6>
 801e0c6:	1e7b      	subs	r3, r7, #1
 801e0c8:	9304      	str	r3, [sp, #16]
 801e0ca:	4649      	mov	r1, r9
 801e0cc:	2300      	movs	r3, #0
 801e0ce:	220a      	movs	r2, #10
 801e0d0:	4658      	mov	r0, fp
 801e0d2:	f000 faf7 	bl	801e6c4 <__multadd>
 801e0d6:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801e0d8:	4681      	mov	r9, r0
 801e0da:	2b00      	cmp	r3, #0
 801e0dc:	f000 8172 	beq.w	801e3c4 <_dtoa_r+0xb4c>
 801e0e0:	2300      	movs	r3, #0
 801e0e2:	4629      	mov	r1, r5
 801e0e4:	220a      	movs	r2, #10
 801e0e6:	4658      	mov	r0, fp
 801e0e8:	f000 faec 	bl	801e6c4 <__multadd>
 801e0ec:	9b00      	ldr	r3, [sp, #0]
 801e0ee:	2b00      	cmp	r3, #0
 801e0f0:	4605      	mov	r5, r0
 801e0f2:	dc67      	bgt.n	801e1c4 <_dtoa_r+0x94c>
 801e0f4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801e0f6:	2b02      	cmp	r3, #2
 801e0f8:	dc41      	bgt.n	801e17e <_dtoa_r+0x906>
 801e0fa:	e063      	b.n	801e1c4 <_dtoa_r+0x94c>
 801e0fc:	9b16      	ldr	r3, [sp, #88]	@ 0x58
 801e0fe:	f1c3 0336 	rsb	r3, r3, #54	@ 0x36
 801e102:	e746      	b.n	801df92 <_dtoa_r+0x71a>
 801e104:	9b07      	ldr	r3, [sp, #28]
 801e106:	1e5c      	subs	r4, r3, #1
 801e108:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801e10a:	42a3      	cmp	r3, r4
 801e10c:	bfbf      	itttt	lt
 801e10e:	9b0a      	ldrlt	r3, [sp, #40]	@ 0x28
 801e110:	9a0f      	ldrlt	r2, [sp, #60]	@ 0x3c
 801e112:	940a      	strlt	r4, [sp, #40]	@ 0x28
 801e114:	1ae3      	sublt	r3, r4, r3
 801e116:	bfb4      	ite	lt
 801e118:	18d2      	addlt	r2, r2, r3
 801e11a:	1b1c      	subge	r4, r3, r4
 801e11c:	9b07      	ldr	r3, [sp, #28]
 801e11e:	bfbc      	itt	lt
 801e120:	920f      	strlt	r2, [sp, #60]	@ 0x3c
 801e122:	2400      	movlt	r4, #0
 801e124:	2b00      	cmp	r3, #0
 801e126:	bfb5      	itete	lt
 801e128:	eba8 0603 	sublt.w	r6, r8, r3
 801e12c:	9b07      	ldrge	r3, [sp, #28]
 801e12e:	2300      	movlt	r3, #0
 801e130:	4646      	movge	r6, r8
 801e132:	e730      	b.n	801df96 <_dtoa_r+0x71e>
 801e134:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 801e136:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 801e138:	4646      	mov	r6, r8
 801e13a:	e735      	b.n	801dfa8 <_dtoa_r+0x730>
 801e13c:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 801e13e:	e75c      	b.n	801dffa <_dtoa_r+0x782>
 801e140:	2300      	movs	r3, #0
 801e142:	e788      	b.n	801e056 <_dtoa_r+0x7de>
 801e144:	3fe00000 	.word	0x3fe00000
 801e148:	40240000 	.word	0x40240000
 801e14c:	40140000 	.word	0x40140000
 801e150:	9b02      	ldr	r3, [sp, #8]
 801e152:	e780      	b.n	801e056 <_dtoa_r+0x7de>
 801e154:	2300      	movs	r3, #0
 801e156:	930a      	str	r3, [sp, #40]	@ 0x28
 801e158:	e782      	b.n	801e060 <_dtoa_r+0x7e8>
 801e15a:	d099      	beq.n	801e090 <_dtoa_r+0x818>
 801e15c:	9a08      	ldr	r2, [sp, #32]
 801e15e:	331c      	adds	r3, #28
 801e160:	441a      	add	r2, r3
 801e162:	4498      	add	r8, r3
 801e164:	441e      	add	r6, r3
 801e166:	9208      	str	r2, [sp, #32]
 801e168:	e792      	b.n	801e090 <_dtoa_r+0x818>
 801e16a:	4603      	mov	r3, r0
 801e16c:	e7f6      	b.n	801e15c <_dtoa_r+0x8e4>
 801e16e:	9b07      	ldr	r3, [sp, #28]
 801e170:	9704      	str	r7, [sp, #16]
 801e172:	2b00      	cmp	r3, #0
 801e174:	dc20      	bgt.n	801e1b8 <_dtoa_r+0x940>
 801e176:	9300      	str	r3, [sp, #0]
 801e178:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801e17a:	2b02      	cmp	r3, #2
 801e17c:	dd1e      	ble.n	801e1bc <_dtoa_r+0x944>
 801e17e:	9b00      	ldr	r3, [sp, #0]
 801e180:	2b00      	cmp	r3, #0
 801e182:	f47f aec0 	bne.w	801df06 <_dtoa_r+0x68e>
 801e186:	4621      	mov	r1, r4
 801e188:	2205      	movs	r2, #5
 801e18a:	4658      	mov	r0, fp
 801e18c:	f000 fa9a 	bl	801e6c4 <__multadd>
 801e190:	4601      	mov	r1, r0
 801e192:	4604      	mov	r4, r0
 801e194:	4648      	mov	r0, r9
 801e196:	f000 fcad 	bl	801eaf4 <__mcmp>
 801e19a:	2800      	cmp	r0, #0
 801e19c:	f77f aeb3 	ble.w	801df06 <_dtoa_r+0x68e>
 801e1a0:	4656      	mov	r6, sl
 801e1a2:	2331      	movs	r3, #49	@ 0x31
 801e1a4:	f806 3b01 	strb.w	r3, [r6], #1
 801e1a8:	9b04      	ldr	r3, [sp, #16]
 801e1aa:	3301      	adds	r3, #1
 801e1ac:	9304      	str	r3, [sp, #16]
 801e1ae:	e6ae      	b.n	801df0e <_dtoa_r+0x696>
 801e1b0:	9c07      	ldr	r4, [sp, #28]
 801e1b2:	9704      	str	r7, [sp, #16]
 801e1b4:	4625      	mov	r5, r4
 801e1b6:	e7f3      	b.n	801e1a0 <_dtoa_r+0x928>
 801e1b8:	9b07      	ldr	r3, [sp, #28]
 801e1ba:	9300      	str	r3, [sp, #0]
 801e1bc:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801e1be:	2b00      	cmp	r3, #0
 801e1c0:	f000 8104 	beq.w	801e3cc <_dtoa_r+0xb54>
 801e1c4:	2e00      	cmp	r6, #0
 801e1c6:	dd05      	ble.n	801e1d4 <_dtoa_r+0x95c>
 801e1c8:	4629      	mov	r1, r5
 801e1ca:	4632      	mov	r2, r6
 801e1cc:	4658      	mov	r0, fp
 801e1ce:	f000 fc25 	bl	801ea1c <__lshift>
 801e1d2:	4605      	mov	r5, r0
 801e1d4:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801e1d6:	2b00      	cmp	r3, #0
 801e1d8:	d05a      	beq.n	801e290 <_dtoa_r+0xa18>
 801e1da:	6869      	ldr	r1, [r5, #4]
 801e1dc:	4658      	mov	r0, fp
 801e1de:	f000 fa0f 	bl	801e600 <_Balloc>
 801e1e2:	4606      	mov	r6, r0
 801e1e4:	b928      	cbnz	r0, 801e1f2 <_dtoa_r+0x97a>
 801e1e6:	4b84      	ldr	r3, [pc, #528]	@ (801e3f8 <_dtoa_r+0xb80>)
 801e1e8:	4602      	mov	r2, r0
 801e1ea:	f240 21ef 	movw	r1, #751	@ 0x2ef
 801e1ee:	f7ff bb5a 	b.w	801d8a6 <_dtoa_r+0x2e>
 801e1f2:	692a      	ldr	r2, [r5, #16]
 801e1f4:	3202      	adds	r2, #2
 801e1f6:	0092      	lsls	r2, r2, #2
 801e1f8:	f105 010c 	add.w	r1, r5, #12
 801e1fc:	300c      	adds	r0, #12
 801e1fe:	f7ff faa2 	bl	801d746 <memcpy>
 801e202:	2201      	movs	r2, #1
 801e204:	4631      	mov	r1, r6
 801e206:	4658      	mov	r0, fp
 801e208:	f000 fc08 	bl	801ea1c <__lshift>
 801e20c:	f10a 0301 	add.w	r3, sl, #1
 801e210:	9307      	str	r3, [sp, #28]
 801e212:	9b00      	ldr	r3, [sp, #0]
 801e214:	4453      	add	r3, sl
 801e216:	930b      	str	r3, [sp, #44]	@ 0x2c
 801e218:	9b02      	ldr	r3, [sp, #8]
 801e21a:	f003 0301 	and.w	r3, r3, #1
 801e21e:	462f      	mov	r7, r5
 801e220:	930a      	str	r3, [sp, #40]	@ 0x28
 801e222:	4605      	mov	r5, r0
 801e224:	9b07      	ldr	r3, [sp, #28]
 801e226:	4621      	mov	r1, r4
 801e228:	3b01      	subs	r3, #1
 801e22a:	4648      	mov	r0, r9
 801e22c:	9300      	str	r3, [sp, #0]
 801e22e:	f7ff fa98 	bl	801d762 <quorem>
 801e232:	4639      	mov	r1, r7
 801e234:	9002      	str	r0, [sp, #8]
 801e236:	f100 0830 	add.w	r8, r0, #48	@ 0x30
 801e23a:	4648      	mov	r0, r9
 801e23c:	f000 fc5a 	bl	801eaf4 <__mcmp>
 801e240:	462a      	mov	r2, r5
 801e242:	9008      	str	r0, [sp, #32]
 801e244:	4621      	mov	r1, r4
 801e246:	4658      	mov	r0, fp
 801e248:	f000 fc70 	bl	801eb2c <__mdiff>
 801e24c:	68c2      	ldr	r2, [r0, #12]
 801e24e:	4606      	mov	r6, r0
 801e250:	bb02      	cbnz	r2, 801e294 <_dtoa_r+0xa1c>
 801e252:	4601      	mov	r1, r0
 801e254:	4648      	mov	r0, r9
 801e256:	f000 fc4d 	bl	801eaf4 <__mcmp>
 801e25a:	4602      	mov	r2, r0
 801e25c:	4631      	mov	r1, r6
 801e25e:	4658      	mov	r0, fp
 801e260:	920e      	str	r2, [sp, #56]	@ 0x38
 801e262:	f000 fa0d 	bl	801e680 <_Bfree>
 801e266:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801e268:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 801e26a:	9e07      	ldr	r6, [sp, #28]
 801e26c:	ea43 0102 	orr.w	r1, r3, r2
 801e270:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801e272:	4319      	orrs	r1, r3
 801e274:	d110      	bne.n	801e298 <_dtoa_r+0xa20>
 801e276:	f1b8 0f39 	cmp.w	r8, #57	@ 0x39
 801e27a:	d029      	beq.n	801e2d0 <_dtoa_r+0xa58>
 801e27c:	9b08      	ldr	r3, [sp, #32]
 801e27e:	2b00      	cmp	r3, #0
 801e280:	dd02      	ble.n	801e288 <_dtoa_r+0xa10>
 801e282:	9b02      	ldr	r3, [sp, #8]
 801e284:	f103 0831 	add.w	r8, r3, #49	@ 0x31
 801e288:	9b00      	ldr	r3, [sp, #0]
 801e28a:	f883 8000 	strb.w	r8, [r3]
 801e28e:	e63f      	b.n	801df10 <_dtoa_r+0x698>
 801e290:	4628      	mov	r0, r5
 801e292:	e7bb      	b.n	801e20c <_dtoa_r+0x994>
 801e294:	2201      	movs	r2, #1
 801e296:	e7e1      	b.n	801e25c <_dtoa_r+0x9e4>
 801e298:	9b08      	ldr	r3, [sp, #32]
 801e29a:	2b00      	cmp	r3, #0
 801e29c:	db04      	blt.n	801e2a8 <_dtoa_r+0xa30>
 801e29e:	9909      	ldr	r1, [sp, #36]	@ 0x24
 801e2a0:	430b      	orrs	r3, r1
 801e2a2:	990a      	ldr	r1, [sp, #40]	@ 0x28
 801e2a4:	430b      	orrs	r3, r1
 801e2a6:	d120      	bne.n	801e2ea <_dtoa_r+0xa72>
 801e2a8:	2a00      	cmp	r2, #0
 801e2aa:	dded      	ble.n	801e288 <_dtoa_r+0xa10>
 801e2ac:	4649      	mov	r1, r9
 801e2ae:	2201      	movs	r2, #1
 801e2b0:	4658      	mov	r0, fp
 801e2b2:	f000 fbb3 	bl	801ea1c <__lshift>
 801e2b6:	4621      	mov	r1, r4
 801e2b8:	4681      	mov	r9, r0
 801e2ba:	f000 fc1b 	bl	801eaf4 <__mcmp>
 801e2be:	2800      	cmp	r0, #0
 801e2c0:	dc03      	bgt.n	801e2ca <_dtoa_r+0xa52>
 801e2c2:	d1e1      	bne.n	801e288 <_dtoa_r+0xa10>
 801e2c4:	f018 0f01 	tst.w	r8, #1
 801e2c8:	d0de      	beq.n	801e288 <_dtoa_r+0xa10>
 801e2ca:	f1b8 0f39 	cmp.w	r8, #57	@ 0x39
 801e2ce:	d1d8      	bne.n	801e282 <_dtoa_r+0xa0a>
 801e2d0:	9a00      	ldr	r2, [sp, #0]
 801e2d2:	2339      	movs	r3, #57	@ 0x39
 801e2d4:	7013      	strb	r3, [r2, #0]
 801e2d6:	4633      	mov	r3, r6
 801e2d8:	461e      	mov	r6, r3
 801e2da:	3b01      	subs	r3, #1
 801e2dc:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 801e2e0:	2a39      	cmp	r2, #57	@ 0x39
 801e2e2:	d052      	beq.n	801e38a <_dtoa_r+0xb12>
 801e2e4:	3201      	adds	r2, #1
 801e2e6:	701a      	strb	r2, [r3, #0]
 801e2e8:	e612      	b.n	801df10 <_dtoa_r+0x698>
 801e2ea:	2a00      	cmp	r2, #0
 801e2ec:	dd07      	ble.n	801e2fe <_dtoa_r+0xa86>
 801e2ee:	f1b8 0f39 	cmp.w	r8, #57	@ 0x39
 801e2f2:	d0ed      	beq.n	801e2d0 <_dtoa_r+0xa58>
 801e2f4:	9a00      	ldr	r2, [sp, #0]
 801e2f6:	f108 0301 	add.w	r3, r8, #1
 801e2fa:	7013      	strb	r3, [r2, #0]
 801e2fc:	e608      	b.n	801df10 <_dtoa_r+0x698>
 801e2fe:	9b07      	ldr	r3, [sp, #28]
 801e300:	9a07      	ldr	r2, [sp, #28]
 801e302:	f803 8c01 	strb.w	r8, [r3, #-1]
 801e306:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801e308:	4293      	cmp	r3, r2
 801e30a:	d028      	beq.n	801e35e <_dtoa_r+0xae6>
 801e30c:	4649      	mov	r1, r9
 801e30e:	2300      	movs	r3, #0
 801e310:	220a      	movs	r2, #10
 801e312:	4658      	mov	r0, fp
 801e314:	f000 f9d6 	bl	801e6c4 <__multadd>
 801e318:	42af      	cmp	r7, r5
 801e31a:	4681      	mov	r9, r0
 801e31c:	f04f 0300 	mov.w	r3, #0
 801e320:	f04f 020a 	mov.w	r2, #10
 801e324:	4639      	mov	r1, r7
 801e326:	4658      	mov	r0, fp
 801e328:	d107      	bne.n	801e33a <_dtoa_r+0xac2>
 801e32a:	f000 f9cb 	bl	801e6c4 <__multadd>
 801e32e:	4607      	mov	r7, r0
 801e330:	4605      	mov	r5, r0
 801e332:	9b07      	ldr	r3, [sp, #28]
 801e334:	3301      	adds	r3, #1
 801e336:	9307      	str	r3, [sp, #28]
 801e338:	e774      	b.n	801e224 <_dtoa_r+0x9ac>
 801e33a:	f000 f9c3 	bl	801e6c4 <__multadd>
 801e33e:	4629      	mov	r1, r5
 801e340:	4607      	mov	r7, r0
 801e342:	2300      	movs	r3, #0
 801e344:	220a      	movs	r2, #10
 801e346:	4658      	mov	r0, fp
 801e348:	f000 f9bc 	bl	801e6c4 <__multadd>
 801e34c:	4605      	mov	r5, r0
 801e34e:	e7f0      	b.n	801e332 <_dtoa_r+0xaba>
 801e350:	9b00      	ldr	r3, [sp, #0]
 801e352:	2b00      	cmp	r3, #0
 801e354:	bfcc      	ite	gt
 801e356:	461e      	movgt	r6, r3
 801e358:	2601      	movle	r6, #1
 801e35a:	4456      	add	r6, sl
 801e35c:	2700      	movs	r7, #0
 801e35e:	4649      	mov	r1, r9
 801e360:	2201      	movs	r2, #1
 801e362:	4658      	mov	r0, fp
 801e364:	f000 fb5a 	bl	801ea1c <__lshift>
 801e368:	4621      	mov	r1, r4
 801e36a:	4681      	mov	r9, r0
 801e36c:	f000 fbc2 	bl	801eaf4 <__mcmp>
 801e370:	2800      	cmp	r0, #0
 801e372:	dcb0      	bgt.n	801e2d6 <_dtoa_r+0xa5e>
 801e374:	d102      	bne.n	801e37c <_dtoa_r+0xb04>
 801e376:	f018 0f01 	tst.w	r8, #1
 801e37a:	d1ac      	bne.n	801e2d6 <_dtoa_r+0xa5e>
 801e37c:	4633      	mov	r3, r6
 801e37e:	461e      	mov	r6, r3
 801e380:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 801e384:	2a30      	cmp	r2, #48	@ 0x30
 801e386:	d0fa      	beq.n	801e37e <_dtoa_r+0xb06>
 801e388:	e5c2      	b.n	801df10 <_dtoa_r+0x698>
 801e38a:	459a      	cmp	sl, r3
 801e38c:	d1a4      	bne.n	801e2d8 <_dtoa_r+0xa60>
 801e38e:	9b04      	ldr	r3, [sp, #16]
 801e390:	3301      	adds	r3, #1
 801e392:	9304      	str	r3, [sp, #16]
 801e394:	2331      	movs	r3, #49	@ 0x31
 801e396:	f88a 3000 	strb.w	r3, [sl]
 801e39a:	e5b9      	b.n	801df10 <_dtoa_r+0x698>
 801e39c:	9b23      	ldr	r3, [sp, #140]	@ 0x8c
 801e39e:	f8df a05c 	ldr.w	sl, [pc, #92]	@ 801e3fc <_dtoa_r+0xb84>
 801e3a2:	b11b      	cbz	r3, 801e3ac <_dtoa_r+0xb34>
 801e3a4:	f10a 0308 	add.w	r3, sl, #8
 801e3a8:	9a23      	ldr	r2, [sp, #140]	@ 0x8c
 801e3aa:	6013      	str	r3, [r2, #0]
 801e3ac:	4650      	mov	r0, sl
 801e3ae:	b019      	add	sp, #100	@ 0x64
 801e3b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e3b4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801e3b6:	2b01      	cmp	r3, #1
 801e3b8:	f77f ae37 	ble.w	801e02a <_dtoa_r+0x7b2>
 801e3bc:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 801e3be:	930a      	str	r3, [sp, #40]	@ 0x28
 801e3c0:	2001      	movs	r0, #1
 801e3c2:	e655      	b.n	801e070 <_dtoa_r+0x7f8>
 801e3c4:	9b00      	ldr	r3, [sp, #0]
 801e3c6:	2b00      	cmp	r3, #0
 801e3c8:	f77f aed6 	ble.w	801e178 <_dtoa_r+0x900>
 801e3cc:	4656      	mov	r6, sl
 801e3ce:	4621      	mov	r1, r4
 801e3d0:	4648      	mov	r0, r9
 801e3d2:	f7ff f9c6 	bl	801d762 <quorem>
 801e3d6:	f100 0830 	add.w	r8, r0, #48	@ 0x30
 801e3da:	f806 8b01 	strb.w	r8, [r6], #1
 801e3de:	9b00      	ldr	r3, [sp, #0]
 801e3e0:	eba6 020a 	sub.w	r2, r6, sl
 801e3e4:	4293      	cmp	r3, r2
 801e3e6:	ddb3      	ble.n	801e350 <_dtoa_r+0xad8>
 801e3e8:	4649      	mov	r1, r9
 801e3ea:	2300      	movs	r3, #0
 801e3ec:	220a      	movs	r2, #10
 801e3ee:	4658      	mov	r0, fp
 801e3f0:	f000 f968 	bl	801e6c4 <__multadd>
 801e3f4:	4681      	mov	r9, r0
 801e3f6:	e7ea      	b.n	801e3ce <_dtoa_r+0xb56>
 801e3f8:	08023af8 	.word	0x08023af8
 801e3fc:	08023a7c 	.word	0x08023a7c

0801e400 <_free_r>:
 801e400:	b538      	push	{r3, r4, r5, lr}
 801e402:	4605      	mov	r5, r0
 801e404:	2900      	cmp	r1, #0
 801e406:	d041      	beq.n	801e48c <_free_r+0x8c>
 801e408:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801e40c:	1f0c      	subs	r4, r1, #4
 801e40e:	2b00      	cmp	r3, #0
 801e410:	bfb8      	it	lt
 801e412:	18e4      	addlt	r4, r4, r3
 801e414:	f000 f8e8 	bl	801e5e8 <__malloc_lock>
 801e418:	4a1d      	ldr	r2, [pc, #116]	@ (801e490 <_free_r+0x90>)
 801e41a:	6813      	ldr	r3, [r2, #0]
 801e41c:	b933      	cbnz	r3, 801e42c <_free_r+0x2c>
 801e41e:	6063      	str	r3, [r4, #4]
 801e420:	6014      	str	r4, [r2, #0]
 801e422:	4628      	mov	r0, r5
 801e424:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801e428:	f000 b8e4 	b.w	801e5f4 <__malloc_unlock>
 801e42c:	42a3      	cmp	r3, r4
 801e42e:	d908      	bls.n	801e442 <_free_r+0x42>
 801e430:	6820      	ldr	r0, [r4, #0]
 801e432:	1821      	adds	r1, r4, r0
 801e434:	428b      	cmp	r3, r1
 801e436:	bf01      	itttt	eq
 801e438:	6819      	ldreq	r1, [r3, #0]
 801e43a:	685b      	ldreq	r3, [r3, #4]
 801e43c:	1809      	addeq	r1, r1, r0
 801e43e:	6021      	streq	r1, [r4, #0]
 801e440:	e7ed      	b.n	801e41e <_free_r+0x1e>
 801e442:	461a      	mov	r2, r3
 801e444:	685b      	ldr	r3, [r3, #4]
 801e446:	b10b      	cbz	r3, 801e44c <_free_r+0x4c>
 801e448:	42a3      	cmp	r3, r4
 801e44a:	d9fa      	bls.n	801e442 <_free_r+0x42>
 801e44c:	6811      	ldr	r1, [r2, #0]
 801e44e:	1850      	adds	r0, r2, r1
 801e450:	42a0      	cmp	r0, r4
 801e452:	d10b      	bne.n	801e46c <_free_r+0x6c>
 801e454:	6820      	ldr	r0, [r4, #0]
 801e456:	4401      	add	r1, r0
 801e458:	1850      	adds	r0, r2, r1
 801e45a:	4283      	cmp	r3, r0
 801e45c:	6011      	str	r1, [r2, #0]
 801e45e:	d1e0      	bne.n	801e422 <_free_r+0x22>
 801e460:	6818      	ldr	r0, [r3, #0]
 801e462:	685b      	ldr	r3, [r3, #4]
 801e464:	6053      	str	r3, [r2, #4]
 801e466:	4408      	add	r0, r1
 801e468:	6010      	str	r0, [r2, #0]
 801e46a:	e7da      	b.n	801e422 <_free_r+0x22>
 801e46c:	d902      	bls.n	801e474 <_free_r+0x74>
 801e46e:	230c      	movs	r3, #12
 801e470:	602b      	str	r3, [r5, #0]
 801e472:	e7d6      	b.n	801e422 <_free_r+0x22>
 801e474:	6820      	ldr	r0, [r4, #0]
 801e476:	1821      	adds	r1, r4, r0
 801e478:	428b      	cmp	r3, r1
 801e47a:	bf04      	itt	eq
 801e47c:	6819      	ldreq	r1, [r3, #0]
 801e47e:	685b      	ldreq	r3, [r3, #4]
 801e480:	6063      	str	r3, [r4, #4]
 801e482:	bf04      	itt	eq
 801e484:	1809      	addeq	r1, r1, r0
 801e486:	6021      	streq	r1, [r4, #0]
 801e488:	6054      	str	r4, [r2, #4]
 801e48a:	e7ca      	b.n	801e422 <_free_r+0x22>
 801e48c:	bd38      	pop	{r3, r4, r5, pc}
 801e48e:	bf00      	nop
 801e490:	2000245c 	.word	0x2000245c

0801e494 <malloc>:
 801e494:	4b02      	ldr	r3, [pc, #8]	@ (801e4a0 <malloc+0xc>)
 801e496:	4601      	mov	r1, r0
 801e498:	6818      	ldr	r0, [r3, #0]
 801e49a:	f000 b825 	b.w	801e4e8 <_malloc_r>
 801e49e:	bf00      	nop
 801e4a0:	20000360 	.word	0x20000360

0801e4a4 <sbrk_aligned>:
 801e4a4:	b570      	push	{r4, r5, r6, lr}
 801e4a6:	4e0f      	ldr	r6, [pc, #60]	@ (801e4e4 <sbrk_aligned+0x40>)
 801e4a8:	460c      	mov	r4, r1
 801e4aa:	6831      	ldr	r1, [r6, #0]
 801e4ac:	4605      	mov	r5, r0
 801e4ae:	b911      	cbnz	r1, 801e4b6 <sbrk_aligned+0x12>
 801e4b0:	f000 fcd4 	bl	801ee5c <_sbrk_r>
 801e4b4:	6030      	str	r0, [r6, #0]
 801e4b6:	4621      	mov	r1, r4
 801e4b8:	4628      	mov	r0, r5
 801e4ba:	f000 fccf 	bl	801ee5c <_sbrk_r>
 801e4be:	1c43      	adds	r3, r0, #1
 801e4c0:	d103      	bne.n	801e4ca <sbrk_aligned+0x26>
 801e4c2:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
 801e4c6:	4620      	mov	r0, r4
 801e4c8:	bd70      	pop	{r4, r5, r6, pc}
 801e4ca:	1cc4      	adds	r4, r0, #3
 801e4cc:	f024 0403 	bic.w	r4, r4, #3
 801e4d0:	42a0      	cmp	r0, r4
 801e4d2:	d0f8      	beq.n	801e4c6 <sbrk_aligned+0x22>
 801e4d4:	1a21      	subs	r1, r4, r0
 801e4d6:	4628      	mov	r0, r5
 801e4d8:	f000 fcc0 	bl	801ee5c <_sbrk_r>
 801e4dc:	3001      	adds	r0, #1
 801e4de:	d1f2      	bne.n	801e4c6 <sbrk_aligned+0x22>
 801e4e0:	e7ef      	b.n	801e4c2 <sbrk_aligned+0x1e>
 801e4e2:	bf00      	nop
 801e4e4:	20002458 	.word	0x20002458

0801e4e8 <_malloc_r>:
 801e4e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801e4ec:	1ccd      	adds	r5, r1, #3
 801e4ee:	f025 0503 	bic.w	r5, r5, #3
 801e4f2:	3508      	adds	r5, #8
 801e4f4:	2d0c      	cmp	r5, #12
 801e4f6:	bf38      	it	cc
 801e4f8:	250c      	movcc	r5, #12
 801e4fa:	2d00      	cmp	r5, #0
 801e4fc:	4606      	mov	r6, r0
 801e4fe:	db01      	blt.n	801e504 <_malloc_r+0x1c>
 801e500:	42a9      	cmp	r1, r5
 801e502:	d904      	bls.n	801e50e <_malloc_r+0x26>
 801e504:	230c      	movs	r3, #12
 801e506:	6033      	str	r3, [r6, #0]
 801e508:	2000      	movs	r0, #0
 801e50a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801e50e:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 801e5e4 <_malloc_r+0xfc>
 801e512:	f000 f869 	bl	801e5e8 <__malloc_lock>
 801e516:	f8d8 3000 	ldr.w	r3, [r8]
 801e51a:	461c      	mov	r4, r3
 801e51c:	bb44      	cbnz	r4, 801e570 <_malloc_r+0x88>
 801e51e:	4629      	mov	r1, r5
 801e520:	4630      	mov	r0, r6
 801e522:	f7ff ffbf 	bl	801e4a4 <sbrk_aligned>
 801e526:	1c43      	adds	r3, r0, #1
 801e528:	4604      	mov	r4, r0
 801e52a:	d158      	bne.n	801e5de <_malloc_r+0xf6>
 801e52c:	f8d8 4000 	ldr.w	r4, [r8]
 801e530:	4627      	mov	r7, r4
 801e532:	2f00      	cmp	r7, #0
 801e534:	d143      	bne.n	801e5be <_malloc_r+0xd6>
 801e536:	2c00      	cmp	r4, #0
 801e538:	d04b      	beq.n	801e5d2 <_malloc_r+0xea>
 801e53a:	6823      	ldr	r3, [r4, #0]
 801e53c:	4639      	mov	r1, r7
 801e53e:	4630      	mov	r0, r6
 801e540:	eb04 0903 	add.w	r9, r4, r3
 801e544:	f000 fc8a 	bl	801ee5c <_sbrk_r>
 801e548:	4581      	cmp	r9, r0
 801e54a:	d142      	bne.n	801e5d2 <_malloc_r+0xea>
 801e54c:	6821      	ldr	r1, [r4, #0]
 801e54e:	1a6d      	subs	r5, r5, r1
 801e550:	4629      	mov	r1, r5
 801e552:	4630      	mov	r0, r6
 801e554:	f7ff ffa6 	bl	801e4a4 <sbrk_aligned>
 801e558:	3001      	adds	r0, #1
 801e55a:	d03a      	beq.n	801e5d2 <_malloc_r+0xea>
 801e55c:	6823      	ldr	r3, [r4, #0]
 801e55e:	442b      	add	r3, r5
 801e560:	6023      	str	r3, [r4, #0]
 801e562:	f8d8 3000 	ldr.w	r3, [r8]
 801e566:	685a      	ldr	r2, [r3, #4]
 801e568:	bb62      	cbnz	r2, 801e5c4 <_malloc_r+0xdc>
 801e56a:	f8c8 7000 	str.w	r7, [r8]
 801e56e:	e00f      	b.n	801e590 <_malloc_r+0xa8>
 801e570:	6822      	ldr	r2, [r4, #0]
 801e572:	1b52      	subs	r2, r2, r5
 801e574:	d420      	bmi.n	801e5b8 <_malloc_r+0xd0>
 801e576:	2a0b      	cmp	r2, #11
 801e578:	d917      	bls.n	801e5aa <_malloc_r+0xc2>
 801e57a:	1961      	adds	r1, r4, r5
 801e57c:	42a3      	cmp	r3, r4
 801e57e:	6025      	str	r5, [r4, #0]
 801e580:	bf18      	it	ne
 801e582:	6059      	strne	r1, [r3, #4]
 801e584:	6863      	ldr	r3, [r4, #4]
 801e586:	bf08      	it	eq
 801e588:	f8c8 1000 	streq.w	r1, [r8]
 801e58c:	5162      	str	r2, [r4, r5]
 801e58e:	604b      	str	r3, [r1, #4]
 801e590:	4630      	mov	r0, r6
 801e592:	f000 f82f 	bl	801e5f4 <__malloc_unlock>
 801e596:	f104 000b 	add.w	r0, r4, #11
 801e59a:	1d23      	adds	r3, r4, #4
 801e59c:	f020 0007 	bic.w	r0, r0, #7
 801e5a0:	1ac2      	subs	r2, r0, r3
 801e5a2:	bf1c      	itt	ne
 801e5a4:	1a1b      	subne	r3, r3, r0
 801e5a6:	50a3      	strne	r3, [r4, r2]
 801e5a8:	e7af      	b.n	801e50a <_malloc_r+0x22>
 801e5aa:	6862      	ldr	r2, [r4, #4]
 801e5ac:	42a3      	cmp	r3, r4
 801e5ae:	bf0c      	ite	eq
 801e5b0:	f8c8 2000 	streq.w	r2, [r8]
 801e5b4:	605a      	strne	r2, [r3, #4]
 801e5b6:	e7eb      	b.n	801e590 <_malloc_r+0xa8>
 801e5b8:	4623      	mov	r3, r4
 801e5ba:	6864      	ldr	r4, [r4, #4]
 801e5bc:	e7ae      	b.n	801e51c <_malloc_r+0x34>
 801e5be:	463c      	mov	r4, r7
 801e5c0:	687f      	ldr	r7, [r7, #4]
 801e5c2:	e7b6      	b.n	801e532 <_malloc_r+0x4a>
 801e5c4:	461a      	mov	r2, r3
 801e5c6:	685b      	ldr	r3, [r3, #4]
 801e5c8:	42a3      	cmp	r3, r4
 801e5ca:	d1fb      	bne.n	801e5c4 <_malloc_r+0xdc>
 801e5cc:	2300      	movs	r3, #0
 801e5ce:	6053      	str	r3, [r2, #4]
 801e5d0:	e7de      	b.n	801e590 <_malloc_r+0xa8>
 801e5d2:	230c      	movs	r3, #12
 801e5d4:	6033      	str	r3, [r6, #0]
 801e5d6:	4630      	mov	r0, r6
 801e5d8:	f000 f80c 	bl	801e5f4 <__malloc_unlock>
 801e5dc:	e794      	b.n	801e508 <_malloc_r+0x20>
 801e5de:	6005      	str	r5, [r0, #0]
 801e5e0:	e7d6      	b.n	801e590 <_malloc_r+0xa8>
 801e5e2:	bf00      	nop
 801e5e4:	2000245c 	.word	0x2000245c

0801e5e8 <__malloc_lock>:
 801e5e8:	4801      	ldr	r0, [pc, #4]	@ (801e5f0 <__malloc_lock+0x8>)
 801e5ea:	f7ff b8aa 	b.w	801d742 <__retarget_lock_acquire_recursive>
 801e5ee:	bf00      	nop
 801e5f0:	20002454 	.word	0x20002454

0801e5f4 <__malloc_unlock>:
 801e5f4:	4801      	ldr	r0, [pc, #4]	@ (801e5fc <__malloc_unlock+0x8>)
 801e5f6:	f7ff b8a5 	b.w	801d744 <__retarget_lock_release_recursive>
 801e5fa:	bf00      	nop
 801e5fc:	20002454 	.word	0x20002454

0801e600 <_Balloc>:
 801e600:	b570      	push	{r4, r5, r6, lr}
 801e602:	69c6      	ldr	r6, [r0, #28]
 801e604:	4604      	mov	r4, r0
 801e606:	460d      	mov	r5, r1
 801e608:	b976      	cbnz	r6, 801e628 <_Balloc+0x28>
 801e60a:	2010      	movs	r0, #16
 801e60c:	f7ff ff42 	bl	801e494 <malloc>
 801e610:	4602      	mov	r2, r0
 801e612:	61e0      	str	r0, [r4, #28]
 801e614:	b920      	cbnz	r0, 801e620 <_Balloc+0x20>
 801e616:	4b18      	ldr	r3, [pc, #96]	@ (801e678 <_Balloc+0x78>)
 801e618:	4818      	ldr	r0, [pc, #96]	@ (801e67c <_Balloc+0x7c>)
 801e61a:	216b      	movs	r1, #107	@ 0x6b
 801e61c:	f000 fc2e 	bl	801ee7c <__assert_func>
 801e620:	e9c0 6601 	strd	r6, r6, [r0, #4]
 801e624:	6006      	str	r6, [r0, #0]
 801e626:	60c6      	str	r6, [r0, #12]
 801e628:	69e6      	ldr	r6, [r4, #28]
 801e62a:	68f3      	ldr	r3, [r6, #12]
 801e62c:	b183      	cbz	r3, 801e650 <_Balloc+0x50>
 801e62e:	69e3      	ldr	r3, [r4, #28]
 801e630:	68db      	ldr	r3, [r3, #12]
 801e632:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 801e636:	b9b8      	cbnz	r0, 801e668 <_Balloc+0x68>
 801e638:	2101      	movs	r1, #1
 801e63a:	fa01 f605 	lsl.w	r6, r1, r5
 801e63e:	1d72      	adds	r2, r6, #5
 801e640:	0092      	lsls	r2, r2, #2
 801e642:	4620      	mov	r0, r4
 801e644:	f000 fc38 	bl	801eeb8 <_calloc_r>
 801e648:	b160      	cbz	r0, 801e664 <_Balloc+0x64>
 801e64a:	e9c0 5601 	strd	r5, r6, [r0, #4]
 801e64e:	e00e      	b.n	801e66e <_Balloc+0x6e>
 801e650:	2221      	movs	r2, #33	@ 0x21
 801e652:	2104      	movs	r1, #4
 801e654:	4620      	mov	r0, r4
 801e656:	f000 fc2f 	bl	801eeb8 <_calloc_r>
 801e65a:	69e3      	ldr	r3, [r4, #28]
 801e65c:	60f0      	str	r0, [r6, #12]
 801e65e:	68db      	ldr	r3, [r3, #12]
 801e660:	2b00      	cmp	r3, #0
 801e662:	d1e4      	bne.n	801e62e <_Balloc+0x2e>
 801e664:	2000      	movs	r0, #0
 801e666:	bd70      	pop	{r4, r5, r6, pc}
 801e668:	6802      	ldr	r2, [r0, #0]
 801e66a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 801e66e:	2300      	movs	r3, #0
 801e670:	e9c0 3303 	strd	r3, r3, [r0, #12]
 801e674:	e7f7      	b.n	801e666 <_Balloc+0x66>
 801e676:	bf00      	nop
 801e678:	08023a89 	.word	0x08023a89
 801e67c:	08023b09 	.word	0x08023b09

0801e680 <_Bfree>:
 801e680:	b570      	push	{r4, r5, r6, lr}
 801e682:	69c6      	ldr	r6, [r0, #28]
 801e684:	4605      	mov	r5, r0
 801e686:	460c      	mov	r4, r1
 801e688:	b976      	cbnz	r6, 801e6a8 <_Bfree+0x28>
 801e68a:	2010      	movs	r0, #16
 801e68c:	f7ff ff02 	bl	801e494 <malloc>
 801e690:	4602      	mov	r2, r0
 801e692:	61e8      	str	r0, [r5, #28]
 801e694:	b920      	cbnz	r0, 801e6a0 <_Bfree+0x20>
 801e696:	4b09      	ldr	r3, [pc, #36]	@ (801e6bc <_Bfree+0x3c>)
 801e698:	4809      	ldr	r0, [pc, #36]	@ (801e6c0 <_Bfree+0x40>)
 801e69a:	218f      	movs	r1, #143	@ 0x8f
 801e69c:	f000 fbee 	bl	801ee7c <__assert_func>
 801e6a0:	e9c0 6601 	strd	r6, r6, [r0, #4]
 801e6a4:	6006      	str	r6, [r0, #0]
 801e6a6:	60c6      	str	r6, [r0, #12]
 801e6a8:	b13c      	cbz	r4, 801e6ba <_Bfree+0x3a>
 801e6aa:	69eb      	ldr	r3, [r5, #28]
 801e6ac:	6862      	ldr	r2, [r4, #4]
 801e6ae:	68db      	ldr	r3, [r3, #12]
 801e6b0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 801e6b4:	6021      	str	r1, [r4, #0]
 801e6b6:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 801e6ba:	bd70      	pop	{r4, r5, r6, pc}
 801e6bc:	08023a89 	.word	0x08023a89
 801e6c0:	08023b09 	.word	0x08023b09

0801e6c4 <__multadd>:
 801e6c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e6c8:	690d      	ldr	r5, [r1, #16]
 801e6ca:	4607      	mov	r7, r0
 801e6cc:	460c      	mov	r4, r1
 801e6ce:	461e      	mov	r6, r3
 801e6d0:	f101 0c14 	add.w	ip, r1, #20
 801e6d4:	2000      	movs	r0, #0
 801e6d6:	f8dc 3000 	ldr.w	r3, [ip]
 801e6da:	b299      	uxth	r1, r3
 801e6dc:	fb02 6101 	mla	r1, r2, r1, r6
 801e6e0:	0c1e      	lsrs	r6, r3, #16
 801e6e2:	0c0b      	lsrs	r3, r1, #16
 801e6e4:	fb02 3306 	mla	r3, r2, r6, r3
 801e6e8:	b289      	uxth	r1, r1
 801e6ea:	3001      	adds	r0, #1
 801e6ec:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 801e6f0:	4285      	cmp	r5, r0
 801e6f2:	f84c 1b04 	str.w	r1, [ip], #4
 801e6f6:	ea4f 4613 	mov.w	r6, r3, lsr #16
 801e6fa:	dcec      	bgt.n	801e6d6 <__multadd+0x12>
 801e6fc:	b30e      	cbz	r6, 801e742 <__multadd+0x7e>
 801e6fe:	68a3      	ldr	r3, [r4, #8]
 801e700:	42ab      	cmp	r3, r5
 801e702:	dc19      	bgt.n	801e738 <__multadd+0x74>
 801e704:	6861      	ldr	r1, [r4, #4]
 801e706:	4638      	mov	r0, r7
 801e708:	3101      	adds	r1, #1
 801e70a:	f7ff ff79 	bl	801e600 <_Balloc>
 801e70e:	4680      	mov	r8, r0
 801e710:	b928      	cbnz	r0, 801e71e <__multadd+0x5a>
 801e712:	4602      	mov	r2, r0
 801e714:	4b0c      	ldr	r3, [pc, #48]	@ (801e748 <__multadd+0x84>)
 801e716:	480d      	ldr	r0, [pc, #52]	@ (801e74c <__multadd+0x88>)
 801e718:	21ba      	movs	r1, #186	@ 0xba
 801e71a:	f000 fbaf 	bl	801ee7c <__assert_func>
 801e71e:	6922      	ldr	r2, [r4, #16]
 801e720:	3202      	adds	r2, #2
 801e722:	f104 010c 	add.w	r1, r4, #12
 801e726:	0092      	lsls	r2, r2, #2
 801e728:	300c      	adds	r0, #12
 801e72a:	f7ff f80c 	bl	801d746 <memcpy>
 801e72e:	4621      	mov	r1, r4
 801e730:	4638      	mov	r0, r7
 801e732:	f7ff ffa5 	bl	801e680 <_Bfree>
 801e736:	4644      	mov	r4, r8
 801e738:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 801e73c:	3501      	adds	r5, #1
 801e73e:	615e      	str	r6, [r3, #20]
 801e740:	6125      	str	r5, [r4, #16]
 801e742:	4620      	mov	r0, r4
 801e744:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801e748:	08023af8 	.word	0x08023af8
 801e74c:	08023b09 	.word	0x08023b09

0801e750 <__hi0bits>:
 801e750:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 801e754:	4603      	mov	r3, r0
 801e756:	bf36      	itet	cc
 801e758:	0403      	lslcc	r3, r0, #16
 801e75a:	2000      	movcs	r0, #0
 801e75c:	2010      	movcc	r0, #16
 801e75e:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 801e762:	bf3c      	itt	cc
 801e764:	021b      	lslcc	r3, r3, #8
 801e766:	3008      	addcc	r0, #8
 801e768:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 801e76c:	bf3c      	itt	cc
 801e76e:	011b      	lslcc	r3, r3, #4
 801e770:	3004      	addcc	r0, #4
 801e772:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 801e776:	bf3c      	itt	cc
 801e778:	009b      	lslcc	r3, r3, #2
 801e77a:	3002      	addcc	r0, #2
 801e77c:	2b00      	cmp	r3, #0
 801e77e:	db05      	blt.n	801e78c <__hi0bits+0x3c>
 801e780:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 801e784:	f100 0001 	add.w	r0, r0, #1
 801e788:	bf08      	it	eq
 801e78a:	2020      	moveq	r0, #32
 801e78c:	4770      	bx	lr

0801e78e <__lo0bits>:
 801e78e:	6803      	ldr	r3, [r0, #0]
 801e790:	4602      	mov	r2, r0
 801e792:	f013 0007 	ands.w	r0, r3, #7
 801e796:	d00b      	beq.n	801e7b0 <__lo0bits+0x22>
 801e798:	07d9      	lsls	r1, r3, #31
 801e79a:	d421      	bmi.n	801e7e0 <__lo0bits+0x52>
 801e79c:	0798      	lsls	r0, r3, #30
 801e79e:	bf49      	itett	mi
 801e7a0:	085b      	lsrmi	r3, r3, #1
 801e7a2:	089b      	lsrpl	r3, r3, #2
 801e7a4:	2001      	movmi	r0, #1
 801e7a6:	6013      	strmi	r3, [r2, #0]
 801e7a8:	bf5c      	itt	pl
 801e7aa:	6013      	strpl	r3, [r2, #0]
 801e7ac:	2002      	movpl	r0, #2
 801e7ae:	4770      	bx	lr
 801e7b0:	b299      	uxth	r1, r3
 801e7b2:	b909      	cbnz	r1, 801e7b8 <__lo0bits+0x2a>
 801e7b4:	0c1b      	lsrs	r3, r3, #16
 801e7b6:	2010      	movs	r0, #16
 801e7b8:	b2d9      	uxtb	r1, r3
 801e7ba:	b909      	cbnz	r1, 801e7c0 <__lo0bits+0x32>
 801e7bc:	3008      	adds	r0, #8
 801e7be:	0a1b      	lsrs	r3, r3, #8
 801e7c0:	0719      	lsls	r1, r3, #28
 801e7c2:	bf04      	itt	eq
 801e7c4:	091b      	lsreq	r3, r3, #4
 801e7c6:	3004      	addeq	r0, #4
 801e7c8:	0799      	lsls	r1, r3, #30
 801e7ca:	bf04      	itt	eq
 801e7cc:	089b      	lsreq	r3, r3, #2
 801e7ce:	3002      	addeq	r0, #2
 801e7d0:	07d9      	lsls	r1, r3, #31
 801e7d2:	d403      	bmi.n	801e7dc <__lo0bits+0x4e>
 801e7d4:	085b      	lsrs	r3, r3, #1
 801e7d6:	f100 0001 	add.w	r0, r0, #1
 801e7da:	d003      	beq.n	801e7e4 <__lo0bits+0x56>
 801e7dc:	6013      	str	r3, [r2, #0]
 801e7de:	4770      	bx	lr
 801e7e0:	2000      	movs	r0, #0
 801e7e2:	4770      	bx	lr
 801e7e4:	2020      	movs	r0, #32
 801e7e6:	4770      	bx	lr

0801e7e8 <__i2b>:
 801e7e8:	b510      	push	{r4, lr}
 801e7ea:	460c      	mov	r4, r1
 801e7ec:	2101      	movs	r1, #1
 801e7ee:	f7ff ff07 	bl	801e600 <_Balloc>
 801e7f2:	4602      	mov	r2, r0
 801e7f4:	b928      	cbnz	r0, 801e802 <__i2b+0x1a>
 801e7f6:	4b05      	ldr	r3, [pc, #20]	@ (801e80c <__i2b+0x24>)
 801e7f8:	4805      	ldr	r0, [pc, #20]	@ (801e810 <__i2b+0x28>)
 801e7fa:	f240 1145 	movw	r1, #325	@ 0x145
 801e7fe:	f000 fb3d 	bl	801ee7c <__assert_func>
 801e802:	2301      	movs	r3, #1
 801e804:	6144      	str	r4, [r0, #20]
 801e806:	6103      	str	r3, [r0, #16]
 801e808:	bd10      	pop	{r4, pc}
 801e80a:	bf00      	nop
 801e80c:	08023af8 	.word	0x08023af8
 801e810:	08023b09 	.word	0x08023b09

0801e814 <__multiply>:
 801e814:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e818:	4614      	mov	r4, r2
 801e81a:	690a      	ldr	r2, [r1, #16]
 801e81c:	6923      	ldr	r3, [r4, #16]
 801e81e:	429a      	cmp	r2, r3
 801e820:	bfa8      	it	ge
 801e822:	4623      	movge	r3, r4
 801e824:	460f      	mov	r7, r1
 801e826:	bfa4      	itt	ge
 801e828:	460c      	movge	r4, r1
 801e82a:	461f      	movge	r7, r3
 801e82c:	f8d4 a010 	ldr.w	sl, [r4, #16]
 801e830:	f8d7 9010 	ldr.w	r9, [r7, #16]
 801e834:	68a3      	ldr	r3, [r4, #8]
 801e836:	6861      	ldr	r1, [r4, #4]
 801e838:	eb0a 0609 	add.w	r6, sl, r9
 801e83c:	42b3      	cmp	r3, r6
 801e83e:	b085      	sub	sp, #20
 801e840:	bfb8      	it	lt
 801e842:	3101      	addlt	r1, #1
 801e844:	f7ff fedc 	bl	801e600 <_Balloc>
 801e848:	b930      	cbnz	r0, 801e858 <__multiply+0x44>
 801e84a:	4602      	mov	r2, r0
 801e84c:	4b44      	ldr	r3, [pc, #272]	@ (801e960 <__multiply+0x14c>)
 801e84e:	4845      	ldr	r0, [pc, #276]	@ (801e964 <__multiply+0x150>)
 801e850:	f44f 71b1 	mov.w	r1, #354	@ 0x162
 801e854:	f000 fb12 	bl	801ee7c <__assert_func>
 801e858:	f100 0514 	add.w	r5, r0, #20
 801e85c:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 801e860:	462b      	mov	r3, r5
 801e862:	2200      	movs	r2, #0
 801e864:	4543      	cmp	r3, r8
 801e866:	d321      	bcc.n	801e8ac <__multiply+0x98>
 801e868:	f107 0114 	add.w	r1, r7, #20
 801e86c:	f104 0214 	add.w	r2, r4, #20
 801e870:	eb02 028a 	add.w	r2, r2, sl, lsl #2
 801e874:	eb01 0389 	add.w	r3, r1, r9, lsl #2
 801e878:	9302      	str	r3, [sp, #8]
 801e87a:	1b13      	subs	r3, r2, r4
 801e87c:	3b15      	subs	r3, #21
 801e87e:	f023 0303 	bic.w	r3, r3, #3
 801e882:	3304      	adds	r3, #4
 801e884:	f104 0715 	add.w	r7, r4, #21
 801e888:	42ba      	cmp	r2, r7
 801e88a:	bf38      	it	cc
 801e88c:	2304      	movcc	r3, #4
 801e88e:	9301      	str	r3, [sp, #4]
 801e890:	9b02      	ldr	r3, [sp, #8]
 801e892:	9103      	str	r1, [sp, #12]
 801e894:	428b      	cmp	r3, r1
 801e896:	d80c      	bhi.n	801e8b2 <__multiply+0x9e>
 801e898:	2e00      	cmp	r6, #0
 801e89a:	dd03      	ble.n	801e8a4 <__multiply+0x90>
 801e89c:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 801e8a0:	2b00      	cmp	r3, #0
 801e8a2:	d05b      	beq.n	801e95c <__multiply+0x148>
 801e8a4:	6106      	str	r6, [r0, #16]
 801e8a6:	b005      	add	sp, #20
 801e8a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801e8ac:	f843 2b04 	str.w	r2, [r3], #4
 801e8b0:	e7d8      	b.n	801e864 <__multiply+0x50>
 801e8b2:	f8b1 a000 	ldrh.w	sl, [r1]
 801e8b6:	f1ba 0f00 	cmp.w	sl, #0
 801e8ba:	d024      	beq.n	801e906 <__multiply+0xf2>
 801e8bc:	f104 0e14 	add.w	lr, r4, #20
 801e8c0:	46a9      	mov	r9, r5
 801e8c2:	f04f 0c00 	mov.w	ip, #0
 801e8c6:	f85e 7b04 	ldr.w	r7, [lr], #4
 801e8ca:	f8d9 3000 	ldr.w	r3, [r9]
 801e8ce:	fa1f fb87 	uxth.w	fp, r7
 801e8d2:	b29b      	uxth	r3, r3
 801e8d4:	fb0a 330b 	mla	r3, sl, fp, r3
 801e8d8:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 801e8dc:	f8d9 7000 	ldr.w	r7, [r9]
 801e8e0:	4463      	add	r3, ip
 801e8e2:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 801e8e6:	fb0a c70b 	mla	r7, sl, fp, ip
 801e8ea:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 801e8ee:	b29b      	uxth	r3, r3
 801e8f0:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 801e8f4:	4572      	cmp	r2, lr
 801e8f6:	f849 3b04 	str.w	r3, [r9], #4
 801e8fa:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 801e8fe:	d8e2      	bhi.n	801e8c6 <__multiply+0xb2>
 801e900:	9b01      	ldr	r3, [sp, #4]
 801e902:	f845 c003 	str.w	ip, [r5, r3]
 801e906:	9b03      	ldr	r3, [sp, #12]
 801e908:	f8b3 9002 	ldrh.w	r9, [r3, #2]
 801e90c:	3104      	adds	r1, #4
 801e90e:	f1b9 0f00 	cmp.w	r9, #0
 801e912:	d021      	beq.n	801e958 <__multiply+0x144>
 801e914:	682b      	ldr	r3, [r5, #0]
 801e916:	f104 0c14 	add.w	ip, r4, #20
 801e91a:	46ae      	mov	lr, r5
 801e91c:	f04f 0a00 	mov.w	sl, #0
 801e920:	f8bc b000 	ldrh.w	fp, [ip]
 801e924:	f8be 7002 	ldrh.w	r7, [lr, #2]
 801e928:	fb09 770b 	mla	r7, r9, fp, r7
 801e92c:	4457      	add	r7, sl
 801e92e:	b29b      	uxth	r3, r3
 801e930:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 801e934:	f84e 3b04 	str.w	r3, [lr], #4
 801e938:	f85c 3b04 	ldr.w	r3, [ip], #4
 801e93c:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 801e940:	f8be 3000 	ldrh.w	r3, [lr]
 801e944:	fb09 330a 	mla	r3, r9, sl, r3
 801e948:	eb03 4317 	add.w	r3, r3, r7, lsr #16
 801e94c:	4562      	cmp	r2, ip
 801e94e:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 801e952:	d8e5      	bhi.n	801e920 <__multiply+0x10c>
 801e954:	9f01      	ldr	r7, [sp, #4]
 801e956:	51eb      	str	r3, [r5, r7]
 801e958:	3504      	adds	r5, #4
 801e95a:	e799      	b.n	801e890 <__multiply+0x7c>
 801e95c:	3e01      	subs	r6, #1
 801e95e:	e79b      	b.n	801e898 <__multiply+0x84>
 801e960:	08023af8 	.word	0x08023af8
 801e964:	08023b09 	.word	0x08023b09

0801e968 <__pow5mult>:
 801e968:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801e96c:	4615      	mov	r5, r2
 801e96e:	f012 0203 	ands.w	r2, r2, #3
 801e972:	4607      	mov	r7, r0
 801e974:	460e      	mov	r6, r1
 801e976:	d007      	beq.n	801e988 <__pow5mult+0x20>
 801e978:	4c25      	ldr	r4, [pc, #148]	@ (801ea10 <__pow5mult+0xa8>)
 801e97a:	3a01      	subs	r2, #1
 801e97c:	2300      	movs	r3, #0
 801e97e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 801e982:	f7ff fe9f 	bl	801e6c4 <__multadd>
 801e986:	4606      	mov	r6, r0
 801e988:	10ad      	asrs	r5, r5, #2
 801e98a:	d03d      	beq.n	801ea08 <__pow5mult+0xa0>
 801e98c:	69fc      	ldr	r4, [r7, #28]
 801e98e:	b97c      	cbnz	r4, 801e9b0 <__pow5mult+0x48>
 801e990:	2010      	movs	r0, #16
 801e992:	f7ff fd7f 	bl	801e494 <malloc>
 801e996:	4602      	mov	r2, r0
 801e998:	61f8      	str	r0, [r7, #28]
 801e99a:	b928      	cbnz	r0, 801e9a8 <__pow5mult+0x40>
 801e99c:	4b1d      	ldr	r3, [pc, #116]	@ (801ea14 <__pow5mult+0xac>)
 801e99e:	481e      	ldr	r0, [pc, #120]	@ (801ea18 <__pow5mult+0xb0>)
 801e9a0:	f240 11b3 	movw	r1, #435	@ 0x1b3
 801e9a4:	f000 fa6a 	bl	801ee7c <__assert_func>
 801e9a8:	e9c0 4401 	strd	r4, r4, [r0, #4]
 801e9ac:	6004      	str	r4, [r0, #0]
 801e9ae:	60c4      	str	r4, [r0, #12]
 801e9b0:	f8d7 801c 	ldr.w	r8, [r7, #28]
 801e9b4:	f8d8 4008 	ldr.w	r4, [r8, #8]
 801e9b8:	b94c      	cbnz	r4, 801e9ce <__pow5mult+0x66>
 801e9ba:	f240 2171 	movw	r1, #625	@ 0x271
 801e9be:	4638      	mov	r0, r7
 801e9c0:	f7ff ff12 	bl	801e7e8 <__i2b>
 801e9c4:	2300      	movs	r3, #0
 801e9c6:	f8c8 0008 	str.w	r0, [r8, #8]
 801e9ca:	4604      	mov	r4, r0
 801e9cc:	6003      	str	r3, [r0, #0]
 801e9ce:	f04f 0900 	mov.w	r9, #0
 801e9d2:	07eb      	lsls	r3, r5, #31
 801e9d4:	d50a      	bpl.n	801e9ec <__pow5mult+0x84>
 801e9d6:	4631      	mov	r1, r6
 801e9d8:	4622      	mov	r2, r4
 801e9da:	4638      	mov	r0, r7
 801e9dc:	f7ff ff1a 	bl	801e814 <__multiply>
 801e9e0:	4631      	mov	r1, r6
 801e9e2:	4680      	mov	r8, r0
 801e9e4:	4638      	mov	r0, r7
 801e9e6:	f7ff fe4b 	bl	801e680 <_Bfree>
 801e9ea:	4646      	mov	r6, r8
 801e9ec:	106d      	asrs	r5, r5, #1
 801e9ee:	d00b      	beq.n	801ea08 <__pow5mult+0xa0>
 801e9f0:	6820      	ldr	r0, [r4, #0]
 801e9f2:	b938      	cbnz	r0, 801ea04 <__pow5mult+0x9c>
 801e9f4:	4622      	mov	r2, r4
 801e9f6:	4621      	mov	r1, r4
 801e9f8:	4638      	mov	r0, r7
 801e9fa:	f7ff ff0b 	bl	801e814 <__multiply>
 801e9fe:	6020      	str	r0, [r4, #0]
 801ea00:	f8c0 9000 	str.w	r9, [r0]
 801ea04:	4604      	mov	r4, r0
 801ea06:	e7e4      	b.n	801e9d2 <__pow5mult+0x6a>
 801ea08:	4630      	mov	r0, r6
 801ea0a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801ea0e:	bf00      	nop
 801ea10:	08023b64 	.word	0x08023b64
 801ea14:	08023a89 	.word	0x08023a89
 801ea18:	08023b09 	.word	0x08023b09

0801ea1c <__lshift>:
 801ea1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801ea20:	460c      	mov	r4, r1
 801ea22:	6849      	ldr	r1, [r1, #4]
 801ea24:	6923      	ldr	r3, [r4, #16]
 801ea26:	eb03 1862 	add.w	r8, r3, r2, asr #5
 801ea2a:	68a3      	ldr	r3, [r4, #8]
 801ea2c:	4607      	mov	r7, r0
 801ea2e:	4691      	mov	r9, r2
 801ea30:	ea4f 1a62 	mov.w	sl, r2, asr #5
 801ea34:	f108 0601 	add.w	r6, r8, #1
 801ea38:	42b3      	cmp	r3, r6
 801ea3a:	db0b      	blt.n	801ea54 <__lshift+0x38>
 801ea3c:	4638      	mov	r0, r7
 801ea3e:	f7ff fddf 	bl	801e600 <_Balloc>
 801ea42:	4605      	mov	r5, r0
 801ea44:	b948      	cbnz	r0, 801ea5a <__lshift+0x3e>
 801ea46:	4602      	mov	r2, r0
 801ea48:	4b28      	ldr	r3, [pc, #160]	@ (801eaec <__lshift+0xd0>)
 801ea4a:	4829      	ldr	r0, [pc, #164]	@ (801eaf0 <__lshift+0xd4>)
 801ea4c:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
 801ea50:	f000 fa14 	bl	801ee7c <__assert_func>
 801ea54:	3101      	adds	r1, #1
 801ea56:	005b      	lsls	r3, r3, #1
 801ea58:	e7ee      	b.n	801ea38 <__lshift+0x1c>
 801ea5a:	2300      	movs	r3, #0
 801ea5c:	f100 0114 	add.w	r1, r0, #20
 801ea60:	f100 0210 	add.w	r2, r0, #16
 801ea64:	4618      	mov	r0, r3
 801ea66:	4553      	cmp	r3, sl
 801ea68:	db33      	blt.n	801ead2 <__lshift+0xb6>
 801ea6a:	6920      	ldr	r0, [r4, #16]
 801ea6c:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 801ea70:	f104 0314 	add.w	r3, r4, #20
 801ea74:	f019 091f 	ands.w	r9, r9, #31
 801ea78:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 801ea7c:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 801ea80:	d02b      	beq.n	801eada <__lshift+0xbe>
 801ea82:	f1c9 0e20 	rsb	lr, r9, #32
 801ea86:	468a      	mov	sl, r1
 801ea88:	2200      	movs	r2, #0
 801ea8a:	6818      	ldr	r0, [r3, #0]
 801ea8c:	fa00 f009 	lsl.w	r0, r0, r9
 801ea90:	4310      	orrs	r0, r2
 801ea92:	f84a 0b04 	str.w	r0, [sl], #4
 801ea96:	f853 2b04 	ldr.w	r2, [r3], #4
 801ea9a:	459c      	cmp	ip, r3
 801ea9c:	fa22 f20e 	lsr.w	r2, r2, lr
 801eaa0:	d8f3      	bhi.n	801ea8a <__lshift+0x6e>
 801eaa2:	ebac 0304 	sub.w	r3, ip, r4
 801eaa6:	3b15      	subs	r3, #21
 801eaa8:	f023 0303 	bic.w	r3, r3, #3
 801eaac:	3304      	adds	r3, #4
 801eaae:	f104 0015 	add.w	r0, r4, #21
 801eab2:	4584      	cmp	ip, r0
 801eab4:	bf38      	it	cc
 801eab6:	2304      	movcc	r3, #4
 801eab8:	50ca      	str	r2, [r1, r3]
 801eaba:	b10a      	cbz	r2, 801eac0 <__lshift+0xa4>
 801eabc:	f108 0602 	add.w	r6, r8, #2
 801eac0:	3e01      	subs	r6, #1
 801eac2:	4638      	mov	r0, r7
 801eac4:	612e      	str	r6, [r5, #16]
 801eac6:	4621      	mov	r1, r4
 801eac8:	f7ff fdda 	bl	801e680 <_Bfree>
 801eacc:	4628      	mov	r0, r5
 801eace:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801ead2:	f842 0f04 	str.w	r0, [r2, #4]!
 801ead6:	3301      	adds	r3, #1
 801ead8:	e7c5      	b.n	801ea66 <__lshift+0x4a>
 801eada:	3904      	subs	r1, #4
 801eadc:	f853 2b04 	ldr.w	r2, [r3], #4
 801eae0:	f841 2f04 	str.w	r2, [r1, #4]!
 801eae4:	459c      	cmp	ip, r3
 801eae6:	d8f9      	bhi.n	801eadc <__lshift+0xc0>
 801eae8:	e7ea      	b.n	801eac0 <__lshift+0xa4>
 801eaea:	bf00      	nop
 801eaec:	08023af8 	.word	0x08023af8
 801eaf0:	08023b09 	.word	0x08023b09

0801eaf4 <__mcmp>:
 801eaf4:	690a      	ldr	r2, [r1, #16]
 801eaf6:	4603      	mov	r3, r0
 801eaf8:	6900      	ldr	r0, [r0, #16]
 801eafa:	1a80      	subs	r0, r0, r2
 801eafc:	b530      	push	{r4, r5, lr}
 801eafe:	d10e      	bne.n	801eb1e <__mcmp+0x2a>
 801eb00:	3314      	adds	r3, #20
 801eb02:	3114      	adds	r1, #20
 801eb04:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 801eb08:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 801eb0c:	f854 5d04 	ldr.w	r5, [r4, #-4]!
 801eb10:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 801eb14:	4295      	cmp	r5, r2
 801eb16:	d003      	beq.n	801eb20 <__mcmp+0x2c>
 801eb18:	d205      	bcs.n	801eb26 <__mcmp+0x32>
 801eb1a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801eb1e:	bd30      	pop	{r4, r5, pc}
 801eb20:	42a3      	cmp	r3, r4
 801eb22:	d3f3      	bcc.n	801eb0c <__mcmp+0x18>
 801eb24:	e7fb      	b.n	801eb1e <__mcmp+0x2a>
 801eb26:	2001      	movs	r0, #1
 801eb28:	e7f9      	b.n	801eb1e <__mcmp+0x2a>
	...

0801eb2c <__mdiff>:
 801eb2c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801eb30:	4689      	mov	r9, r1
 801eb32:	4606      	mov	r6, r0
 801eb34:	4611      	mov	r1, r2
 801eb36:	4648      	mov	r0, r9
 801eb38:	4614      	mov	r4, r2
 801eb3a:	f7ff ffdb 	bl	801eaf4 <__mcmp>
 801eb3e:	1e05      	subs	r5, r0, #0
 801eb40:	d112      	bne.n	801eb68 <__mdiff+0x3c>
 801eb42:	4629      	mov	r1, r5
 801eb44:	4630      	mov	r0, r6
 801eb46:	f7ff fd5b 	bl	801e600 <_Balloc>
 801eb4a:	4602      	mov	r2, r0
 801eb4c:	b928      	cbnz	r0, 801eb5a <__mdiff+0x2e>
 801eb4e:	4b3f      	ldr	r3, [pc, #252]	@ (801ec4c <__mdiff+0x120>)
 801eb50:	f240 2137 	movw	r1, #567	@ 0x237
 801eb54:	483e      	ldr	r0, [pc, #248]	@ (801ec50 <__mdiff+0x124>)
 801eb56:	f000 f991 	bl	801ee7c <__assert_func>
 801eb5a:	2301      	movs	r3, #1
 801eb5c:	e9c0 3504 	strd	r3, r5, [r0, #16]
 801eb60:	4610      	mov	r0, r2
 801eb62:	b003      	add	sp, #12
 801eb64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801eb68:	bfbc      	itt	lt
 801eb6a:	464b      	movlt	r3, r9
 801eb6c:	46a1      	movlt	r9, r4
 801eb6e:	4630      	mov	r0, r6
 801eb70:	f8d9 1004 	ldr.w	r1, [r9, #4]
 801eb74:	bfba      	itte	lt
 801eb76:	461c      	movlt	r4, r3
 801eb78:	2501      	movlt	r5, #1
 801eb7a:	2500      	movge	r5, #0
 801eb7c:	f7ff fd40 	bl	801e600 <_Balloc>
 801eb80:	4602      	mov	r2, r0
 801eb82:	b918      	cbnz	r0, 801eb8c <__mdiff+0x60>
 801eb84:	4b31      	ldr	r3, [pc, #196]	@ (801ec4c <__mdiff+0x120>)
 801eb86:	f240 2145 	movw	r1, #581	@ 0x245
 801eb8a:	e7e3      	b.n	801eb54 <__mdiff+0x28>
 801eb8c:	f8d9 7010 	ldr.w	r7, [r9, #16]
 801eb90:	6926      	ldr	r6, [r4, #16]
 801eb92:	60c5      	str	r5, [r0, #12]
 801eb94:	f109 0310 	add.w	r3, r9, #16
 801eb98:	f109 0514 	add.w	r5, r9, #20
 801eb9c:	f104 0e14 	add.w	lr, r4, #20
 801eba0:	f100 0b14 	add.w	fp, r0, #20
 801eba4:	eb05 0887 	add.w	r8, r5, r7, lsl #2
 801eba8:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
 801ebac:	9301      	str	r3, [sp, #4]
 801ebae:	46d9      	mov	r9, fp
 801ebb0:	f04f 0c00 	mov.w	ip, #0
 801ebb4:	9b01      	ldr	r3, [sp, #4]
 801ebb6:	f85e 0b04 	ldr.w	r0, [lr], #4
 801ebba:	f853 af04 	ldr.w	sl, [r3, #4]!
 801ebbe:	9301      	str	r3, [sp, #4]
 801ebc0:	fa1f f38a 	uxth.w	r3, sl
 801ebc4:	4619      	mov	r1, r3
 801ebc6:	b283      	uxth	r3, r0
 801ebc8:	1acb      	subs	r3, r1, r3
 801ebca:	0c00      	lsrs	r0, r0, #16
 801ebcc:	4463      	add	r3, ip
 801ebce:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
 801ebd2:	eb00 4023 	add.w	r0, r0, r3, asr #16
 801ebd6:	b29b      	uxth	r3, r3
 801ebd8:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 801ebdc:	4576      	cmp	r6, lr
 801ebde:	f849 3b04 	str.w	r3, [r9], #4
 801ebe2:	ea4f 4c20 	mov.w	ip, r0, asr #16
 801ebe6:	d8e5      	bhi.n	801ebb4 <__mdiff+0x88>
 801ebe8:	1b33      	subs	r3, r6, r4
 801ebea:	3b15      	subs	r3, #21
 801ebec:	f023 0303 	bic.w	r3, r3, #3
 801ebf0:	3415      	adds	r4, #21
 801ebf2:	3304      	adds	r3, #4
 801ebf4:	42a6      	cmp	r6, r4
 801ebf6:	bf38      	it	cc
 801ebf8:	2304      	movcc	r3, #4
 801ebfa:	441d      	add	r5, r3
 801ebfc:	445b      	add	r3, fp
 801ebfe:	461e      	mov	r6, r3
 801ec00:	462c      	mov	r4, r5
 801ec02:	4544      	cmp	r4, r8
 801ec04:	d30e      	bcc.n	801ec24 <__mdiff+0xf8>
 801ec06:	f108 0103 	add.w	r1, r8, #3
 801ec0a:	1b49      	subs	r1, r1, r5
 801ec0c:	f021 0103 	bic.w	r1, r1, #3
 801ec10:	3d03      	subs	r5, #3
 801ec12:	45a8      	cmp	r8, r5
 801ec14:	bf38      	it	cc
 801ec16:	2100      	movcc	r1, #0
 801ec18:	440b      	add	r3, r1
 801ec1a:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 801ec1e:	b191      	cbz	r1, 801ec46 <__mdiff+0x11a>
 801ec20:	6117      	str	r7, [r2, #16]
 801ec22:	e79d      	b.n	801eb60 <__mdiff+0x34>
 801ec24:	f854 1b04 	ldr.w	r1, [r4], #4
 801ec28:	46e6      	mov	lr, ip
 801ec2a:	0c08      	lsrs	r0, r1, #16
 801ec2c:	fa1c fc81 	uxtah	ip, ip, r1
 801ec30:	4471      	add	r1, lr
 801ec32:	eb00 402c 	add.w	r0, r0, ip, asr #16
 801ec36:	b289      	uxth	r1, r1
 801ec38:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 801ec3c:	f846 1b04 	str.w	r1, [r6], #4
 801ec40:	ea4f 4c20 	mov.w	ip, r0, asr #16
 801ec44:	e7dd      	b.n	801ec02 <__mdiff+0xd6>
 801ec46:	3f01      	subs	r7, #1
 801ec48:	e7e7      	b.n	801ec1a <__mdiff+0xee>
 801ec4a:	bf00      	nop
 801ec4c:	08023af8 	.word	0x08023af8
 801ec50:	08023b09 	.word	0x08023b09

0801ec54 <__d2b>:
 801ec54:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 801ec58:	460f      	mov	r7, r1
 801ec5a:	2101      	movs	r1, #1
 801ec5c:	ec59 8b10 	vmov	r8, r9, d0
 801ec60:	4616      	mov	r6, r2
 801ec62:	f7ff fccd 	bl	801e600 <_Balloc>
 801ec66:	4604      	mov	r4, r0
 801ec68:	b930      	cbnz	r0, 801ec78 <__d2b+0x24>
 801ec6a:	4602      	mov	r2, r0
 801ec6c:	4b23      	ldr	r3, [pc, #140]	@ (801ecfc <__d2b+0xa8>)
 801ec6e:	4824      	ldr	r0, [pc, #144]	@ (801ed00 <__d2b+0xac>)
 801ec70:	f240 310f 	movw	r1, #783	@ 0x30f
 801ec74:	f000 f902 	bl	801ee7c <__assert_func>
 801ec78:	f3c9 550a 	ubfx	r5, r9, #20, #11
 801ec7c:	f3c9 0313 	ubfx	r3, r9, #0, #20
 801ec80:	b10d      	cbz	r5, 801ec86 <__d2b+0x32>
 801ec82:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 801ec86:	9301      	str	r3, [sp, #4]
 801ec88:	f1b8 0300 	subs.w	r3, r8, #0
 801ec8c:	d023      	beq.n	801ecd6 <__d2b+0x82>
 801ec8e:	4668      	mov	r0, sp
 801ec90:	9300      	str	r3, [sp, #0]
 801ec92:	f7ff fd7c 	bl	801e78e <__lo0bits>
 801ec96:	e9dd 1200 	ldrd	r1, r2, [sp]
 801ec9a:	b1d0      	cbz	r0, 801ecd2 <__d2b+0x7e>
 801ec9c:	f1c0 0320 	rsb	r3, r0, #32
 801eca0:	fa02 f303 	lsl.w	r3, r2, r3
 801eca4:	430b      	orrs	r3, r1
 801eca6:	40c2      	lsrs	r2, r0
 801eca8:	6163      	str	r3, [r4, #20]
 801ecaa:	9201      	str	r2, [sp, #4]
 801ecac:	9b01      	ldr	r3, [sp, #4]
 801ecae:	61a3      	str	r3, [r4, #24]
 801ecb0:	2b00      	cmp	r3, #0
 801ecb2:	bf0c      	ite	eq
 801ecb4:	2201      	moveq	r2, #1
 801ecb6:	2202      	movne	r2, #2
 801ecb8:	6122      	str	r2, [r4, #16]
 801ecba:	b1a5      	cbz	r5, 801ece6 <__d2b+0x92>
 801ecbc:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
 801ecc0:	4405      	add	r5, r0
 801ecc2:	603d      	str	r5, [r7, #0]
 801ecc4:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
 801ecc8:	6030      	str	r0, [r6, #0]
 801ecca:	4620      	mov	r0, r4
 801eccc:	b003      	add	sp, #12
 801ecce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801ecd2:	6161      	str	r1, [r4, #20]
 801ecd4:	e7ea      	b.n	801ecac <__d2b+0x58>
 801ecd6:	a801      	add	r0, sp, #4
 801ecd8:	f7ff fd59 	bl	801e78e <__lo0bits>
 801ecdc:	9b01      	ldr	r3, [sp, #4]
 801ecde:	6163      	str	r3, [r4, #20]
 801ece0:	3020      	adds	r0, #32
 801ece2:	2201      	movs	r2, #1
 801ece4:	e7e8      	b.n	801ecb8 <__d2b+0x64>
 801ece6:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 801ecea:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
 801ecee:	6038      	str	r0, [r7, #0]
 801ecf0:	6918      	ldr	r0, [r3, #16]
 801ecf2:	f7ff fd2d 	bl	801e750 <__hi0bits>
 801ecf6:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 801ecfa:	e7e5      	b.n	801ecc8 <__d2b+0x74>
 801ecfc:	08023af8 	.word	0x08023af8
 801ed00:	08023b09 	.word	0x08023b09

0801ed04 <__sflush_r>:
 801ed04:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 801ed08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801ed0c:	0716      	lsls	r6, r2, #28
 801ed0e:	4605      	mov	r5, r0
 801ed10:	460c      	mov	r4, r1
 801ed12:	d454      	bmi.n	801edbe <__sflush_r+0xba>
 801ed14:	684b      	ldr	r3, [r1, #4]
 801ed16:	2b00      	cmp	r3, #0
 801ed18:	dc02      	bgt.n	801ed20 <__sflush_r+0x1c>
 801ed1a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 801ed1c:	2b00      	cmp	r3, #0
 801ed1e:	dd48      	ble.n	801edb2 <__sflush_r+0xae>
 801ed20:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 801ed22:	2e00      	cmp	r6, #0
 801ed24:	d045      	beq.n	801edb2 <__sflush_r+0xae>
 801ed26:	2300      	movs	r3, #0
 801ed28:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 801ed2c:	682f      	ldr	r7, [r5, #0]
 801ed2e:	6a21      	ldr	r1, [r4, #32]
 801ed30:	602b      	str	r3, [r5, #0]
 801ed32:	d030      	beq.n	801ed96 <__sflush_r+0x92>
 801ed34:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 801ed36:	89a3      	ldrh	r3, [r4, #12]
 801ed38:	0759      	lsls	r1, r3, #29
 801ed3a:	d505      	bpl.n	801ed48 <__sflush_r+0x44>
 801ed3c:	6863      	ldr	r3, [r4, #4]
 801ed3e:	1ad2      	subs	r2, r2, r3
 801ed40:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 801ed42:	b10b      	cbz	r3, 801ed48 <__sflush_r+0x44>
 801ed44:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 801ed46:	1ad2      	subs	r2, r2, r3
 801ed48:	2300      	movs	r3, #0
 801ed4a:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 801ed4c:	6a21      	ldr	r1, [r4, #32]
 801ed4e:	4628      	mov	r0, r5
 801ed50:	47b0      	blx	r6
 801ed52:	1c43      	adds	r3, r0, #1
 801ed54:	89a3      	ldrh	r3, [r4, #12]
 801ed56:	d106      	bne.n	801ed66 <__sflush_r+0x62>
 801ed58:	6829      	ldr	r1, [r5, #0]
 801ed5a:	291d      	cmp	r1, #29
 801ed5c:	d82b      	bhi.n	801edb6 <__sflush_r+0xb2>
 801ed5e:	4a2a      	ldr	r2, [pc, #168]	@ (801ee08 <__sflush_r+0x104>)
 801ed60:	410a      	asrs	r2, r1
 801ed62:	07d6      	lsls	r6, r2, #31
 801ed64:	d427      	bmi.n	801edb6 <__sflush_r+0xb2>
 801ed66:	2200      	movs	r2, #0
 801ed68:	6062      	str	r2, [r4, #4]
 801ed6a:	04d9      	lsls	r1, r3, #19
 801ed6c:	6922      	ldr	r2, [r4, #16]
 801ed6e:	6022      	str	r2, [r4, #0]
 801ed70:	d504      	bpl.n	801ed7c <__sflush_r+0x78>
 801ed72:	1c42      	adds	r2, r0, #1
 801ed74:	d101      	bne.n	801ed7a <__sflush_r+0x76>
 801ed76:	682b      	ldr	r3, [r5, #0]
 801ed78:	b903      	cbnz	r3, 801ed7c <__sflush_r+0x78>
 801ed7a:	6560      	str	r0, [r4, #84]	@ 0x54
 801ed7c:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 801ed7e:	602f      	str	r7, [r5, #0]
 801ed80:	b1b9      	cbz	r1, 801edb2 <__sflush_r+0xae>
 801ed82:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 801ed86:	4299      	cmp	r1, r3
 801ed88:	d002      	beq.n	801ed90 <__sflush_r+0x8c>
 801ed8a:	4628      	mov	r0, r5
 801ed8c:	f7ff fb38 	bl	801e400 <_free_r>
 801ed90:	2300      	movs	r3, #0
 801ed92:	6363      	str	r3, [r4, #52]	@ 0x34
 801ed94:	e00d      	b.n	801edb2 <__sflush_r+0xae>
 801ed96:	2301      	movs	r3, #1
 801ed98:	4628      	mov	r0, r5
 801ed9a:	47b0      	blx	r6
 801ed9c:	4602      	mov	r2, r0
 801ed9e:	1c50      	adds	r0, r2, #1
 801eda0:	d1c9      	bne.n	801ed36 <__sflush_r+0x32>
 801eda2:	682b      	ldr	r3, [r5, #0]
 801eda4:	2b00      	cmp	r3, #0
 801eda6:	d0c6      	beq.n	801ed36 <__sflush_r+0x32>
 801eda8:	2b1d      	cmp	r3, #29
 801edaa:	d001      	beq.n	801edb0 <__sflush_r+0xac>
 801edac:	2b16      	cmp	r3, #22
 801edae:	d11e      	bne.n	801edee <__sflush_r+0xea>
 801edb0:	602f      	str	r7, [r5, #0]
 801edb2:	2000      	movs	r0, #0
 801edb4:	e022      	b.n	801edfc <__sflush_r+0xf8>
 801edb6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801edba:	b21b      	sxth	r3, r3
 801edbc:	e01b      	b.n	801edf6 <__sflush_r+0xf2>
 801edbe:	690f      	ldr	r7, [r1, #16]
 801edc0:	2f00      	cmp	r7, #0
 801edc2:	d0f6      	beq.n	801edb2 <__sflush_r+0xae>
 801edc4:	0793      	lsls	r3, r2, #30
 801edc6:	680e      	ldr	r6, [r1, #0]
 801edc8:	bf08      	it	eq
 801edca:	694b      	ldreq	r3, [r1, #20]
 801edcc:	600f      	str	r7, [r1, #0]
 801edce:	bf18      	it	ne
 801edd0:	2300      	movne	r3, #0
 801edd2:	eba6 0807 	sub.w	r8, r6, r7
 801edd6:	608b      	str	r3, [r1, #8]
 801edd8:	f1b8 0f00 	cmp.w	r8, #0
 801eddc:	dde9      	ble.n	801edb2 <__sflush_r+0xae>
 801edde:	6a21      	ldr	r1, [r4, #32]
 801ede0:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 801ede2:	4643      	mov	r3, r8
 801ede4:	463a      	mov	r2, r7
 801ede6:	4628      	mov	r0, r5
 801ede8:	47b0      	blx	r6
 801edea:	2800      	cmp	r0, #0
 801edec:	dc08      	bgt.n	801ee00 <__sflush_r+0xfc>
 801edee:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801edf2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801edf6:	81a3      	strh	r3, [r4, #12]
 801edf8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801edfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801ee00:	4407      	add	r7, r0
 801ee02:	eba8 0800 	sub.w	r8, r8, r0
 801ee06:	e7e7      	b.n	801edd8 <__sflush_r+0xd4>
 801ee08:	dfbffffe 	.word	0xdfbffffe

0801ee0c <_fflush_r>:
 801ee0c:	b538      	push	{r3, r4, r5, lr}
 801ee0e:	690b      	ldr	r3, [r1, #16]
 801ee10:	4605      	mov	r5, r0
 801ee12:	460c      	mov	r4, r1
 801ee14:	b913      	cbnz	r3, 801ee1c <_fflush_r+0x10>
 801ee16:	2500      	movs	r5, #0
 801ee18:	4628      	mov	r0, r5
 801ee1a:	bd38      	pop	{r3, r4, r5, pc}
 801ee1c:	b118      	cbz	r0, 801ee26 <_fflush_r+0x1a>
 801ee1e:	6a03      	ldr	r3, [r0, #32]
 801ee20:	b90b      	cbnz	r3, 801ee26 <_fflush_r+0x1a>
 801ee22:	f7fe fb97 	bl	801d554 <__sinit>
 801ee26:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801ee2a:	2b00      	cmp	r3, #0
 801ee2c:	d0f3      	beq.n	801ee16 <_fflush_r+0xa>
 801ee2e:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 801ee30:	07d0      	lsls	r0, r2, #31
 801ee32:	d404      	bmi.n	801ee3e <_fflush_r+0x32>
 801ee34:	0599      	lsls	r1, r3, #22
 801ee36:	d402      	bmi.n	801ee3e <_fflush_r+0x32>
 801ee38:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801ee3a:	f7fe fc82 	bl	801d742 <__retarget_lock_acquire_recursive>
 801ee3e:	4628      	mov	r0, r5
 801ee40:	4621      	mov	r1, r4
 801ee42:	f7ff ff5f 	bl	801ed04 <__sflush_r>
 801ee46:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 801ee48:	07da      	lsls	r2, r3, #31
 801ee4a:	4605      	mov	r5, r0
 801ee4c:	d4e4      	bmi.n	801ee18 <_fflush_r+0xc>
 801ee4e:	89a3      	ldrh	r3, [r4, #12]
 801ee50:	059b      	lsls	r3, r3, #22
 801ee52:	d4e1      	bmi.n	801ee18 <_fflush_r+0xc>
 801ee54:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801ee56:	f7fe fc75 	bl	801d744 <__retarget_lock_release_recursive>
 801ee5a:	e7dd      	b.n	801ee18 <_fflush_r+0xc>

0801ee5c <_sbrk_r>:
 801ee5c:	b538      	push	{r3, r4, r5, lr}
 801ee5e:	4d06      	ldr	r5, [pc, #24]	@ (801ee78 <_sbrk_r+0x1c>)
 801ee60:	2300      	movs	r3, #0
 801ee62:	4604      	mov	r4, r0
 801ee64:	4608      	mov	r0, r1
 801ee66:	602b      	str	r3, [r5, #0]
 801ee68:	f7e7 f90e 	bl	8006088 <_sbrk>
 801ee6c:	1c43      	adds	r3, r0, #1
 801ee6e:	d102      	bne.n	801ee76 <_sbrk_r+0x1a>
 801ee70:	682b      	ldr	r3, [r5, #0]
 801ee72:	b103      	cbz	r3, 801ee76 <_sbrk_r+0x1a>
 801ee74:	6023      	str	r3, [r4, #0]
 801ee76:	bd38      	pop	{r3, r4, r5, pc}
 801ee78:	20002450 	.word	0x20002450

0801ee7c <__assert_func>:
 801ee7c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801ee7e:	4614      	mov	r4, r2
 801ee80:	461a      	mov	r2, r3
 801ee82:	4b09      	ldr	r3, [pc, #36]	@ (801eea8 <__assert_func+0x2c>)
 801ee84:	681b      	ldr	r3, [r3, #0]
 801ee86:	4605      	mov	r5, r0
 801ee88:	68d8      	ldr	r0, [r3, #12]
 801ee8a:	b954      	cbnz	r4, 801eea2 <__assert_func+0x26>
 801ee8c:	4b07      	ldr	r3, [pc, #28]	@ (801eeac <__assert_func+0x30>)
 801ee8e:	461c      	mov	r4, r3
 801ee90:	e9cd 3401 	strd	r3, r4, [sp, #4]
 801ee94:	9100      	str	r1, [sp, #0]
 801ee96:	462b      	mov	r3, r5
 801ee98:	4905      	ldr	r1, [pc, #20]	@ (801eeb0 <__assert_func+0x34>)
 801ee9a:	f000 f841 	bl	801ef20 <fiprintf>
 801ee9e:	f000 f851 	bl	801ef44 <abort>
 801eea2:	4b04      	ldr	r3, [pc, #16]	@ (801eeb4 <__assert_func+0x38>)
 801eea4:	e7f4      	b.n	801ee90 <__assert_func+0x14>
 801eea6:	bf00      	nop
 801eea8:	20000360 	.word	0x20000360
 801eeac:	08023ca5 	.word	0x08023ca5
 801eeb0:	08023c77 	.word	0x08023c77
 801eeb4:	08023c6a 	.word	0x08023c6a

0801eeb8 <_calloc_r>:
 801eeb8:	b570      	push	{r4, r5, r6, lr}
 801eeba:	fba1 5402 	umull	r5, r4, r1, r2
 801eebe:	b93c      	cbnz	r4, 801eed0 <_calloc_r+0x18>
 801eec0:	4629      	mov	r1, r5
 801eec2:	f7ff fb11 	bl	801e4e8 <_malloc_r>
 801eec6:	4606      	mov	r6, r0
 801eec8:	b928      	cbnz	r0, 801eed6 <_calloc_r+0x1e>
 801eeca:	2600      	movs	r6, #0
 801eecc:	4630      	mov	r0, r6
 801eece:	bd70      	pop	{r4, r5, r6, pc}
 801eed0:	220c      	movs	r2, #12
 801eed2:	6002      	str	r2, [r0, #0]
 801eed4:	e7f9      	b.n	801eeca <_calloc_r+0x12>
 801eed6:	462a      	mov	r2, r5
 801eed8:	4621      	mov	r1, r4
 801eeda:	f7fe fbb4 	bl	801d646 <memset>
 801eede:	e7f5      	b.n	801eecc <_calloc_r+0x14>

0801eee0 <__ascii_mbtowc>:
 801eee0:	b082      	sub	sp, #8
 801eee2:	b901      	cbnz	r1, 801eee6 <__ascii_mbtowc+0x6>
 801eee4:	a901      	add	r1, sp, #4
 801eee6:	b142      	cbz	r2, 801eefa <__ascii_mbtowc+0x1a>
 801eee8:	b14b      	cbz	r3, 801eefe <__ascii_mbtowc+0x1e>
 801eeea:	7813      	ldrb	r3, [r2, #0]
 801eeec:	600b      	str	r3, [r1, #0]
 801eeee:	7812      	ldrb	r2, [r2, #0]
 801eef0:	1e10      	subs	r0, r2, #0
 801eef2:	bf18      	it	ne
 801eef4:	2001      	movne	r0, #1
 801eef6:	b002      	add	sp, #8
 801eef8:	4770      	bx	lr
 801eefa:	4610      	mov	r0, r2
 801eefc:	e7fb      	b.n	801eef6 <__ascii_mbtowc+0x16>
 801eefe:	f06f 0001 	mvn.w	r0, #1
 801ef02:	e7f8      	b.n	801eef6 <__ascii_mbtowc+0x16>

0801ef04 <__ascii_wctomb>:
 801ef04:	4603      	mov	r3, r0
 801ef06:	4608      	mov	r0, r1
 801ef08:	b141      	cbz	r1, 801ef1c <__ascii_wctomb+0x18>
 801ef0a:	2aff      	cmp	r2, #255	@ 0xff
 801ef0c:	d904      	bls.n	801ef18 <__ascii_wctomb+0x14>
 801ef0e:	228a      	movs	r2, #138	@ 0x8a
 801ef10:	601a      	str	r2, [r3, #0]
 801ef12:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801ef16:	4770      	bx	lr
 801ef18:	700a      	strb	r2, [r1, #0]
 801ef1a:	2001      	movs	r0, #1
 801ef1c:	4770      	bx	lr
	...

0801ef20 <fiprintf>:
 801ef20:	b40e      	push	{r1, r2, r3}
 801ef22:	b503      	push	{r0, r1, lr}
 801ef24:	4601      	mov	r1, r0
 801ef26:	ab03      	add	r3, sp, #12
 801ef28:	4805      	ldr	r0, [pc, #20]	@ (801ef40 <fiprintf+0x20>)
 801ef2a:	f853 2b04 	ldr.w	r2, [r3], #4
 801ef2e:	6800      	ldr	r0, [r0, #0]
 801ef30:	9301      	str	r3, [sp, #4]
 801ef32:	f000 f837 	bl	801efa4 <_vfiprintf_r>
 801ef36:	b002      	add	sp, #8
 801ef38:	f85d eb04 	ldr.w	lr, [sp], #4
 801ef3c:	b003      	add	sp, #12
 801ef3e:	4770      	bx	lr
 801ef40:	20000360 	.word	0x20000360

0801ef44 <abort>:
 801ef44:	b508      	push	{r3, lr}
 801ef46:	2006      	movs	r0, #6
 801ef48:	f000 fa00 	bl	801f34c <raise>
 801ef4c:	2001      	movs	r0, #1
 801ef4e:	f7e7 f823 	bl	8005f98 <_exit>

0801ef52 <__sfputc_r>:
 801ef52:	6893      	ldr	r3, [r2, #8]
 801ef54:	3b01      	subs	r3, #1
 801ef56:	2b00      	cmp	r3, #0
 801ef58:	b410      	push	{r4}
 801ef5a:	6093      	str	r3, [r2, #8]
 801ef5c:	da08      	bge.n	801ef70 <__sfputc_r+0x1e>
 801ef5e:	6994      	ldr	r4, [r2, #24]
 801ef60:	42a3      	cmp	r3, r4
 801ef62:	db01      	blt.n	801ef68 <__sfputc_r+0x16>
 801ef64:	290a      	cmp	r1, #10
 801ef66:	d103      	bne.n	801ef70 <__sfputc_r+0x1e>
 801ef68:	f85d 4b04 	ldr.w	r4, [sp], #4
 801ef6c:	f000 b932 	b.w	801f1d4 <__swbuf_r>
 801ef70:	6813      	ldr	r3, [r2, #0]
 801ef72:	1c58      	adds	r0, r3, #1
 801ef74:	6010      	str	r0, [r2, #0]
 801ef76:	7019      	strb	r1, [r3, #0]
 801ef78:	4608      	mov	r0, r1
 801ef7a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801ef7e:	4770      	bx	lr

0801ef80 <__sfputs_r>:
 801ef80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ef82:	4606      	mov	r6, r0
 801ef84:	460f      	mov	r7, r1
 801ef86:	4614      	mov	r4, r2
 801ef88:	18d5      	adds	r5, r2, r3
 801ef8a:	42ac      	cmp	r4, r5
 801ef8c:	d101      	bne.n	801ef92 <__sfputs_r+0x12>
 801ef8e:	2000      	movs	r0, #0
 801ef90:	e007      	b.n	801efa2 <__sfputs_r+0x22>
 801ef92:	f814 1b01 	ldrb.w	r1, [r4], #1
 801ef96:	463a      	mov	r2, r7
 801ef98:	4630      	mov	r0, r6
 801ef9a:	f7ff ffda 	bl	801ef52 <__sfputc_r>
 801ef9e:	1c43      	adds	r3, r0, #1
 801efa0:	d1f3      	bne.n	801ef8a <__sfputs_r+0xa>
 801efa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0801efa4 <_vfiprintf_r>:
 801efa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801efa8:	460d      	mov	r5, r1
 801efaa:	b09d      	sub	sp, #116	@ 0x74
 801efac:	4614      	mov	r4, r2
 801efae:	4698      	mov	r8, r3
 801efb0:	4606      	mov	r6, r0
 801efb2:	b118      	cbz	r0, 801efbc <_vfiprintf_r+0x18>
 801efb4:	6a03      	ldr	r3, [r0, #32]
 801efb6:	b90b      	cbnz	r3, 801efbc <_vfiprintf_r+0x18>
 801efb8:	f7fe facc 	bl	801d554 <__sinit>
 801efbc:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801efbe:	07d9      	lsls	r1, r3, #31
 801efc0:	d405      	bmi.n	801efce <_vfiprintf_r+0x2a>
 801efc2:	89ab      	ldrh	r3, [r5, #12]
 801efc4:	059a      	lsls	r2, r3, #22
 801efc6:	d402      	bmi.n	801efce <_vfiprintf_r+0x2a>
 801efc8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 801efca:	f7fe fbba 	bl	801d742 <__retarget_lock_acquire_recursive>
 801efce:	89ab      	ldrh	r3, [r5, #12]
 801efd0:	071b      	lsls	r3, r3, #28
 801efd2:	d501      	bpl.n	801efd8 <_vfiprintf_r+0x34>
 801efd4:	692b      	ldr	r3, [r5, #16]
 801efd6:	b99b      	cbnz	r3, 801f000 <_vfiprintf_r+0x5c>
 801efd8:	4629      	mov	r1, r5
 801efda:	4630      	mov	r0, r6
 801efdc:	f000 f938 	bl	801f250 <__swsetup_r>
 801efe0:	b170      	cbz	r0, 801f000 <_vfiprintf_r+0x5c>
 801efe2:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801efe4:	07dc      	lsls	r4, r3, #31
 801efe6:	d504      	bpl.n	801eff2 <_vfiprintf_r+0x4e>
 801efe8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801efec:	b01d      	add	sp, #116	@ 0x74
 801efee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801eff2:	89ab      	ldrh	r3, [r5, #12]
 801eff4:	0598      	lsls	r0, r3, #22
 801eff6:	d4f7      	bmi.n	801efe8 <_vfiprintf_r+0x44>
 801eff8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 801effa:	f7fe fba3 	bl	801d744 <__retarget_lock_release_recursive>
 801effe:	e7f3      	b.n	801efe8 <_vfiprintf_r+0x44>
 801f000:	2300      	movs	r3, #0
 801f002:	9309      	str	r3, [sp, #36]	@ 0x24
 801f004:	2320      	movs	r3, #32
 801f006:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 801f00a:	f8cd 800c 	str.w	r8, [sp, #12]
 801f00e:	2330      	movs	r3, #48	@ 0x30
 801f010:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 801f1c0 <_vfiprintf_r+0x21c>
 801f014:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 801f018:	f04f 0901 	mov.w	r9, #1
 801f01c:	4623      	mov	r3, r4
 801f01e:	469a      	mov	sl, r3
 801f020:	f813 2b01 	ldrb.w	r2, [r3], #1
 801f024:	b10a      	cbz	r2, 801f02a <_vfiprintf_r+0x86>
 801f026:	2a25      	cmp	r2, #37	@ 0x25
 801f028:	d1f9      	bne.n	801f01e <_vfiprintf_r+0x7a>
 801f02a:	ebba 0b04 	subs.w	fp, sl, r4
 801f02e:	d00b      	beq.n	801f048 <_vfiprintf_r+0xa4>
 801f030:	465b      	mov	r3, fp
 801f032:	4622      	mov	r2, r4
 801f034:	4629      	mov	r1, r5
 801f036:	4630      	mov	r0, r6
 801f038:	f7ff ffa2 	bl	801ef80 <__sfputs_r>
 801f03c:	3001      	adds	r0, #1
 801f03e:	f000 80a7 	beq.w	801f190 <_vfiprintf_r+0x1ec>
 801f042:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801f044:	445a      	add	r2, fp
 801f046:	9209      	str	r2, [sp, #36]	@ 0x24
 801f048:	f89a 3000 	ldrb.w	r3, [sl]
 801f04c:	2b00      	cmp	r3, #0
 801f04e:	f000 809f 	beq.w	801f190 <_vfiprintf_r+0x1ec>
 801f052:	2300      	movs	r3, #0
 801f054:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801f058:	e9cd 2305 	strd	r2, r3, [sp, #20]
 801f05c:	f10a 0a01 	add.w	sl, sl, #1
 801f060:	9304      	str	r3, [sp, #16]
 801f062:	9307      	str	r3, [sp, #28]
 801f064:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 801f068:	931a      	str	r3, [sp, #104]	@ 0x68
 801f06a:	4654      	mov	r4, sl
 801f06c:	2205      	movs	r2, #5
 801f06e:	f814 1b01 	ldrb.w	r1, [r4], #1
 801f072:	4853      	ldr	r0, [pc, #332]	@ (801f1c0 <_vfiprintf_r+0x21c>)
 801f074:	f7e1 f8b4 	bl	80001e0 <memchr>
 801f078:	9a04      	ldr	r2, [sp, #16]
 801f07a:	b9d8      	cbnz	r0, 801f0b4 <_vfiprintf_r+0x110>
 801f07c:	06d1      	lsls	r1, r2, #27
 801f07e:	bf44      	itt	mi
 801f080:	2320      	movmi	r3, #32
 801f082:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 801f086:	0713      	lsls	r3, r2, #28
 801f088:	bf44      	itt	mi
 801f08a:	232b      	movmi	r3, #43	@ 0x2b
 801f08c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 801f090:	f89a 3000 	ldrb.w	r3, [sl]
 801f094:	2b2a      	cmp	r3, #42	@ 0x2a
 801f096:	d015      	beq.n	801f0c4 <_vfiprintf_r+0x120>
 801f098:	9a07      	ldr	r2, [sp, #28]
 801f09a:	4654      	mov	r4, sl
 801f09c:	2000      	movs	r0, #0
 801f09e:	f04f 0c0a 	mov.w	ip, #10
 801f0a2:	4621      	mov	r1, r4
 801f0a4:	f811 3b01 	ldrb.w	r3, [r1], #1
 801f0a8:	3b30      	subs	r3, #48	@ 0x30
 801f0aa:	2b09      	cmp	r3, #9
 801f0ac:	d94b      	bls.n	801f146 <_vfiprintf_r+0x1a2>
 801f0ae:	b1b0      	cbz	r0, 801f0de <_vfiprintf_r+0x13a>
 801f0b0:	9207      	str	r2, [sp, #28]
 801f0b2:	e014      	b.n	801f0de <_vfiprintf_r+0x13a>
 801f0b4:	eba0 0308 	sub.w	r3, r0, r8
 801f0b8:	fa09 f303 	lsl.w	r3, r9, r3
 801f0bc:	4313      	orrs	r3, r2
 801f0be:	9304      	str	r3, [sp, #16]
 801f0c0:	46a2      	mov	sl, r4
 801f0c2:	e7d2      	b.n	801f06a <_vfiprintf_r+0xc6>
 801f0c4:	9b03      	ldr	r3, [sp, #12]
 801f0c6:	1d19      	adds	r1, r3, #4
 801f0c8:	681b      	ldr	r3, [r3, #0]
 801f0ca:	9103      	str	r1, [sp, #12]
 801f0cc:	2b00      	cmp	r3, #0
 801f0ce:	bfbb      	ittet	lt
 801f0d0:	425b      	neglt	r3, r3
 801f0d2:	f042 0202 	orrlt.w	r2, r2, #2
 801f0d6:	9307      	strge	r3, [sp, #28]
 801f0d8:	9307      	strlt	r3, [sp, #28]
 801f0da:	bfb8      	it	lt
 801f0dc:	9204      	strlt	r2, [sp, #16]
 801f0de:	7823      	ldrb	r3, [r4, #0]
 801f0e0:	2b2e      	cmp	r3, #46	@ 0x2e
 801f0e2:	d10a      	bne.n	801f0fa <_vfiprintf_r+0x156>
 801f0e4:	7863      	ldrb	r3, [r4, #1]
 801f0e6:	2b2a      	cmp	r3, #42	@ 0x2a
 801f0e8:	d132      	bne.n	801f150 <_vfiprintf_r+0x1ac>
 801f0ea:	9b03      	ldr	r3, [sp, #12]
 801f0ec:	1d1a      	adds	r2, r3, #4
 801f0ee:	681b      	ldr	r3, [r3, #0]
 801f0f0:	9203      	str	r2, [sp, #12]
 801f0f2:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 801f0f6:	3402      	adds	r4, #2
 801f0f8:	9305      	str	r3, [sp, #20]
 801f0fa:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 801f1d0 <_vfiprintf_r+0x22c>
 801f0fe:	7821      	ldrb	r1, [r4, #0]
 801f100:	2203      	movs	r2, #3
 801f102:	4650      	mov	r0, sl
 801f104:	f7e1 f86c 	bl	80001e0 <memchr>
 801f108:	b138      	cbz	r0, 801f11a <_vfiprintf_r+0x176>
 801f10a:	9b04      	ldr	r3, [sp, #16]
 801f10c:	eba0 000a 	sub.w	r0, r0, sl
 801f110:	2240      	movs	r2, #64	@ 0x40
 801f112:	4082      	lsls	r2, r0
 801f114:	4313      	orrs	r3, r2
 801f116:	3401      	adds	r4, #1
 801f118:	9304      	str	r3, [sp, #16]
 801f11a:	f814 1b01 	ldrb.w	r1, [r4], #1
 801f11e:	4829      	ldr	r0, [pc, #164]	@ (801f1c4 <_vfiprintf_r+0x220>)
 801f120:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 801f124:	2206      	movs	r2, #6
 801f126:	f7e1 f85b 	bl	80001e0 <memchr>
 801f12a:	2800      	cmp	r0, #0
 801f12c:	d03f      	beq.n	801f1ae <_vfiprintf_r+0x20a>
 801f12e:	4b26      	ldr	r3, [pc, #152]	@ (801f1c8 <_vfiprintf_r+0x224>)
 801f130:	bb1b      	cbnz	r3, 801f17a <_vfiprintf_r+0x1d6>
 801f132:	9b03      	ldr	r3, [sp, #12]
 801f134:	3307      	adds	r3, #7
 801f136:	f023 0307 	bic.w	r3, r3, #7
 801f13a:	3308      	adds	r3, #8
 801f13c:	9303      	str	r3, [sp, #12]
 801f13e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801f140:	443b      	add	r3, r7
 801f142:	9309      	str	r3, [sp, #36]	@ 0x24
 801f144:	e76a      	b.n	801f01c <_vfiprintf_r+0x78>
 801f146:	fb0c 3202 	mla	r2, ip, r2, r3
 801f14a:	460c      	mov	r4, r1
 801f14c:	2001      	movs	r0, #1
 801f14e:	e7a8      	b.n	801f0a2 <_vfiprintf_r+0xfe>
 801f150:	2300      	movs	r3, #0
 801f152:	3401      	adds	r4, #1
 801f154:	9305      	str	r3, [sp, #20]
 801f156:	4619      	mov	r1, r3
 801f158:	f04f 0c0a 	mov.w	ip, #10
 801f15c:	4620      	mov	r0, r4
 801f15e:	f810 2b01 	ldrb.w	r2, [r0], #1
 801f162:	3a30      	subs	r2, #48	@ 0x30
 801f164:	2a09      	cmp	r2, #9
 801f166:	d903      	bls.n	801f170 <_vfiprintf_r+0x1cc>
 801f168:	2b00      	cmp	r3, #0
 801f16a:	d0c6      	beq.n	801f0fa <_vfiprintf_r+0x156>
 801f16c:	9105      	str	r1, [sp, #20]
 801f16e:	e7c4      	b.n	801f0fa <_vfiprintf_r+0x156>
 801f170:	fb0c 2101 	mla	r1, ip, r1, r2
 801f174:	4604      	mov	r4, r0
 801f176:	2301      	movs	r3, #1
 801f178:	e7f0      	b.n	801f15c <_vfiprintf_r+0x1b8>
 801f17a:	ab03      	add	r3, sp, #12
 801f17c:	9300      	str	r3, [sp, #0]
 801f17e:	462a      	mov	r2, r5
 801f180:	4b12      	ldr	r3, [pc, #72]	@ (801f1cc <_vfiprintf_r+0x228>)
 801f182:	a904      	add	r1, sp, #16
 801f184:	4630      	mov	r0, r6
 801f186:	f7fd fda1 	bl	801cccc <_printf_float>
 801f18a:	4607      	mov	r7, r0
 801f18c:	1c78      	adds	r0, r7, #1
 801f18e:	d1d6      	bne.n	801f13e <_vfiprintf_r+0x19a>
 801f190:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801f192:	07d9      	lsls	r1, r3, #31
 801f194:	d405      	bmi.n	801f1a2 <_vfiprintf_r+0x1fe>
 801f196:	89ab      	ldrh	r3, [r5, #12]
 801f198:	059a      	lsls	r2, r3, #22
 801f19a:	d402      	bmi.n	801f1a2 <_vfiprintf_r+0x1fe>
 801f19c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 801f19e:	f7fe fad1 	bl	801d744 <__retarget_lock_release_recursive>
 801f1a2:	89ab      	ldrh	r3, [r5, #12]
 801f1a4:	065b      	lsls	r3, r3, #25
 801f1a6:	f53f af1f 	bmi.w	801efe8 <_vfiprintf_r+0x44>
 801f1aa:	9809      	ldr	r0, [sp, #36]	@ 0x24
 801f1ac:	e71e      	b.n	801efec <_vfiprintf_r+0x48>
 801f1ae:	ab03      	add	r3, sp, #12
 801f1b0:	9300      	str	r3, [sp, #0]
 801f1b2:	462a      	mov	r2, r5
 801f1b4:	4b05      	ldr	r3, [pc, #20]	@ (801f1cc <_vfiprintf_r+0x228>)
 801f1b6:	a904      	add	r1, sp, #16
 801f1b8:	4630      	mov	r0, r6
 801f1ba:	f7fe f81f 	bl	801d1fc <_printf_i>
 801f1be:	e7e4      	b.n	801f18a <_vfiprintf_r+0x1e6>
 801f1c0:	08023da7 	.word	0x08023da7
 801f1c4:	08023db1 	.word	0x08023db1
 801f1c8:	0801cccd 	.word	0x0801cccd
 801f1cc:	0801ef81 	.word	0x0801ef81
 801f1d0:	08023dad 	.word	0x08023dad

0801f1d4 <__swbuf_r>:
 801f1d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f1d6:	460e      	mov	r6, r1
 801f1d8:	4614      	mov	r4, r2
 801f1da:	4605      	mov	r5, r0
 801f1dc:	b118      	cbz	r0, 801f1e6 <__swbuf_r+0x12>
 801f1de:	6a03      	ldr	r3, [r0, #32]
 801f1e0:	b90b      	cbnz	r3, 801f1e6 <__swbuf_r+0x12>
 801f1e2:	f7fe f9b7 	bl	801d554 <__sinit>
 801f1e6:	69a3      	ldr	r3, [r4, #24]
 801f1e8:	60a3      	str	r3, [r4, #8]
 801f1ea:	89a3      	ldrh	r3, [r4, #12]
 801f1ec:	071a      	lsls	r2, r3, #28
 801f1ee:	d501      	bpl.n	801f1f4 <__swbuf_r+0x20>
 801f1f0:	6923      	ldr	r3, [r4, #16]
 801f1f2:	b943      	cbnz	r3, 801f206 <__swbuf_r+0x32>
 801f1f4:	4621      	mov	r1, r4
 801f1f6:	4628      	mov	r0, r5
 801f1f8:	f000 f82a 	bl	801f250 <__swsetup_r>
 801f1fc:	b118      	cbz	r0, 801f206 <__swbuf_r+0x32>
 801f1fe:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
 801f202:	4638      	mov	r0, r7
 801f204:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801f206:	6823      	ldr	r3, [r4, #0]
 801f208:	6922      	ldr	r2, [r4, #16]
 801f20a:	1a98      	subs	r0, r3, r2
 801f20c:	6963      	ldr	r3, [r4, #20]
 801f20e:	b2f6      	uxtb	r6, r6
 801f210:	4283      	cmp	r3, r0
 801f212:	4637      	mov	r7, r6
 801f214:	dc05      	bgt.n	801f222 <__swbuf_r+0x4e>
 801f216:	4621      	mov	r1, r4
 801f218:	4628      	mov	r0, r5
 801f21a:	f7ff fdf7 	bl	801ee0c <_fflush_r>
 801f21e:	2800      	cmp	r0, #0
 801f220:	d1ed      	bne.n	801f1fe <__swbuf_r+0x2a>
 801f222:	68a3      	ldr	r3, [r4, #8]
 801f224:	3b01      	subs	r3, #1
 801f226:	60a3      	str	r3, [r4, #8]
 801f228:	6823      	ldr	r3, [r4, #0]
 801f22a:	1c5a      	adds	r2, r3, #1
 801f22c:	6022      	str	r2, [r4, #0]
 801f22e:	701e      	strb	r6, [r3, #0]
 801f230:	6962      	ldr	r2, [r4, #20]
 801f232:	1c43      	adds	r3, r0, #1
 801f234:	429a      	cmp	r2, r3
 801f236:	d004      	beq.n	801f242 <__swbuf_r+0x6e>
 801f238:	89a3      	ldrh	r3, [r4, #12]
 801f23a:	07db      	lsls	r3, r3, #31
 801f23c:	d5e1      	bpl.n	801f202 <__swbuf_r+0x2e>
 801f23e:	2e0a      	cmp	r6, #10
 801f240:	d1df      	bne.n	801f202 <__swbuf_r+0x2e>
 801f242:	4621      	mov	r1, r4
 801f244:	4628      	mov	r0, r5
 801f246:	f7ff fde1 	bl	801ee0c <_fflush_r>
 801f24a:	2800      	cmp	r0, #0
 801f24c:	d0d9      	beq.n	801f202 <__swbuf_r+0x2e>
 801f24e:	e7d6      	b.n	801f1fe <__swbuf_r+0x2a>

0801f250 <__swsetup_r>:
 801f250:	b538      	push	{r3, r4, r5, lr}
 801f252:	4b29      	ldr	r3, [pc, #164]	@ (801f2f8 <__swsetup_r+0xa8>)
 801f254:	4605      	mov	r5, r0
 801f256:	6818      	ldr	r0, [r3, #0]
 801f258:	460c      	mov	r4, r1
 801f25a:	b118      	cbz	r0, 801f264 <__swsetup_r+0x14>
 801f25c:	6a03      	ldr	r3, [r0, #32]
 801f25e:	b90b      	cbnz	r3, 801f264 <__swsetup_r+0x14>
 801f260:	f7fe f978 	bl	801d554 <__sinit>
 801f264:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801f268:	0719      	lsls	r1, r3, #28
 801f26a:	d422      	bmi.n	801f2b2 <__swsetup_r+0x62>
 801f26c:	06da      	lsls	r2, r3, #27
 801f26e:	d407      	bmi.n	801f280 <__swsetup_r+0x30>
 801f270:	2209      	movs	r2, #9
 801f272:	602a      	str	r2, [r5, #0]
 801f274:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801f278:	81a3      	strh	r3, [r4, #12]
 801f27a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801f27e:	e033      	b.n	801f2e8 <__swsetup_r+0x98>
 801f280:	0758      	lsls	r0, r3, #29
 801f282:	d512      	bpl.n	801f2aa <__swsetup_r+0x5a>
 801f284:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 801f286:	b141      	cbz	r1, 801f29a <__swsetup_r+0x4a>
 801f288:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 801f28c:	4299      	cmp	r1, r3
 801f28e:	d002      	beq.n	801f296 <__swsetup_r+0x46>
 801f290:	4628      	mov	r0, r5
 801f292:	f7ff f8b5 	bl	801e400 <_free_r>
 801f296:	2300      	movs	r3, #0
 801f298:	6363      	str	r3, [r4, #52]	@ 0x34
 801f29a:	89a3      	ldrh	r3, [r4, #12]
 801f29c:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 801f2a0:	81a3      	strh	r3, [r4, #12]
 801f2a2:	2300      	movs	r3, #0
 801f2a4:	6063      	str	r3, [r4, #4]
 801f2a6:	6923      	ldr	r3, [r4, #16]
 801f2a8:	6023      	str	r3, [r4, #0]
 801f2aa:	89a3      	ldrh	r3, [r4, #12]
 801f2ac:	f043 0308 	orr.w	r3, r3, #8
 801f2b0:	81a3      	strh	r3, [r4, #12]
 801f2b2:	6923      	ldr	r3, [r4, #16]
 801f2b4:	b94b      	cbnz	r3, 801f2ca <__swsetup_r+0x7a>
 801f2b6:	89a3      	ldrh	r3, [r4, #12]
 801f2b8:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 801f2bc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801f2c0:	d003      	beq.n	801f2ca <__swsetup_r+0x7a>
 801f2c2:	4621      	mov	r1, r4
 801f2c4:	4628      	mov	r0, r5
 801f2c6:	f000 f883 	bl	801f3d0 <__smakebuf_r>
 801f2ca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801f2ce:	f013 0201 	ands.w	r2, r3, #1
 801f2d2:	d00a      	beq.n	801f2ea <__swsetup_r+0x9a>
 801f2d4:	2200      	movs	r2, #0
 801f2d6:	60a2      	str	r2, [r4, #8]
 801f2d8:	6962      	ldr	r2, [r4, #20]
 801f2da:	4252      	negs	r2, r2
 801f2dc:	61a2      	str	r2, [r4, #24]
 801f2de:	6922      	ldr	r2, [r4, #16]
 801f2e0:	b942      	cbnz	r2, 801f2f4 <__swsetup_r+0xa4>
 801f2e2:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 801f2e6:	d1c5      	bne.n	801f274 <__swsetup_r+0x24>
 801f2e8:	bd38      	pop	{r3, r4, r5, pc}
 801f2ea:	0799      	lsls	r1, r3, #30
 801f2ec:	bf58      	it	pl
 801f2ee:	6962      	ldrpl	r2, [r4, #20]
 801f2f0:	60a2      	str	r2, [r4, #8]
 801f2f2:	e7f4      	b.n	801f2de <__swsetup_r+0x8e>
 801f2f4:	2000      	movs	r0, #0
 801f2f6:	e7f7      	b.n	801f2e8 <__swsetup_r+0x98>
 801f2f8:	20000360 	.word	0x20000360

0801f2fc <_raise_r>:
 801f2fc:	291f      	cmp	r1, #31
 801f2fe:	b538      	push	{r3, r4, r5, lr}
 801f300:	4605      	mov	r5, r0
 801f302:	460c      	mov	r4, r1
 801f304:	d904      	bls.n	801f310 <_raise_r+0x14>
 801f306:	2316      	movs	r3, #22
 801f308:	6003      	str	r3, [r0, #0]
 801f30a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801f30e:	bd38      	pop	{r3, r4, r5, pc}
 801f310:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 801f312:	b112      	cbz	r2, 801f31a <_raise_r+0x1e>
 801f314:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 801f318:	b94b      	cbnz	r3, 801f32e <_raise_r+0x32>
 801f31a:	4628      	mov	r0, r5
 801f31c:	f000 f830 	bl	801f380 <_getpid_r>
 801f320:	4622      	mov	r2, r4
 801f322:	4601      	mov	r1, r0
 801f324:	4628      	mov	r0, r5
 801f326:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801f32a:	f000 b817 	b.w	801f35c <_kill_r>
 801f32e:	2b01      	cmp	r3, #1
 801f330:	d00a      	beq.n	801f348 <_raise_r+0x4c>
 801f332:	1c59      	adds	r1, r3, #1
 801f334:	d103      	bne.n	801f33e <_raise_r+0x42>
 801f336:	2316      	movs	r3, #22
 801f338:	6003      	str	r3, [r0, #0]
 801f33a:	2001      	movs	r0, #1
 801f33c:	e7e7      	b.n	801f30e <_raise_r+0x12>
 801f33e:	2100      	movs	r1, #0
 801f340:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 801f344:	4620      	mov	r0, r4
 801f346:	4798      	blx	r3
 801f348:	2000      	movs	r0, #0
 801f34a:	e7e0      	b.n	801f30e <_raise_r+0x12>

0801f34c <raise>:
 801f34c:	4b02      	ldr	r3, [pc, #8]	@ (801f358 <raise+0xc>)
 801f34e:	4601      	mov	r1, r0
 801f350:	6818      	ldr	r0, [r3, #0]
 801f352:	f7ff bfd3 	b.w	801f2fc <_raise_r>
 801f356:	bf00      	nop
 801f358:	20000360 	.word	0x20000360

0801f35c <_kill_r>:
 801f35c:	b538      	push	{r3, r4, r5, lr}
 801f35e:	4d07      	ldr	r5, [pc, #28]	@ (801f37c <_kill_r+0x20>)
 801f360:	2300      	movs	r3, #0
 801f362:	4604      	mov	r4, r0
 801f364:	4608      	mov	r0, r1
 801f366:	4611      	mov	r1, r2
 801f368:	602b      	str	r3, [r5, #0]
 801f36a:	f7e6 fe05 	bl	8005f78 <_kill>
 801f36e:	1c43      	adds	r3, r0, #1
 801f370:	d102      	bne.n	801f378 <_kill_r+0x1c>
 801f372:	682b      	ldr	r3, [r5, #0]
 801f374:	b103      	cbz	r3, 801f378 <_kill_r+0x1c>
 801f376:	6023      	str	r3, [r4, #0]
 801f378:	bd38      	pop	{r3, r4, r5, pc}
 801f37a:	bf00      	nop
 801f37c:	20002450 	.word	0x20002450

0801f380 <_getpid_r>:
 801f380:	f7e6 bdf2 	b.w	8005f68 <_getpid>

0801f384 <__swhatbuf_r>:
 801f384:	b570      	push	{r4, r5, r6, lr}
 801f386:	460c      	mov	r4, r1
 801f388:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801f38c:	2900      	cmp	r1, #0
 801f38e:	b096      	sub	sp, #88	@ 0x58
 801f390:	4615      	mov	r5, r2
 801f392:	461e      	mov	r6, r3
 801f394:	da0d      	bge.n	801f3b2 <__swhatbuf_r+0x2e>
 801f396:	89a3      	ldrh	r3, [r4, #12]
 801f398:	f013 0f80 	tst.w	r3, #128	@ 0x80
 801f39c:	f04f 0100 	mov.w	r1, #0
 801f3a0:	bf14      	ite	ne
 801f3a2:	2340      	movne	r3, #64	@ 0x40
 801f3a4:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 801f3a8:	2000      	movs	r0, #0
 801f3aa:	6031      	str	r1, [r6, #0]
 801f3ac:	602b      	str	r3, [r5, #0]
 801f3ae:	b016      	add	sp, #88	@ 0x58
 801f3b0:	bd70      	pop	{r4, r5, r6, pc}
 801f3b2:	466a      	mov	r2, sp
 801f3b4:	f000 f848 	bl	801f448 <_fstat_r>
 801f3b8:	2800      	cmp	r0, #0
 801f3ba:	dbec      	blt.n	801f396 <__swhatbuf_r+0x12>
 801f3bc:	9901      	ldr	r1, [sp, #4]
 801f3be:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 801f3c2:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 801f3c6:	4259      	negs	r1, r3
 801f3c8:	4159      	adcs	r1, r3
 801f3ca:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801f3ce:	e7eb      	b.n	801f3a8 <__swhatbuf_r+0x24>

0801f3d0 <__smakebuf_r>:
 801f3d0:	898b      	ldrh	r3, [r1, #12]
 801f3d2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801f3d4:	079d      	lsls	r5, r3, #30
 801f3d6:	4606      	mov	r6, r0
 801f3d8:	460c      	mov	r4, r1
 801f3da:	d507      	bpl.n	801f3ec <__smakebuf_r+0x1c>
 801f3dc:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 801f3e0:	6023      	str	r3, [r4, #0]
 801f3e2:	6123      	str	r3, [r4, #16]
 801f3e4:	2301      	movs	r3, #1
 801f3e6:	6163      	str	r3, [r4, #20]
 801f3e8:	b003      	add	sp, #12
 801f3ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801f3ec:	ab01      	add	r3, sp, #4
 801f3ee:	466a      	mov	r2, sp
 801f3f0:	f7ff ffc8 	bl	801f384 <__swhatbuf_r>
 801f3f4:	9f00      	ldr	r7, [sp, #0]
 801f3f6:	4605      	mov	r5, r0
 801f3f8:	4639      	mov	r1, r7
 801f3fa:	4630      	mov	r0, r6
 801f3fc:	f7ff f874 	bl	801e4e8 <_malloc_r>
 801f400:	b948      	cbnz	r0, 801f416 <__smakebuf_r+0x46>
 801f402:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801f406:	059a      	lsls	r2, r3, #22
 801f408:	d4ee      	bmi.n	801f3e8 <__smakebuf_r+0x18>
 801f40a:	f023 0303 	bic.w	r3, r3, #3
 801f40e:	f043 0302 	orr.w	r3, r3, #2
 801f412:	81a3      	strh	r3, [r4, #12]
 801f414:	e7e2      	b.n	801f3dc <__smakebuf_r+0xc>
 801f416:	89a3      	ldrh	r3, [r4, #12]
 801f418:	6020      	str	r0, [r4, #0]
 801f41a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801f41e:	81a3      	strh	r3, [r4, #12]
 801f420:	9b01      	ldr	r3, [sp, #4]
 801f422:	e9c4 0704 	strd	r0, r7, [r4, #16]
 801f426:	b15b      	cbz	r3, 801f440 <__smakebuf_r+0x70>
 801f428:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801f42c:	4630      	mov	r0, r6
 801f42e:	f000 f81d 	bl	801f46c <_isatty_r>
 801f432:	b128      	cbz	r0, 801f440 <__smakebuf_r+0x70>
 801f434:	89a3      	ldrh	r3, [r4, #12]
 801f436:	f023 0303 	bic.w	r3, r3, #3
 801f43a:	f043 0301 	orr.w	r3, r3, #1
 801f43e:	81a3      	strh	r3, [r4, #12]
 801f440:	89a3      	ldrh	r3, [r4, #12]
 801f442:	431d      	orrs	r5, r3
 801f444:	81a5      	strh	r5, [r4, #12]
 801f446:	e7cf      	b.n	801f3e8 <__smakebuf_r+0x18>

0801f448 <_fstat_r>:
 801f448:	b538      	push	{r3, r4, r5, lr}
 801f44a:	4d07      	ldr	r5, [pc, #28]	@ (801f468 <_fstat_r+0x20>)
 801f44c:	2300      	movs	r3, #0
 801f44e:	4604      	mov	r4, r0
 801f450:	4608      	mov	r0, r1
 801f452:	4611      	mov	r1, r2
 801f454:	602b      	str	r3, [r5, #0]
 801f456:	f7e6 fdef 	bl	8006038 <_fstat>
 801f45a:	1c43      	adds	r3, r0, #1
 801f45c:	d102      	bne.n	801f464 <_fstat_r+0x1c>
 801f45e:	682b      	ldr	r3, [r5, #0]
 801f460:	b103      	cbz	r3, 801f464 <_fstat_r+0x1c>
 801f462:	6023      	str	r3, [r4, #0]
 801f464:	bd38      	pop	{r3, r4, r5, pc}
 801f466:	bf00      	nop
 801f468:	20002450 	.word	0x20002450

0801f46c <_isatty_r>:
 801f46c:	b538      	push	{r3, r4, r5, lr}
 801f46e:	4d06      	ldr	r5, [pc, #24]	@ (801f488 <_isatty_r+0x1c>)
 801f470:	2300      	movs	r3, #0
 801f472:	4604      	mov	r4, r0
 801f474:	4608      	mov	r0, r1
 801f476:	602b      	str	r3, [r5, #0]
 801f478:	f7e6 fdee 	bl	8006058 <_isatty>
 801f47c:	1c43      	adds	r3, r0, #1
 801f47e:	d102      	bne.n	801f486 <_isatty_r+0x1a>
 801f480:	682b      	ldr	r3, [r5, #0]
 801f482:	b103      	cbz	r3, 801f486 <_isatty_r+0x1a>
 801f484:	6023      	str	r3, [r4, #0]
 801f486:	bd38      	pop	{r3, r4, r5, pc}
 801f488:	20002450 	.word	0x20002450

0801f48c <acos>:
 801f48c:	b538      	push	{r3, r4, r5, lr}
 801f48e:	ed2d 8b02 	vpush	{d8}
 801f492:	ec55 4b10 	vmov	r4, r5, d0
 801f496:	f001 f843 	bl	8020520 <__ieee754_acos>
 801f49a:	4622      	mov	r2, r4
 801f49c:	462b      	mov	r3, r5
 801f49e:	4620      	mov	r0, r4
 801f4a0:	4629      	mov	r1, r5
 801f4a2:	eeb0 8a40 	vmov.f32	s16, s0
 801f4a6:	eef0 8a60 	vmov.f32	s17, s1
 801f4aa:	f7e1 fb47 	bl	8000b3c <__aeabi_dcmpun>
 801f4ae:	b9a8      	cbnz	r0, 801f4dc <acos+0x50>
 801f4b0:	ec45 4b10 	vmov	d0, r4, r5
 801f4b4:	f000 f944 	bl	801f740 <fabs>
 801f4b8:	4b0c      	ldr	r3, [pc, #48]	@ (801f4ec <acos+0x60>)
 801f4ba:	ec51 0b10 	vmov	r0, r1, d0
 801f4be:	2200      	movs	r2, #0
 801f4c0:	f7e1 fb32 	bl	8000b28 <__aeabi_dcmpgt>
 801f4c4:	b150      	cbz	r0, 801f4dc <acos+0x50>
 801f4c6:	f7fe f911 	bl	801d6ec <__errno>
 801f4ca:	ecbd 8b02 	vpop	{d8}
 801f4ce:	2321      	movs	r3, #33	@ 0x21
 801f4d0:	6003      	str	r3, [r0, #0]
 801f4d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801f4d6:	4806      	ldr	r0, [pc, #24]	@ (801f4f0 <acos+0x64>)
 801f4d8:	f000 baba 	b.w	801fa50 <nan>
 801f4dc:	eeb0 0a48 	vmov.f32	s0, s16
 801f4e0:	eef0 0a68 	vmov.f32	s1, s17
 801f4e4:	ecbd 8b02 	vpop	{d8}
 801f4e8:	bd38      	pop	{r3, r4, r5, pc}
 801f4ea:	bf00      	nop
 801f4ec:	3ff00000 	.word	0x3ff00000
 801f4f0:	08023ca5 	.word	0x08023ca5

0801f4f4 <asin>:
 801f4f4:	b538      	push	{r3, r4, r5, lr}
 801f4f6:	ed2d 8b02 	vpush	{d8}
 801f4fa:	ec55 4b10 	vmov	r4, r5, d0
 801f4fe:	f001 fa6b 	bl	80209d8 <__ieee754_asin>
 801f502:	4622      	mov	r2, r4
 801f504:	462b      	mov	r3, r5
 801f506:	4620      	mov	r0, r4
 801f508:	4629      	mov	r1, r5
 801f50a:	eeb0 8a40 	vmov.f32	s16, s0
 801f50e:	eef0 8a60 	vmov.f32	s17, s1
 801f512:	f7e1 fb13 	bl	8000b3c <__aeabi_dcmpun>
 801f516:	b9a8      	cbnz	r0, 801f544 <asin+0x50>
 801f518:	ec45 4b10 	vmov	d0, r4, r5
 801f51c:	f000 f910 	bl	801f740 <fabs>
 801f520:	4b0c      	ldr	r3, [pc, #48]	@ (801f554 <asin+0x60>)
 801f522:	ec51 0b10 	vmov	r0, r1, d0
 801f526:	2200      	movs	r2, #0
 801f528:	f7e1 fafe 	bl	8000b28 <__aeabi_dcmpgt>
 801f52c:	b150      	cbz	r0, 801f544 <asin+0x50>
 801f52e:	f7fe f8dd 	bl	801d6ec <__errno>
 801f532:	ecbd 8b02 	vpop	{d8}
 801f536:	2321      	movs	r3, #33	@ 0x21
 801f538:	6003      	str	r3, [r0, #0]
 801f53a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801f53e:	4806      	ldr	r0, [pc, #24]	@ (801f558 <asin+0x64>)
 801f540:	f000 ba86 	b.w	801fa50 <nan>
 801f544:	eeb0 0a48 	vmov.f32	s0, s16
 801f548:	eef0 0a68 	vmov.f32	s1, s17
 801f54c:	ecbd 8b02 	vpop	{d8}
 801f550:	bd38      	pop	{r3, r4, r5, pc}
 801f552:	bf00      	nop
 801f554:	3ff00000 	.word	0x3ff00000
 801f558:	08023ca5 	.word	0x08023ca5

0801f55c <atan2>:
 801f55c:	f001 bc40 	b.w	8020de0 <__ieee754_atan2>

0801f560 <pow>:
 801f560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f562:	ed2d 8b02 	vpush	{d8}
 801f566:	eeb0 8a40 	vmov.f32	s16, s0
 801f56a:	eef0 8a60 	vmov.f32	s17, s1
 801f56e:	ec55 4b11 	vmov	r4, r5, d1
 801f572:	f001 fcfd 	bl	8020f70 <__ieee754_pow>
 801f576:	4622      	mov	r2, r4
 801f578:	462b      	mov	r3, r5
 801f57a:	4620      	mov	r0, r4
 801f57c:	4629      	mov	r1, r5
 801f57e:	ec57 6b10 	vmov	r6, r7, d0
 801f582:	f7e1 fadb 	bl	8000b3c <__aeabi_dcmpun>
 801f586:	2800      	cmp	r0, #0
 801f588:	d13b      	bne.n	801f602 <pow+0xa2>
 801f58a:	ec51 0b18 	vmov	r0, r1, d8
 801f58e:	2200      	movs	r2, #0
 801f590:	2300      	movs	r3, #0
 801f592:	f7e1 faa1 	bl	8000ad8 <__aeabi_dcmpeq>
 801f596:	b1b8      	cbz	r0, 801f5c8 <pow+0x68>
 801f598:	2200      	movs	r2, #0
 801f59a:	2300      	movs	r3, #0
 801f59c:	4620      	mov	r0, r4
 801f59e:	4629      	mov	r1, r5
 801f5a0:	f7e1 fa9a 	bl	8000ad8 <__aeabi_dcmpeq>
 801f5a4:	2800      	cmp	r0, #0
 801f5a6:	d146      	bne.n	801f636 <pow+0xd6>
 801f5a8:	ec45 4b10 	vmov	d0, r4, r5
 801f5ac:	f000 fa44 	bl	801fa38 <finite>
 801f5b0:	b338      	cbz	r0, 801f602 <pow+0xa2>
 801f5b2:	2200      	movs	r2, #0
 801f5b4:	2300      	movs	r3, #0
 801f5b6:	4620      	mov	r0, r4
 801f5b8:	4629      	mov	r1, r5
 801f5ba:	f7e1 fa97 	bl	8000aec <__aeabi_dcmplt>
 801f5be:	b300      	cbz	r0, 801f602 <pow+0xa2>
 801f5c0:	f7fe f894 	bl	801d6ec <__errno>
 801f5c4:	2322      	movs	r3, #34	@ 0x22
 801f5c6:	e01b      	b.n	801f600 <pow+0xa0>
 801f5c8:	ec47 6b10 	vmov	d0, r6, r7
 801f5cc:	f000 fa34 	bl	801fa38 <finite>
 801f5d0:	b9e0      	cbnz	r0, 801f60c <pow+0xac>
 801f5d2:	eeb0 0a48 	vmov.f32	s0, s16
 801f5d6:	eef0 0a68 	vmov.f32	s1, s17
 801f5da:	f000 fa2d 	bl	801fa38 <finite>
 801f5de:	b1a8      	cbz	r0, 801f60c <pow+0xac>
 801f5e0:	ec45 4b10 	vmov	d0, r4, r5
 801f5e4:	f000 fa28 	bl	801fa38 <finite>
 801f5e8:	b180      	cbz	r0, 801f60c <pow+0xac>
 801f5ea:	4632      	mov	r2, r6
 801f5ec:	463b      	mov	r3, r7
 801f5ee:	4630      	mov	r0, r6
 801f5f0:	4639      	mov	r1, r7
 801f5f2:	f7e1 faa3 	bl	8000b3c <__aeabi_dcmpun>
 801f5f6:	2800      	cmp	r0, #0
 801f5f8:	d0e2      	beq.n	801f5c0 <pow+0x60>
 801f5fa:	f7fe f877 	bl	801d6ec <__errno>
 801f5fe:	2321      	movs	r3, #33	@ 0x21
 801f600:	6003      	str	r3, [r0, #0]
 801f602:	ecbd 8b02 	vpop	{d8}
 801f606:	ec47 6b10 	vmov	d0, r6, r7
 801f60a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801f60c:	2200      	movs	r2, #0
 801f60e:	2300      	movs	r3, #0
 801f610:	4630      	mov	r0, r6
 801f612:	4639      	mov	r1, r7
 801f614:	f7e1 fa60 	bl	8000ad8 <__aeabi_dcmpeq>
 801f618:	2800      	cmp	r0, #0
 801f61a:	d0f2      	beq.n	801f602 <pow+0xa2>
 801f61c:	eeb0 0a48 	vmov.f32	s0, s16
 801f620:	eef0 0a68 	vmov.f32	s1, s17
 801f624:	f000 fa08 	bl	801fa38 <finite>
 801f628:	2800      	cmp	r0, #0
 801f62a:	d0ea      	beq.n	801f602 <pow+0xa2>
 801f62c:	ec45 4b10 	vmov	d0, r4, r5
 801f630:	f000 fa02 	bl	801fa38 <finite>
 801f634:	e7c3      	b.n	801f5be <pow+0x5e>
 801f636:	4f01      	ldr	r7, [pc, #4]	@ (801f63c <pow+0xdc>)
 801f638:	2600      	movs	r6, #0
 801f63a:	e7e2      	b.n	801f602 <pow+0xa2>
 801f63c:	3ff00000 	.word	0x3ff00000

0801f640 <sqrt>:
 801f640:	b538      	push	{r3, r4, r5, lr}
 801f642:	ed2d 8b02 	vpush	{d8}
 801f646:	ec55 4b10 	vmov	r4, r5, d0
 801f64a:	f000 fa0f 	bl	801fa6c <__ieee754_sqrt>
 801f64e:	4622      	mov	r2, r4
 801f650:	462b      	mov	r3, r5
 801f652:	4620      	mov	r0, r4
 801f654:	4629      	mov	r1, r5
 801f656:	eeb0 8a40 	vmov.f32	s16, s0
 801f65a:	eef0 8a60 	vmov.f32	s17, s1
 801f65e:	f7e1 fa6d 	bl	8000b3c <__aeabi_dcmpun>
 801f662:	b990      	cbnz	r0, 801f68a <sqrt+0x4a>
 801f664:	2200      	movs	r2, #0
 801f666:	2300      	movs	r3, #0
 801f668:	4620      	mov	r0, r4
 801f66a:	4629      	mov	r1, r5
 801f66c:	f7e1 fa3e 	bl	8000aec <__aeabi_dcmplt>
 801f670:	b158      	cbz	r0, 801f68a <sqrt+0x4a>
 801f672:	f7fe f83b 	bl	801d6ec <__errno>
 801f676:	2321      	movs	r3, #33	@ 0x21
 801f678:	6003      	str	r3, [r0, #0]
 801f67a:	2200      	movs	r2, #0
 801f67c:	2300      	movs	r3, #0
 801f67e:	4610      	mov	r0, r2
 801f680:	4619      	mov	r1, r3
 801f682:	f7e1 f8eb 	bl	800085c <__aeabi_ddiv>
 801f686:	ec41 0b18 	vmov	d8, r0, r1
 801f68a:	eeb0 0a48 	vmov.f32	s0, s16
 801f68e:	eef0 0a68 	vmov.f32	s1, s17
 801f692:	ecbd 8b02 	vpop	{d8}
 801f696:	bd38      	pop	{r3, r4, r5, pc}

0801f698 <cos>:
 801f698:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801f69a:	ec53 2b10 	vmov	r2, r3, d0
 801f69e:	4826      	ldr	r0, [pc, #152]	@ (801f738 <cos+0xa0>)
 801f6a0:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 801f6a4:	4281      	cmp	r1, r0
 801f6a6:	d806      	bhi.n	801f6b6 <cos+0x1e>
 801f6a8:	ed9f 1b21 	vldr	d1, [pc, #132]	@ 801f730 <cos+0x98>
 801f6ac:	b005      	add	sp, #20
 801f6ae:	f85d eb04 	ldr.w	lr, [sp], #4
 801f6b2:	f000 bbad 	b.w	801fe10 <__kernel_cos>
 801f6b6:	4821      	ldr	r0, [pc, #132]	@ (801f73c <cos+0xa4>)
 801f6b8:	4281      	cmp	r1, r0
 801f6ba:	d908      	bls.n	801f6ce <cos+0x36>
 801f6bc:	4610      	mov	r0, r2
 801f6be:	4619      	mov	r1, r3
 801f6c0:	f7e0 fdea 	bl	8000298 <__aeabi_dsub>
 801f6c4:	ec41 0b10 	vmov	d0, r0, r1
 801f6c8:	b005      	add	sp, #20
 801f6ca:	f85d fb04 	ldr.w	pc, [sp], #4
 801f6ce:	4668      	mov	r0, sp
 801f6d0:	f002 f992 	bl	80219f8 <__ieee754_rem_pio2>
 801f6d4:	f000 0003 	and.w	r0, r0, #3
 801f6d8:	2801      	cmp	r0, #1
 801f6da:	d00b      	beq.n	801f6f4 <cos+0x5c>
 801f6dc:	2802      	cmp	r0, #2
 801f6de:	d015      	beq.n	801f70c <cos+0x74>
 801f6e0:	b9d8      	cbnz	r0, 801f71a <cos+0x82>
 801f6e2:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f6e6:	ed9d 0b00 	vldr	d0, [sp]
 801f6ea:	f000 fb91 	bl	801fe10 <__kernel_cos>
 801f6ee:	ec51 0b10 	vmov	r0, r1, d0
 801f6f2:	e7e7      	b.n	801f6c4 <cos+0x2c>
 801f6f4:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f6f8:	ed9d 0b00 	vldr	d0, [sp]
 801f6fc:	f000 fc50 	bl	801ffa0 <__kernel_sin>
 801f700:	ec53 2b10 	vmov	r2, r3, d0
 801f704:	4610      	mov	r0, r2
 801f706:	f103 4100 	add.w	r1, r3, #2147483648	@ 0x80000000
 801f70a:	e7db      	b.n	801f6c4 <cos+0x2c>
 801f70c:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f710:	ed9d 0b00 	vldr	d0, [sp]
 801f714:	f000 fb7c 	bl	801fe10 <__kernel_cos>
 801f718:	e7f2      	b.n	801f700 <cos+0x68>
 801f71a:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f71e:	ed9d 0b00 	vldr	d0, [sp]
 801f722:	2001      	movs	r0, #1
 801f724:	f000 fc3c 	bl	801ffa0 <__kernel_sin>
 801f728:	e7e1      	b.n	801f6ee <cos+0x56>
 801f72a:	bf00      	nop
 801f72c:	f3af 8000 	nop.w
	...
 801f738:	3fe921fb 	.word	0x3fe921fb
 801f73c:	7fefffff 	.word	0x7fefffff

0801f740 <fabs>:
 801f740:	ec51 0b10 	vmov	r0, r1, d0
 801f744:	4602      	mov	r2, r0
 801f746:	f021 4300 	bic.w	r3, r1, #2147483648	@ 0x80000000
 801f74a:	ec43 2b10 	vmov	d0, r2, r3
 801f74e:	4770      	bx	lr

0801f750 <sin>:
 801f750:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801f752:	ec53 2b10 	vmov	r2, r3, d0
 801f756:	4826      	ldr	r0, [pc, #152]	@ (801f7f0 <sin+0xa0>)
 801f758:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 801f75c:	4281      	cmp	r1, r0
 801f75e:	d807      	bhi.n	801f770 <sin+0x20>
 801f760:	ed9f 1b21 	vldr	d1, [pc, #132]	@ 801f7e8 <sin+0x98>
 801f764:	2000      	movs	r0, #0
 801f766:	b005      	add	sp, #20
 801f768:	f85d eb04 	ldr.w	lr, [sp], #4
 801f76c:	f000 bc18 	b.w	801ffa0 <__kernel_sin>
 801f770:	4820      	ldr	r0, [pc, #128]	@ (801f7f4 <sin+0xa4>)
 801f772:	4281      	cmp	r1, r0
 801f774:	d908      	bls.n	801f788 <sin+0x38>
 801f776:	4610      	mov	r0, r2
 801f778:	4619      	mov	r1, r3
 801f77a:	f7e0 fd8d 	bl	8000298 <__aeabi_dsub>
 801f77e:	ec41 0b10 	vmov	d0, r0, r1
 801f782:	b005      	add	sp, #20
 801f784:	f85d fb04 	ldr.w	pc, [sp], #4
 801f788:	4668      	mov	r0, sp
 801f78a:	f002 f935 	bl	80219f8 <__ieee754_rem_pio2>
 801f78e:	f000 0003 	and.w	r0, r0, #3
 801f792:	2801      	cmp	r0, #1
 801f794:	d00c      	beq.n	801f7b0 <sin+0x60>
 801f796:	2802      	cmp	r0, #2
 801f798:	d011      	beq.n	801f7be <sin+0x6e>
 801f79a:	b9e8      	cbnz	r0, 801f7d8 <sin+0x88>
 801f79c:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f7a0:	ed9d 0b00 	vldr	d0, [sp]
 801f7a4:	2001      	movs	r0, #1
 801f7a6:	f000 fbfb 	bl	801ffa0 <__kernel_sin>
 801f7aa:	ec51 0b10 	vmov	r0, r1, d0
 801f7ae:	e7e6      	b.n	801f77e <sin+0x2e>
 801f7b0:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f7b4:	ed9d 0b00 	vldr	d0, [sp]
 801f7b8:	f000 fb2a 	bl	801fe10 <__kernel_cos>
 801f7bc:	e7f5      	b.n	801f7aa <sin+0x5a>
 801f7be:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f7c2:	ed9d 0b00 	vldr	d0, [sp]
 801f7c6:	2001      	movs	r0, #1
 801f7c8:	f000 fbea 	bl	801ffa0 <__kernel_sin>
 801f7cc:	ec53 2b10 	vmov	r2, r3, d0
 801f7d0:	4610      	mov	r0, r2
 801f7d2:	f103 4100 	add.w	r1, r3, #2147483648	@ 0x80000000
 801f7d6:	e7d2      	b.n	801f77e <sin+0x2e>
 801f7d8:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f7dc:	ed9d 0b00 	vldr	d0, [sp]
 801f7e0:	f000 fb16 	bl	801fe10 <__kernel_cos>
 801f7e4:	e7f2      	b.n	801f7cc <sin+0x7c>
 801f7e6:	bf00      	nop
	...
 801f7f0:	3fe921fb 	.word	0x3fe921fb
 801f7f4:	7fefffff 	.word	0x7fefffff

0801f7f8 <tan>:
 801f7f8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801f7fa:	ec53 2b10 	vmov	r2, r3, d0
 801f7fe:	4816      	ldr	r0, [pc, #88]	@ (801f858 <tan+0x60>)
 801f800:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 801f804:	4281      	cmp	r1, r0
 801f806:	d807      	bhi.n	801f818 <tan+0x20>
 801f808:	ed9f 1b11 	vldr	d1, [pc, #68]	@ 801f850 <tan+0x58>
 801f80c:	2001      	movs	r0, #1
 801f80e:	b005      	add	sp, #20
 801f810:	f85d eb04 	ldr.w	lr, [sp], #4
 801f814:	f000 bc80 	b.w	8020118 <__kernel_tan>
 801f818:	4810      	ldr	r0, [pc, #64]	@ (801f85c <tan+0x64>)
 801f81a:	4281      	cmp	r1, r0
 801f81c:	d908      	bls.n	801f830 <tan+0x38>
 801f81e:	4610      	mov	r0, r2
 801f820:	4619      	mov	r1, r3
 801f822:	f7e0 fd39 	bl	8000298 <__aeabi_dsub>
 801f826:	ec41 0b10 	vmov	d0, r0, r1
 801f82a:	b005      	add	sp, #20
 801f82c:	f85d fb04 	ldr.w	pc, [sp], #4
 801f830:	4668      	mov	r0, sp
 801f832:	f002 f8e1 	bl	80219f8 <__ieee754_rem_pio2>
 801f836:	0040      	lsls	r0, r0, #1
 801f838:	f000 0002 	and.w	r0, r0, #2
 801f83c:	ed9d 1b02 	vldr	d1, [sp, #8]
 801f840:	ed9d 0b00 	vldr	d0, [sp]
 801f844:	f1c0 0001 	rsb	r0, r0, #1
 801f848:	f000 fc66 	bl	8020118 <__kernel_tan>
 801f84c:	e7ed      	b.n	801f82a <tan+0x32>
 801f84e:	bf00      	nop
	...
 801f858:	3fe921fb 	.word	0x3fe921fb
 801f85c:	7fefffff 	.word	0x7fefffff

0801f860 <asinf>:
 801f860:	b508      	push	{r3, lr}
 801f862:	ed2d 8b02 	vpush	{d8}
 801f866:	eeb0 8a40 	vmov.f32	s16, s0
 801f86a:	f002 fdd9 	bl	8022420 <__ieee754_asinf>
 801f86e:	eeb4 8a48 	vcmp.f32	s16, s16
 801f872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f876:	eef0 8a40 	vmov.f32	s17, s0
 801f87a:	d615      	bvs.n	801f8a8 <asinf+0x48>
 801f87c:	eeb0 0a48 	vmov.f32	s0, s16
 801f880:	f000 f860 	bl	801f944 <fabsf>
 801f884:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 801f888:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801f88c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801f890:	dd0a      	ble.n	801f8a8 <asinf+0x48>
 801f892:	f7fd ff2b 	bl	801d6ec <__errno>
 801f896:	ecbd 8b02 	vpop	{d8}
 801f89a:	2321      	movs	r3, #33	@ 0x21
 801f89c:	6003      	str	r3, [r0, #0]
 801f89e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801f8a2:	4804      	ldr	r0, [pc, #16]	@ (801f8b4 <asinf+0x54>)
 801f8a4:	f000 b8dc 	b.w	801fa60 <nanf>
 801f8a8:	eeb0 0a68 	vmov.f32	s0, s17
 801f8ac:	ecbd 8b02 	vpop	{d8}
 801f8b0:	bd08      	pop	{r3, pc}
 801f8b2:	bf00      	nop
 801f8b4:	08023ca5 	.word	0x08023ca5

0801f8b8 <atan2f>:
 801f8b8:	f002 be98 	b.w	80225ec <__ieee754_atan2f>

0801f8bc <cosf>:
 801f8bc:	ee10 3a10 	vmov	r3, s0
 801f8c0:	b507      	push	{r0, r1, r2, lr}
 801f8c2:	4a1e      	ldr	r2, [pc, #120]	@ (801f93c <cosf+0x80>)
 801f8c4:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 801f8c8:	4293      	cmp	r3, r2
 801f8ca:	d806      	bhi.n	801f8da <cosf+0x1e>
 801f8cc:	eddf 0a1c 	vldr	s1, [pc, #112]	@ 801f940 <cosf+0x84>
 801f8d0:	b003      	add	sp, #12
 801f8d2:	f85d eb04 	ldr.w	lr, [sp], #4
 801f8d6:	f002 bc23 	b.w	8022120 <__kernel_cosf>
 801f8da:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 801f8de:	d304      	bcc.n	801f8ea <cosf+0x2e>
 801f8e0:	ee30 0a40 	vsub.f32	s0, s0, s0
 801f8e4:	b003      	add	sp, #12
 801f8e6:	f85d fb04 	ldr.w	pc, [sp], #4
 801f8ea:	4668      	mov	r0, sp
 801f8ec:	f002 ff1e 	bl	802272c <__ieee754_rem_pio2f>
 801f8f0:	f000 0003 	and.w	r0, r0, #3
 801f8f4:	2801      	cmp	r0, #1
 801f8f6:	d009      	beq.n	801f90c <cosf+0x50>
 801f8f8:	2802      	cmp	r0, #2
 801f8fa:	d010      	beq.n	801f91e <cosf+0x62>
 801f8fc:	b9b0      	cbnz	r0, 801f92c <cosf+0x70>
 801f8fe:	eddd 0a01 	vldr	s1, [sp, #4]
 801f902:	ed9d 0a00 	vldr	s0, [sp]
 801f906:	f002 fc0b 	bl	8022120 <__kernel_cosf>
 801f90a:	e7eb      	b.n	801f8e4 <cosf+0x28>
 801f90c:	eddd 0a01 	vldr	s1, [sp, #4]
 801f910:	ed9d 0a00 	vldr	s0, [sp]
 801f914:	f002 fc5c 	bl	80221d0 <__kernel_sinf>
 801f918:	eeb1 0a40 	vneg.f32	s0, s0
 801f91c:	e7e2      	b.n	801f8e4 <cosf+0x28>
 801f91e:	eddd 0a01 	vldr	s1, [sp, #4]
 801f922:	ed9d 0a00 	vldr	s0, [sp]
 801f926:	f002 fbfb 	bl	8022120 <__kernel_cosf>
 801f92a:	e7f5      	b.n	801f918 <cosf+0x5c>
 801f92c:	eddd 0a01 	vldr	s1, [sp, #4]
 801f930:	ed9d 0a00 	vldr	s0, [sp]
 801f934:	2001      	movs	r0, #1
 801f936:	f002 fc4b 	bl	80221d0 <__kernel_sinf>
 801f93a:	e7d3      	b.n	801f8e4 <cosf+0x28>
 801f93c:	3f490fd8 	.word	0x3f490fd8
 801f940:	00000000 	.word	0x00000000

0801f944 <fabsf>:
 801f944:	ee10 3a10 	vmov	r3, s0
 801f948:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 801f94c:	ee00 3a10 	vmov	s0, r3
 801f950:	4770      	bx	lr
	...

0801f954 <sinf>:
 801f954:	ee10 3a10 	vmov	r3, s0
 801f958:	b507      	push	{r0, r1, r2, lr}
 801f95a:	4a1f      	ldr	r2, [pc, #124]	@ (801f9d8 <sinf+0x84>)
 801f95c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 801f960:	4293      	cmp	r3, r2
 801f962:	d807      	bhi.n	801f974 <sinf+0x20>
 801f964:	eddf 0a1d 	vldr	s1, [pc, #116]	@ 801f9dc <sinf+0x88>
 801f968:	2000      	movs	r0, #0
 801f96a:	b003      	add	sp, #12
 801f96c:	f85d eb04 	ldr.w	lr, [sp], #4
 801f970:	f002 bc2e 	b.w	80221d0 <__kernel_sinf>
 801f974:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 801f978:	d304      	bcc.n	801f984 <sinf+0x30>
 801f97a:	ee30 0a40 	vsub.f32	s0, s0, s0
 801f97e:	b003      	add	sp, #12
 801f980:	f85d fb04 	ldr.w	pc, [sp], #4
 801f984:	4668      	mov	r0, sp
 801f986:	f002 fed1 	bl	802272c <__ieee754_rem_pio2f>
 801f98a:	f000 0003 	and.w	r0, r0, #3
 801f98e:	2801      	cmp	r0, #1
 801f990:	d00a      	beq.n	801f9a8 <sinf+0x54>
 801f992:	2802      	cmp	r0, #2
 801f994:	d00f      	beq.n	801f9b6 <sinf+0x62>
 801f996:	b9c0      	cbnz	r0, 801f9ca <sinf+0x76>
 801f998:	eddd 0a01 	vldr	s1, [sp, #4]
 801f99c:	ed9d 0a00 	vldr	s0, [sp]
 801f9a0:	2001      	movs	r0, #1
 801f9a2:	f002 fc15 	bl	80221d0 <__kernel_sinf>
 801f9a6:	e7ea      	b.n	801f97e <sinf+0x2a>
 801f9a8:	eddd 0a01 	vldr	s1, [sp, #4]
 801f9ac:	ed9d 0a00 	vldr	s0, [sp]
 801f9b0:	f002 fbb6 	bl	8022120 <__kernel_cosf>
 801f9b4:	e7e3      	b.n	801f97e <sinf+0x2a>
 801f9b6:	eddd 0a01 	vldr	s1, [sp, #4]
 801f9ba:	ed9d 0a00 	vldr	s0, [sp]
 801f9be:	2001      	movs	r0, #1
 801f9c0:	f002 fc06 	bl	80221d0 <__kernel_sinf>
 801f9c4:	eeb1 0a40 	vneg.f32	s0, s0
 801f9c8:	e7d9      	b.n	801f97e <sinf+0x2a>
 801f9ca:	eddd 0a01 	vldr	s1, [sp, #4]
 801f9ce:	ed9d 0a00 	vldr	s0, [sp]
 801f9d2:	f002 fba5 	bl	8022120 <__kernel_cosf>
 801f9d6:	e7f5      	b.n	801f9c4 <sinf+0x70>
 801f9d8:	3f490fd8 	.word	0x3f490fd8
 801f9dc:	00000000 	.word	0x00000000

0801f9e0 <tanf>:
 801f9e0:	ee10 3a10 	vmov	r3, s0
 801f9e4:	b507      	push	{r0, r1, r2, lr}
 801f9e6:	4a12      	ldr	r2, [pc, #72]	@ (801fa30 <tanf+0x50>)
 801f9e8:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 801f9ec:	4293      	cmp	r3, r2
 801f9ee:	d807      	bhi.n	801fa00 <tanf+0x20>
 801f9f0:	eddf 0a10 	vldr	s1, [pc, #64]	@ 801fa34 <tanf+0x54>
 801f9f4:	2001      	movs	r0, #1
 801f9f6:	b003      	add	sp, #12
 801f9f8:	f85d eb04 	ldr.w	lr, [sp], #4
 801f9fc:	f002 bc30 	b.w	8022260 <__kernel_tanf>
 801fa00:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 801fa04:	d304      	bcc.n	801fa10 <tanf+0x30>
 801fa06:	ee30 0a40 	vsub.f32	s0, s0, s0
 801fa0a:	b003      	add	sp, #12
 801fa0c:	f85d fb04 	ldr.w	pc, [sp], #4
 801fa10:	4668      	mov	r0, sp
 801fa12:	f002 fe8b 	bl	802272c <__ieee754_rem_pio2f>
 801fa16:	0040      	lsls	r0, r0, #1
 801fa18:	f000 0002 	and.w	r0, r0, #2
 801fa1c:	eddd 0a01 	vldr	s1, [sp, #4]
 801fa20:	ed9d 0a00 	vldr	s0, [sp]
 801fa24:	f1c0 0001 	rsb	r0, r0, #1
 801fa28:	f002 fc1a 	bl	8022260 <__kernel_tanf>
 801fa2c:	e7ed      	b.n	801fa0a <tanf+0x2a>
 801fa2e:	bf00      	nop
 801fa30:	3f490fda 	.word	0x3f490fda
 801fa34:	00000000 	.word	0x00000000

0801fa38 <finite>:
 801fa38:	b082      	sub	sp, #8
 801fa3a:	ed8d 0b00 	vstr	d0, [sp]
 801fa3e:	9801      	ldr	r0, [sp, #4]
 801fa40:	f040 4000 	orr.w	r0, r0, #2147483648	@ 0x80000000
 801fa44:	f500 1080 	add.w	r0, r0, #1048576	@ 0x100000
 801fa48:	0fc0      	lsrs	r0, r0, #31
 801fa4a:	b002      	add	sp, #8
 801fa4c:	4770      	bx	lr
	...

0801fa50 <nan>:
 801fa50:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 801fa58 <nan+0x8>
 801fa54:	4770      	bx	lr
 801fa56:	bf00      	nop
 801fa58:	00000000 	.word	0x00000000
 801fa5c:	7ff80000 	.word	0x7ff80000

0801fa60 <nanf>:
 801fa60:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 801fa68 <nanf+0x8>
 801fa64:	4770      	bx	lr
 801fa66:	bf00      	nop
 801fa68:	7fc00000 	.word	0x7fc00000

0801fa6c <__ieee754_sqrt>:
 801fa6c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fa70:	4a68      	ldr	r2, [pc, #416]	@ (801fc14 <__ieee754_sqrt+0x1a8>)
 801fa72:	ec55 4b10 	vmov	r4, r5, d0
 801fa76:	43aa      	bics	r2, r5
 801fa78:	462b      	mov	r3, r5
 801fa7a:	4621      	mov	r1, r4
 801fa7c:	d110      	bne.n	801faa0 <__ieee754_sqrt+0x34>
 801fa7e:	4622      	mov	r2, r4
 801fa80:	4620      	mov	r0, r4
 801fa82:	4629      	mov	r1, r5
 801fa84:	f7e0 fdc0 	bl	8000608 <__aeabi_dmul>
 801fa88:	4602      	mov	r2, r0
 801fa8a:	460b      	mov	r3, r1
 801fa8c:	4620      	mov	r0, r4
 801fa8e:	4629      	mov	r1, r5
 801fa90:	f7e0 fc04 	bl	800029c <__adddf3>
 801fa94:	4604      	mov	r4, r0
 801fa96:	460d      	mov	r5, r1
 801fa98:	ec45 4b10 	vmov	d0, r4, r5
 801fa9c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801faa0:	2d00      	cmp	r5, #0
 801faa2:	dc0e      	bgt.n	801fac2 <__ieee754_sqrt+0x56>
 801faa4:	f025 4200 	bic.w	r2, r5, #2147483648	@ 0x80000000
 801faa8:	4322      	orrs	r2, r4
 801faaa:	d0f5      	beq.n	801fa98 <__ieee754_sqrt+0x2c>
 801faac:	b19d      	cbz	r5, 801fad6 <__ieee754_sqrt+0x6a>
 801faae:	4622      	mov	r2, r4
 801fab0:	4620      	mov	r0, r4
 801fab2:	4629      	mov	r1, r5
 801fab4:	f7e0 fbf0 	bl	8000298 <__aeabi_dsub>
 801fab8:	4602      	mov	r2, r0
 801faba:	460b      	mov	r3, r1
 801fabc:	f7e0 fece 	bl	800085c <__aeabi_ddiv>
 801fac0:	e7e8      	b.n	801fa94 <__ieee754_sqrt+0x28>
 801fac2:	152a      	asrs	r2, r5, #20
 801fac4:	d115      	bne.n	801faf2 <__ieee754_sqrt+0x86>
 801fac6:	2000      	movs	r0, #0
 801fac8:	e009      	b.n	801fade <__ieee754_sqrt+0x72>
 801faca:	0acb      	lsrs	r3, r1, #11
 801facc:	3a15      	subs	r2, #21
 801face:	0549      	lsls	r1, r1, #21
 801fad0:	2b00      	cmp	r3, #0
 801fad2:	d0fa      	beq.n	801faca <__ieee754_sqrt+0x5e>
 801fad4:	e7f7      	b.n	801fac6 <__ieee754_sqrt+0x5a>
 801fad6:	462a      	mov	r2, r5
 801fad8:	e7fa      	b.n	801fad0 <__ieee754_sqrt+0x64>
 801fada:	005b      	lsls	r3, r3, #1
 801fadc:	3001      	adds	r0, #1
 801fade:	02dc      	lsls	r4, r3, #11
 801fae0:	d5fb      	bpl.n	801fada <__ieee754_sqrt+0x6e>
 801fae2:	1e44      	subs	r4, r0, #1
 801fae4:	1b12      	subs	r2, r2, r4
 801fae6:	f1c0 0420 	rsb	r4, r0, #32
 801faea:	fa21 f404 	lsr.w	r4, r1, r4
 801faee:	4323      	orrs	r3, r4
 801faf0:	4081      	lsls	r1, r0
 801faf2:	f3c3 0313 	ubfx	r3, r3, #0, #20
 801faf6:	f2a2 35ff 	subw	r5, r2, #1023	@ 0x3ff
 801fafa:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 801fafe:	07d2      	lsls	r2, r2, #31
 801fb00:	bf5c      	itt	pl
 801fb02:	005b      	lslpl	r3, r3, #1
 801fb04:	eb03 73d1 	addpl.w	r3, r3, r1, lsr #31
 801fb08:	ea4f 0343 	mov.w	r3, r3, lsl #1
 801fb0c:	bf58      	it	pl
 801fb0e:	0049      	lslpl	r1, r1, #1
 801fb10:	2600      	movs	r6, #0
 801fb12:	eb03 73d1 	add.w	r3, r3, r1, lsr #31
 801fb16:	106d      	asrs	r5, r5, #1
 801fb18:	0049      	lsls	r1, r1, #1
 801fb1a:	2016      	movs	r0, #22
 801fb1c:	4632      	mov	r2, r6
 801fb1e:	f44f 1400 	mov.w	r4, #2097152	@ 0x200000
 801fb22:	1917      	adds	r7, r2, r4
 801fb24:	429f      	cmp	r7, r3
 801fb26:	bfde      	ittt	le
 801fb28:	193a      	addle	r2, r7, r4
 801fb2a:	1bdb      	suble	r3, r3, r7
 801fb2c:	1936      	addle	r6, r6, r4
 801fb2e:	0fcf      	lsrs	r7, r1, #31
 801fb30:	3801      	subs	r0, #1
 801fb32:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 801fb36:	ea4f 0141 	mov.w	r1, r1, lsl #1
 801fb3a:	ea4f 0454 	mov.w	r4, r4, lsr #1
 801fb3e:	d1f0      	bne.n	801fb22 <__ieee754_sqrt+0xb6>
 801fb40:	4604      	mov	r4, r0
 801fb42:	2720      	movs	r7, #32
 801fb44:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 801fb48:	429a      	cmp	r2, r3
 801fb4a:	eb00 0e0c 	add.w	lr, r0, ip
 801fb4e:	db02      	blt.n	801fb56 <__ieee754_sqrt+0xea>
 801fb50:	d113      	bne.n	801fb7a <__ieee754_sqrt+0x10e>
 801fb52:	458e      	cmp	lr, r1
 801fb54:	d811      	bhi.n	801fb7a <__ieee754_sqrt+0x10e>
 801fb56:	f1be 0f00 	cmp.w	lr, #0
 801fb5a:	eb0e 000c 	add.w	r0, lr, ip
 801fb5e:	da42      	bge.n	801fbe6 <__ieee754_sqrt+0x17a>
 801fb60:	2800      	cmp	r0, #0
 801fb62:	db40      	blt.n	801fbe6 <__ieee754_sqrt+0x17a>
 801fb64:	f102 0801 	add.w	r8, r2, #1
 801fb68:	1a9b      	subs	r3, r3, r2
 801fb6a:	458e      	cmp	lr, r1
 801fb6c:	bf88      	it	hi
 801fb6e:	f103 33ff 	addhi.w	r3, r3, #4294967295	@ 0xffffffff
 801fb72:	eba1 010e 	sub.w	r1, r1, lr
 801fb76:	4464      	add	r4, ip
 801fb78:	4642      	mov	r2, r8
 801fb7a:	ea4f 7ed1 	mov.w	lr, r1, lsr #31
 801fb7e:	3f01      	subs	r7, #1
 801fb80:	eb0e 0343 	add.w	r3, lr, r3, lsl #1
 801fb84:	ea4f 0141 	mov.w	r1, r1, lsl #1
 801fb88:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
 801fb8c:	d1dc      	bne.n	801fb48 <__ieee754_sqrt+0xdc>
 801fb8e:	4319      	orrs	r1, r3
 801fb90:	d01b      	beq.n	801fbca <__ieee754_sqrt+0x15e>
 801fb92:	f8df a084 	ldr.w	sl, [pc, #132]	@ 801fc18 <__ieee754_sqrt+0x1ac>
 801fb96:	f8df b084 	ldr.w	fp, [pc, #132]	@ 801fc1c <__ieee754_sqrt+0x1b0>
 801fb9a:	e9da 0100 	ldrd	r0, r1, [sl]
 801fb9e:	e9db 2300 	ldrd	r2, r3, [fp]
 801fba2:	f7e0 fb79 	bl	8000298 <__aeabi_dsub>
 801fba6:	e9da 8900 	ldrd	r8, r9, [sl]
 801fbaa:	4602      	mov	r2, r0
 801fbac:	460b      	mov	r3, r1
 801fbae:	4640      	mov	r0, r8
 801fbb0:	4649      	mov	r1, r9
 801fbb2:	f7e0 ffa5 	bl	8000b00 <__aeabi_dcmple>
 801fbb6:	b140      	cbz	r0, 801fbca <__ieee754_sqrt+0x15e>
 801fbb8:	f1b4 3fff 	cmp.w	r4, #4294967295	@ 0xffffffff
 801fbbc:	e9da 0100 	ldrd	r0, r1, [sl]
 801fbc0:	e9db 2300 	ldrd	r2, r3, [fp]
 801fbc4:	d111      	bne.n	801fbea <__ieee754_sqrt+0x17e>
 801fbc6:	3601      	adds	r6, #1
 801fbc8:	463c      	mov	r4, r7
 801fbca:	1072      	asrs	r2, r6, #1
 801fbcc:	0863      	lsrs	r3, r4, #1
 801fbce:	07f1      	lsls	r1, r6, #31
 801fbd0:	f102 527f 	add.w	r2, r2, #1069547520	@ 0x3fc00000
 801fbd4:	f502 1200 	add.w	r2, r2, #2097152	@ 0x200000
 801fbd8:	bf48      	it	mi
 801fbda:	f043 4300 	orrmi.w	r3, r3, #2147483648	@ 0x80000000
 801fbde:	eb02 5105 	add.w	r1, r2, r5, lsl #20
 801fbe2:	4618      	mov	r0, r3
 801fbe4:	e756      	b.n	801fa94 <__ieee754_sqrt+0x28>
 801fbe6:	4690      	mov	r8, r2
 801fbe8:	e7be      	b.n	801fb68 <__ieee754_sqrt+0xfc>
 801fbea:	f7e0 fb57 	bl	800029c <__adddf3>
 801fbee:	e9da 8900 	ldrd	r8, r9, [sl]
 801fbf2:	4602      	mov	r2, r0
 801fbf4:	460b      	mov	r3, r1
 801fbf6:	4640      	mov	r0, r8
 801fbf8:	4649      	mov	r1, r9
 801fbfa:	f7e0 ff77 	bl	8000aec <__aeabi_dcmplt>
 801fbfe:	b120      	cbz	r0, 801fc0a <__ieee754_sqrt+0x19e>
 801fc00:	1ca0      	adds	r0, r4, #2
 801fc02:	bf08      	it	eq
 801fc04:	3601      	addeq	r6, #1
 801fc06:	3402      	adds	r4, #2
 801fc08:	e7df      	b.n	801fbca <__ieee754_sqrt+0x15e>
 801fc0a:	1c63      	adds	r3, r4, #1
 801fc0c:	f023 0401 	bic.w	r4, r3, #1
 801fc10:	e7db      	b.n	801fbca <__ieee754_sqrt+0x15e>
 801fc12:	bf00      	nop
 801fc14:	7ff00000 	.word	0x7ff00000
 801fc18:	20000528 	.word	0x20000528
 801fc1c:	20000520 	.word	0x20000520

0801fc20 <ceil>:
 801fc20:	ec51 0b10 	vmov	r0, r1, d0
 801fc24:	f3c1 530a 	ubfx	r3, r1, #20, #11
 801fc28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801fc2c:	f2a3 36ff 	subw	r6, r3, #1023	@ 0x3ff
 801fc30:	2e13      	cmp	r6, #19
 801fc32:	460c      	mov	r4, r1
 801fc34:	4605      	mov	r5, r0
 801fc36:	4680      	mov	r8, r0
 801fc38:	dc2e      	bgt.n	801fc98 <ceil+0x78>
 801fc3a:	2e00      	cmp	r6, #0
 801fc3c:	da11      	bge.n	801fc62 <ceil+0x42>
 801fc3e:	a332      	add	r3, pc, #200	@ (adr r3, 801fd08 <ceil+0xe8>)
 801fc40:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fc44:	f7e0 fb2a 	bl	800029c <__adddf3>
 801fc48:	2200      	movs	r2, #0
 801fc4a:	2300      	movs	r3, #0
 801fc4c:	f7e0 ff6c 	bl	8000b28 <__aeabi_dcmpgt>
 801fc50:	b120      	cbz	r0, 801fc5c <ceil+0x3c>
 801fc52:	2c00      	cmp	r4, #0
 801fc54:	db4f      	blt.n	801fcf6 <ceil+0xd6>
 801fc56:	4325      	orrs	r5, r4
 801fc58:	d151      	bne.n	801fcfe <ceil+0xde>
 801fc5a:	462c      	mov	r4, r5
 801fc5c:	4621      	mov	r1, r4
 801fc5e:	4628      	mov	r0, r5
 801fc60:	e023      	b.n	801fcaa <ceil+0x8a>
 801fc62:	4f2b      	ldr	r7, [pc, #172]	@ (801fd10 <ceil+0xf0>)
 801fc64:	4137      	asrs	r7, r6
 801fc66:	ea01 0307 	and.w	r3, r1, r7
 801fc6a:	4303      	orrs	r3, r0
 801fc6c:	d01d      	beq.n	801fcaa <ceil+0x8a>
 801fc6e:	a326      	add	r3, pc, #152	@ (adr r3, 801fd08 <ceil+0xe8>)
 801fc70:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fc74:	f7e0 fb12 	bl	800029c <__adddf3>
 801fc78:	2200      	movs	r2, #0
 801fc7a:	2300      	movs	r3, #0
 801fc7c:	f7e0 ff54 	bl	8000b28 <__aeabi_dcmpgt>
 801fc80:	2800      	cmp	r0, #0
 801fc82:	d0eb      	beq.n	801fc5c <ceil+0x3c>
 801fc84:	2c00      	cmp	r4, #0
 801fc86:	bfc2      	ittt	gt
 801fc88:	f44f 1380 	movgt.w	r3, #1048576	@ 0x100000
 801fc8c:	4133      	asrgt	r3, r6
 801fc8e:	18e4      	addgt	r4, r4, r3
 801fc90:	ea24 0407 	bic.w	r4, r4, r7
 801fc94:	2500      	movs	r5, #0
 801fc96:	e7e1      	b.n	801fc5c <ceil+0x3c>
 801fc98:	2e33      	cmp	r6, #51	@ 0x33
 801fc9a:	dd0a      	ble.n	801fcb2 <ceil+0x92>
 801fc9c:	f5b6 6f80 	cmp.w	r6, #1024	@ 0x400
 801fca0:	d103      	bne.n	801fcaa <ceil+0x8a>
 801fca2:	4602      	mov	r2, r0
 801fca4:	460b      	mov	r3, r1
 801fca6:	f7e0 faf9 	bl	800029c <__adddf3>
 801fcaa:	ec41 0b10 	vmov	d0, r0, r1
 801fcae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801fcb2:	f2a3 4313 	subw	r3, r3, #1043	@ 0x413
 801fcb6:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
 801fcba:	40df      	lsrs	r7, r3
 801fcbc:	4238      	tst	r0, r7
 801fcbe:	d0f4      	beq.n	801fcaa <ceil+0x8a>
 801fcc0:	a311      	add	r3, pc, #68	@ (adr r3, 801fd08 <ceil+0xe8>)
 801fcc2:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fcc6:	f7e0 fae9 	bl	800029c <__adddf3>
 801fcca:	2200      	movs	r2, #0
 801fccc:	2300      	movs	r3, #0
 801fcce:	f7e0 ff2b 	bl	8000b28 <__aeabi_dcmpgt>
 801fcd2:	2800      	cmp	r0, #0
 801fcd4:	d0c2      	beq.n	801fc5c <ceil+0x3c>
 801fcd6:	2c00      	cmp	r4, #0
 801fcd8:	dd0a      	ble.n	801fcf0 <ceil+0xd0>
 801fcda:	2e14      	cmp	r6, #20
 801fcdc:	d101      	bne.n	801fce2 <ceil+0xc2>
 801fcde:	3401      	adds	r4, #1
 801fce0:	e006      	b.n	801fcf0 <ceil+0xd0>
 801fce2:	f1c6 0634 	rsb	r6, r6, #52	@ 0x34
 801fce6:	2301      	movs	r3, #1
 801fce8:	40b3      	lsls	r3, r6
 801fcea:	441d      	add	r5, r3
 801fcec:	45a8      	cmp	r8, r5
 801fcee:	d8f6      	bhi.n	801fcde <ceil+0xbe>
 801fcf0:	ea25 0507 	bic.w	r5, r5, r7
 801fcf4:	e7b2      	b.n	801fc5c <ceil+0x3c>
 801fcf6:	2500      	movs	r5, #0
 801fcf8:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
 801fcfc:	e7ae      	b.n	801fc5c <ceil+0x3c>
 801fcfe:	4c05      	ldr	r4, [pc, #20]	@ (801fd14 <ceil+0xf4>)
 801fd00:	2500      	movs	r5, #0
 801fd02:	e7ab      	b.n	801fc5c <ceil+0x3c>
 801fd04:	f3af 8000 	nop.w
 801fd08:	8800759c 	.word	0x8800759c
 801fd0c:	7e37e43c 	.word	0x7e37e43c
 801fd10:	000fffff 	.word	0x000fffff
 801fd14:	3ff00000 	.word	0x3ff00000

0801fd18 <floor>:
 801fd18:	ec51 0b10 	vmov	r0, r1, d0
 801fd1c:	f3c1 530a 	ubfx	r3, r1, #20, #11
 801fd20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801fd24:	f2a3 36ff 	subw	r6, r3, #1023	@ 0x3ff
 801fd28:	2e13      	cmp	r6, #19
 801fd2a:	460c      	mov	r4, r1
 801fd2c:	4605      	mov	r5, r0
 801fd2e:	4680      	mov	r8, r0
 801fd30:	dc34      	bgt.n	801fd9c <floor+0x84>
 801fd32:	2e00      	cmp	r6, #0
 801fd34:	da17      	bge.n	801fd66 <floor+0x4e>
 801fd36:	a332      	add	r3, pc, #200	@ (adr r3, 801fe00 <floor+0xe8>)
 801fd38:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fd3c:	f7e0 faae 	bl	800029c <__adddf3>
 801fd40:	2200      	movs	r2, #0
 801fd42:	2300      	movs	r3, #0
 801fd44:	f7e0 fef0 	bl	8000b28 <__aeabi_dcmpgt>
 801fd48:	b150      	cbz	r0, 801fd60 <floor+0x48>
 801fd4a:	2c00      	cmp	r4, #0
 801fd4c:	da55      	bge.n	801fdfa <floor+0xe2>
 801fd4e:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
 801fd52:	432c      	orrs	r4, r5
 801fd54:	2500      	movs	r5, #0
 801fd56:	42ac      	cmp	r4, r5
 801fd58:	4c2b      	ldr	r4, [pc, #172]	@ (801fe08 <floor+0xf0>)
 801fd5a:	bf08      	it	eq
 801fd5c:	f04f 4400 	moveq.w	r4, #2147483648	@ 0x80000000
 801fd60:	4621      	mov	r1, r4
 801fd62:	4628      	mov	r0, r5
 801fd64:	e023      	b.n	801fdae <floor+0x96>
 801fd66:	4f29      	ldr	r7, [pc, #164]	@ (801fe0c <floor+0xf4>)
 801fd68:	4137      	asrs	r7, r6
 801fd6a:	ea01 0307 	and.w	r3, r1, r7
 801fd6e:	4303      	orrs	r3, r0
 801fd70:	d01d      	beq.n	801fdae <floor+0x96>
 801fd72:	a323      	add	r3, pc, #140	@ (adr r3, 801fe00 <floor+0xe8>)
 801fd74:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fd78:	f7e0 fa90 	bl	800029c <__adddf3>
 801fd7c:	2200      	movs	r2, #0
 801fd7e:	2300      	movs	r3, #0
 801fd80:	f7e0 fed2 	bl	8000b28 <__aeabi_dcmpgt>
 801fd84:	2800      	cmp	r0, #0
 801fd86:	d0eb      	beq.n	801fd60 <floor+0x48>
 801fd88:	2c00      	cmp	r4, #0
 801fd8a:	bfbe      	ittt	lt
 801fd8c:	f44f 1380 	movlt.w	r3, #1048576	@ 0x100000
 801fd90:	4133      	asrlt	r3, r6
 801fd92:	18e4      	addlt	r4, r4, r3
 801fd94:	ea24 0407 	bic.w	r4, r4, r7
 801fd98:	2500      	movs	r5, #0
 801fd9a:	e7e1      	b.n	801fd60 <floor+0x48>
 801fd9c:	2e33      	cmp	r6, #51	@ 0x33
 801fd9e:	dd0a      	ble.n	801fdb6 <floor+0x9e>
 801fda0:	f5b6 6f80 	cmp.w	r6, #1024	@ 0x400
 801fda4:	d103      	bne.n	801fdae <floor+0x96>
 801fda6:	4602      	mov	r2, r0
 801fda8:	460b      	mov	r3, r1
 801fdaa:	f7e0 fa77 	bl	800029c <__adddf3>
 801fdae:	ec41 0b10 	vmov	d0, r0, r1
 801fdb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801fdb6:	f2a3 4313 	subw	r3, r3, #1043	@ 0x413
 801fdba:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
 801fdbe:	40df      	lsrs	r7, r3
 801fdc0:	4207      	tst	r7, r0
 801fdc2:	d0f4      	beq.n	801fdae <floor+0x96>
 801fdc4:	a30e      	add	r3, pc, #56	@ (adr r3, 801fe00 <floor+0xe8>)
 801fdc6:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fdca:	f7e0 fa67 	bl	800029c <__adddf3>
 801fdce:	2200      	movs	r2, #0
 801fdd0:	2300      	movs	r3, #0
 801fdd2:	f7e0 fea9 	bl	8000b28 <__aeabi_dcmpgt>
 801fdd6:	2800      	cmp	r0, #0
 801fdd8:	d0c2      	beq.n	801fd60 <floor+0x48>
 801fdda:	2c00      	cmp	r4, #0
 801fddc:	da0a      	bge.n	801fdf4 <floor+0xdc>
 801fdde:	2e14      	cmp	r6, #20
 801fde0:	d101      	bne.n	801fde6 <floor+0xce>
 801fde2:	3401      	adds	r4, #1
 801fde4:	e006      	b.n	801fdf4 <floor+0xdc>
 801fde6:	f1c6 0634 	rsb	r6, r6, #52	@ 0x34
 801fdea:	2301      	movs	r3, #1
 801fdec:	40b3      	lsls	r3, r6
 801fdee:	441d      	add	r5, r3
 801fdf0:	4545      	cmp	r5, r8
 801fdf2:	d3f6      	bcc.n	801fde2 <floor+0xca>
 801fdf4:	ea25 0507 	bic.w	r5, r5, r7
 801fdf8:	e7b2      	b.n	801fd60 <floor+0x48>
 801fdfa:	2500      	movs	r5, #0
 801fdfc:	462c      	mov	r4, r5
 801fdfe:	e7af      	b.n	801fd60 <floor+0x48>
 801fe00:	8800759c 	.word	0x8800759c
 801fe04:	7e37e43c 	.word	0x7e37e43c
 801fe08:	bff00000 	.word	0xbff00000
 801fe0c:	000fffff 	.word	0x000fffff

0801fe10 <__kernel_cos>:
 801fe10:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fe14:	ec57 6b10 	vmov	r6, r7, d0
 801fe18:	f027 4800 	bic.w	r8, r7, #2147483648	@ 0x80000000
 801fe1c:	f1b8 5f79 	cmp.w	r8, #1044381696	@ 0x3e400000
 801fe20:	ed8d 1b00 	vstr	d1, [sp]
 801fe24:	d206      	bcs.n	801fe34 <__kernel_cos+0x24>
 801fe26:	4630      	mov	r0, r6
 801fe28:	4639      	mov	r1, r7
 801fe2a:	f7e0 fe9d 	bl	8000b68 <__aeabi_d2iz>
 801fe2e:	2800      	cmp	r0, #0
 801fe30:	f000 8088 	beq.w	801ff44 <__kernel_cos+0x134>
 801fe34:	4632      	mov	r2, r6
 801fe36:	463b      	mov	r3, r7
 801fe38:	4630      	mov	r0, r6
 801fe3a:	4639      	mov	r1, r7
 801fe3c:	f7e0 fbe4 	bl	8000608 <__aeabi_dmul>
 801fe40:	4b51      	ldr	r3, [pc, #324]	@ (801ff88 <__kernel_cos+0x178>)
 801fe42:	2200      	movs	r2, #0
 801fe44:	4604      	mov	r4, r0
 801fe46:	460d      	mov	r5, r1
 801fe48:	f7e0 fbde 	bl	8000608 <__aeabi_dmul>
 801fe4c:	a340      	add	r3, pc, #256	@ (adr r3, 801ff50 <__kernel_cos+0x140>)
 801fe4e:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fe52:	4682      	mov	sl, r0
 801fe54:	468b      	mov	fp, r1
 801fe56:	4620      	mov	r0, r4
 801fe58:	4629      	mov	r1, r5
 801fe5a:	f7e0 fbd5 	bl	8000608 <__aeabi_dmul>
 801fe5e:	a33e      	add	r3, pc, #248	@ (adr r3, 801ff58 <__kernel_cos+0x148>)
 801fe60:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fe64:	f7e0 fa1a 	bl	800029c <__adddf3>
 801fe68:	4622      	mov	r2, r4
 801fe6a:	462b      	mov	r3, r5
 801fe6c:	f7e0 fbcc 	bl	8000608 <__aeabi_dmul>
 801fe70:	a33b      	add	r3, pc, #236	@ (adr r3, 801ff60 <__kernel_cos+0x150>)
 801fe72:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fe76:	f7e0 fa0f 	bl	8000298 <__aeabi_dsub>
 801fe7a:	4622      	mov	r2, r4
 801fe7c:	462b      	mov	r3, r5
 801fe7e:	f7e0 fbc3 	bl	8000608 <__aeabi_dmul>
 801fe82:	a339      	add	r3, pc, #228	@ (adr r3, 801ff68 <__kernel_cos+0x158>)
 801fe84:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fe88:	f7e0 fa08 	bl	800029c <__adddf3>
 801fe8c:	4622      	mov	r2, r4
 801fe8e:	462b      	mov	r3, r5
 801fe90:	f7e0 fbba 	bl	8000608 <__aeabi_dmul>
 801fe94:	a336      	add	r3, pc, #216	@ (adr r3, 801ff70 <__kernel_cos+0x160>)
 801fe96:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fe9a:	f7e0 f9fd 	bl	8000298 <__aeabi_dsub>
 801fe9e:	4622      	mov	r2, r4
 801fea0:	462b      	mov	r3, r5
 801fea2:	f7e0 fbb1 	bl	8000608 <__aeabi_dmul>
 801fea6:	a334      	add	r3, pc, #208	@ (adr r3, 801ff78 <__kernel_cos+0x168>)
 801fea8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801feac:	f7e0 f9f6 	bl	800029c <__adddf3>
 801feb0:	4622      	mov	r2, r4
 801feb2:	462b      	mov	r3, r5
 801feb4:	f7e0 fba8 	bl	8000608 <__aeabi_dmul>
 801feb8:	4622      	mov	r2, r4
 801feba:	462b      	mov	r3, r5
 801febc:	f7e0 fba4 	bl	8000608 <__aeabi_dmul>
 801fec0:	e9dd 2300 	ldrd	r2, r3, [sp]
 801fec4:	4604      	mov	r4, r0
 801fec6:	460d      	mov	r5, r1
 801fec8:	4630      	mov	r0, r6
 801feca:	4639      	mov	r1, r7
 801fecc:	f7e0 fb9c 	bl	8000608 <__aeabi_dmul>
 801fed0:	460b      	mov	r3, r1
 801fed2:	4602      	mov	r2, r0
 801fed4:	4629      	mov	r1, r5
 801fed6:	4620      	mov	r0, r4
 801fed8:	f7e0 f9de 	bl	8000298 <__aeabi_dsub>
 801fedc:	4b2b      	ldr	r3, [pc, #172]	@ (801ff8c <__kernel_cos+0x17c>)
 801fede:	4598      	cmp	r8, r3
 801fee0:	4606      	mov	r6, r0
 801fee2:	460f      	mov	r7, r1
 801fee4:	d810      	bhi.n	801ff08 <__kernel_cos+0xf8>
 801fee6:	4602      	mov	r2, r0
 801fee8:	460b      	mov	r3, r1
 801feea:	4650      	mov	r0, sl
 801feec:	4659      	mov	r1, fp
 801feee:	f7e0 f9d3 	bl	8000298 <__aeabi_dsub>
 801fef2:	460b      	mov	r3, r1
 801fef4:	4926      	ldr	r1, [pc, #152]	@ (801ff90 <__kernel_cos+0x180>)
 801fef6:	4602      	mov	r2, r0
 801fef8:	2000      	movs	r0, #0
 801fefa:	f7e0 f9cd 	bl	8000298 <__aeabi_dsub>
 801fefe:	ec41 0b10 	vmov	d0, r0, r1
 801ff02:	b003      	add	sp, #12
 801ff04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ff08:	4b22      	ldr	r3, [pc, #136]	@ (801ff94 <__kernel_cos+0x184>)
 801ff0a:	4921      	ldr	r1, [pc, #132]	@ (801ff90 <__kernel_cos+0x180>)
 801ff0c:	4598      	cmp	r8, r3
 801ff0e:	bf8c      	ite	hi
 801ff10:	4d21      	ldrhi	r5, [pc, #132]	@ (801ff98 <__kernel_cos+0x188>)
 801ff12:	f5a8 1500 	subls.w	r5, r8, #2097152	@ 0x200000
 801ff16:	2400      	movs	r4, #0
 801ff18:	4622      	mov	r2, r4
 801ff1a:	462b      	mov	r3, r5
 801ff1c:	2000      	movs	r0, #0
 801ff1e:	f7e0 f9bb 	bl	8000298 <__aeabi_dsub>
 801ff22:	4622      	mov	r2, r4
 801ff24:	4680      	mov	r8, r0
 801ff26:	4689      	mov	r9, r1
 801ff28:	462b      	mov	r3, r5
 801ff2a:	4650      	mov	r0, sl
 801ff2c:	4659      	mov	r1, fp
 801ff2e:	f7e0 f9b3 	bl	8000298 <__aeabi_dsub>
 801ff32:	4632      	mov	r2, r6
 801ff34:	463b      	mov	r3, r7
 801ff36:	f7e0 f9af 	bl	8000298 <__aeabi_dsub>
 801ff3a:	4602      	mov	r2, r0
 801ff3c:	460b      	mov	r3, r1
 801ff3e:	4640      	mov	r0, r8
 801ff40:	4649      	mov	r1, r9
 801ff42:	e7da      	b.n	801fefa <__kernel_cos+0xea>
 801ff44:	ed9f 0b0e 	vldr	d0, [pc, #56]	@ 801ff80 <__kernel_cos+0x170>
 801ff48:	e7db      	b.n	801ff02 <__kernel_cos+0xf2>
 801ff4a:	bf00      	nop
 801ff4c:	f3af 8000 	nop.w
 801ff50:	be8838d4 	.word	0xbe8838d4
 801ff54:	bda8fae9 	.word	0xbda8fae9
 801ff58:	bdb4b1c4 	.word	0xbdb4b1c4
 801ff5c:	3e21ee9e 	.word	0x3e21ee9e
 801ff60:	809c52ad 	.word	0x809c52ad
 801ff64:	3e927e4f 	.word	0x3e927e4f
 801ff68:	19cb1590 	.word	0x19cb1590
 801ff6c:	3efa01a0 	.word	0x3efa01a0
 801ff70:	16c15177 	.word	0x16c15177
 801ff74:	3f56c16c 	.word	0x3f56c16c
 801ff78:	5555554c 	.word	0x5555554c
 801ff7c:	3fa55555 	.word	0x3fa55555
 801ff80:	00000000 	.word	0x00000000
 801ff84:	3ff00000 	.word	0x3ff00000
 801ff88:	3fe00000 	.word	0x3fe00000
 801ff8c:	3fd33332 	.word	0x3fd33332
 801ff90:	3ff00000 	.word	0x3ff00000
 801ff94:	3fe90000 	.word	0x3fe90000
 801ff98:	3fd20000 	.word	0x3fd20000
 801ff9c:	00000000 	.word	0x00000000

0801ffa0 <__kernel_sin>:
 801ffa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ffa4:	ec55 4b10 	vmov	r4, r5, d0
 801ffa8:	f025 4300 	bic.w	r3, r5, #2147483648	@ 0x80000000
 801ffac:	b085      	sub	sp, #20
 801ffae:	f1b3 5f79 	cmp.w	r3, #1044381696	@ 0x3e400000
 801ffb2:	ed8d 1b02 	vstr	d1, [sp, #8]
 801ffb6:	4680      	mov	r8, r0
 801ffb8:	d205      	bcs.n	801ffc6 <__kernel_sin+0x26>
 801ffba:	4620      	mov	r0, r4
 801ffbc:	4629      	mov	r1, r5
 801ffbe:	f7e0 fdd3 	bl	8000b68 <__aeabi_d2iz>
 801ffc2:	2800      	cmp	r0, #0
 801ffc4:	d052      	beq.n	802006c <__kernel_sin+0xcc>
 801ffc6:	4622      	mov	r2, r4
 801ffc8:	462b      	mov	r3, r5
 801ffca:	4620      	mov	r0, r4
 801ffcc:	4629      	mov	r1, r5
 801ffce:	f7e0 fb1b 	bl	8000608 <__aeabi_dmul>
 801ffd2:	4682      	mov	sl, r0
 801ffd4:	468b      	mov	fp, r1
 801ffd6:	4602      	mov	r2, r0
 801ffd8:	460b      	mov	r3, r1
 801ffda:	4620      	mov	r0, r4
 801ffdc:	4629      	mov	r1, r5
 801ffde:	f7e0 fb13 	bl	8000608 <__aeabi_dmul>
 801ffe2:	a342      	add	r3, pc, #264	@ (adr r3, 80200ec <__kernel_sin+0x14c>)
 801ffe4:	e9d3 2300 	ldrd	r2, r3, [r3]
 801ffe8:	e9cd 0100 	strd	r0, r1, [sp]
 801ffec:	4650      	mov	r0, sl
 801ffee:	4659      	mov	r1, fp
 801fff0:	f7e0 fb0a 	bl	8000608 <__aeabi_dmul>
 801fff4:	a33f      	add	r3, pc, #252	@ (adr r3, 80200f4 <__kernel_sin+0x154>)
 801fff6:	e9d3 2300 	ldrd	r2, r3, [r3]
 801fffa:	f7e0 f94d 	bl	8000298 <__aeabi_dsub>
 801fffe:	4652      	mov	r2, sl
 8020000:	465b      	mov	r3, fp
 8020002:	f7e0 fb01 	bl	8000608 <__aeabi_dmul>
 8020006:	a33d      	add	r3, pc, #244	@ (adr r3, 80200fc <__kernel_sin+0x15c>)
 8020008:	e9d3 2300 	ldrd	r2, r3, [r3]
 802000c:	f7e0 f946 	bl	800029c <__adddf3>
 8020010:	4652      	mov	r2, sl
 8020012:	465b      	mov	r3, fp
 8020014:	f7e0 faf8 	bl	8000608 <__aeabi_dmul>
 8020018:	a33a      	add	r3, pc, #232	@ (adr r3, 8020104 <__kernel_sin+0x164>)
 802001a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802001e:	f7e0 f93b 	bl	8000298 <__aeabi_dsub>
 8020022:	4652      	mov	r2, sl
 8020024:	465b      	mov	r3, fp
 8020026:	f7e0 faef 	bl	8000608 <__aeabi_dmul>
 802002a:	a338      	add	r3, pc, #224	@ (adr r3, 802010c <__kernel_sin+0x16c>)
 802002c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020030:	f7e0 f934 	bl	800029c <__adddf3>
 8020034:	4606      	mov	r6, r0
 8020036:	460f      	mov	r7, r1
 8020038:	f1b8 0f00 	cmp.w	r8, #0
 802003c:	d11b      	bne.n	8020076 <__kernel_sin+0xd6>
 802003e:	4602      	mov	r2, r0
 8020040:	460b      	mov	r3, r1
 8020042:	4650      	mov	r0, sl
 8020044:	4659      	mov	r1, fp
 8020046:	f7e0 fadf 	bl	8000608 <__aeabi_dmul>
 802004a:	a325      	add	r3, pc, #148	@ (adr r3, 80200e0 <__kernel_sin+0x140>)
 802004c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020050:	f7e0 f922 	bl	8000298 <__aeabi_dsub>
 8020054:	e9dd 2300 	ldrd	r2, r3, [sp]
 8020058:	f7e0 fad6 	bl	8000608 <__aeabi_dmul>
 802005c:	4602      	mov	r2, r0
 802005e:	460b      	mov	r3, r1
 8020060:	4620      	mov	r0, r4
 8020062:	4629      	mov	r1, r5
 8020064:	f7e0 f91a 	bl	800029c <__adddf3>
 8020068:	4604      	mov	r4, r0
 802006a:	460d      	mov	r5, r1
 802006c:	ec45 4b10 	vmov	d0, r4, r5
 8020070:	b005      	add	sp, #20
 8020072:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020076:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802007a:	4b1b      	ldr	r3, [pc, #108]	@ (80200e8 <__kernel_sin+0x148>)
 802007c:	2200      	movs	r2, #0
 802007e:	f7e0 fac3 	bl	8000608 <__aeabi_dmul>
 8020082:	4632      	mov	r2, r6
 8020084:	4680      	mov	r8, r0
 8020086:	4689      	mov	r9, r1
 8020088:	463b      	mov	r3, r7
 802008a:	e9dd 0100 	ldrd	r0, r1, [sp]
 802008e:	f7e0 fabb 	bl	8000608 <__aeabi_dmul>
 8020092:	4602      	mov	r2, r0
 8020094:	460b      	mov	r3, r1
 8020096:	4640      	mov	r0, r8
 8020098:	4649      	mov	r1, r9
 802009a:	f7e0 f8fd 	bl	8000298 <__aeabi_dsub>
 802009e:	4652      	mov	r2, sl
 80200a0:	465b      	mov	r3, fp
 80200a2:	f7e0 fab1 	bl	8000608 <__aeabi_dmul>
 80200a6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80200aa:	f7e0 f8f5 	bl	8000298 <__aeabi_dsub>
 80200ae:	a30c      	add	r3, pc, #48	@ (adr r3, 80200e0 <__kernel_sin+0x140>)
 80200b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80200b4:	4606      	mov	r6, r0
 80200b6:	460f      	mov	r7, r1
 80200b8:	e9dd 0100 	ldrd	r0, r1, [sp]
 80200bc:	f7e0 faa4 	bl	8000608 <__aeabi_dmul>
 80200c0:	4602      	mov	r2, r0
 80200c2:	460b      	mov	r3, r1
 80200c4:	4630      	mov	r0, r6
 80200c6:	4639      	mov	r1, r7
 80200c8:	f7e0 f8e8 	bl	800029c <__adddf3>
 80200cc:	4602      	mov	r2, r0
 80200ce:	460b      	mov	r3, r1
 80200d0:	4620      	mov	r0, r4
 80200d2:	4629      	mov	r1, r5
 80200d4:	f7e0 f8e0 	bl	8000298 <__aeabi_dsub>
 80200d8:	e7c6      	b.n	8020068 <__kernel_sin+0xc8>
 80200da:	bf00      	nop
 80200dc:	f3af 8000 	nop.w
 80200e0:	55555549 	.word	0x55555549
 80200e4:	3fc55555 	.word	0x3fc55555
 80200e8:	3fe00000 	.word	0x3fe00000
 80200ec:	5acfd57c 	.word	0x5acfd57c
 80200f0:	3de5d93a 	.word	0x3de5d93a
 80200f4:	8a2b9ceb 	.word	0x8a2b9ceb
 80200f8:	3e5ae5e6 	.word	0x3e5ae5e6
 80200fc:	57b1fe7d 	.word	0x57b1fe7d
 8020100:	3ec71de3 	.word	0x3ec71de3
 8020104:	19c161d5 	.word	0x19c161d5
 8020108:	3f2a01a0 	.word	0x3f2a01a0
 802010c:	1110f8a6 	.word	0x1110f8a6
 8020110:	3f811111 	.word	0x3f811111
 8020114:	00000000 	.word	0x00000000

08020118 <__kernel_tan>:
 8020118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802011c:	ec5b ab10 	vmov	sl, fp, d0
 8020120:	4bdb      	ldr	r3, [pc, #876]	@ (8020490 <__kernel_tan+0x378>)
 8020122:	b089      	sub	sp, #36	@ 0x24
 8020124:	f02b 4700 	bic.w	r7, fp, #2147483648	@ 0x80000000
 8020128:	429f      	cmp	r7, r3
 802012a:	ec59 8b11 	vmov	r8, r9, d1
 802012e:	4606      	mov	r6, r0
 8020130:	f8cd b008 	str.w	fp, [sp, #8]
 8020134:	d85d      	bhi.n	80201f2 <__kernel_tan+0xda>
 8020136:	4650      	mov	r0, sl
 8020138:	4659      	mov	r1, fp
 802013a:	f7e0 fd15 	bl	8000b68 <__aeabi_d2iz>
 802013e:	4605      	mov	r5, r0
 8020140:	2800      	cmp	r0, #0
 8020142:	d17c      	bne.n	802023e <__kernel_tan+0x126>
 8020144:	1c73      	adds	r3, r6, #1
 8020146:	4652      	mov	r2, sl
 8020148:	4313      	orrs	r3, r2
 802014a:	433b      	orrs	r3, r7
 802014c:	d110      	bne.n	8020170 <__kernel_tan+0x58>
 802014e:	ec4b ab10 	vmov	d0, sl, fp
 8020152:	f7ff faf5 	bl	801f740 <fabs>
 8020156:	49cf      	ldr	r1, [pc, #828]	@ (8020494 <__kernel_tan+0x37c>)
 8020158:	ec53 2b10 	vmov	r2, r3, d0
 802015c:	2000      	movs	r0, #0
 802015e:	f7e0 fb7d 	bl	800085c <__aeabi_ddiv>
 8020162:	4682      	mov	sl, r0
 8020164:	468b      	mov	fp, r1
 8020166:	ec4b ab10 	vmov	d0, sl, fp
 802016a:	b009      	add	sp, #36	@ 0x24
 802016c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020170:	2e01      	cmp	r6, #1
 8020172:	d0f8      	beq.n	8020166 <__kernel_tan+0x4e>
 8020174:	4642      	mov	r2, r8
 8020176:	464b      	mov	r3, r9
 8020178:	4650      	mov	r0, sl
 802017a:	4659      	mov	r1, fp
 802017c:	f7e0 f88e 	bl	800029c <__adddf3>
 8020180:	4602      	mov	r2, r0
 8020182:	460b      	mov	r3, r1
 8020184:	460f      	mov	r7, r1
 8020186:	2000      	movs	r0, #0
 8020188:	49c3      	ldr	r1, [pc, #780]	@ (8020498 <__kernel_tan+0x380>)
 802018a:	f7e0 fb67 	bl	800085c <__aeabi_ddiv>
 802018e:	e9cd 0100 	strd	r0, r1, [sp]
 8020192:	e9dd 2300 	ldrd	r2, r3, [sp]
 8020196:	462e      	mov	r6, r5
 8020198:	4652      	mov	r2, sl
 802019a:	462c      	mov	r4, r5
 802019c:	4630      	mov	r0, r6
 802019e:	461d      	mov	r5, r3
 80201a0:	4639      	mov	r1, r7
 80201a2:	465b      	mov	r3, fp
 80201a4:	f7e0 f878 	bl	8000298 <__aeabi_dsub>
 80201a8:	4602      	mov	r2, r0
 80201aa:	460b      	mov	r3, r1
 80201ac:	4640      	mov	r0, r8
 80201ae:	4649      	mov	r1, r9
 80201b0:	f7e0 f872 	bl	8000298 <__aeabi_dsub>
 80201b4:	4632      	mov	r2, r6
 80201b6:	462b      	mov	r3, r5
 80201b8:	f7e0 fa26 	bl	8000608 <__aeabi_dmul>
 80201bc:	4632      	mov	r2, r6
 80201be:	4682      	mov	sl, r0
 80201c0:	468b      	mov	fp, r1
 80201c2:	462b      	mov	r3, r5
 80201c4:	4630      	mov	r0, r6
 80201c6:	4639      	mov	r1, r7
 80201c8:	f7e0 fa1e 	bl	8000608 <__aeabi_dmul>
 80201cc:	4bb1      	ldr	r3, [pc, #708]	@ (8020494 <__kernel_tan+0x37c>)
 80201ce:	2200      	movs	r2, #0
 80201d0:	f7e0 f864 	bl	800029c <__adddf3>
 80201d4:	4602      	mov	r2, r0
 80201d6:	460b      	mov	r3, r1
 80201d8:	4650      	mov	r0, sl
 80201da:	4659      	mov	r1, fp
 80201dc:	f7e0 f85e 	bl	800029c <__adddf3>
 80201e0:	e9dd 2300 	ldrd	r2, r3, [sp]
 80201e4:	f7e0 fa10 	bl	8000608 <__aeabi_dmul>
 80201e8:	4622      	mov	r2, r4
 80201ea:	462b      	mov	r3, r5
 80201ec:	f7e0 f856 	bl	800029c <__adddf3>
 80201f0:	e7b7      	b.n	8020162 <__kernel_tan+0x4a>
 80201f2:	4baa      	ldr	r3, [pc, #680]	@ (802049c <__kernel_tan+0x384>)
 80201f4:	429f      	cmp	r7, r3
 80201f6:	d922      	bls.n	802023e <__kernel_tan+0x126>
 80201f8:	9b02      	ldr	r3, [sp, #8]
 80201fa:	2b00      	cmp	r3, #0
 80201fc:	da05      	bge.n	802020a <__kernel_tan+0xf2>
 80201fe:	f10b 4300 	add.w	r3, fp, #2147483648	@ 0x80000000
 8020202:	469b      	mov	fp, r3
 8020204:	f109 4300 	add.w	r3, r9, #2147483648	@ 0x80000000
 8020208:	4699      	mov	r9, r3
 802020a:	4652      	mov	r2, sl
 802020c:	465b      	mov	r3, fp
 802020e:	a182      	add	r1, pc, #520	@ (adr r1, 8020418 <__kernel_tan+0x300>)
 8020210:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020214:	f7e0 f840 	bl	8000298 <__aeabi_dsub>
 8020218:	4642      	mov	r2, r8
 802021a:	464b      	mov	r3, r9
 802021c:	4604      	mov	r4, r0
 802021e:	460d      	mov	r5, r1
 8020220:	a17f      	add	r1, pc, #508	@ (adr r1, 8020420 <__kernel_tan+0x308>)
 8020222:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020226:	f7e0 f837 	bl	8000298 <__aeabi_dsub>
 802022a:	4622      	mov	r2, r4
 802022c:	462b      	mov	r3, r5
 802022e:	f7e0 f835 	bl	800029c <__adddf3>
 8020232:	f04f 0800 	mov.w	r8, #0
 8020236:	4682      	mov	sl, r0
 8020238:	468b      	mov	fp, r1
 802023a:	f04f 0900 	mov.w	r9, #0
 802023e:	4652      	mov	r2, sl
 8020240:	465b      	mov	r3, fp
 8020242:	4650      	mov	r0, sl
 8020244:	4659      	mov	r1, fp
 8020246:	f7e0 f9df 	bl	8000608 <__aeabi_dmul>
 802024a:	4602      	mov	r2, r0
 802024c:	460b      	mov	r3, r1
 802024e:	e9cd 2300 	strd	r2, r3, [sp]
 8020252:	f7e0 f9d9 	bl	8000608 <__aeabi_dmul>
 8020256:	e9dd 2300 	ldrd	r2, r3, [sp]
 802025a:	4604      	mov	r4, r0
 802025c:	460d      	mov	r5, r1
 802025e:	4650      	mov	r0, sl
 8020260:	4659      	mov	r1, fp
 8020262:	f7e0 f9d1 	bl	8000608 <__aeabi_dmul>
 8020266:	a370      	add	r3, pc, #448	@ (adr r3, 8020428 <__kernel_tan+0x310>)
 8020268:	e9d3 2300 	ldrd	r2, r3, [r3]
 802026c:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8020270:	4620      	mov	r0, r4
 8020272:	4629      	mov	r1, r5
 8020274:	f7e0 f9c8 	bl	8000608 <__aeabi_dmul>
 8020278:	a36d      	add	r3, pc, #436	@ (adr r3, 8020430 <__kernel_tan+0x318>)
 802027a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802027e:	f7e0 f80d 	bl	800029c <__adddf3>
 8020282:	4622      	mov	r2, r4
 8020284:	462b      	mov	r3, r5
 8020286:	f7e0 f9bf 	bl	8000608 <__aeabi_dmul>
 802028a:	a36b      	add	r3, pc, #428	@ (adr r3, 8020438 <__kernel_tan+0x320>)
 802028c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020290:	f7e0 f804 	bl	800029c <__adddf3>
 8020294:	4622      	mov	r2, r4
 8020296:	462b      	mov	r3, r5
 8020298:	f7e0 f9b6 	bl	8000608 <__aeabi_dmul>
 802029c:	a368      	add	r3, pc, #416	@ (adr r3, 8020440 <__kernel_tan+0x328>)
 802029e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80202a2:	f7df fffb 	bl	800029c <__adddf3>
 80202a6:	4622      	mov	r2, r4
 80202a8:	462b      	mov	r3, r5
 80202aa:	f7e0 f9ad 	bl	8000608 <__aeabi_dmul>
 80202ae:	a366      	add	r3, pc, #408	@ (adr r3, 8020448 <__kernel_tan+0x330>)
 80202b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80202b4:	f7df fff2 	bl	800029c <__adddf3>
 80202b8:	4622      	mov	r2, r4
 80202ba:	462b      	mov	r3, r5
 80202bc:	f7e0 f9a4 	bl	8000608 <__aeabi_dmul>
 80202c0:	a363      	add	r3, pc, #396	@ (adr r3, 8020450 <__kernel_tan+0x338>)
 80202c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80202c6:	f7df ffe9 	bl	800029c <__adddf3>
 80202ca:	e9dd 2300 	ldrd	r2, r3, [sp]
 80202ce:	f7e0 f99b 	bl	8000608 <__aeabi_dmul>
 80202d2:	a361      	add	r3, pc, #388	@ (adr r3, 8020458 <__kernel_tan+0x340>)
 80202d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80202d8:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80202dc:	4620      	mov	r0, r4
 80202de:	4629      	mov	r1, r5
 80202e0:	f7e0 f992 	bl	8000608 <__aeabi_dmul>
 80202e4:	a35e      	add	r3, pc, #376	@ (adr r3, 8020460 <__kernel_tan+0x348>)
 80202e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80202ea:	f7df ffd7 	bl	800029c <__adddf3>
 80202ee:	4622      	mov	r2, r4
 80202f0:	462b      	mov	r3, r5
 80202f2:	f7e0 f989 	bl	8000608 <__aeabi_dmul>
 80202f6:	a35c      	add	r3, pc, #368	@ (adr r3, 8020468 <__kernel_tan+0x350>)
 80202f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80202fc:	f7df ffce 	bl	800029c <__adddf3>
 8020300:	4622      	mov	r2, r4
 8020302:	462b      	mov	r3, r5
 8020304:	f7e0 f980 	bl	8000608 <__aeabi_dmul>
 8020308:	a359      	add	r3, pc, #356	@ (adr r3, 8020470 <__kernel_tan+0x358>)
 802030a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802030e:	f7df ffc5 	bl	800029c <__adddf3>
 8020312:	4622      	mov	r2, r4
 8020314:	462b      	mov	r3, r5
 8020316:	f7e0 f977 	bl	8000608 <__aeabi_dmul>
 802031a:	a357      	add	r3, pc, #348	@ (adr r3, 8020478 <__kernel_tan+0x360>)
 802031c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020320:	f7df ffbc 	bl	800029c <__adddf3>
 8020324:	4622      	mov	r2, r4
 8020326:	462b      	mov	r3, r5
 8020328:	f7e0 f96e 	bl	8000608 <__aeabi_dmul>
 802032c:	a354      	add	r3, pc, #336	@ (adr r3, 8020480 <__kernel_tan+0x368>)
 802032e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020332:	f7df ffb3 	bl	800029c <__adddf3>
 8020336:	4602      	mov	r2, r0
 8020338:	460b      	mov	r3, r1
 802033a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802033e:	f7df ffad 	bl	800029c <__adddf3>
 8020342:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8020346:	f7e0 f95f 	bl	8000608 <__aeabi_dmul>
 802034a:	4642      	mov	r2, r8
 802034c:	464b      	mov	r3, r9
 802034e:	f7df ffa5 	bl	800029c <__adddf3>
 8020352:	e9dd 2300 	ldrd	r2, r3, [sp]
 8020356:	f7e0 f957 	bl	8000608 <__aeabi_dmul>
 802035a:	4642      	mov	r2, r8
 802035c:	464b      	mov	r3, r9
 802035e:	f7df ff9d 	bl	800029c <__adddf3>
 8020362:	a349      	add	r3, pc, #292	@ (adr r3, 8020488 <__kernel_tan+0x370>)
 8020364:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020368:	4604      	mov	r4, r0
 802036a:	460d      	mov	r5, r1
 802036c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8020370:	f7e0 f94a 	bl	8000608 <__aeabi_dmul>
 8020374:	4622      	mov	r2, r4
 8020376:	462b      	mov	r3, r5
 8020378:	f7df ff90 	bl	800029c <__adddf3>
 802037c:	e9cd 0100 	strd	r0, r1, [sp]
 8020380:	460b      	mov	r3, r1
 8020382:	4602      	mov	r2, r0
 8020384:	4659      	mov	r1, fp
 8020386:	4650      	mov	r0, sl
 8020388:	f7df ff88 	bl	800029c <__adddf3>
 802038c:	4b43      	ldr	r3, [pc, #268]	@ (802049c <__kernel_tan+0x384>)
 802038e:	429f      	cmp	r7, r3
 8020390:	4604      	mov	r4, r0
 8020392:	460d      	mov	r5, r1
 8020394:	f240 8084 	bls.w	80204a0 <__kernel_tan+0x388>
 8020398:	4630      	mov	r0, r6
 802039a:	f7e0 f8cb 	bl	8000534 <__aeabi_i2d>
 802039e:	4622      	mov	r2, r4
 80203a0:	4680      	mov	r8, r0
 80203a2:	4689      	mov	r9, r1
 80203a4:	462b      	mov	r3, r5
 80203a6:	4620      	mov	r0, r4
 80203a8:	4629      	mov	r1, r5
 80203aa:	f7e0 f92d 	bl	8000608 <__aeabi_dmul>
 80203ae:	4642      	mov	r2, r8
 80203b0:	4606      	mov	r6, r0
 80203b2:	460f      	mov	r7, r1
 80203b4:	464b      	mov	r3, r9
 80203b6:	4620      	mov	r0, r4
 80203b8:	4629      	mov	r1, r5
 80203ba:	f7df ff6f 	bl	800029c <__adddf3>
 80203be:	4602      	mov	r2, r0
 80203c0:	460b      	mov	r3, r1
 80203c2:	4630      	mov	r0, r6
 80203c4:	4639      	mov	r1, r7
 80203c6:	f7e0 fa49 	bl	800085c <__aeabi_ddiv>
 80203ca:	e9dd 2300 	ldrd	r2, r3, [sp]
 80203ce:	f7df ff63 	bl	8000298 <__aeabi_dsub>
 80203d2:	4602      	mov	r2, r0
 80203d4:	460b      	mov	r3, r1
 80203d6:	4650      	mov	r0, sl
 80203d8:	4659      	mov	r1, fp
 80203da:	f7df ff5d 	bl	8000298 <__aeabi_dsub>
 80203de:	4602      	mov	r2, r0
 80203e0:	460b      	mov	r3, r1
 80203e2:	f7df ff5b 	bl	800029c <__adddf3>
 80203e6:	4602      	mov	r2, r0
 80203e8:	460b      	mov	r3, r1
 80203ea:	4640      	mov	r0, r8
 80203ec:	4649      	mov	r1, r9
 80203ee:	f7df ff53 	bl	8000298 <__aeabi_dsub>
 80203f2:	9b02      	ldr	r3, [sp, #8]
 80203f4:	ea4f 7aa3 	mov.w	sl, r3, asr #30
 80203f8:	f00a 0a02 	and.w	sl, sl, #2
 80203fc:	4604      	mov	r4, r0
 80203fe:	f1ca 0001 	rsb	r0, sl, #1
 8020402:	460d      	mov	r5, r1
 8020404:	f7e0 f896 	bl	8000534 <__aeabi_i2d>
 8020408:	4602      	mov	r2, r0
 802040a:	460b      	mov	r3, r1
 802040c:	4620      	mov	r0, r4
 802040e:	4629      	mov	r1, r5
 8020410:	f7e0 f8fa 	bl	8000608 <__aeabi_dmul>
 8020414:	e6a5      	b.n	8020162 <__kernel_tan+0x4a>
 8020416:	bf00      	nop
 8020418:	54442d18 	.word	0x54442d18
 802041c:	3fe921fb 	.word	0x3fe921fb
 8020420:	33145c07 	.word	0x33145c07
 8020424:	3c81a626 	.word	0x3c81a626
 8020428:	74bf7ad4 	.word	0x74bf7ad4
 802042c:	3efb2a70 	.word	0x3efb2a70
 8020430:	32f0a7e9 	.word	0x32f0a7e9
 8020434:	3f12b80f 	.word	0x3f12b80f
 8020438:	1a8d1068 	.word	0x1a8d1068
 802043c:	3f3026f7 	.word	0x3f3026f7
 8020440:	fee08315 	.word	0xfee08315
 8020444:	3f57dbc8 	.word	0x3f57dbc8
 8020448:	e96e8493 	.word	0xe96e8493
 802044c:	3f8226e3 	.word	0x3f8226e3
 8020450:	1bb341fe 	.word	0x1bb341fe
 8020454:	3faba1ba 	.word	0x3faba1ba
 8020458:	db605373 	.word	0xdb605373
 802045c:	bef375cb 	.word	0xbef375cb
 8020460:	a03792a6 	.word	0xa03792a6
 8020464:	3f147e88 	.word	0x3f147e88
 8020468:	f2f26501 	.word	0xf2f26501
 802046c:	3f4344d8 	.word	0x3f4344d8
 8020470:	c9560328 	.word	0xc9560328
 8020474:	3f6d6d22 	.word	0x3f6d6d22
 8020478:	8406d637 	.word	0x8406d637
 802047c:	3f9664f4 	.word	0x3f9664f4
 8020480:	1110fe7a 	.word	0x1110fe7a
 8020484:	3fc11111 	.word	0x3fc11111
 8020488:	55555563 	.word	0x55555563
 802048c:	3fd55555 	.word	0x3fd55555
 8020490:	3e2fffff 	.word	0x3e2fffff
 8020494:	3ff00000 	.word	0x3ff00000
 8020498:	bff00000 	.word	0xbff00000
 802049c:	3fe59427 	.word	0x3fe59427
 80204a0:	2e01      	cmp	r6, #1
 80204a2:	d033      	beq.n	802050c <__kernel_tan+0x3f4>
 80204a4:	f04f 0800 	mov.w	r8, #0
 80204a8:	4689      	mov	r9, r1
 80204aa:	4602      	mov	r2, r0
 80204ac:	460b      	mov	r3, r1
 80204ae:	2000      	movs	r0, #0
 80204b0:	4918      	ldr	r1, [pc, #96]	@ (8020514 <__kernel_tan+0x3fc>)
 80204b2:	e9cd 8902 	strd	r8, r9, [sp, #8]
 80204b6:	f7e0 f9d1 	bl	800085c <__aeabi_ddiv>
 80204ba:	4652      	mov	r2, sl
 80204bc:	460f      	mov	r7, r1
 80204be:	465b      	mov	r3, fp
 80204c0:	4606      	mov	r6, r0
 80204c2:	460d      	mov	r5, r1
 80204c4:	4640      	mov	r0, r8
 80204c6:	4649      	mov	r1, r9
 80204c8:	f7df fee6 	bl	8000298 <__aeabi_dsub>
 80204cc:	4602      	mov	r2, r0
 80204ce:	460b      	mov	r3, r1
 80204d0:	e9dd 0100 	ldrd	r0, r1, [sp]
 80204d4:	f7df fee0 	bl	8000298 <__aeabi_dsub>
 80204d8:	4642      	mov	r2, r8
 80204da:	463b      	mov	r3, r7
 80204dc:	f7e0 f894 	bl	8000608 <__aeabi_dmul>
 80204e0:	4642      	mov	r2, r8
 80204e2:	4682      	mov	sl, r0
 80204e4:	468b      	mov	fp, r1
 80204e6:	463b      	mov	r3, r7
 80204e8:	4640      	mov	r0, r8
 80204ea:	4649      	mov	r1, r9
 80204ec:	f7e0 f88c 	bl	8000608 <__aeabi_dmul>
 80204f0:	4b09      	ldr	r3, [pc, #36]	@ (8020518 <__kernel_tan+0x400>)
 80204f2:	2200      	movs	r2, #0
 80204f4:	f7df fed2 	bl	800029c <__adddf3>
 80204f8:	4602      	mov	r2, r0
 80204fa:	460b      	mov	r3, r1
 80204fc:	4650      	mov	r0, sl
 80204fe:	4659      	mov	r1, fp
 8020500:	f7df fecc 	bl	800029c <__adddf3>
 8020504:	4644      	mov	r4, r8
 8020506:	4632      	mov	r2, r6
 8020508:	463b      	mov	r3, r7
 802050a:	e66b      	b.n	80201e4 <__kernel_tan+0xcc>
 802050c:	4682      	mov	sl, r0
 802050e:	468b      	mov	fp, r1
 8020510:	e629      	b.n	8020166 <__kernel_tan+0x4e>
 8020512:	bf00      	nop
 8020514:	bff00000 	.word	0xbff00000
 8020518:	3ff00000 	.word	0x3ff00000
 802051c:	00000000 	.word	0x00000000

08020520 <__ieee754_acos>:
 8020520:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020524:	ec55 4b10 	vmov	r4, r5, d0
 8020528:	49b7      	ldr	r1, [pc, #732]	@ (8020808 <__ieee754_acos+0x2e8>)
 802052a:	f025 4300 	bic.w	r3, r5, #2147483648	@ 0x80000000
 802052e:	428b      	cmp	r3, r1
 8020530:	d919      	bls.n	8020566 <__ieee754_acos+0x46>
 8020532:	f103 4340 	add.w	r3, r3, #3221225472	@ 0xc0000000
 8020536:	f503 1380 	add.w	r3, r3, #1048576	@ 0x100000
 802053a:	4323      	orrs	r3, r4
 802053c:	d106      	bne.n	802054c <__ieee754_acos+0x2c>
 802053e:	2d00      	cmp	r5, #0
 8020540:	f340 8210 	ble.w	8020964 <__ieee754_acos+0x444>
 8020544:	ed9f 0b94 	vldr	d0, [pc, #592]	@ 8020798 <__ieee754_acos+0x278>
 8020548:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802054c:	4622      	mov	r2, r4
 802054e:	462b      	mov	r3, r5
 8020550:	4620      	mov	r0, r4
 8020552:	4629      	mov	r1, r5
 8020554:	f7df fea0 	bl	8000298 <__aeabi_dsub>
 8020558:	4602      	mov	r2, r0
 802055a:	460b      	mov	r3, r1
 802055c:	f7e0 f97e 	bl	800085c <__aeabi_ddiv>
 8020560:	ec41 0b10 	vmov	d0, r0, r1
 8020564:	e7f0      	b.n	8020548 <__ieee754_acos+0x28>
 8020566:	49a9      	ldr	r1, [pc, #676]	@ (802080c <__ieee754_acos+0x2ec>)
 8020568:	428b      	cmp	r3, r1
 802056a:	f200 8085 	bhi.w	8020678 <__ieee754_acos+0x158>
 802056e:	4aa8      	ldr	r2, [pc, #672]	@ (8020810 <__ieee754_acos+0x2f0>)
 8020570:	4293      	cmp	r3, r2
 8020572:	f240 81fa 	bls.w	802096a <__ieee754_acos+0x44a>
 8020576:	4622      	mov	r2, r4
 8020578:	462b      	mov	r3, r5
 802057a:	4620      	mov	r0, r4
 802057c:	4629      	mov	r1, r5
 802057e:	f7e0 f843 	bl	8000608 <__aeabi_dmul>
 8020582:	a387      	add	r3, pc, #540	@ (adr r3, 80207a0 <__ieee754_acos+0x280>)
 8020584:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020588:	4606      	mov	r6, r0
 802058a:	460f      	mov	r7, r1
 802058c:	f7e0 f83c 	bl	8000608 <__aeabi_dmul>
 8020590:	a385      	add	r3, pc, #532	@ (adr r3, 80207a8 <__ieee754_acos+0x288>)
 8020592:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020596:	f7df fe81 	bl	800029c <__adddf3>
 802059a:	4632      	mov	r2, r6
 802059c:	463b      	mov	r3, r7
 802059e:	f7e0 f833 	bl	8000608 <__aeabi_dmul>
 80205a2:	a383      	add	r3, pc, #524	@ (adr r3, 80207b0 <__ieee754_acos+0x290>)
 80205a4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80205a8:	f7df fe76 	bl	8000298 <__aeabi_dsub>
 80205ac:	4632      	mov	r2, r6
 80205ae:	463b      	mov	r3, r7
 80205b0:	f7e0 f82a 	bl	8000608 <__aeabi_dmul>
 80205b4:	a380      	add	r3, pc, #512	@ (adr r3, 80207b8 <__ieee754_acos+0x298>)
 80205b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80205ba:	f7df fe6f 	bl	800029c <__adddf3>
 80205be:	4632      	mov	r2, r6
 80205c0:	463b      	mov	r3, r7
 80205c2:	f7e0 f821 	bl	8000608 <__aeabi_dmul>
 80205c6:	a37e      	add	r3, pc, #504	@ (adr r3, 80207c0 <__ieee754_acos+0x2a0>)
 80205c8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80205cc:	f7df fe64 	bl	8000298 <__aeabi_dsub>
 80205d0:	4632      	mov	r2, r6
 80205d2:	463b      	mov	r3, r7
 80205d4:	f7e0 f818 	bl	8000608 <__aeabi_dmul>
 80205d8:	a37b      	add	r3, pc, #492	@ (adr r3, 80207c8 <__ieee754_acos+0x2a8>)
 80205da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80205de:	f7df fe5d 	bl	800029c <__adddf3>
 80205e2:	4632      	mov	r2, r6
 80205e4:	463b      	mov	r3, r7
 80205e6:	f7e0 f80f 	bl	8000608 <__aeabi_dmul>
 80205ea:	a379      	add	r3, pc, #484	@ (adr r3, 80207d0 <__ieee754_acos+0x2b0>)
 80205ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80205f0:	4680      	mov	r8, r0
 80205f2:	4689      	mov	r9, r1
 80205f4:	4630      	mov	r0, r6
 80205f6:	4639      	mov	r1, r7
 80205f8:	f7e0 f806 	bl	8000608 <__aeabi_dmul>
 80205fc:	a376      	add	r3, pc, #472	@ (adr r3, 80207d8 <__ieee754_acos+0x2b8>)
 80205fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020602:	f7df fe49 	bl	8000298 <__aeabi_dsub>
 8020606:	4632      	mov	r2, r6
 8020608:	463b      	mov	r3, r7
 802060a:	f7df fffd 	bl	8000608 <__aeabi_dmul>
 802060e:	a374      	add	r3, pc, #464	@ (adr r3, 80207e0 <__ieee754_acos+0x2c0>)
 8020610:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020614:	f7df fe42 	bl	800029c <__adddf3>
 8020618:	4632      	mov	r2, r6
 802061a:	463b      	mov	r3, r7
 802061c:	f7df fff4 	bl	8000608 <__aeabi_dmul>
 8020620:	a371      	add	r3, pc, #452	@ (adr r3, 80207e8 <__ieee754_acos+0x2c8>)
 8020622:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020626:	f7df fe37 	bl	8000298 <__aeabi_dsub>
 802062a:	4632      	mov	r2, r6
 802062c:	463b      	mov	r3, r7
 802062e:	f7df ffeb 	bl	8000608 <__aeabi_dmul>
 8020632:	4b78      	ldr	r3, [pc, #480]	@ (8020814 <__ieee754_acos+0x2f4>)
 8020634:	2200      	movs	r2, #0
 8020636:	f7df fe31 	bl	800029c <__adddf3>
 802063a:	4602      	mov	r2, r0
 802063c:	460b      	mov	r3, r1
 802063e:	4640      	mov	r0, r8
 8020640:	4649      	mov	r1, r9
 8020642:	f7e0 f90b 	bl	800085c <__aeabi_ddiv>
 8020646:	4622      	mov	r2, r4
 8020648:	462b      	mov	r3, r5
 802064a:	f7df ffdd 	bl	8000608 <__aeabi_dmul>
 802064e:	4602      	mov	r2, r0
 8020650:	460b      	mov	r3, r1
 8020652:	a167      	add	r1, pc, #412	@ (adr r1, 80207f0 <__ieee754_acos+0x2d0>)
 8020654:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020658:	f7df fe1e 	bl	8000298 <__aeabi_dsub>
 802065c:	4602      	mov	r2, r0
 802065e:	460b      	mov	r3, r1
 8020660:	4620      	mov	r0, r4
 8020662:	4629      	mov	r1, r5
 8020664:	f7df fe18 	bl	8000298 <__aeabi_dsub>
 8020668:	4602      	mov	r2, r0
 802066a:	460b      	mov	r3, r1
 802066c:	a162      	add	r1, pc, #392	@ (adr r1, 80207f8 <__ieee754_acos+0x2d8>)
 802066e:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020672:	f7df fe11 	bl	8000298 <__aeabi_dsub>
 8020676:	e773      	b.n	8020560 <__ieee754_acos+0x40>
 8020678:	2d00      	cmp	r5, #0
 802067a:	f280 80cf 	bge.w	802081c <__ieee754_acos+0x2fc>
 802067e:	4b65      	ldr	r3, [pc, #404]	@ (8020814 <__ieee754_acos+0x2f4>)
 8020680:	2200      	movs	r2, #0
 8020682:	4620      	mov	r0, r4
 8020684:	4629      	mov	r1, r5
 8020686:	f7df fe09 	bl	800029c <__adddf3>
 802068a:	4b63      	ldr	r3, [pc, #396]	@ (8020818 <__ieee754_acos+0x2f8>)
 802068c:	2200      	movs	r2, #0
 802068e:	f7df ffbb 	bl	8000608 <__aeabi_dmul>
 8020692:	a343      	add	r3, pc, #268	@ (adr r3, 80207a0 <__ieee754_acos+0x280>)
 8020694:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020698:	4604      	mov	r4, r0
 802069a:	460d      	mov	r5, r1
 802069c:	f7df ffb4 	bl	8000608 <__aeabi_dmul>
 80206a0:	a341      	add	r3, pc, #260	@ (adr r3, 80207a8 <__ieee754_acos+0x288>)
 80206a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206a6:	f7df fdf9 	bl	800029c <__adddf3>
 80206aa:	4622      	mov	r2, r4
 80206ac:	462b      	mov	r3, r5
 80206ae:	f7df ffab 	bl	8000608 <__aeabi_dmul>
 80206b2:	a33f      	add	r3, pc, #252	@ (adr r3, 80207b0 <__ieee754_acos+0x290>)
 80206b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206b8:	f7df fdee 	bl	8000298 <__aeabi_dsub>
 80206bc:	4622      	mov	r2, r4
 80206be:	462b      	mov	r3, r5
 80206c0:	f7df ffa2 	bl	8000608 <__aeabi_dmul>
 80206c4:	a33c      	add	r3, pc, #240	@ (adr r3, 80207b8 <__ieee754_acos+0x298>)
 80206c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206ca:	f7df fde7 	bl	800029c <__adddf3>
 80206ce:	4622      	mov	r2, r4
 80206d0:	462b      	mov	r3, r5
 80206d2:	f7df ff99 	bl	8000608 <__aeabi_dmul>
 80206d6:	a33a      	add	r3, pc, #232	@ (adr r3, 80207c0 <__ieee754_acos+0x2a0>)
 80206d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206dc:	f7df fddc 	bl	8000298 <__aeabi_dsub>
 80206e0:	4622      	mov	r2, r4
 80206e2:	462b      	mov	r3, r5
 80206e4:	f7df ff90 	bl	8000608 <__aeabi_dmul>
 80206e8:	a337      	add	r3, pc, #220	@ (adr r3, 80207c8 <__ieee754_acos+0x2a8>)
 80206ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 80206ee:	f7df fdd5 	bl	800029c <__adddf3>
 80206f2:	4622      	mov	r2, r4
 80206f4:	462b      	mov	r3, r5
 80206f6:	f7df ff87 	bl	8000608 <__aeabi_dmul>
 80206fa:	a335      	add	r3, pc, #212	@ (adr r3, 80207d0 <__ieee754_acos+0x2b0>)
 80206fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020700:	4606      	mov	r6, r0
 8020702:	460f      	mov	r7, r1
 8020704:	4620      	mov	r0, r4
 8020706:	4629      	mov	r1, r5
 8020708:	f7df ff7e 	bl	8000608 <__aeabi_dmul>
 802070c:	a332      	add	r3, pc, #200	@ (adr r3, 80207d8 <__ieee754_acos+0x2b8>)
 802070e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020712:	f7df fdc1 	bl	8000298 <__aeabi_dsub>
 8020716:	4622      	mov	r2, r4
 8020718:	462b      	mov	r3, r5
 802071a:	f7df ff75 	bl	8000608 <__aeabi_dmul>
 802071e:	a330      	add	r3, pc, #192	@ (adr r3, 80207e0 <__ieee754_acos+0x2c0>)
 8020720:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020724:	f7df fdba 	bl	800029c <__adddf3>
 8020728:	4622      	mov	r2, r4
 802072a:	462b      	mov	r3, r5
 802072c:	f7df ff6c 	bl	8000608 <__aeabi_dmul>
 8020730:	a32d      	add	r3, pc, #180	@ (adr r3, 80207e8 <__ieee754_acos+0x2c8>)
 8020732:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020736:	f7df fdaf 	bl	8000298 <__aeabi_dsub>
 802073a:	4622      	mov	r2, r4
 802073c:	462b      	mov	r3, r5
 802073e:	f7df ff63 	bl	8000608 <__aeabi_dmul>
 8020742:	4b34      	ldr	r3, [pc, #208]	@ (8020814 <__ieee754_acos+0x2f4>)
 8020744:	2200      	movs	r2, #0
 8020746:	f7df fda9 	bl	800029c <__adddf3>
 802074a:	ec45 4b10 	vmov	d0, r4, r5
 802074e:	4680      	mov	r8, r0
 8020750:	4689      	mov	r9, r1
 8020752:	f7ff f98b 	bl	801fa6c <__ieee754_sqrt>
 8020756:	ec55 4b10 	vmov	r4, r5, d0
 802075a:	4642      	mov	r2, r8
 802075c:	464b      	mov	r3, r9
 802075e:	4630      	mov	r0, r6
 8020760:	4639      	mov	r1, r7
 8020762:	f7e0 f87b 	bl	800085c <__aeabi_ddiv>
 8020766:	4622      	mov	r2, r4
 8020768:	462b      	mov	r3, r5
 802076a:	f7df ff4d 	bl	8000608 <__aeabi_dmul>
 802076e:	a320      	add	r3, pc, #128	@ (adr r3, 80207f0 <__ieee754_acos+0x2d0>)
 8020770:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020774:	f7df fd90 	bl	8000298 <__aeabi_dsub>
 8020778:	4622      	mov	r2, r4
 802077a:	462b      	mov	r3, r5
 802077c:	f7df fd8e 	bl	800029c <__adddf3>
 8020780:	4602      	mov	r2, r0
 8020782:	460b      	mov	r3, r1
 8020784:	f7df fd8a 	bl	800029c <__adddf3>
 8020788:	4602      	mov	r2, r0
 802078a:	460b      	mov	r3, r1
 802078c:	a11c      	add	r1, pc, #112	@ (adr r1, 8020800 <__ieee754_acos+0x2e0>)
 802078e:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020792:	e76e      	b.n	8020672 <__ieee754_acos+0x152>
 8020794:	f3af 8000 	nop.w
	...
 80207a0:	0dfdf709 	.word	0x0dfdf709
 80207a4:	3f023de1 	.word	0x3f023de1
 80207a8:	7501b288 	.word	0x7501b288
 80207ac:	3f49efe0 	.word	0x3f49efe0
 80207b0:	b5688f3b 	.word	0xb5688f3b
 80207b4:	3fa48228 	.word	0x3fa48228
 80207b8:	0e884455 	.word	0x0e884455
 80207bc:	3fc9c155 	.word	0x3fc9c155
 80207c0:	03eb6f7d 	.word	0x03eb6f7d
 80207c4:	3fd4d612 	.word	0x3fd4d612
 80207c8:	55555555 	.word	0x55555555
 80207cc:	3fc55555 	.word	0x3fc55555
 80207d0:	b12e9282 	.word	0xb12e9282
 80207d4:	3fb3b8c5 	.word	0x3fb3b8c5
 80207d8:	1b8d0159 	.word	0x1b8d0159
 80207dc:	3fe6066c 	.word	0x3fe6066c
 80207e0:	9c598ac8 	.word	0x9c598ac8
 80207e4:	40002ae5 	.word	0x40002ae5
 80207e8:	1c8a2d4b 	.word	0x1c8a2d4b
 80207ec:	40033a27 	.word	0x40033a27
 80207f0:	33145c07 	.word	0x33145c07
 80207f4:	3c91a626 	.word	0x3c91a626
 80207f8:	54442d18 	.word	0x54442d18
 80207fc:	3ff921fb 	.word	0x3ff921fb
 8020800:	54442d18 	.word	0x54442d18
 8020804:	400921fb 	.word	0x400921fb
 8020808:	3fefffff 	.word	0x3fefffff
 802080c:	3fdfffff 	.word	0x3fdfffff
 8020810:	3c600000 	.word	0x3c600000
 8020814:	3ff00000 	.word	0x3ff00000
 8020818:	3fe00000 	.word	0x3fe00000
 802081c:	4622      	mov	r2, r4
 802081e:	462b      	mov	r3, r5
 8020820:	496b      	ldr	r1, [pc, #428]	@ (80209d0 <__ieee754_acos+0x4b0>)
 8020822:	2000      	movs	r0, #0
 8020824:	f7df fd38 	bl	8000298 <__aeabi_dsub>
 8020828:	4b6a      	ldr	r3, [pc, #424]	@ (80209d4 <__ieee754_acos+0x4b4>)
 802082a:	2200      	movs	r2, #0
 802082c:	f7df feec 	bl	8000608 <__aeabi_dmul>
 8020830:	4604      	mov	r4, r0
 8020832:	460d      	mov	r5, r1
 8020834:	ec45 4b10 	vmov	d0, r4, r5
 8020838:	f7ff f918 	bl	801fa6c <__ieee754_sqrt>
 802083c:	a34c      	add	r3, pc, #304	@ (adr r3, 8020970 <__ieee754_acos+0x450>)
 802083e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020842:	4620      	mov	r0, r4
 8020844:	4629      	mov	r1, r5
 8020846:	ec59 8b10 	vmov	r8, r9, d0
 802084a:	f7df fedd 	bl	8000608 <__aeabi_dmul>
 802084e:	a34a      	add	r3, pc, #296	@ (adr r3, 8020978 <__ieee754_acos+0x458>)
 8020850:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020854:	f7df fd22 	bl	800029c <__adddf3>
 8020858:	4622      	mov	r2, r4
 802085a:	462b      	mov	r3, r5
 802085c:	f7df fed4 	bl	8000608 <__aeabi_dmul>
 8020860:	a347      	add	r3, pc, #284	@ (adr r3, 8020980 <__ieee754_acos+0x460>)
 8020862:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020866:	f7df fd17 	bl	8000298 <__aeabi_dsub>
 802086a:	4622      	mov	r2, r4
 802086c:	462b      	mov	r3, r5
 802086e:	f7df fecb 	bl	8000608 <__aeabi_dmul>
 8020872:	a345      	add	r3, pc, #276	@ (adr r3, 8020988 <__ieee754_acos+0x468>)
 8020874:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020878:	f7df fd10 	bl	800029c <__adddf3>
 802087c:	4622      	mov	r2, r4
 802087e:	462b      	mov	r3, r5
 8020880:	f7df fec2 	bl	8000608 <__aeabi_dmul>
 8020884:	a342      	add	r3, pc, #264	@ (adr r3, 8020990 <__ieee754_acos+0x470>)
 8020886:	e9d3 2300 	ldrd	r2, r3, [r3]
 802088a:	f7df fd05 	bl	8000298 <__aeabi_dsub>
 802088e:	4622      	mov	r2, r4
 8020890:	462b      	mov	r3, r5
 8020892:	f7df feb9 	bl	8000608 <__aeabi_dmul>
 8020896:	a340      	add	r3, pc, #256	@ (adr r3, 8020998 <__ieee754_acos+0x478>)
 8020898:	e9d3 2300 	ldrd	r2, r3, [r3]
 802089c:	f7df fcfe 	bl	800029c <__adddf3>
 80208a0:	4622      	mov	r2, r4
 80208a2:	462b      	mov	r3, r5
 80208a4:	f7df feb0 	bl	8000608 <__aeabi_dmul>
 80208a8:	a33d      	add	r3, pc, #244	@ (adr r3, 80209a0 <__ieee754_acos+0x480>)
 80208aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80208ae:	4682      	mov	sl, r0
 80208b0:	468b      	mov	fp, r1
 80208b2:	4620      	mov	r0, r4
 80208b4:	4629      	mov	r1, r5
 80208b6:	f7df fea7 	bl	8000608 <__aeabi_dmul>
 80208ba:	a33b      	add	r3, pc, #236	@ (adr r3, 80209a8 <__ieee754_acos+0x488>)
 80208bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80208c0:	f7df fcea 	bl	8000298 <__aeabi_dsub>
 80208c4:	4622      	mov	r2, r4
 80208c6:	462b      	mov	r3, r5
 80208c8:	f7df fe9e 	bl	8000608 <__aeabi_dmul>
 80208cc:	a338      	add	r3, pc, #224	@ (adr r3, 80209b0 <__ieee754_acos+0x490>)
 80208ce:	e9d3 2300 	ldrd	r2, r3, [r3]
 80208d2:	f7df fce3 	bl	800029c <__adddf3>
 80208d6:	4622      	mov	r2, r4
 80208d8:	462b      	mov	r3, r5
 80208da:	f7df fe95 	bl	8000608 <__aeabi_dmul>
 80208de:	a336      	add	r3, pc, #216	@ (adr r3, 80209b8 <__ieee754_acos+0x498>)
 80208e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80208e4:	f7df fcd8 	bl	8000298 <__aeabi_dsub>
 80208e8:	4622      	mov	r2, r4
 80208ea:	462b      	mov	r3, r5
 80208ec:	f7df fe8c 	bl	8000608 <__aeabi_dmul>
 80208f0:	4b37      	ldr	r3, [pc, #220]	@ (80209d0 <__ieee754_acos+0x4b0>)
 80208f2:	2200      	movs	r2, #0
 80208f4:	f7df fcd2 	bl	800029c <__adddf3>
 80208f8:	4602      	mov	r2, r0
 80208fa:	460b      	mov	r3, r1
 80208fc:	4650      	mov	r0, sl
 80208fe:	4659      	mov	r1, fp
 8020900:	f7df ffac 	bl	800085c <__aeabi_ddiv>
 8020904:	4642      	mov	r2, r8
 8020906:	464b      	mov	r3, r9
 8020908:	f7df fe7e 	bl	8000608 <__aeabi_dmul>
 802090c:	2600      	movs	r6, #0
 802090e:	4682      	mov	sl, r0
 8020910:	468b      	mov	fp, r1
 8020912:	4632      	mov	r2, r6
 8020914:	464b      	mov	r3, r9
 8020916:	4630      	mov	r0, r6
 8020918:	4649      	mov	r1, r9
 802091a:	f7df fe75 	bl	8000608 <__aeabi_dmul>
 802091e:	4602      	mov	r2, r0
 8020920:	460b      	mov	r3, r1
 8020922:	4620      	mov	r0, r4
 8020924:	4629      	mov	r1, r5
 8020926:	f7df fcb7 	bl	8000298 <__aeabi_dsub>
 802092a:	4632      	mov	r2, r6
 802092c:	4604      	mov	r4, r0
 802092e:	460d      	mov	r5, r1
 8020930:	464b      	mov	r3, r9
 8020932:	4640      	mov	r0, r8
 8020934:	4649      	mov	r1, r9
 8020936:	f7df fcb1 	bl	800029c <__adddf3>
 802093a:	4602      	mov	r2, r0
 802093c:	460b      	mov	r3, r1
 802093e:	4620      	mov	r0, r4
 8020940:	4629      	mov	r1, r5
 8020942:	f7df ff8b 	bl	800085c <__aeabi_ddiv>
 8020946:	4602      	mov	r2, r0
 8020948:	460b      	mov	r3, r1
 802094a:	4650      	mov	r0, sl
 802094c:	4659      	mov	r1, fp
 802094e:	f7df fca5 	bl	800029c <__adddf3>
 8020952:	4632      	mov	r2, r6
 8020954:	464b      	mov	r3, r9
 8020956:	f7df fca1 	bl	800029c <__adddf3>
 802095a:	4602      	mov	r2, r0
 802095c:	460b      	mov	r3, r1
 802095e:	f7df fc9d 	bl	800029c <__adddf3>
 8020962:	e5fd      	b.n	8020560 <__ieee754_acos+0x40>
 8020964:	ed9f 0b16 	vldr	d0, [pc, #88]	@ 80209c0 <__ieee754_acos+0x4a0>
 8020968:	e5ee      	b.n	8020548 <__ieee754_acos+0x28>
 802096a:	ed9f 0b17 	vldr	d0, [pc, #92]	@ 80209c8 <__ieee754_acos+0x4a8>
 802096e:	e5eb      	b.n	8020548 <__ieee754_acos+0x28>
 8020970:	0dfdf709 	.word	0x0dfdf709
 8020974:	3f023de1 	.word	0x3f023de1
 8020978:	7501b288 	.word	0x7501b288
 802097c:	3f49efe0 	.word	0x3f49efe0
 8020980:	b5688f3b 	.word	0xb5688f3b
 8020984:	3fa48228 	.word	0x3fa48228
 8020988:	0e884455 	.word	0x0e884455
 802098c:	3fc9c155 	.word	0x3fc9c155
 8020990:	03eb6f7d 	.word	0x03eb6f7d
 8020994:	3fd4d612 	.word	0x3fd4d612
 8020998:	55555555 	.word	0x55555555
 802099c:	3fc55555 	.word	0x3fc55555
 80209a0:	b12e9282 	.word	0xb12e9282
 80209a4:	3fb3b8c5 	.word	0x3fb3b8c5
 80209a8:	1b8d0159 	.word	0x1b8d0159
 80209ac:	3fe6066c 	.word	0x3fe6066c
 80209b0:	9c598ac8 	.word	0x9c598ac8
 80209b4:	40002ae5 	.word	0x40002ae5
 80209b8:	1c8a2d4b 	.word	0x1c8a2d4b
 80209bc:	40033a27 	.word	0x40033a27
 80209c0:	54442d18 	.word	0x54442d18
 80209c4:	400921fb 	.word	0x400921fb
 80209c8:	54442d18 	.word	0x54442d18
 80209cc:	3ff921fb 	.word	0x3ff921fb
 80209d0:	3ff00000 	.word	0x3ff00000
 80209d4:	3fe00000 	.word	0x3fe00000

080209d8 <__ieee754_asin>:
 80209d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80209dc:	ec55 4b10 	vmov	r4, r5, d0
 80209e0:	4bc7      	ldr	r3, [pc, #796]	@ (8020d00 <__ieee754_asin+0x328>)
 80209e2:	b087      	sub	sp, #28
 80209e4:	f025 4600 	bic.w	r6, r5, #2147483648	@ 0x80000000
 80209e8:	429e      	cmp	r6, r3
 80209ea:	9501      	str	r5, [sp, #4]
 80209ec:	d92d      	bls.n	8020a4a <__ieee754_asin+0x72>
 80209ee:	f106 4640 	add.w	r6, r6, #3221225472	@ 0xc0000000
 80209f2:	f506 1680 	add.w	r6, r6, #1048576	@ 0x100000
 80209f6:	4326      	orrs	r6, r4
 80209f8:	d116      	bne.n	8020a28 <__ieee754_asin+0x50>
 80209fa:	a3a7      	add	r3, pc, #668	@ (adr r3, 8020c98 <__ieee754_asin+0x2c0>)
 80209fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020a00:	4620      	mov	r0, r4
 8020a02:	4629      	mov	r1, r5
 8020a04:	f7df fe00 	bl	8000608 <__aeabi_dmul>
 8020a08:	a3a5      	add	r3, pc, #660	@ (adr r3, 8020ca0 <__ieee754_asin+0x2c8>)
 8020a0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020a0e:	4606      	mov	r6, r0
 8020a10:	460f      	mov	r7, r1
 8020a12:	4620      	mov	r0, r4
 8020a14:	4629      	mov	r1, r5
 8020a16:	f7df fdf7 	bl	8000608 <__aeabi_dmul>
 8020a1a:	4602      	mov	r2, r0
 8020a1c:	460b      	mov	r3, r1
 8020a1e:	4630      	mov	r0, r6
 8020a20:	4639      	mov	r1, r7
 8020a22:	f7df fc3b 	bl	800029c <__adddf3>
 8020a26:	e009      	b.n	8020a3c <__ieee754_asin+0x64>
 8020a28:	4622      	mov	r2, r4
 8020a2a:	462b      	mov	r3, r5
 8020a2c:	4620      	mov	r0, r4
 8020a2e:	4629      	mov	r1, r5
 8020a30:	f7df fc32 	bl	8000298 <__aeabi_dsub>
 8020a34:	4602      	mov	r2, r0
 8020a36:	460b      	mov	r3, r1
 8020a38:	f7df ff10 	bl	800085c <__aeabi_ddiv>
 8020a3c:	4604      	mov	r4, r0
 8020a3e:	460d      	mov	r5, r1
 8020a40:	ec45 4b10 	vmov	d0, r4, r5
 8020a44:	b007      	add	sp, #28
 8020a46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020a4a:	4bae      	ldr	r3, [pc, #696]	@ (8020d04 <__ieee754_asin+0x32c>)
 8020a4c:	429e      	cmp	r6, r3
 8020a4e:	d810      	bhi.n	8020a72 <__ieee754_asin+0x9a>
 8020a50:	f1b6 5f79 	cmp.w	r6, #1044381696	@ 0x3e400000
 8020a54:	f080 80ad 	bcs.w	8020bb2 <__ieee754_asin+0x1da>
 8020a58:	a393      	add	r3, pc, #588	@ (adr r3, 8020ca8 <__ieee754_asin+0x2d0>)
 8020a5a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020a5e:	4620      	mov	r0, r4
 8020a60:	4629      	mov	r1, r5
 8020a62:	f7df fc1b 	bl	800029c <__adddf3>
 8020a66:	4ba8      	ldr	r3, [pc, #672]	@ (8020d08 <__ieee754_asin+0x330>)
 8020a68:	2200      	movs	r2, #0
 8020a6a:	f7e0 f85d 	bl	8000b28 <__aeabi_dcmpgt>
 8020a6e:	2800      	cmp	r0, #0
 8020a70:	d1e6      	bne.n	8020a40 <__ieee754_asin+0x68>
 8020a72:	ec45 4b10 	vmov	d0, r4, r5
 8020a76:	f7fe fe63 	bl	801f740 <fabs>
 8020a7a:	49a3      	ldr	r1, [pc, #652]	@ (8020d08 <__ieee754_asin+0x330>)
 8020a7c:	ec53 2b10 	vmov	r2, r3, d0
 8020a80:	2000      	movs	r0, #0
 8020a82:	f7df fc09 	bl	8000298 <__aeabi_dsub>
 8020a86:	4ba1      	ldr	r3, [pc, #644]	@ (8020d0c <__ieee754_asin+0x334>)
 8020a88:	2200      	movs	r2, #0
 8020a8a:	f7df fdbd 	bl	8000608 <__aeabi_dmul>
 8020a8e:	a388      	add	r3, pc, #544	@ (adr r3, 8020cb0 <__ieee754_asin+0x2d8>)
 8020a90:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020a94:	4604      	mov	r4, r0
 8020a96:	460d      	mov	r5, r1
 8020a98:	f7df fdb6 	bl	8000608 <__aeabi_dmul>
 8020a9c:	a386      	add	r3, pc, #536	@ (adr r3, 8020cb8 <__ieee754_asin+0x2e0>)
 8020a9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020aa2:	f7df fbfb 	bl	800029c <__adddf3>
 8020aa6:	4622      	mov	r2, r4
 8020aa8:	462b      	mov	r3, r5
 8020aaa:	f7df fdad 	bl	8000608 <__aeabi_dmul>
 8020aae:	a384      	add	r3, pc, #528	@ (adr r3, 8020cc0 <__ieee754_asin+0x2e8>)
 8020ab0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020ab4:	f7df fbf0 	bl	8000298 <__aeabi_dsub>
 8020ab8:	4622      	mov	r2, r4
 8020aba:	462b      	mov	r3, r5
 8020abc:	f7df fda4 	bl	8000608 <__aeabi_dmul>
 8020ac0:	a381      	add	r3, pc, #516	@ (adr r3, 8020cc8 <__ieee754_asin+0x2f0>)
 8020ac2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020ac6:	f7df fbe9 	bl	800029c <__adddf3>
 8020aca:	4622      	mov	r2, r4
 8020acc:	462b      	mov	r3, r5
 8020ace:	f7df fd9b 	bl	8000608 <__aeabi_dmul>
 8020ad2:	a37f      	add	r3, pc, #508	@ (adr r3, 8020cd0 <__ieee754_asin+0x2f8>)
 8020ad4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020ad8:	f7df fbde 	bl	8000298 <__aeabi_dsub>
 8020adc:	4622      	mov	r2, r4
 8020ade:	462b      	mov	r3, r5
 8020ae0:	f7df fd92 	bl	8000608 <__aeabi_dmul>
 8020ae4:	a37c      	add	r3, pc, #496	@ (adr r3, 8020cd8 <__ieee754_asin+0x300>)
 8020ae6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020aea:	f7df fbd7 	bl	800029c <__adddf3>
 8020aee:	4622      	mov	r2, r4
 8020af0:	462b      	mov	r3, r5
 8020af2:	f7df fd89 	bl	8000608 <__aeabi_dmul>
 8020af6:	a37a      	add	r3, pc, #488	@ (adr r3, 8020ce0 <__ieee754_asin+0x308>)
 8020af8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020afc:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8020b00:	4620      	mov	r0, r4
 8020b02:	4629      	mov	r1, r5
 8020b04:	f7df fd80 	bl	8000608 <__aeabi_dmul>
 8020b08:	a377      	add	r3, pc, #476	@ (adr r3, 8020ce8 <__ieee754_asin+0x310>)
 8020b0a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020b0e:	f7df fbc3 	bl	8000298 <__aeabi_dsub>
 8020b12:	4622      	mov	r2, r4
 8020b14:	462b      	mov	r3, r5
 8020b16:	f7df fd77 	bl	8000608 <__aeabi_dmul>
 8020b1a:	a375      	add	r3, pc, #468	@ (adr r3, 8020cf0 <__ieee754_asin+0x318>)
 8020b1c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020b20:	f7df fbbc 	bl	800029c <__adddf3>
 8020b24:	4622      	mov	r2, r4
 8020b26:	462b      	mov	r3, r5
 8020b28:	f7df fd6e 	bl	8000608 <__aeabi_dmul>
 8020b2c:	a372      	add	r3, pc, #456	@ (adr r3, 8020cf8 <__ieee754_asin+0x320>)
 8020b2e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020b32:	f7df fbb1 	bl	8000298 <__aeabi_dsub>
 8020b36:	4622      	mov	r2, r4
 8020b38:	462b      	mov	r3, r5
 8020b3a:	f7df fd65 	bl	8000608 <__aeabi_dmul>
 8020b3e:	4b72      	ldr	r3, [pc, #456]	@ (8020d08 <__ieee754_asin+0x330>)
 8020b40:	2200      	movs	r2, #0
 8020b42:	f7df fbab 	bl	800029c <__adddf3>
 8020b46:	ec45 4b10 	vmov	d0, r4, r5
 8020b4a:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8020b4e:	f7fe ff8d 	bl	801fa6c <__ieee754_sqrt>
 8020b52:	4b6f      	ldr	r3, [pc, #444]	@ (8020d10 <__ieee754_asin+0x338>)
 8020b54:	429e      	cmp	r6, r3
 8020b56:	ec5b ab10 	vmov	sl, fp, d0
 8020b5a:	f240 80db 	bls.w	8020d14 <__ieee754_asin+0x33c>
 8020b5e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8020b62:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020b66:	f7df fe79 	bl	800085c <__aeabi_ddiv>
 8020b6a:	4652      	mov	r2, sl
 8020b6c:	465b      	mov	r3, fp
 8020b6e:	f7df fd4b 	bl	8000608 <__aeabi_dmul>
 8020b72:	4652      	mov	r2, sl
 8020b74:	465b      	mov	r3, fp
 8020b76:	f7df fb91 	bl	800029c <__adddf3>
 8020b7a:	4602      	mov	r2, r0
 8020b7c:	460b      	mov	r3, r1
 8020b7e:	f7df fb8d 	bl	800029c <__adddf3>
 8020b82:	a347      	add	r3, pc, #284	@ (adr r3, 8020ca0 <__ieee754_asin+0x2c8>)
 8020b84:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020b88:	f7df fb86 	bl	8000298 <__aeabi_dsub>
 8020b8c:	4602      	mov	r2, r0
 8020b8e:	460b      	mov	r3, r1
 8020b90:	a141      	add	r1, pc, #260	@ (adr r1, 8020c98 <__ieee754_asin+0x2c0>)
 8020b92:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020b96:	f7df fb7f 	bl	8000298 <__aeabi_dsub>
 8020b9a:	9b01      	ldr	r3, [sp, #4]
 8020b9c:	2b00      	cmp	r3, #0
 8020b9e:	bfdc      	itt	le
 8020ba0:	4602      	movle	r2, r0
 8020ba2:	f101 4300 	addle.w	r3, r1, #2147483648	@ 0x80000000
 8020ba6:	4604      	mov	r4, r0
 8020ba8:	460d      	mov	r5, r1
 8020baa:	bfdc      	itt	le
 8020bac:	4614      	movle	r4, r2
 8020bae:	461d      	movle	r5, r3
 8020bb0:	e746      	b.n	8020a40 <__ieee754_asin+0x68>
 8020bb2:	4622      	mov	r2, r4
 8020bb4:	462b      	mov	r3, r5
 8020bb6:	4620      	mov	r0, r4
 8020bb8:	4629      	mov	r1, r5
 8020bba:	f7df fd25 	bl	8000608 <__aeabi_dmul>
 8020bbe:	a33c      	add	r3, pc, #240	@ (adr r3, 8020cb0 <__ieee754_asin+0x2d8>)
 8020bc0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020bc4:	4606      	mov	r6, r0
 8020bc6:	460f      	mov	r7, r1
 8020bc8:	f7df fd1e 	bl	8000608 <__aeabi_dmul>
 8020bcc:	a33a      	add	r3, pc, #232	@ (adr r3, 8020cb8 <__ieee754_asin+0x2e0>)
 8020bce:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020bd2:	f7df fb63 	bl	800029c <__adddf3>
 8020bd6:	4632      	mov	r2, r6
 8020bd8:	463b      	mov	r3, r7
 8020bda:	f7df fd15 	bl	8000608 <__aeabi_dmul>
 8020bde:	a338      	add	r3, pc, #224	@ (adr r3, 8020cc0 <__ieee754_asin+0x2e8>)
 8020be0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020be4:	f7df fb58 	bl	8000298 <__aeabi_dsub>
 8020be8:	4632      	mov	r2, r6
 8020bea:	463b      	mov	r3, r7
 8020bec:	f7df fd0c 	bl	8000608 <__aeabi_dmul>
 8020bf0:	a335      	add	r3, pc, #212	@ (adr r3, 8020cc8 <__ieee754_asin+0x2f0>)
 8020bf2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020bf6:	f7df fb51 	bl	800029c <__adddf3>
 8020bfa:	4632      	mov	r2, r6
 8020bfc:	463b      	mov	r3, r7
 8020bfe:	f7df fd03 	bl	8000608 <__aeabi_dmul>
 8020c02:	a333      	add	r3, pc, #204	@ (adr r3, 8020cd0 <__ieee754_asin+0x2f8>)
 8020c04:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020c08:	f7df fb46 	bl	8000298 <__aeabi_dsub>
 8020c0c:	4632      	mov	r2, r6
 8020c0e:	463b      	mov	r3, r7
 8020c10:	f7df fcfa 	bl	8000608 <__aeabi_dmul>
 8020c14:	a330      	add	r3, pc, #192	@ (adr r3, 8020cd8 <__ieee754_asin+0x300>)
 8020c16:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020c1a:	f7df fb3f 	bl	800029c <__adddf3>
 8020c1e:	4632      	mov	r2, r6
 8020c20:	463b      	mov	r3, r7
 8020c22:	f7df fcf1 	bl	8000608 <__aeabi_dmul>
 8020c26:	a32e      	add	r3, pc, #184	@ (adr r3, 8020ce0 <__ieee754_asin+0x308>)
 8020c28:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020c2c:	4680      	mov	r8, r0
 8020c2e:	4689      	mov	r9, r1
 8020c30:	4630      	mov	r0, r6
 8020c32:	4639      	mov	r1, r7
 8020c34:	f7df fce8 	bl	8000608 <__aeabi_dmul>
 8020c38:	a32b      	add	r3, pc, #172	@ (adr r3, 8020ce8 <__ieee754_asin+0x310>)
 8020c3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020c3e:	f7df fb2b 	bl	8000298 <__aeabi_dsub>
 8020c42:	4632      	mov	r2, r6
 8020c44:	463b      	mov	r3, r7
 8020c46:	f7df fcdf 	bl	8000608 <__aeabi_dmul>
 8020c4a:	a329      	add	r3, pc, #164	@ (adr r3, 8020cf0 <__ieee754_asin+0x318>)
 8020c4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020c50:	f7df fb24 	bl	800029c <__adddf3>
 8020c54:	4632      	mov	r2, r6
 8020c56:	463b      	mov	r3, r7
 8020c58:	f7df fcd6 	bl	8000608 <__aeabi_dmul>
 8020c5c:	a326      	add	r3, pc, #152	@ (adr r3, 8020cf8 <__ieee754_asin+0x320>)
 8020c5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020c62:	f7df fb19 	bl	8000298 <__aeabi_dsub>
 8020c66:	4632      	mov	r2, r6
 8020c68:	463b      	mov	r3, r7
 8020c6a:	f7df fccd 	bl	8000608 <__aeabi_dmul>
 8020c6e:	4b26      	ldr	r3, [pc, #152]	@ (8020d08 <__ieee754_asin+0x330>)
 8020c70:	2200      	movs	r2, #0
 8020c72:	f7df fb13 	bl	800029c <__adddf3>
 8020c76:	4602      	mov	r2, r0
 8020c78:	460b      	mov	r3, r1
 8020c7a:	4640      	mov	r0, r8
 8020c7c:	4649      	mov	r1, r9
 8020c7e:	f7df fded 	bl	800085c <__aeabi_ddiv>
 8020c82:	4622      	mov	r2, r4
 8020c84:	462b      	mov	r3, r5
 8020c86:	f7df fcbf 	bl	8000608 <__aeabi_dmul>
 8020c8a:	4602      	mov	r2, r0
 8020c8c:	460b      	mov	r3, r1
 8020c8e:	4620      	mov	r0, r4
 8020c90:	4629      	mov	r1, r5
 8020c92:	e6c6      	b.n	8020a22 <__ieee754_asin+0x4a>
 8020c94:	f3af 8000 	nop.w
 8020c98:	54442d18 	.word	0x54442d18
 8020c9c:	3ff921fb 	.word	0x3ff921fb
 8020ca0:	33145c07 	.word	0x33145c07
 8020ca4:	3c91a626 	.word	0x3c91a626
 8020ca8:	8800759c 	.word	0x8800759c
 8020cac:	7e37e43c 	.word	0x7e37e43c
 8020cb0:	0dfdf709 	.word	0x0dfdf709
 8020cb4:	3f023de1 	.word	0x3f023de1
 8020cb8:	7501b288 	.word	0x7501b288
 8020cbc:	3f49efe0 	.word	0x3f49efe0
 8020cc0:	b5688f3b 	.word	0xb5688f3b
 8020cc4:	3fa48228 	.word	0x3fa48228
 8020cc8:	0e884455 	.word	0x0e884455
 8020ccc:	3fc9c155 	.word	0x3fc9c155
 8020cd0:	03eb6f7d 	.word	0x03eb6f7d
 8020cd4:	3fd4d612 	.word	0x3fd4d612
 8020cd8:	55555555 	.word	0x55555555
 8020cdc:	3fc55555 	.word	0x3fc55555
 8020ce0:	b12e9282 	.word	0xb12e9282
 8020ce4:	3fb3b8c5 	.word	0x3fb3b8c5
 8020ce8:	1b8d0159 	.word	0x1b8d0159
 8020cec:	3fe6066c 	.word	0x3fe6066c
 8020cf0:	9c598ac8 	.word	0x9c598ac8
 8020cf4:	40002ae5 	.word	0x40002ae5
 8020cf8:	1c8a2d4b 	.word	0x1c8a2d4b
 8020cfc:	40033a27 	.word	0x40033a27
 8020d00:	3fefffff 	.word	0x3fefffff
 8020d04:	3fdfffff 	.word	0x3fdfffff
 8020d08:	3ff00000 	.word	0x3ff00000
 8020d0c:	3fe00000 	.word	0x3fe00000
 8020d10:	3fef3332 	.word	0x3fef3332
 8020d14:	4652      	mov	r2, sl
 8020d16:	465b      	mov	r3, fp
 8020d18:	4650      	mov	r0, sl
 8020d1a:	4659      	mov	r1, fp
 8020d1c:	f7df fabe 	bl	800029c <__adddf3>
 8020d20:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8020d24:	4606      	mov	r6, r0
 8020d26:	460f      	mov	r7, r1
 8020d28:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8020d2c:	f7df fd96 	bl	800085c <__aeabi_ddiv>
 8020d30:	4602      	mov	r2, r0
 8020d32:	460b      	mov	r3, r1
 8020d34:	4630      	mov	r0, r6
 8020d36:	4639      	mov	r1, r7
 8020d38:	f7df fc66 	bl	8000608 <__aeabi_dmul>
 8020d3c:	f04f 0800 	mov.w	r8, #0
 8020d40:	4606      	mov	r6, r0
 8020d42:	460f      	mov	r7, r1
 8020d44:	4642      	mov	r2, r8
 8020d46:	465b      	mov	r3, fp
 8020d48:	4640      	mov	r0, r8
 8020d4a:	4659      	mov	r1, fp
 8020d4c:	f7df fc5c 	bl	8000608 <__aeabi_dmul>
 8020d50:	4602      	mov	r2, r0
 8020d52:	460b      	mov	r3, r1
 8020d54:	4620      	mov	r0, r4
 8020d56:	4629      	mov	r1, r5
 8020d58:	f7df fa9e 	bl	8000298 <__aeabi_dsub>
 8020d5c:	4642      	mov	r2, r8
 8020d5e:	4604      	mov	r4, r0
 8020d60:	460d      	mov	r5, r1
 8020d62:	465b      	mov	r3, fp
 8020d64:	4650      	mov	r0, sl
 8020d66:	4659      	mov	r1, fp
 8020d68:	f7df fa98 	bl	800029c <__adddf3>
 8020d6c:	4602      	mov	r2, r0
 8020d6e:	460b      	mov	r3, r1
 8020d70:	4620      	mov	r0, r4
 8020d72:	4629      	mov	r1, r5
 8020d74:	f7df fd72 	bl	800085c <__aeabi_ddiv>
 8020d78:	4602      	mov	r2, r0
 8020d7a:	460b      	mov	r3, r1
 8020d7c:	f7df fa8e 	bl	800029c <__adddf3>
 8020d80:	4602      	mov	r2, r0
 8020d82:	460b      	mov	r3, r1
 8020d84:	a112      	add	r1, pc, #72	@ (adr r1, 8020dd0 <__ieee754_asin+0x3f8>)
 8020d86:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020d8a:	f7df fa85 	bl	8000298 <__aeabi_dsub>
 8020d8e:	4602      	mov	r2, r0
 8020d90:	460b      	mov	r3, r1
 8020d92:	4630      	mov	r0, r6
 8020d94:	4639      	mov	r1, r7
 8020d96:	f7df fa7f 	bl	8000298 <__aeabi_dsub>
 8020d9a:	4642      	mov	r2, r8
 8020d9c:	4604      	mov	r4, r0
 8020d9e:	460d      	mov	r5, r1
 8020da0:	465b      	mov	r3, fp
 8020da2:	4640      	mov	r0, r8
 8020da4:	4659      	mov	r1, fp
 8020da6:	f7df fa79 	bl	800029c <__adddf3>
 8020daa:	4602      	mov	r2, r0
 8020dac:	460b      	mov	r3, r1
 8020dae:	a10a      	add	r1, pc, #40	@ (adr r1, 8020dd8 <__ieee754_asin+0x400>)
 8020db0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020db4:	f7df fa70 	bl	8000298 <__aeabi_dsub>
 8020db8:	4602      	mov	r2, r0
 8020dba:	460b      	mov	r3, r1
 8020dbc:	4620      	mov	r0, r4
 8020dbe:	4629      	mov	r1, r5
 8020dc0:	f7df fa6a 	bl	8000298 <__aeabi_dsub>
 8020dc4:	4602      	mov	r2, r0
 8020dc6:	460b      	mov	r3, r1
 8020dc8:	a103      	add	r1, pc, #12	@ (adr r1, 8020dd8 <__ieee754_asin+0x400>)
 8020dca:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020dce:	e6e2      	b.n	8020b96 <__ieee754_asin+0x1be>
 8020dd0:	33145c07 	.word	0x33145c07
 8020dd4:	3c91a626 	.word	0x3c91a626
 8020dd8:	54442d18 	.word	0x54442d18
 8020ddc:	3fe921fb 	.word	0x3fe921fb

08020de0 <__ieee754_atan2>:
 8020de0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8020de4:	ec57 6b11 	vmov	r6, r7, d1
 8020de8:	4273      	negs	r3, r6
 8020dea:	f8df 817c 	ldr.w	r8, [pc, #380]	@ 8020f68 <__ieee754_atan2+0x188>
 8020dee:	f027 4200 	bic.w	r2, r7, #2147483648	@ 0x80000000
 8020df2:	4333      	orrs	r3, r6
 8020df4:	ea42 73d3 	orr.w	r3, r2, r3, lsr #31
 8020df8:	4543      	cmp	r3, r8
 8020dfa:	ec51 0b10 	vmov	r0, r1, d0
 8020dfe:	4635      	mov	r5, r6
 8020e00:	d809      	bhi.n	8020e16 <__ieee754_atan2+0x36>
 8020e02:	4244      	negs	r4, r0
 8020e04:	f021 4300 	bic.w	r3, r1, #2147483648	@ 0x80000000
 8020e08:	4304      	orrs	r4, r0
 8020e0a:	ea43 74d4 	orr.w	r4, r3, r4, lsr #31
 8020e0e:	4544      	cmp	r4, r8
 8020e10:	468e      	mov	lr, r1
 8020e12:	4681      	mov	r9, r0
 8020e14:	d907      	bls.n	8020e26 <__ieee754_atan2+0x46>
 8020e16:	4632      	mov	r2, r6
 8020e18:	463b      	mov	r3, r7
 8020e1a:	f7df fa3f 	bl	800029c <__adddf3>
 8020e1e:	ec41 0b10 	vmov	d0, r0, r1
 8020e22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8020e26:	f107 4440 	add.w	r4, r7, #3221225472	@ 0xc0000000
 8020e2a:	f504 1480 	add.w	r4, r4, #1048576	@ 0x100000
 8020e2e:	4334      	orrs	r4, r6
 8020e30:	d103      	bne.n	8020e3a <__ieee754_atan2+0x5a>
 8020e32:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8020e36:	f000 bfdb 	b.w	8021df0 <atan>
 8020e3a:	17bc      	asrs	r4, r7, #30
 8020e3c:	f004 0402 	and.w	r4, r4, #2
 8020e40:	ea53 0909 	orrs.w	r9, r3, r9
 8020e44:	ea44 74d1 	orr.w	r4, r4, r1, lsr #31
 8020e48:	d107      	bne.n	8020e5a <__ieee754_atan2+0x7a>
 8020e4a:	2c02      	cmp	r4, #2
 8020e4c:	d05f      	beq.n	8020f0e <__ieee754_atan2+0x12e>
 8020e4e:	2c03      	cmp	r4, #3
 8020e50:	d1e5      	bne.n	8020e1e <__ieee754_atan2+0x3e>
 8020e52:	a141      	add	r1, pc, #260	@ (adr r1, 8020f58 <__ieee754_atan2+0x178>)
 8020e54:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020e58:	e7e1      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020e5a:	4315      	orrs	r5, r2
 8020e5c:	d106      	bne.n	8020e6c <__ieee754_atan2+0x8c>
 8020e5e:	f1be 0f00 	cmp.w	lr, #0
 8020e62:	da5f      	bge.n	8020f24 <__ieee754_atan2+0x144>
 8020e64:	a13e      	add	r1, pc, #248	@ (adr r1, 8020f60 <__ieee754_atan2+0x180>)
 8020e66:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020e6a:	e7d8      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020e6c:	4542      	cmp	r2, r8
 8020e6e:	d10f      	bne.n	8020e90 <__ieee754_atan2+0xb0>
 8020e70:	4293      	cmp	r3, r2
 8020e72:	f104 34ff 	add.w	r4, r4, #4294967295	@ 0xffffffff
 8020e76:	d107      	bne.n	8020e88 <__ieee754_atan2+0xa8>
 8020e78:	2c02      	cmp	r4, #2
 8020e7a:	d84c      	bhi.n	8020f16 <__ieee754_atan2+0x136>
 8020e7c:	4b34      	ldr	r3, [pc, #208]	@ (8020f50 <__ieee754_atan2+0x170>)
 8020e7e:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8020e82:	e9d3 0100 	ldrd	r0, r1, [r3]
 8020e86:	e7ca      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020e88:	2c02      	cmp	r4, #2
 8020e8a:	d848      	bhi.n	8020f1e <__ieee754_atan2+0x13e>
 8020e8c:	4b31      	ldr	r3, [pc, #196]	@ (8020f54 <__ieee754_atan2+0x174>)
 8020e8e:	e7f6      	b.n	8020e7e <__ieee754_atan2+0x9e>
 8020e90:	4543      	cmp	r3, r8
 8020e92:	d0e4      	beq.n	8020e5e <__ieee754_atan2+0x7e>
 8020e94:	1a9b      	subs	r3, r3, r2
 8020e96:	f1b3 7f74 	cmp.w	r3, #63963136	@ 0x3d00000
 8020e9a:	ea4f 5223 	mov.w	r2, r3, asr #20
 8020e9e:	da1e      	bge.n	8020ede <__ieee754_atan2+0xfe>
 8020ea0:	2f00      	cmp	r7, #0
 8020ea2:	da01      	bge.n	8020ea8 <__ieee754_atan2+0xc8>
 8020ea4:	323c      	adds	r2, #60	@ 0x3c
 8020ea6:	db1e      	blt.n	8020ee6 <__ieee754_atan2+0x106>
 8020ea8:	4632      	mov	r2, r6
 8020eaa:	463b      	mov	r3, r7
 8020eac:	f7df fcd6 	bl	800085c <__aeabi_ddiv>
 8020eb0:	ec41 0b10 	vmov	d0, r0, r1
 8020eb4:	f7fe fc44 	bl	801f740 <fabs>
 8020eb8:	f000 ff9a 	bl	8021df0 <atan>
 8020ebc:	ec51 0b10 	vmov	r0, r1, d0
 8020ec0:	2c01      	cmp	r4, #1
 8020ec2:	d013      	beq.n	8020eec <__ieee754_atan2+0x10c>
 8020ec4:	2c02      	cmp	r4, #2
 8020ec6:	d015      	beq.n	8020ef4 <__ieee754_atan2+0x114>
 8020ec8:	2c00      	cmp	r4, #0
 8020eca:	d0a8      	beq.n	8020e1e <__ieee754_atan2+0x3e>
 8020ecc:	a318      	add	r3, pc, #96	@ (adr r3, 8020f30 <__ieee754_atan2+0x150>)
 8020ece:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020ed2:	f7df f9e1 	bl	8000298 <__aeabi_dsub>
 8020ed6:	a318      	add	r3, pc, #96	@ (adr r3, 8020f38 <__ieee754_atan2+0x158>)
 8020ed8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020edc:	e014      	b.n	8020f08 <__ieee754_atan2+0x128>
 8020ede:	a118      	add	r1, pc, #96	@ (adr r1, 8020f40 <__ieee754_atan2+0x160>)
 8020ee0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020ee4:	e7ec      	b.n	8020ec0 <__ieee754_atan2+0xe0>
 8020ee6:	2000      	movs	r0, #0
 8020ee8:	2100      	movs	r1, #0
 8020eea:	e7e9      	b.n	8020ec0 <__ieee754_atan2+0xe0>
 8020eec:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8020ef0:	4619      	mov	r1, r3
 8020ef2:	e794      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020ef4:	a30e      	add	r3, pc, #56	@ (adr r3, 8020f30 <__ieee754_atan2+0x150>)
 8020ef6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020efa:	f7df f9cd 	bl	8000298 <__aeabi_dsub>
 8020efe:	4602      	mov	r2, r0
 8020f00:	460b      	mov	r3, r1
 8020f02:	a10d      	add	r1, pc, #52	@ (adr r1, 8020f38 <__ieee754_atan2+0x158>)
 8020f04:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020f08:	f7df f9c6 	bl	8000298 <__aeabi_dsub>
 8020f0c:	e787      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020f0e:	a10a      	add	r1, pc, #40	@ (adr r1, 8020f38 <__ieee754_atan2+0x158>)
 8020f10:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020f14:	e783      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020f16:	a10c      	add	r1, pc, #48	@ (adr r1, 8020f48 <__ieee754_atan2+0x168>)
 8020f18:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020f1c:	e77f      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020f1e:	2000      	movs	r0, #0
 8020f20:	2100      	movs	r1, #0
 8020f22:	e77c      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020f24:	a106      	add	r1, pc, #24	@ (adr r1, 8020f40 <__ieee754_atan2+0x160>)
 8020f26:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020f2a:	e778      	b.n	8020e1e <__ieee754_atan2+0x3e>
 8020f2c:	f3af 8000 	nop.w
 8020f30:	33145c07 	.word	0x33145c07
 8020f34:	3ca1a626 	.word	0x3ca1a626
 8020f38:	54442d18 	.word	0x54442d18
 8020f3c:	400921fb 	.word	0x400921fb
 8020f40:	54442d18 	.word	0x54442d18
 8020f44:	3ff921fb 	.word	0x3ff921fb
 8020f48:	54442d18 	.word	0x54442d18
 8020f4c:	3fe921fb 	.word	0x3fe921fb
 8020f50:	08023dd0 	.word	0x08023dd0
 8020f54:	08023db8 	.word	0x08023db8
 8020f58:	54442d18 	.word	0x54442d18
 8020f5c:	c00921fb 	.word	0xc00921fb
 8020f60:	54442d18 	.word	0x54442d18
 8020f64:	bff921fb 	.word	0xbff921fb
 8020f68:	7ff00000 	.word	0x7ff00000
 8020f6c:	00000000 	.word	0x00000000

08020f70 <__ieee754_pow>:
 8020f70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020f74:	b091      	sub	sp, #68	@ 0x44
 8020f76:	ed8d 1b00 	vstr	d1, [sp]
 8020f7a:	e9dd 1900 	ldrd	r1, r9, [sp]
 8020f7e:	f029 4a00 	bic.w	sl, r9, #2147483648	@ 0x80000000
 8020f82:	ea5a 0001 	orrs.w	r0, sl, r1
 8020f86:	ec57 6b10 	vmov	r6, r7, d0
 8020f8a:	d113      	bne.n	8020fb4 <__ieee754_pow+0x44>
 8020f8c:	19b3      	adds	r3, r6, r6
 8020f8e:	f487 2200 	eor.w	r2, r7, #524288	@ 0x80000
 8020f92:	4152      	adcs	r2, r2
 8020f94:	4298      	cmp	r0, r3
 8020f96:	4b98      	ldr	r3, [pc, #608]	@ (80211f8 <__ieee754_pow+0x288>)
 8020f98:	4193      	sbcs	r3, r2
 8020f9a:	f080 84ea 	bcs.w	8021972 <__ieee754_pow+0xa02>
 8020f9e:	e9dd 2300 	ldrd	r2, r3, [sp]
 8020fa2:	4630      	mov	r0, r6
 8020fa4:	4639      	mov	r1, r7
 8020fa6:	f7df f979 	bl	800029c <__adddf3>
 8020faa:	ec41 0b10 	vmov	d0, r0, r1
 8020fae:	b011      	add	sp, #68	@ 0x44
 8020fb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020fb4:	4a91      	ldr	r2, [pc, #580]	@ (80211fc <__ieee754_pow+0x28c>)
 8020fb6:	f027 4800 	bic.w	r8, r7, #2147483648	@ 0x80000000
 8020fba:	4590      	cmp	r8, r2
 8020fbc:	463d      	mov	r5, r7
 8020fbe:	4633      	mov	r3, r6
 8020fc0:	d806      	bhi.n	8020fd0 <__ieee754_pow+0x60>
 8020fc2:	d101      	bne.n	8020fc8 <__ieee754_pow+0x58>
 8020fc4:	2e00      	cmp	r6, #0
 8020fc6:	d1ea      	bne.n	8020f9e <__ieee754_pow+0x2e>
 8020fc8:	4592      	cmp	sl, r2
 8020fca:	d801      	bhi.n	8020fd0 <__ieee754_pow+0x60>
 8020fcc:	d10e      	bne.n	8020fec <__ieee754_pow+0x7c>
 8020fce:	b169      	cbz	r1, 8020fec <__ieee754_pow+0x7c>
 8020fd0:	f105 4540 	add.w	r5, r5, #3221225472	@ 0xc0000000
 8020fd4:	f505 1580 	add.w	r5, r5, #1048576	@ 0x100000
 8020fd8:	431d      	orrs	r5, r3
 8020fda:	d1e0      	bne.n	8020f9e <__ieee754_pow+0x2e>
 8020fdc:	e9dd 3200 	ldrd	r3, r2, [sp]
 8020fe0:	18db      	adds	r3, r3, r3
 8020fe2:	f482 2200 	eor.w	r2, r2, #524288	@ 0x80000
 8020fe6:	4152      	adcs	r2, r2
 8020fe8:	429d      	cmp	r5, r3
 8020fea:	e7d4      	b.n	8020f96 <__ieee754_pow+0x26>
 8020fec:	2d00      	cmp	r5, #0
 8020fee:	46c3      	mov	fp, r8
 8020ff0:	da3a      	bge.n	8021068 <__ieee754_pow+0xf8>
 8020ff2:	4a83      	ldr	r2, [pc, #524]	@ (8021200 <__ieee754_pow+0x290>)
 8020ff4:	4592      	cmp	sl, r2
 8020ff6:	d84d      	bhi.n	8021094 <__ieee754_pow+0x124>
 8020ff8:	f1a2 7254 	sub.w	r2, r2, #55574528	@ 0x3500000
 8020ffc:	4592      	cmp	sl, r2
 8020ffe:	f240 84c7 	bls.w	8021990 <__ieee754_pow+0xa20>
 8021002:	ea4f 522a 	mov.w	r2, sl, asr #20
 8021006:	f2a2 32ff 	subw	r2, r2, #1023	@ 0x3ff
 802100a:	2a14      	cmp	r2, #20
 802100c:	dd0f      	ble.n	802102e <__ieee754_pow+0xbe>
 802100e:	f1c2 0234 	rsb	r2, r2, #52	@ 0x34
 8021012:	fa21 f402 	lsr.w	r4, r1, r2
 8021016:	fa04 f202 	lsl.w	r2, r4, r2
 802101a:	428a      	cmp	r2, r1
 802101c:	f040 84b8 	bne.w	8021990 <__ieee754_pow+0xa20>
 8021020:	f004 0401 	and.w	r4, r4, #1
 8021024:	f1c4 0402 	rsb	r4, r4, #2
 8021028:	2900      	cmp	r1, #0
 802102a:	d158      	bne.n	80210de <__ieee754_pow+0x16e>
 802102c:	e00e      	b.n	802104c <__ieee754_pow+0xdc>
 802102e:	2900      	cmp	r1, #0
 8021030:	d154      	bne.n	80210dc <__ieee754_pow+0x16c>
 8021032:	f1c2 0214 	rsb	r2, r2, #20
 8021036:	fa4a f402 	asr.w	r4, sl, r2
 802103a:	fa04 f202 	lsl.w	r2, r4, r2
 802103e:	4552      	cmp	r2, sl
 8021040:	f040 84a3 	bne.w	802198a <__ieee754_pow+0xa1a>
 8021044:	f004 0401 	and.w	r4, r4, #1
 8021048:	f1c4 0402 	rsb	r4, r4, #2
 802104c:	4a6d      	ldr	r2, [pc, #436]	@ (8021204 <__ieee754_pow+0x294>)
 802104e:	4592      	cmp	sl, r2
 8021050:	d12e      	bne.n	80210b0 <__ieee754_pow+0x140>
 8021052:	f1b9 0f00 	cmp.w	r9, #0
 8021056:	f280 8494 	bge.w	8021982 <__ieee754_pow+0xa12>
 802105a:	496a      	ldr	r1, [pc, #424]	@ (8021204 <__ieee754_pow+0x294>)
 802105c:	4632      	mov	r2, r6
 802105e:	463b      	mov	r3, r7
 8021060:	2000      	movs	r0, #0
 8021062:	f7df fbfb 	bl	800085c <__aeabi_ddiv>
 8021066:	e7a0      	b.n	8020faa <__ieee754_pow+0x3a>
 8021068:	2400      	movs	r4, #0
 802106a:	bbc1      	cbnz	r1, 80210de <__ieee754_pow+0x16e>
 802106c:	4a63      	ldr	r2, [pc, #396]	@ (80211fc <__ieee754_pow+0x28c>)
 802106e:	4592      	cmp	sl, r2
 8021070:	d1ec      	bne.n	802104c <__ieee754_pow+0xdc>
 8021072:	f108 4240 	add.w	r2, r8, #3221225472	@ 0xc0000000
 8021076:	f502 1280 	add.w	r2, r2, #1048576	@ 0x100000
 802107a:	431a      	orrs	r2, r3
 802107c:	f000 8479 	beq.w	8021972 <__ieee754_pow+0xa02>
 8021080:	4b61      	ldr	r3, [pc, #388]	@ (8021208 <__ieee754_pow+0x298>)
 8021082:	4598      	cmp	r8, r3
 8021084:	d908      	bls.n	8021098 <__ieee754_pow+0x128>
 8021086:	f1b9 0f00 	cmp.w	r9, #0
 802108a:	f2c0 8476 	blt.w	802197a <__ieee754_pow+0xa0a>
 802108e:	e9dd 0100 	ldrd	r0, r1, [sp]
 8021092:	e78a      	b.n	8020faa <__ieee754_pow+0x3a>
 8021094:	2402      	movs	r4, #2
 8021096:	e7e8      	b.n	802106a <__ieee754_pow+0xfa>
 8021098:	f1b9 0f00 	cmp.w	r9, #0
 802109c:	f04f 0000 	mov.w	r0, #0
 80210a0:	f04f 0100 	mov.w	r1, #0
 80210a4:	da81      	bge.n	8020faa <__ieee754_pow+0x3a>
 80210a6:	e9dd 0300 	ldrd	r0, r3, [sp]
 80210aa:	f103 4100 	add.w	r1, r3, #2147483648	@ 0x80000000
 80210ae:	e77c      	b.n	8020faa <__ieee754_pow+0x3a>
 80210b0:	f1b9 4f80 	cmp.w	r9, #1073741824	@ 0x40000000
 80210b4:	d106      	bne.n	80210c4 <__ieee754_pow+0x154>
 80210b6:	4632      	mov	r2, r6
 80210b8:	463b      	mov	r3, r7
 80210ba:	4630      	mov	r0, r6
 80210bc:	4639      	mov	r1, r7
 80210be:	f7df faa3 	bl	8000608 <__aeabi_dmul>
 80210c2:	e772      	b.n	8020faa <__ieee754_pow+0x3a>
 80210c4:	4a51      	ldr	r2, [pc, #324]	@ (802120c <__ieee754_pow+0x29c>)
 80210c6:	4591      	cmp	r9, r2
 80210c8:	d109      	bne.n	80210de <__ieee754_pow+0x16e>
 80210ca:	2d00      	cmp	r5, #0
 80210cc:	db07      	blt.n	80210de <__ieee754_pow+0x16e>
 80210ce:	ec47 6b10 	vmov	d0, r6, r7
 80210d2:	b011      	add	sp, #68	@ 0x44
 80210d4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80210d8:	f7fe bcc8 	b.w	801fa6c <__ieee754_sqrt>
 80210dc:	2400      	movs	r4, #0
 80210de:	ec47 6b10 	vmov	d0, r6, r7
 80210e2:	9302      	str	r3, [sp, #8]
 80210e4:	f7fe fb2c 	bl	801f740 <fabs>
 80210e8:	9b02      	ldr	r3, [sp, #8]
 80210ea:	ec51 0b10 	vmov	r0, r1, d0
 80210ee:	bb53      	cbnz	r3, 8021146 <__ieee754_pow+0x1d6>
 80210f0:	4b44      	ldr	r3, [pc, #272]	@ (8021204 <__ieee754_pow+0x294>)
 80210f2:	f025 4240 	bic.w	r2, r5, #3221225472	@ 0xc0000000
 80210f6:	429a      	cmp	r2, r3
 80210f8:	d002      	beq.n	8021100 <__ieee754_pow+0x190>
 80210fa:	f1b8 0f00 	cmp.w	r8, #0
 80210fe:	d122      	bne.n	8021146 <__ieee754_pow+0x1d6>
 8021100:	f1b9 0f00 	cmp.w	r9, #0
 8021104:	da05      	bge.n	8021112 <__ieee754_pow+0x1a2>
 8021106:	4602      	mov	r2, r0
 8021108:	460b      	mov	r3, r1
 802110a:	2000      	movs	r0, #0
 802110c:	493d      	ldr	r1, [pc, #244]	@ (8021204 <__ieee754_pow+0x294>)
 802110e:	f7df fba5 	bl	800085c <__aeabi_ddiv>
 8021112:	2d00      	cmp	r5, #0
 8021114:	f6bf af49 	bge.w	8020faa <__ieee754_pow+0x3a>
 8021118:	f108 4840 	add.w	r8, r8, #3221225472	@ 0xc0000000
 802111c:	f508 1880 	add.w	r8, r8, #1048576	@ 0x100000
 8021120:	ea58 0804 	orrs.w	r8, r8, r4
 8021124:	d108      	bne.n	8021138 <__ieee754_pow+0x1c8>
 8021126:	4602      	mov	r2, r0
 8021128:	460b      	mov	r3, r1
 802112a:	4610      	mov	r0, r2
 802112c:	4619      	mov	r1, r3
 802112e:	f7df f8b3 	bl	8000298 <__aeabi_dsub>
 8021132:	4602      	mov	r2, r0
 8021134:	460b      	mov	r3, r1
 8021136:	e794      	b.n	8021062 <__ieee754_pow+0xf2>
 8021138:	2c01      	cmp	r4, #1
 802113a:	f47f af36 	bne.w	8020faa <__ieee754_pow+0x3a>
 802113e:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8021142:	4619      	mov	r1, r3
 8021144:	e731      	b.n	8020faa <__ieee754_pow+0x3a>
 8021146:	0feb      	lsrs	r3, r5, #31
 8021148:	3b01      	subs	r3, #1
 802114a:	ea53 0204 	orrs.w	r2, r3, r4
 802114e:	d102      	bne.n	8021156 <__ieee754_pow+0x1e6>
 8021150:	4632      	mov	r2, r6
 8021152:	463b      	mov	r3, r7
 8021154:	e7e9      	b.n	802112a <__ieee754_pow+0x1ba>
 8021156:	3c01      	subs	r4, #1
 8021158:	431c      	orrs	r4, r3
 802115a:	d016      	beq.n	802118a <__ieee754_pow+0x21a>
 802115c:	ed9f 7b22 	vldr	d7, [pc, #136]	@ 80211e8 <__ieee754_pow+0x278>
 8021160:	f1ba 4f84 	cmp.w	sl, #1107296256	@ 0x42000000
 8021164:	ed8d 7b02 	vstr	d7, [sp, #8]
 8021168:	f240 8112 	bls.w	8021390 <__ieee754_pow+0x420>
 802116c:	4b28      	ldr	r3, [pc, #160]	@ (8021210 <__ieee754_pow+0x2a0>)
 802116e:	459a      	cmp	sl, r3
 8021170:	4b25      	ldr	r3, [pc, #148]	@ (8021208 <__ieee754_pow+0x298>)
 8021172:	d916      	bls.n	80211a2 <__ieee754_pow+0x232>
 8021174:	4598      	cmp	r8, r3
 8021176:	d80b      	bhi.n	8021190 <__ieee754_pow+0x220>
 8021178:	f1b9 0f00 	cmp.w	r9, #0
 802117c:	da0b      	bge.n	8021196 <__ieee754_pow+0x226>
 802117e:	2000      	movs	r0, #0
 8021180:	b011      	add	sp, #68	@ 0x44
 8021182:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021186:	f001 bd8b 	b.w	8022ca0 <__math_oflow>
 802118a:	ed9f 7b19 	vldr	d7, [pc, #100]	@ 80211f0 <__ieee754_pow+0x280>
 802118e:	e7e7      	b.n	8021160 <__ieee754_pow+0x1f0>
 8021190:	f1b9 0f00 	cmp.w	r9, #0
 8021194:	dcf3      	bgt.n	802117e <__ieee754_pow+0x20e>
 8021196:	2000      	movs	r0, #0
 8021198:	b011      	add	sp, #68	@ 0x44
 802119a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802119e:	f001 bd77 	b.w	8022c90 <__math_uflow>
 80211a2:	4598      	cmp	r8, r3
 80211a4:	d20c      	bcs.n	80211c0 <__ieee754_pow+0x250>
 80211a6:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80211aa:	2200      	movs	r2, #0
 80211ac:	2300      	movs	r3, #0
 80211ae:	f7df fc9d 	bl	8000aec <__aeabi_dcmplt>
 80211b2:	3800      	subs	r0, #0
 80211b4:	bf18      	it	ne
 80211b6:	2001      	movne	r0, #1
 80211b8:	f1b9 0f00 	cmp.w	r9, #0
 80211bc:	daec      	bge.n	8021198 <__ieee754_pow+0x228>
 80211be:	e7df      	b.n	8021180 <__ieee754_pow+0x210>
 80211c0:	4b10      	ldr	r3, [pc, #64]	@ (8021204 <__ieee754_pow+0x294>)
 80211c2:	4598      	cmp	r8, r3
 80211c4:	f04f 0200 	mov.w	r2, #0
 80211c8:	d924      	bls.n	8021214 <__ieee754_pow+0x2a4>
 80211ca:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80211ce:	2300      	movs	r3, #0
 80211d0:	f7df fc8c 	bl	8000aec <__aeabi_dcmplt>
 80211d4:	3800      	subs	r0, #0
 80211d6:	bf18      	it	ne
 80211d8:	2001      	movne	r0, #1
 80211da:	f1b9 0f00 	cmp.w	r9, #0
 80211de:	dccf      	bgt.n	8021180 <__ieee754_pow+0x210>
 80211e0:	e7da      	b.n	8021198 <__ieee754_pow+0x228>
 80211e2:	bf00      	nop
 80211e4:	f3af 8000 	nop.w
 80211e8:	00000000 	.word	0x00000000
 80211ec:	3ff00000 	.word	0x3ff00000
 80211f0:	00000000 	.word	0x00000000
 80211f4:	bff00000 	.word	0xbff00000
 80211f8:	fff00000 	.word	0xfff00000
 80211fc:	7ff00000 	.word	0x7ff00000
 8021200:	433fffff 	.word	0x433fffff
 8021204:	3ff00000 	.word	0x3ff00000
 8021208:	3fefffff 	.word	0x3fefffff
 802120c:	3fe00000 	.word	0x3fe00000
 8021210:	43f00000 	.word	0x43f00000
 8021214:	4b5a      	ldr	r3, [pc, #360]	@ (8021380 <__ieee754_pow+0x410>)
 8021216:	f7df f83f 	bl	8000298 <__aeabi_dsub>
 802121a:	a351      	add	r3, pc, #324	@ (adr r3, 8021360 <__ieee754_pow+0x3f0>)
 802121c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021220:	4604      	mov	r4, r0
 8021222:	460d      	mov	r5, r1
 8021224:	f7df f9f0 	bl	8000608 <__aeabi_dmul>
 8021228:	a34f      	add	r3, pc, #316	@ (adr r3, 8021368 <__ieee754_pow+0x3f8>)
 802122a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802122e:	4606      	mov	r6, r0
 8021230:	460f      	mov	r7, r1
 8021232:	4620      	mov	r0, r4
 8021234:	4629      	mov	r1, r5
 8021236:	f7df f9e7 	bl	8000608 <__aeabi_dmul>
 802123a:	4b52      	ldr	r3, [pc, #328]	@ (8021384 <__ieee754_pow+0x414>)
 802123c:	4682      	mov	sl, r0
 802123e:	468b      	mov	fp, r1
 8021240:	2200      	movs	r2, #0
 8021242:	4620      	mov	r0, r4
 8021244:	4629      	mov	r1, r5
 8021246:	f7df f9df 	bl	8000608 <__aeabi_dmul>
 802124a:	4602      	mov	r2, r0
 802124c:	460b      	mov	r3, r1
 802124e:	a148      	add	r1, pc, #288	@ (adr r1, 8021370 <__ieee754_pow+0x400>)
 8021250:	e9d1 0100 	ldrd	r0, r1, [r1]
 8021254:	f7df f820 	bl	8000298 <__aeabi_dsub>
 8021258:	4622      	mov	r2, r4
 802125a:	462b      	mov	r3, r5
 802125c:	f7df f9d4 	bl	8000608 <__aeabi_dmul>
 8021260:	4602      	mov	r2, r0
 8021262:	460b      	mov	r3, r1
 8021264:	2000      	movs	r0, #0
 8021266:	4948      	ldr	r1, [pc, #288]	@ (8021388 <__ieee754_pow+0x418>)
 8021268:	f7df f816 	bl	8000298 <__aeabi_dsub>
 802126c:	4622      	mov	r2, r4
 802126e:	4680      	mov	r8, r0
 8021270:	4689      	mov	r9, r1
 8021272:	462b      	mov	r3, r5
 8021274:	4620      	mov	r0, r4
 8021276:	4629      	mov	r1, r5
 8021278:	f7df f9c6 	bl	8000608 <__aeabi_dmul>
 802127c:	4602      	mov	r2, r0
 802127e:	460b      	mov	r3, r1
 8021280:	4640      	mov	r0, r8
 8021282:	4649      	mov	r1, r9
 8021284:	f7df f9c0 	bl	8000608 <__aeabi_dmul>
 8021288:	a33b      	add	r3, pc, #236	@ (adr r3, 8021378 <__ieee754_pow+0x408>)
 802128a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802128e:	f7df f9bb 	bl	8000608 <__aeabi_dmul>
 8021292:	4602      	mov	r2, r0
 8021294:	460b      	mov	r3, r1
 8021296:	4650      	mov	r0, sl
 8021298:	4659      	mov	r1, fp
 802129a:	f7de fffd 	bl	8000298 <__aeabi_dsub>
 802129e:	4602      	mov	r2, r0
 80212a0:	460b      	mov	r3, r1
 80212a2:	4680      	mov	r8, r0
 80212a4:	4689      	mov	r9, r1
 80212a6:	4630      	mov	r0, r6
 80212a8:	4639      	mov	r1, r7
 80212aa:	f7de fff7 	bl	800029c <__adddf3>
 80212ae:	2400      	movs	r4, #0
 80212b0:	4632      	mov	r2, r6
 80212b2:	463b      	mov	r3, r7
 80212b4:	4620      	mov	r0, r4
 80212b6:	460d      	mov	r5, r1
 80212b8:	f7de ffee 	bl	8000298 <__aeabi_dsub>
 80212bc:	4602      	mov	r2, r0
 80212be:	460b      	mov	r3, r1
 80212c0:	4640      	mov	r0, r8
 80212c2:	4649      	mov	r1, r9
 80212c4:	f7de ffe8 	bl	8000298 <__aeabi_dsub>
 80212c8:	e9dd 2300 	ldrd	r2, r3, [sp]
 80212cc:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80212d0:	2300      	movs	r3, #0
 80212d2:	9304      	str	r3, [sp, #16]
 80212d4:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80212d8:	4606      	mov	r6, r0
 80212da:	460f      	mov	r7, r1
 80212dc:	4652      	mov	r2, sl
 80212de:	465b      	mov	r3, fp
 80212e0:	e9dd 0100 	ldrd	r0, r1, [sp]
 80212e4:	f7de ffd8 	bl	8000298 <__aeabi_dsub>
 80212e8:	4622      	mov	r2, r4
 80212ea:	462b      	mov	r3, r5
 80212ec:	f7df f98c 	bl	8000608 <__aeabi_dmul>
 80212f0:	e9dd 2300 	ldrd	r2, r3, [sp]
 80212f4:	4680      	mov	r8, r0
 80212f6:	4689      	mov	r9, r1
 80212f8:	4630      	mov	r0, r6
 80212fa:	4639      	mov	r1, r7
 80212fc:	f7df f984 	bl	8000608 <__aeabi_dmul>
 8021300:	4602      	mov	r2, r0
 8021302:	460b      	mov	r3, r1
 8021304:	4640      	mov	r0, r8
 8021306:	4649      	mov	r1, r9
 8021308:	f7de ffc8 	bl	800029c <__adddf3>
 802130c:	4652      	mov	r2, sl
 802130e:	465b      	mov	r3, fp
 8021310:	4606      	mov	r6, r0
 8021312:	460f      	mov	r7, r1
 8021314:	4620      	mov	r0, r4
 8021316:	4629      	mov	r1, r5
 8021318:	f7df f976 	bl	8000608 <__aeabi_dmul>
 802131c:	460b      	mov	r3, r1
 802131e:	4602      	mov	r2, r0
 8021320:	4680      	mov	r8, r0
 8021322:	4689      	mov	r9, r1
 8021324:	4630      	mov	r0, r6
 8021326:	4639      	mov	r1, r7
 8021328:	f7de ffb8 	bl	800029c <__adddf3>
 802132c:	4b17      	ldr	r3, [pc, #92]	@ (802138c <__ieee754_pow+0x41c>)
 802132e:	4299      	cmp	r1, r3
 8021330:	4604      	mov	r4, r0
 8021332:	460d      	mov	r5, r1
 8021334:	468a      	mov	sl, r1
 8021336:	468b      	mov	fp, r1
 8021338:	f340 82ef 	ble.w	802191a <__ieee754_pow+0x9aa>
 802133c:	f101 433f 	add.w	r3, r1, #3204448256	@ 0xbf000000
 8021340:	f503 03e0 	add.w	r3, r3, #7340032	@ 0x700000
 8021344:	4303      	orrs	r3, r0
 8021346:	f000 81e8 	beq.w	802171a <__ieee754_pow+0x7aa>
 802134a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802134e:	2200      	movs	r2, #0
 8021350:	2300      	movs	r3, #0
 8021352:	f7df fbcb 	bl	8000aec <__aeabi_dcmplt>
 8021356:	3800      	subs	r0, #0
 8021358:	bf18      	it	ne
 802135a:	2001      	movne	r0, #1
 802135c:	e710      	b.n	8021180 <__ieee754_pow+0x210>
 802135e:	bf00      	nop
 8021360:	60000000 	.word	0x60000000
 8021364:	3ff71547 	.word	0x3ff71547
 8021368:	f85ddf44 	.word	0xf85ddf44
 802136c:	3e54ae0b 	.word	0x3e54ae0b
 8021370:	55555555 	.word	0x55555555
 8021374:	3fd55555 	.word	0x3fd55555
 8021378:	652b82fe 	.word	0x652b82fe
 802137c:	3ff71547 	.word	0x3ff71547
 8021380:	3ff00000 	.word	0x3ff00000
 8021384:	3fd00000 	.word	0x3fd00000
 8021388:	3fe00000 	.word	0x3fe00000
 802138c:	408fffff 	.word	0x408fffff
 8021390:	4bd5      	ldr	r3, [pc, #852]	@ (80216e8 <__ieee754_pow+0x778>)
 8021392:	402b      	ands	r3, r5
 8021394:	2200      	movs	r2, #0
 8021396:	b92b      	cbnz	r3, 80213a4 <__ieee754_pow+0x434>
 8021398:	4bd4      	ldr	r3, [pc, #848]	@ (80216ec <__ieee754_pow+0x77c>)
 802139a:	f7df f935 	bl	8000608 <__aeabi_dmul>
 802139e:	f06f 0234 	mvn.w	r2, #52	@ 0x34
 80213a2:	468b      	mov	fp, r1
 80213a4:	ea4f 532b 	mov.w	r3, fp, asr #20
 80213a8:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
 80213ac:	4413      	add	r3, r2
 80213ae:	930a      	str	r3, [sp, #40]	@ 0x28
 80213b0:	4bcf      	ldr	r3, [pc, #828]	@ (80216f0 <__ieee754_pow+0x780>)
 80213b2:	f3cb 0b13 	ubfx	fp, fp, #0, #20
 80213b6:	f04b 557f 	orr.w	r5, fp, #1069547520	@ 0x3fc00000
 80213ba:	459b      	cmp	fp, r3
 80213bc:	f445 1540 	orr.w	r5, r5, #3145728	@ 0x300000
 80213c0:	dd08      	ble.n	80213d4 <__ieee754_pow+0x464>
 80213c2:	4bcc      	ldr	r3, [pc, #816]	@ (80216f4 <__ieee754_pow+0x784>)
 80213c4:	459b      	cmp	fp, r3
 80213c6:	f340 81a5 	ble.w	8021714 <__ieee754_pow+0x7a4>
 80213ca:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 80213cc:	3301      	adds	r3, #1
 80213ce:	930a      	str	r3, [sp, #40]	@ 0x28
 80213d0:	f5a5 1580 	sub.w	r5, r5, #1048576	@ 0x100000
 80213d4:	f04f 0a00 	mov.w	sl, #0
 80213d8:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 80213dc:	930b      	str	r3, [sp, #44]	@ 0x2c
 80213de:	4bc6      	ldr	r3, [pc, #792]	@ (80216f8 <__ieee754_pow+0x788>)
 80213e0:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 80213e4:	ed93 7b00 	vldr	d7, [r3]
 80213e8:	4629      	mov	r1, r5
 80213ea:	ec53 2b17 	vmov	r2, r3, d7
 80213ee:	ed8d 7b06 	vstr	d7, [sp, #24]
 80213f2:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80213f6:	f7de ff4f 	bl	8000298 <__aeabi_dsub>
 80213fa:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80213fe:	4606      	mov	r6, r0
 8021400:	460f      	mov	r7, r1
 8021402:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8021406:	f7de ff49 	bl	800029c <__adddf3>
 802140a:	4602      	mov	r2, r0
 802140c:	460b      	mov	r3, r1
 802140e:	2000      	movs	r0, #0
 8021410:	49ba      	ldr	r1, [pc, #744]	@ (80216fc <__ieee754_pow+0x78c>)
 8021412:	f7df fa23 	bl	800085c <__aeabi_ddiv>
 8021416:	e9cd 010c 	strd	r0, r1, [sp, #48]	@ 0x30
 802141a:	4602      	mov	r2, r0
 802141c:	460b      	mov	r3, r1
 802141e:	4630      	mov	r0, r6
 8021420:	4639      	mov	r1, r7
 8021422:	f7df f8f1 	bl	8000608 <__aeabi_dmul>
 8021426:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802142a:	e9dd bc04 	ldrd	fp, ip, [sp, #16]
 802142e:	106d      	asrs	r5, r5, #1
 8021430:	f045 5500 	orr.w	r5, r5, #536870912	@ 0x20000000
 8021434:	f04f 0b00 	mov.w	fp, #0
 8021438:	f505 2500 	add.w	r5, r5, #524288	@ 0x80000
 802143c:	4661      	mov	r1, ip
 802143e:	2200      	movs	r2, #0
 8021440:	eb05 438a 	add.w	r3, r5, sl, lsl #18
 8021444:	4658      	mov	r0, fp
 8021446:	46e1      	mov	r9, ip
 8021448:	e9cd bc0e 	strd	fp, ip, [sp, #56]	@ 0x38
 802144c:	4614      	mov	r4, r2
 802144e:	461d      	mov	r5, r3
 8021450:	f7df f8da 	bl	8000608 <__aeabi_dmul>
 8021454:	4602      	mov	r2, r0
 8021456:	460b      	mov	r3, r1
 8021458:	4630      	mov	r0, r6
 802145a:	4639      	mov	r1, r7
 802145c:	f7de ff1c 	bl	8000298 <__aeabi_dsub>
 8021460:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8021464:	4606      	mov	r6, r0
 8021466:	460f      	mov	r7, r1
 8021468:	4620      	mov	r0, r4
 802146a:	4629      	mov	r1, r5
 802146c:	f7de ff14 	bl	8000298 <__aeabi_dsub>
 8021470:	4602      	mov	r2, r0
 8021472:	460b      	mov	r3, r1
 8021474:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8021478:	f7de ff0e 	bl	8000298 <__aeabi_dsub>
 802147c:	465a      	mov	r2, fp
 802147e:	464b      	mov	r3, r9
 8021480:	f7df f8c2 	bl	8000608 <__aeabi_dmul>
 8021484:	4602      	mov	r2, r0
 8021486:	460b      	mov	r3, r1
 8021488:	4630      	mov	r0, r6
 802148a:	4639      	mov	r1, r7
 802148c:	f7de ff04 	bl	8000298 <__aeabi_dsub>
 8021490:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	@ 0x30
 8021494:	f7df f8b8 	bl	8000608 <__aeabi_dmul>
 8021498:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 802149c:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80214a0:	4610      	mov	r0, r2
 80214a2:	4619      	mov	r1, r3
 80214a4:	f7df f8b0 	bl	8000608 <__aeabi_dmul>
 80214a8:	a37d      	add	r3, pc, #500	@ (adr r3, 80216a0 <__ieee754_pow+0x730>)
 80214aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80214ae:	4604      	mov	r4, r0
 80214b0:	460d      	mov	r5, r1
 80214b2:	f7df f8a9 	bl	8000608 <__aeabi_dmul>
 80214b6:	a37c      	add	r3, pc, #496	@ (adr r3, 80216a8 <__ieee754_pow+0x738>)
 80214b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80214bc:	f7de feee 	bl	800029c <__adddf3>
 80214c0:	4622      	mov	r2, r4
 80214c2:	462b      	mov	r3, r5
 80214c4:	f7df f8a0 	bl	8000608 <__aeabi_dmul>
 80214c8:	a379      	add	r3, pc, #484	@ (adr r3, 80216b0 <__ieee754_pow+0x740>)
 80214ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 80214ce:	f7de fee5 	bl	800029c <__adddf3>
 80214d2:	4622      	mov	r2, r4
 80214d4:	462b      	mov	r3, r5
 80214d6:	f7df f897 	bl	8000608 <__aeabi_dmul>
 80214da:	a377      	add	r3, pc, #476	@ (adr r3, 80216b8 <__ieee754_pow+0x748>)
 80214dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80214e0:	f7de fedc 	bl	800029c <__adddf3>
 80214e4:	4622      	mov	r2, r4
 80214e6:	462b      	mov	r3, r5
 80214e8:	f7df f88e 	bl	8000608 <__aeabi_dmul>
 80214ec:	a374      	add	r3, pc, #464	@ (adr r3, 80216c0 <__ieee754_pow+0x750>)
 80214ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80214f2:	f7de fed3 	bl	800029c <__adddf3>
 80214f6:	4622      	mov	r2, r4
 80214f8:	462b      	mov	r3, r5
 80214fa:	f7df f885 	bl	8000608 <__aeabi_dmul>
 80214fe:	a372      	add	r3, pc, #456	@ (adr r3, 80216c8 <__ieee754_pow+0x758>)
 8021500:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021504:	f7de feca 	bl	800029c <__adddf3>
 8021508:	4622      	mov	r2, r4
 802150a:	4606      	mov	r6, r0
 802150c:	460f      	mov	r7, r1
 802150e:	462b      	mov	r3, r5
 8021510:	4620      	mov	r0, r4
 8021512:	4629      	mov	r1, r5
 8021514:	f7df f878 	bl	8000608 <__aeabi_dmul>
 8021518:	4602      	mov	r2, r0
 802151a:	460b      	mov	r3, r1
 802151c:	4630      	mov	r0, r6
 802151e:	4639      	mov	r1, r7
 8021520:	f7df f872 	bl	8000608 <__aeabi_dmul>
 8021524:	465a      	mov	r2, fp
 8021526:	4604      	mov	r4, r0
 8021528:	460d      	mov	r5, r1
 802152a:	464b      	mov	r3, r9
 802152c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8021530:	f7de feb4 	bl	800029c <__adddf3>
 8021534:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8021538:	f7df f866 	bl	8000608 <__aeabi_dmul>
 802153c:	4622      	mov	r2, r4
 802153e:	462b      	mov	r3, r5
 8021540:	f7de feac 	bl	800029c <__adddf3>
 8021544:	465a      	mov	r2, fp
 8021546:	e9cd 0108 	strd	r0, r1, [sp, #32]
 802154a:	464b      	mov	r3, r9
 802154c:	4658      	mov	r0, fp
 802154e:	4649      	mov	r1, r9
 8021550:	f7df f85a 	bl	8000608 <__aeabi_dmul>
 8021554:	4b6a      	ldr	r3, [pc, #424]	@ (8021700 <__ieee754_pow+0x790>)
 8021556:	2200      	movs	r2, #0
 8021558:	4606      	mov	r6, r0
 802155a:	460f      	mov	r7, r1
 802155c:	f7de fe9e 	bl	800029c <__adddf3>
 8021560:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8021564:	f7de fe9a 	bl	800029c <__adddf3>
 8021568:	46d8      	mov	r8, fp
 802156a:	e9dd bc0e 	ldrd	fp, ip, [sp, #56]	@ 0x38
 802156e:	460d      	mov	r5, r1
 8021570:	465a      	mov	r2, fp
 8021572:	460b      	mov	r3, r1
 8021574:	4640      	mov	r0, r8
 8021576:	4649      	mov	r1, r9
 8021578:	e9cd bc0c 	strd	fp, ip, [sp, #48]	@ 0x30
 802157c:	f7df f844 	bl	8000608 <__aeabi_dmul>
 8021580:	465c      	mov	r4, fp
 8021582:	4680      	mov	r8, r0
 8021584:	4689      	mov	r9, r1
 8021586:	4b5e      	ldr	r3, [pc, #376]	@ (8021700 <__ieee754_pow+0x790>)
 8021588:	2200      	movs	r2, #0
 802158a:	4620      	mov	r0, r4
 802158c:	4629      	mov	r1, r5
 802158e:	f7de fe83 	bl	8000298 <__aeabi_dsub>
 8021592:	4632      	mov	r2, r6
 8021594:	463b      	mov	r3, r7
 8021596:	f7de fe7f 	bl	8000298 <__aeabi_dsub>
 802159a:	4602      	mov	r2, r0
 802159c:	460b      	mov	r3, r1
 802159e:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80215a2:	f7de fe79 	bl	8000298 <__aeabi_dsub>
 80215a6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80215aa:	f7df f82d 	bl	8000608 <__aeabi_dmul>
 80215ae:	4622      	mov	r2, r4
 80215b0:	4606      	mov	r6, r0
 80215b2:	460f      	mov	r7, r1
 80215b4:	462b      	mov	r3, r5
 80215b6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80215ba:	f7df f825 	bl	8000608 <__aeabi_dmul>
 80215be:	4602      	mov	r2, r0
 80215c0:	460b      	mov	r3, r1
 80215c2:	4630      	mov	r0, r6
 80215c4:	4639      	mov	r1, r7
 80215c6:	f7de fe69 	bl	800029c <__adddf3>
 80215ca:	4606      	mov	r6, r0
 80215cc:	460f      	mov	r7, r1
 80215ce:	4602      	mov	r2, r0
 80215d0:	460b      	mov	r3, r1
 80215d2:	4640      	mov	r0, r8
 80215d4:	4649      	mov	r1, r9
 80215d6:	f7de fe61 	bl	800029c <__adddf3>
 80215da:	e9dd bc0c 	ldrd	fp, ip, [sp, #48]	@ 0x30
 80215de:	a33c      	add	r3, pc, #240	@ (adr r3, 80216d0 <__ieee754_pow+0x760>)
 80215e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80215e4:	4658      	mov	r0, fp
 80215e6:	e9cd bc08 	strd	fp, ip, [sp, #32]
 80215ea:	460d      	mov	r5, r1
 80215ec:	f7df f80c 	bl	8000608 <__aeabi_dmul>
 80215f0:	465c      	mov	r4, fp
 80215f2:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80215f6:	4642      	mov	r2, r8
 80215f8:	464b      	mov	r3, r9
 80215fa:	4620      	mov	r0, r4
 80215fc:	4629      	mov	r1, r5
 80215fe:	f7de fe4b 	bl	8000298 <__aeabi_dsub>
 8021602:	4602      	mov	r2, r0
 8021604:	460b      	mov	r3, r1
 8021606:	4630      	mov	r0, r6
 8021608:	4639      	mov	r1, r7
 802160a:	f7de fe45 	bl	8000298 <__aeabi_dsub>
 802160e:	a332      	add	r3, pc, #200	@ (adr r3, 80216d8 <__ieee754_pow+0x768>)
 8021610:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021614:	f7de fff8 	bl	8000608 <__aeabi_dmul>
 8021618:	a331      	add	r3, pc, #196	@ (adr r3, 80216e0 <__ieee754_pow+0x770>)
 802161a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802161e:	4606      	mov	r6, r0
 8021620:	460f      	mov	r7, r1
 8021622:	4620      	mov	r0, r4
 8021624:	4629      	mov	r1, r5
 8021626:	f7de ffef 	bl	8000608 <__aeabi_dmul>
 802162a:	4602      	mov	r2, r0
 802162c:	460b      	mov	r3, r1
 802162e:	4630      	mov	r0, r6
 8021630:	4639      	mov	r1, r7
 8021632:	f7de fe33 	bl	800029c <__adddf3>
 8021636:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8021638:	4b32      	ldr	r3, [pc, #200]	@ (8021704 <__ieee754_pow+0x794>)
 802163a:	4413      	add	r3, r2
 802163c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021640:	f7de fe2c 	bl	800029c <__adddf3>
 8021644:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8021648:	980a      	ldr	r0, [sp, #40]	@ 0x28
 802164a:	f7de ff73 	bl	8000534 <__aeabi_i2d>
 802164e:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8021650:	4b2d      	ldr	r3, [pc, #180]	@ (8021708 <__ieee754_pow+0x798>)
 8021652:	4413      	add	r3, r2
 8021654:	e9d3 8900 	ldrd	r8, r9, [r3]
 8021658:	4606      	mov	r6, r0
 802165a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802165e:	460f      	mov	r7, r1
 8021660:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8021664:	f7de fe1a 	bl	800029c <__adddf3>
 8021668:	4642      	mov	r2, r8
 802166a:	464b      	mov	r3, r9
 802166c:	f7de fe16 	bl	800029c <__adddf3>
 8021670:	4632      	mov	r2, r6
 8021672:	463b      	mov	r3, r7
 8021674:	f7de fe12 	bl	800029c <__adddf3>
 8021678:	e9dd bc08 	ldrd	fp, ip, [sp, #32]
 802167c:	4632      	mov	r2, r6
 802167e:	463b      	mov	r3, r7
 8021680:	4658      	mov	r0, fp
 8021682:	460d      	mov	r5, r1
 8021684:	f7de fe08 	bl	8000298 <__aeabi_dsub>
 8021688:	4642      	mov	r2, r8
 802168a:	464b      	mov	r3, r9
 802168c:	f7de fe04 	bl	8000298 <__aeabi_dsub>
 8021690:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8021694:	f7de fe00 	bl	8000298 <__aeabi_dsub>
 8021698:	465c      	mov	r4, fp
 802169a:	4602      	mov	r2, r0
 802169c:	e036      	b.n	802170c <__ieee754_pow+0x79c>
 802169e:	bf00      	nop
 80216a0:	4a454eef 	.word	0x4a454eef
 80216a4:	3fca7e28 	.word	0x3fca7e28
 80216a8:	93c9db65 	.word	0x93c9db65
 80216ac:	3fcd864a 	.word	0x3fcd864a
 80216b0:	a91d4101 	.word	0xa91d4101
 80216b4:	3fd17460 	.word	0x3fd17460
 80216b8:	518f264d 	.word	0x518f264d
 80216bc:	3fd55555 	.word	0x3fd55555
 80216c0:	db6fabff 	.word	0xdb6fabff
 80216c4:	3fdb6db6 	.word	0x3fdb6db6
 80216c8:	33333303 	.word	0x33333303
 80216cc:	3fe33333 	.word	0x3fe33333
 80216d0:	e0000000 	.word	0xe0000000
 80216d4:	3feec709 	.word	0x3feec709
 80216d8:	dc3a03fd 	.word	0xdc3a03fd
 80216dc:	3feec709 	.word	0x3feec709
 80216e0:	145b01f5 	.word	0x145b01f5
 80216e4:	be3e2fe0 	.word	0xbe3e2fe0
 80216e8:	7ff00000 	.word	0x7ff00000
 80216ec:	43400000 	.word	0x43400000
 80216f0:	0003988e 	.word	0x0003988e
 80216f4:	000bb679 	.word	0x000bb679
 80216f8:	08023e08 	.word	0x08023e08
 80216fc:	3ff00000 	.word	0x3ff00000
 8021700:	40080000 	.word	0x40080000
 8021704:	08023de8 	.word	0x08023de8
 8021708:	08023df8 	.word	0x08023df8
 802170c:	460b      	mov	r3, r1
 802170e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8021712:	e5d7      	b.n	80212c4 <__ieee754_pow+0x354>
 8021714:	f04f 0a01 	mov.w	sl, #1
 8021718:	e65e      	b.n	80213d8 <__ieee754_pow+0x468>
 802171a:	a3b4      	add	r3, pc, #720	@ (adr r3, 80219ec <__ieee754_pow+0xa7c>)
 802171c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021720:	4630      	mov	r0, r6
 8021722:	4639      	mov	r1, r7
 8021724:	f7de fdba 	bl	800029c <__adddf3>
 8021728:	4642      	mov	r2, r8
 802172a:	e9cd 0100 	strd	r0, r1, [sp]
 802172e:	464b      	mov	r3, r9
 8021730:	4620      	mov	r0, r4
 8021732:	4629      	mov	r1, r5
 8021734:	f7de fdb0 	bl	8000298 <__aeabi_dsub>
 8021738:	4602      	mov	r2, r0
 802173a:	460b      	mov	r3, r1
 802173c:	e9dd 0100 	ldrd	r0, r1, [sp]
 8021740:	f7df f9f2 	bl	8000b28 <__aeabi_dcmpgt>
 8021744:	2800      	cmp	r0, #0
 8021746:	f47f ae00 	bne.w	802134a <__ieee754_pow+0x3da>
 802174a:	ea4f 5a2a 	mov.w	sl, sl, asr #20
 802174e:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 8021752:	f2aa 3afe 	subw	sl, sl, #1022	@ 0x3fe
 8021756:	fa43 fa0a 	asr.w	sl, r3, sl
 802175a:	44da      	add	sl, fp
 802175c:	f3ca 510a 	ubfx	r1, sl, #20, #11
 8021760:	489d      	ldr	r0, [pc, #628]	@ (80219d8 <__ieee754_pow+0xa68>)
 8021762:	f2a1 31ff 	subw	r1, r1, #1023	@ 0x3ff
 8021766:	4108      	asrs	r0, r1
 8021768:	ea00 030a 	and.w	r3, r0, sl
 802176c:	f3ca 0a13 	ubfx	sl, sl, #0, #20
 8021770:	f1c1 0114 	rsb	r1, r1, #20
 8021774:	f44a 1a80 	orr.w	sl, sl, #1048576	@ 0x100000
 8021778:	fa4a fa01 	asr.w	sl, sl, r1
 802177c:	f1bb 0f00 	cmp.w	fp, #0
 8021780:	4640      	mov	r0, r8
 8021782:	4649      	mov	r1, r9
 8021784:	f04f 0200 	mov.w	r2, #0
 8021788:	bfb8      	it	lt
 802178a:	f1ca 0a00 	rsblt	sl, sl, #0
 802178e:	f7de fd83 	bl	8000298 <__aeabi_dsub>
 8021792:	4680      	mov	r8, r0
 8021794:	4689      	mov	r9, r1
 8021796:	4632      	mov	r2, r6
 8021798:	463b      	mov	r3, r7
 802179a:	4640      	mov	r0, r8
 802179c:	4649      	mov	r1, r9
 802179e:	f7de fd7d 	bl	800029c <__adddf3>
 80217a2:	2400      	movs	r4, #0
 80217a4:	a37c      	add	r3, pc, #496	@ (adr r3, 8021998 <__ieee754_pow+0xa28>)
 80217a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80217aa:	4620      	mov	r0, r4
 80217ac:	460d      	mov	r5, r1
 80217ae:	f7de ff2b 	bl	8000608 <__aeabi_dmul>
 80217b2:	4642      	mov	r2, r8
 80217b4:	e9cd 0100 	strd	r0, r1, [sp]
 80217b8:	464b      	mov	r3, r9
 80217ba:	4620      	mov	r0, r4
 80217bc:	4629      	mov	r1, r5
 80217be:	f7de fd6b 	bl	8000298 <__aeabi_dsub>
 80217c2:	4602      	mov	r2, r0
 80217c4:	460b      	mov	r3, r1
 80217c6:	4630      	mov	r0, r6
 80217c8:	4639      	mov	r1, r7
 80217ca:	f7de fd65 	bl	8000298 <__aeabi_dsub>
 80217ce:	a374      	add	r3, pc, #464	@ (adr r3, 80219a0 <__ieee754_pow+0xa30>)
 80217d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80217d4:	f7de ff18 	bl	8000608 <__aeabi_dmul>
 80217d8:	a373      	add	r3, pc, #460	@ (adr r3, 80219a8 <__ieee754_pow+0xa38>)
 80217da:	e9d3 2300 	ldrd	r2, r3, [r3]
 80217de:	4680      	mov	r8, r0
 80217e0:	4689      	mov	r9, r1
 80217e2:	4620      	mov	r0, r4
 80217e4:	4629      	mov	r1, r5
 80217e6:	f7de ff0f 	bl	8000608 <__aeabi_dmul>
 80217ea:	4602      	mov	r2, r0
 80217ec:	460b      	mov	r3, r1
 80217ee:	4640      	mov	r0, r8
 80217f0:	4649      	mov	r1, r9
 80217f2:	f7de fd53 	bl	800029c <__adddf3>
 80217f6:	4604      	mov	r4, r0
 80217f8:	460d      	mov	r5, r1
 80217fa:	4602      	mov	r2, r0
 80217fc:	460b      	mov	r3, r1
 80217fe:	e9dd 0100 	ldrd	r0, r1, [sp]
 8021802:	f7de fd4b 	bl	800029c <__adddf3>
 8021806:	e9dd 2300 	ldrd	r2, r3, [sp]
 802180a:	4680      	mov	r8, r0
 802180c:	4689      	mov	r9, r1
 802180e:	f7de fd43 	bl	8000298 <__aeabi_dsub>
 8021812:	4602      	mov	r2, r0
 8021814:	460b      	mov	r3, r1
 8021816:	4620      	mov	r0, r4
 8021818:	4629      	mov	r1, r5
 802181a:	f7de fd3d 	bl	8000298 <__aeabi_dsub>
 802181e:	4642      	mov	r2, r8
 8021820:	4606      	mov	r6, r0
 8021822:	460f      	mov	r7, r1
 8021824:	464b      	mov	r3, r9
 8021826:	4640      	mov	r0, r8
 8021828:	4649      	mov	r1, r9
 802182a:	f7de feed 	bl	8000608 <__aeabi_dmul>
 802182e:	a360      	add	r3, pc, #384	@ (adr r3, 80219b0 <__ieee754_pow+0xa40>)
 8021830:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021834:	4604      	mov	r4, r0
 8021836:	460d      	mov	r5, r1
 8021838:	f7de fee6 	bl	8000608 <__aeabi_dmul>
 802183c:	a35e      	add	r3, pc, #376	@ (adr r3, 80219b8 <__ieee754_pow+0xa48>)
 802183e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021842:	f7de fd29 	bl	8000298 <__aeabi_dsub>
 8021846:	4622      	mov	r2, r4
 8021848:	462b      	mov	r3, r5
 802184a:	f7de fedd 	bl	8000608 <__aeabi_dmul>
 802184e:	a35c      	add	r3, pc, #368	@ (adr r3, 80219c0 <__ieee754_pow+0xa50>)
 8021850:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021854:	f7de fd22 	bl	800029c <__adddf3>
 8021858:	4622      	mov	r2, r4
 802185a:	462b      	mov	r3, r5
 802185c:	f7de fed4 	bl	8000608 <__aeabi_dmul>
 8021860:	a359      	add	r3, pc, #356	@ (adr r3, 80219c8 <__ieee754_pow+0xa58>)
 8021862:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021866:	f7de fd17 	bl	8000298 <__aeabi_dsub>
 802186a:	4622      	mov	r2, r4
 802186c:	462b      	mov	r3, r5
 802186e:	f7de fecb 	bl	8000608 <__aeabi_dmul>
 8021872:	a357      	add	r3, pc, #348	@ (adr r3, 80219d0 <__ieee754_pow+0xa60>)
 8021874:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021878:	f7de fd10 	bl	800029c <__adddf3>
 802187c:	4622      	mov	r2, r4
 802187e:	462b      	mov	r3, r5
 8021880:	f7de fec2 	bl	8000608 <__aeabi_dmul>
 8021884:	4602      	mov	r2, r0
 8021886:	460b      	mov	r3, r1
 8021888:	4640      	mov	r0, r8
 802188a:	4649      	mov	r1, r9
 802188c:	f7de fd04 	bl	8000298 <__aeabi_dsub>
 8021890:	4604      	mov	r4, r0
 8021892:	460d      	mov	r5, r1
 8021894:	4602      	mov	r2, r0
 8021896:	460b      	mov	r3, r1
 8021898:	4640      	mov	r0, r8
 802189a:	4649      	mov	r1, r9
 802189c:	f7de feb4 	bl	8000608 <__aeabi_dmul>
 80218a0:	2200      	movs	r2, #0
 80218a2:	e9cd 0100 	strd	r0, r1, [sp]
 80218a6:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80218aa:	4620      	mov	r0, r4
 80218ac:	4629      	mov	r1, r5
 80218ae:	f7de fcf3 	bl	8000298 <__aeabi_dsub>
 80218b2:	4602      	mov	r2, r0
 80218b4:	460b      	mov	r3, r1
 80218b6:	e9dd 0100 	ldrd	r0, r1, [sp]
 80218ba:	f7de ffcf 	bl	800085c <__aeabi_ddiv>
 80218be:	4632      	mov	r2, r6
 80218c0:	4604      	mov	r4, r0
 80218c2:	460d      	mov	r5, r1
 80218c4:	463b      	mov	r3, r7
 80218c6:	4640      	mov	r0, r8
 80218c8:	4649      	mov	r1, r9
 80218ca:	f7de fe9d 	bl	8000608 <__aeabi_dmul>
 80218ce:	4632      	mov	r2, r6
 80218d0:	463b      	mov	r3, r7
 80218d2:	f7de fce3 	bl	800029c <__adddf3>
 80218d6:	4602      	mov	r2, r0
 80218d8:	460b      	mov	r3, r1
 80218da:	4620      	mov	r0, r4
 80218dc:	4629      	mov	r1, r5
 80218de:	f7de fcdb 	bl	8000298 <__aeabi_dsub>
 80218e2:	4642      	mov	r2, r8
 80218e4:	464b      	mov	r3, r9
 80218e6:	f7de fcd7 	bl	8000298 <__aeabi_dsub>
 80218ea:	460b      	mov	r3, r1
 80218ec:	4602      	mov	r2, r0
 80218ee:	493b      	ldr	r1, [pc, #236]	@ (80219dc <__ieee754_pow+0xa6c>)
 80218f0:	2000      	movs	r0, #0
 80218f2:	f7de fcd1 	bl	8000298 <__aeabi_dsub>
 80218f6:	ec41 0b10 	vmov	d0, r0, r1
 80218fa:	ee10 3a90 	vmov	r3, s1
 80218fe:	eb03 530a 	add.w	r3, r3, sl, lsl #20
 8021902:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8021906:	da30      	bge.n	802196a <__ieee754_pow+0x9fa>
 8021908:	4650      	mov	r0, sl
 802190a:	f001 f915 	bl	8022b38 <scalbn>
 802190e:	ec51 0b10 	vmov	r0, r1, d0
 8021912:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8021916:	f7ff bbd2 	b.w	80210be <__ieee754_pow+0x14e>
 802191a:	4c31      	ldr	r4, [pc, #196]	@ (80219e0 <__ieee754_pow+0xa70>)
 802191c:	f021 4300 	bic.w	r3, r1, #2147483648	@ 0x80000000
 8021920:	42a3      	cmp	r3, r4
 8021922:	d91a      	bls.n	802195a <__ieee754_pow+0x9ea>
 8021924:	4b2f      	ldr	r3, [pc, #188]	@ (80219e4 <__ieee754_pow+0xa74>)
 8021926:	440b      	add	r3, r1
 8021928:	4303      	orrs	r3, r0
 802192a:	d009      	beq.n	8021940 <__ieee754_pow+0x9d0>
 802192c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021930:	2200      	movs	r2, #0
 8021932:	2300      	movs	r3, #0
 8021934:	f7df f8da 	bl	8000aec <__aeabi_dcmplt>
 8021938:	3800      	subs	r0, #0
 802193a:	bf18      	it	ne
 802193c:	2001      	movne	r0, #1
 802193e:	e42b      	b.n	8021198 <__ieee754_pow+0x228>
 8021940:	4642      	mov	r2, r8
 8021942:	464b      	mov	r3, r9
 8021944:	f7de fca8 	bl	8000298 <__aeabi_dsub>
 8021948:	4632      	mov	r2, r6
 802194a:	463b      	mov	r3, r7
 802194c:	f7df f8e2 	bl	8000b14 <__aeabi_dcmpge>
 8021950:	2800      	cmp	r0, #0
 8021952:	d1eb      	bne.n	802192c <__ieee754_pow+0x9bc>
 8021954:	f8df a09c 	ldr.w	sl, [pc, #156]	@ 80219f4 <__ieee754_pow+0xa84>
 8021958:	e6f7      	b.n	802174a <__ieee754_pow+0x7da>
 802195a:	469a      	mov	sl, r3
 802195c:	4b22      	ldr	r3, [pc, #136]	@ (80219e8 <__ieee754_pow+0xa78>)
 802195e:	459a      	cmp	sl, r3
 8021960:	f63f aef3 	bhi.w	802174a <__ieee754_pow+0x7da>
 8021964:	f8dd a010 	ldr.w	sl, [sp, #16]
 8021968:	e715      	b.n	8021796 <__ieee754_pow+0x826>
 802196a:	ec51 0b10 	vmov	r0, r1, d0
 802196e:	4619      	mov	r1, r3
 8021970:	e7cf      	b.n	8021912 <__ieee754_pow+0x9a2>
 8021972:	491a      	ldr	r1, [pc, #104]	@ (80219dc <__ieee754_pow+0xa6c>)
 8021974:	2000      	movs	r0, #0
 8021976:	f7ff bb18 	b.w	8020faa <__ieee754_pow+0x3a>
 802197a:	2000      	movs	r0, #0
 802197c:	2100      	movs	r1, #0
 802197e:	f7ff bb14 	b.w	8020faa <__ieee754_pow+0x3a>
 8021982:	4630      	mov	r0, r6
 8021984:	4639      	mov	r1, r7
 8021986:	f7ff bb10 	b.w	8020faa <__ieee754_pow+0x3a>
 802198a:	460c      	mov	r4, r1
 802198c:	f7ff bb5e 	b.w	802104c <__ieee754_pow+0xdc>
 8021990:	2400      	movs	r4, #0
 8021992:	f7ff bb49 	b.w	8021028 <__ieee754_pow+0xb8>
 8021996:	bf00      	nop
 8021998:	00000000 	.word	0x00000000
 802199c:	3fe62e43 	.word	0x3fe62e43
 80219a0:	fefa39ef 	.word	0xfefa39ef
 80219a4:	3fe62e42 	.word	0x3fe62e42
 80219a8:	0ca86c39 	.word	0x0ca86c39
 80219ac:	be205c61 	.word	0xbe205c61
 80219b0:	72bea4d0 	.word	0x72bea4d0
 80219b4:	3e663769 	.word	0x3e663769
 80219b8:	c5d26bf1 	.word	0xc5d26bf1
 80219bc:	3ebbbd41 	.word	0x3ebbbd41
 80219c0:	af25de2c 	.word	0xaf25de2c
 80219c4:	3f11566a 	.word	0x3f11566a
 80219c8:	16bebd93 	.word	0x16bebd93
 80219cc:	3f66c16c 	.word	0x3f66c16c
 80219d0:	5555553e 	.word	0x5555553e
 80219d4:	3fc55555 	.word	0x3fc55555
 80219d8:	fff00000 	.word	0xfff00000
 80219dc:	3ff00000 	.word	0x3ff00000
 80219e0:	4090cbff 	.word	0x4090cbff
 80219e4:	3f6f3400 	.word	0x3f6f3400
 80219e8:	3fe00000 	.word	0x3fe00000
 80219ec:	652b82fe 	.word	0x652b82fe
 80219f0:	3c971547 	.word	0x3c971547
 80219f4:	4090cc00 	.word	0x4090cc00

080219f8 <__ieee754_rem_pio2>:
 80219f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80219fc:	ec57 6b10 	vmov	r6, r7, d0
 8021a00:	4bc5      	ldr	r3, [pc, #788]	@ (8021d18 <__ieee754_rem_pio2+0x320>)
 8021a02:	b08d      	sub	sp, #52	@ 0x34
 8021a04:	f027 4800 	bic.w	r8, r7, #2147483648	@ 0x80000000
 8021a08:	4598      	cmp	r8, r3
 8021a0a:	4604      	mov	r4, r0
 8021a0c:	9704      	str	r7, [sp, #16]
 8021a0e:	d807      	bhi.n	8021a20 <__ieee754_rem_pio2+0x28>
 8021a10:	2200      	movs	r2, #0
 8021a12:	2300      	movs	r3, #0
 8021a14:	ed80 0b00 	vstr	d0, [r0]
 8021a18:	e9c0 2302 	strd	r2, r3, [r0, #8]
 8021a1c:	2500      	movs	r5, #0
 8021a1e:	e028      	b.n	8021a72 <__ieee754_rem_pio2+0x7a>
 8021a20:	4bbe      	ldr	r3, [pc, #760]	@ (8021d1c <__ieee754_rem_pio2+0x324>)
 8021a22:	4598      	cmp	r8, r3
 8021a24:	d878      	bhi.n	8021b18 <__ieee754_rem_pio2+0x120>
 8021a26:	9b04      	ldr	r3, [sp, #16]
 8021a28:	4dbd      	ldr	r5, [pc, #756]	@ (8021d20 <__ieee754_rem_pio2+0x328>)
 8021a2a:	2b00      	cmp	r3, #0
 8021a2c:	4630      	mov	r0, r6
 8021a2e:	a3ac      	add	r3, pc, #688	@ (adr r3, 8021ce0 <__ieee754_rem_pio2+0x2e8>)
 8021a30:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021a34:	4639      	mov	r1, r7
 8021a36:	dd38      	ble.n	8021aaa <__ieee754_rem_pio2+0xb2>
 8021a38:	f7de fc2e 	bl	8000298 <__aeabi_dsub>
 8021a3c:	45a8      	cmp	r8, r5
 8021a3e:	4606      	mov	r6, r0
 8021a40:	460f      	mov	r7, r1
 8021a42:	d01a      	beq.n	8021a7a <__ieee754_rem_pio2+0x82>
 8021a44:	a3a8      	add	r3, pc, #672	@ (adr r3, 8021ce8 <__ieee754_rem_pio2+0x2f0>)
 8021a46:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021a4a:	f7de fc25 	bl	8000298 <__aeabi_dsub>
 8021a4e:	4602      	mov	r2, r0
 8021a50:	460b      	mov	r3, r1
 8021a52:	4680      	mov	r8, r0
 8021a54:	4689      	mov	r9, r1
 8021a56:	4630      	mov	r0, r6
 8021a58:	4639      	mov	r1, r7
 8021a5a:	f7de fc1d 	bl	8000298 <__aeabi_dsub>
 8021a5e:	a3a2      	add	r3, pc, #648	@ (adr r3, 8021ce8 <__ieee754_rem_pio2+0x2f0>)
 8021a60:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021a64:	f7de fc18 	bl	8000298 <__aeabi_dsub>
 8021a68:	e9c4 8900 	strd	r8, r9, [r4]
 8021a6c:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8021a70:	2501      	movs	r5, #1
 8021a72:	4628      	mov	r0, r5
 8021a74:	b00d      	add	sp, #52	@ 0x34
 8021a76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021a7a:	a39d      	add	r3, pc, #628	@ (adr r3, 8021cf0 <__ieee754_rem_pio2+0x2f8>)
 8021a7c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021a80:	f7de fc0a 	bl	8000298 <__aeabi_dsub>
 8021a84:	a39c      	add	r3, pc, #624	@ (adr r3, 8021cf8 <__ieee754_rem_pio2+0x300>)
 8021a86:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021a8a:	4606      	mov	r6, r0
 8021a8c:	460f      	mov	r7, r1
 8021a8e:	f7de fc03 	bl	8000298 <__aeabi_dsub>
 8021a92:	4602      	mov	r2, r0
 8021a94:	460b      	mov	r3, r1
 8021a96:	4680      	mov	r8, r0
 8021a98:	4689      	mov	r9, r1
 8021a9a:	4630      	mov	r0, r6
 8021a9c:	4639      	mov	r1, r7
 8021a9e:	f7de fbfb 	bl	8000298 <__aeabi_dsub>
 8021aa2:	a395      	add	r3, pc, #596	@ (adr r3, 8021cf8 <__ieee754_rem_pio2+0x300>)
 8021aa4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021aa8:	e7dc      	b.n	8021a64 <__ieee754_rem_pio2+0x6c>
 8021aaa:	f7de fbf7 	bl	800029c <__adddf3>
 8021aae:	45a8      	cmp	r8, r5
 8021ab0:	4606      	mov	r6, r0
 8021ab2:	460f      	mov	r7, r1
 8021ab4:	d018      	beq.n	8021ae8 <__ieee754_rem_pio2+0xf0>
 8021ab6:	a38c      	add	r3, pc, #560	@ (adr r3, 8021ce8 <__ieee754_rem_pio2+0x2f0>)
 8021ab8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021abc:	f7de fbee 	bl	800029c <__adddf3>
 8021ac0:	4602      	mov	r2, r0
 8021ac2:	460b      	mov	r3, r1
 8021ac4:	4680      	mov	r8, r0
 8021ac6:	4689      	mov	r9, r1
 8021ac8:	4630      	mov	r0, r6
 8021aca:	4639      	mov	r1, r7
 8021acc:	f7de fbe4 	bl	8000298 <__aeabi_dsub>
 8021ad0:	a385      	add	r3, pc, #532	@ (adr r3, 8021ce8 <__ieee754_rem_pio2+0x2f0>)
 8021ad2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021ad6:	f7de fbe1 	bl	800029c <__adddf3>
 8021ada:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 8021ade:	e9c4 8900 	strd	r8, r9, [r4]
 8021ae2:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8021ae6:	e7c4      	b.n	8021a72 <__ieee754_rem_pio2+0x7a>
 8021ae8:	a381      	add	r3, pc, #516	@ (adr r3, 8021cf0 <__ieee754_rem_pio2+0x2f8>)
 8021aea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021aee:	f7de fbd5 	bl	800029c <__adddf3>
 8021af2:	a381      	add	r3, pc, #516	@ (adr r3, 8021cf8 <__ieee754_rem_pio2+0x300>)
 8021af4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021af8:	4606      	mov	r6, r0
 8021afa:	460f      	mov	r7, r1
 8021afc:	f7de fbce 	bl	800029c <__adddf3>
 8021b00:	4602      	mov	r2, r0
 8021b02:	460b      	mov	r3, r1
 8021b04:	4680      	mov	r8, r0
 8021b06:	4689      	mov	r9, r1
 8021b08:	4630      	mov	r0, r6
 8021b0a:	4639      	mov	r1, r7
 8021b0c:	f7de fbc4 	bl	8000298 <__aeabi_dsub>
 8021b10:	a379      	add	r3, pc, #484	@ (adr r3, 8021cf8 <__ieee754_rem_pio2+0x300>)
 8021b12:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021b16:	e7de      	b.n	8021ad6 <__ieee754_rem_pio2+0xde>
 8021b18:	4b82      	ldr	r3, [pc, #520]	@ (8021d24 <__ieee754_rem_pio2+0x32c>)
 8021b1a:	4598      	cmp	r8, r3
 8021b1c:	f200 80d1 	bhi.w	8021cc2 <__ieee754_rem_pio2+0x2ca>
 8021b20:	f7fd fe0e 	bl	801f740 <fabs>
 8021b24:	ec57 6b10 	vmov	r6, r7, d0
 8021b28:	a375      	add	r3, pc, #468	@ (adr r3, 8021d00 <__ieee754_rem_pio2+0x308>)
 8021b2a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021b2e:	4630      	mov	r0, r6
 8021b30:	4639      	mov	r1, r7
 8021b32:	f7de fd69 	bl	8000608 <__aeabi_dmul>
 8021b36:	4b7c      	ldr	r3, [pc, #496]	@ (8021d28 <__ieee754_rem_pio2+0x330>)
 8021b38:	2200      	movs	r2, #0
 8021b3a:	f7de fbaf 	bl	800029c <__adddf3>
 8021b3e:	f7df f813 	bl	8000b68 <__aeabi_d2iz>
 8021b42:	4605      	mov	r5, r0
 8021b44:	f7de fcf6 	bl	8000534 <__aeabi_i2d>
 8021b48:	4602      	mov	r2, r0
 8021b4a:	460b      	mov	r3, r1
 8021b4c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8021b50:	a363      	add	r3, pc, #396	@ (adr r3, 8021ce0 <__ieee754_rem_pio2+0x2e8>)
 8021b52:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021b56:	f7de fd57 	bl	8000608 <__aeabi_dmul>
 8021b5a:	4602      	mov	r2, r0
 8021b5c:	460b      	mov	r3, r1
 8021b5e:	4630      	mov	r0, r6
 8021b60:	4639      	mov	r1, r7
 8021b62:	f7de fb99 	bl	8000298 <__aeabi_dsub>
 8021b66:	a360      	add	r3, pc, #384	@ (adr r3, 8021ce8 <__ieee754_rem_pio2+0x2f0>)
 8021b68:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021b6c:	4682      	mov	sl, r0
 8021b6e:	468b      	mov	fp, r1
 8021b70:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021b74:	f7de fd48 	bl	8000608 <__aeabi_dmul>
 8021b78:	2d1f      	cmp	r5, #31
 8021b7a:	4606      	mov	r6, r0
 8021b7c:	460f      	mov	r7, r1
 8021b7e:	dc0c      	bgt.n	8021b9a <__ieee754_rem_pio2+0x1a2>
 8021b80:	4b6a      	ldr	r3, [pc, #424]	@ (8021d2c <__ieee754_rem_pio2+0x334>)
 8021b82:	1e6a      	subs	r2, r5, #1
 8021b84:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8021b88:	4543      	cmp	r3, r8
 8021b8a:	d006      	beq.n	8021b9a <__ieee754_rem_pio2+0x1a2>
 8021b8c:	4632      	mov	r2, r6
 8021b8e:	463b      	mov	r3, r7
 8021b90:	4650      	mov	r0, sl
 8021b92:	4659      	mov	r1, fp
 8021b94:	f7de fb80 	bl	8000298 <__aeabi_dsub>
 8021b98:	e00e      	b.n	8021bb8 <__ieee754_rem_pio2+0x1c0>
 8021b9a:	463b      	mov	r3, r7
 8021b9c:	4632      	mov	r2, r6
 8021b9e:	4650      	mov	r0, sl
 8021ba0:	4659      	mov	r1, fp
 8021ba2:	f7de fb79 	bl	8000298 <__aeabi_dsub>
 8021ba6:	ea4f 5328 	mov.w	r3, r8, asr #20
 8021baa:	9305      	str	r3, [sp, #20]
 8021bac:	f3c1 530a 	ubfx	r3, r1, #20, #11
 8021bb0:	ebc3 5318 	rsb	r3, r3, r8, lsr #20
 8021bb4:	2b10      	cmp	r3, #16
 8021bb6:	dc02      	bgt.n	8021bbe <__ieee754_rem_pio2+0x1c6>
 8021bb8:	e9c4 0100 	strd	r0, r1, [r4]
 8021bbc:	e039      	b.n	8021c32 <__ieee754_rem_pio2+0x23a>
 8021bbe:	a34c      	add	r3, pc, #304	@ (adr r3, 8021cf0 <__ieee754_rem_pio2+0x2f8>)
 8021bc0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021bc4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021bc8:	f7de fd1e 	bl	8000608 <__aeabi_dmul>
 8021bcc:	4606      	mov	r6, r0
 8021bce:	460f      	mov	r7, r1
 8021bd0:	4602      	mov	r2, r0
 8021bd2:	460b      	mov	r3, r1
 8021bd4:	4650      	mov	r0, sl
 8021bd6:	4659      	mov	r1, fp
 8021bd8:	f7de fb5e 	bl	8000298 <__aeabi_dsub>
 8021bdc:	4602      	mov	r2, r0
 8021bde:	460b      	mov	r3, r1
 8021be0:	4680      	mov	r8, r0
 8021be2:	4689      	mov	r9, r1
 8021be4:	4650      	mov	r0, sl
 8021be6:	4659      	mov	r1, fp
 8021be8:	f7de fb56 	bl	8000298 <__aeabi_dsub>
 8021bec:	4632      	mov	r2, r6
 8021bee:	463b      	mov	r3, r7
 8021bf0:	f7de fb52 	bl	8000298 <__aeabi_dsub>
 8021bf4:	a340      	add	r3, pc, #256	@ (adr r3, 8021cf8 <__ieee754_rem_pio2+0x300>)
 8021bf6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021bfa:	4606      	mov	r6, r0
 8021bfc:	460f      	mov	r7, r1
 8021bfe:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021c02:	f7de fd01 	bl	8000608 <__aeabi_dmul>
 8021c06:	4632      	mov	r2, r6
 8021c08:	463b      	mov	r3, r7
 8021c0a:	f7de fb45 	bl	8000298 <__aeabi_dsub>
 8021c0e:	4602      	mov	r2, r0
 8021c10:	460b      	mov	r3, r1
 8021c12:	4606      	mov	r6, r0
 8021c14:	460f      	mov	r7, r1
 8021c16:	4640      	mov	r0, r8
 8021c18:	4649      	mov	r1, r9
 8021c1a:	f7de fb3d 	bl	8000298 <__aeabi_dsub>
 8021c1e:	9a05      	ldr	r2, [sp, #20]
 8021c20:	f3c1 530a 	ubfx	r3, r1, #20, #11
 8021c24:	1ad3      	subs	r3, r2, r3
 8021c26:	2b31      	cmp	r3, #49	@ 0x31
 8021c28:	dc20      	bgt.n	8021c6c <__ieee754_rem_pio2+0x274>
 8021c2a:	e9c4 0100 	strd	r0, r1, [r4]
 8021c2e:	46c2      	mov	sl, r8
 8021c30:	46cb      	mov	fp, r9
 8021c32:	e9d4 8900 	ldrd	r8, r9, [r4]
 8021c36:	4650      	mov	r0, sl
 8021c38:	4642      	mov	r2, r8
 8021c3a:	464b      	mov	r3, r9
 8021c3c:	4659      	mov	r1, fp
 8021c3e:	f7de fb2b 	bl	8000298 <__aeabi_dsub>
 8021c42:	463b      	mov	r3, r7
 8021c44:	4632      	mov	r2, r6
 8021c46:	f7de fb27 	bl	8000298 <__aeabi_dsub>
 8021c4a:	9b04      	ldr	r3, [sp, #16]
 8021c4c:	2b00      	cmp	r3, #0
 8021c4e:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8021c52:	f6bf af0e 	bge.w	8021a72 <__ieee754_rem_pio2+0x7a>
 8021c56:	f109 4300 	add.w	r3, r9, #2147483648	@ 0x80000000
 8021c5a:	6063      	str	r3, [r4, #4]
 8021c5c:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8021c60:	f8c4 8000 	str.w	r8, [r4]
 8021c64:	60a0      	str	r0, [r4, #8]
 8021c66:	60e3      	str	r3, [r4, #12]
 8021c68:	426d      	negs	r5, r5
 8021c6a:	e702      	b.n	8021a72 <__ieee754_rem_pio2+0x7a>
 8021c6c:	a326      	add	r3, pc, #152	@ (adr r3, 8021d08 <__ieee754_rem_pio2+0x310>)
 8021c6e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021c72:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021c76:	f7de fcc7 	bl	8000608 <__aeabi_dmul>
 8021c7a:	4606      	mov	r6, r0
 8021c7c:	460f      	mov	r7, r1
 8021c7e:	4602      	mov	r2, r0
 8021c80:	460b      	mov	r3, r1
 8021c82:	4640      	mov	r0, r8
 8021c84:	4649      	mov	r1, r9
 8021c86:	f7de fb07 	bl	8000298 <__aeabi_dsub>
 8021c8a:	4602      	mov	r2, r0
 8021c8c:	460b      	mov	r3, r1
 8021c8e:	4682      	mov	sl, r0
 8021c90:	468b      	mov	fp, r1
 8021c92:	4640      	mov	r0, r8
 8021c94:	4649      	mov	r1, r9
 8021c96:	f7de faff 	bl	8000298 <__aeabi_dsub>
 8021c9a:	4632      	mov	r2, r6
 8021c9c:	463b      	mov	r3, r7
 8021c9e:	f7de fafb 	bl	8000298 <__aeabi_dsub>
 8021ca2:	a31b      	add	r3, pc, #108	@ (adr r3, 8021d10 <__ieee754_rem_pio2+0x318>)
 8021ca4:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021ca8:	4606      	mov	r6, r0
 8021caa:	460f      	mov	r7, r1
 8021cac:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021cb0:	f7de fcaa 	bl	8000608 <__aeabi_dmul>
 8021cb4:	4632      	mov	r2, r6
 8021cb6:	463b      	mov	r3, r7
 8021cb8:	f7de faee 	bl	8000298 <__aeabi_dsub>
 8021cbc:	4606      	mov	r6, r0
 8021cbe:	460f      	mov	r7, r1
 8021cc0:	e764      	b.n	8021b8c <__ieee754_rem_pio2+0x194>
 8021cc2:	4b1b      	ldr	r3, [pc, #108]	@ (8021d30 <__ieee754_rem_pio2+0x338>)
 8021cc4:	4598      	cmp	r8, r3
 8021cc6:	d935      	bls.n	8021d34 <__ieee754_rem_pio2+0x33c>
 8021cc8:	4632      	mov	r2, r6
 8021cca:	463b      	mov	r3, r7
 8021ccc:	4630      	mov	r0, r6
 8021cce:	4639      	mov	r1, r7
 8021cd0:	f7de fae2 	bl	8000298 <__aeabi_dsub>
 8021cd4:	e9c4 0102 	strd	r0, r1, [r4, #8]
 8021cd8:	e9c4 0100 	strd	r0, r1, [r4]
 8021cdc:	e69e      	b.n	8021a1c <__ieee754_rem_pio2+0x24>
 8021cde:	bf00      	nop
 8021ce0:	54400000 	.word	0x54400000
 8021ce4:	3ff921fb 	.word	0x3ff921fb
 8021ce8:	1a626331 	.word	0x1a626331
 8021cec:	3dd0b461 	.word	0x3dd0b461
 8021cf0:	1a600000 	.word	0x1a600000
 8021cf4:	3dd0b461 	.word	0x3dd0b461
 8021cf8:	2e037073 	.word	0x2e037073
 8021cfc:	3ba3198a 	.word	0x3ba3198a
 8021d00:	6dc9c883 	.word	0x6dc9c883
 8021d04:	3fe45f30 	.word	0x3fe45f30
 8021d08:	2e000000 	.word	0x2e000000
 8021d0c:	3ba3198a 	.word	0x3ba3198a
 8021d10:	252049c1 	.word	0x252049c1
 8021d14:	397b839a 	.word	0x397b839a
 8021d18:	3fe921fb 	.word	0x3fe921fb
 8021d1c:	4002d97b 	.word	0x4002d97b
 8021d20:	3ff921fb 	.word	0x3ff921fb
 8021d24:	413921fb 	.word	0x413921fb
 8021d28:	3fe00000 	.word	0x3fe00000
 8021d2c:	08023e18 	.word	0x08023e18
 8021d30:	7fefffff 	.word	0x7fefffff
 8021d34:	ea4f 5528 	mov.w	r5, r8, asr #20
 8021d38:	f2a5 4516 	subw	r5, r5, #1046	@ 0x416
 8021d3c:	eba8 5105 	sub.w	r1, r8, r5, lsl #20
 8021d40:	4630      	mov	r0, r6
 8021d42:	460f      	mov	r7, r1
 8021d44:	f7de ff10 	bl	8000b68 <__aeabi_d2iz>
 8021d48:	f7de fbf4 	bl	8000534 <__aeabi_i2d>
 8021d4c:	4602      	mov	r2, r0
 8021d4e:	460b      	mov	r3, r1
 8021d50:	4630      	mov	r0, r6
 8021d52:	4639      	mov	r1, r7
 8021d54:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8021d58:	f7de fa9e 	bl	8000298 <__aeabi_dsub>
 8021d5c:	4b22      	ldr	r3, [pc, #136]	@ (8021de8 <__ieee754_rem_pio2+0x3f0>)
 8021d5e:	2200      	movs	r2, #0
 8021d60:	f7de fc52 	bl	8000608 <__aeabi_dmul>
 8021d64:	460f      	mov	r7, r1
 8021d66:	4606      	mov	r6, r0
 8021d68:	f7de fefe 	bl	8000b68 <__aeabi_d2iz>
 8021d6c:	f7de fbe2 	bl	8000534 <__aeabi_i2d>
 8021d70:	4602      	mov	r2, r0
 8021d72:	460b      	mov	r3, r1
 8021d74:	4630      	mov	r0, r6
 8021d76:	4639      	mov	r1, r7
 8021d78:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8021d7c:	f7de fa8c 	bl	8000298 <__aeabi_dsub>
 8021d80:	4b19      	ldr	r3, [pc, #100]	@ (8021de8 <__ieee754_rem_pio2+0x3f0>)
 8021d82:	2200      	movs	r2, #0
 8021d84:	f7de fc40 	bl	8000608 <__aeabi_dmul>
 8021d88:	e9cd 010a 	strd	r0, r1, [sp, #40]	@ 0x28
 8021d8c:	f10d 0930 	add.w	r9, sp, #48	@ 0x30
 8021d90:	f04f 0803 	mov.w	r8, #3
 8021d94:	2600      	movs	r6, #0
 8021d96:	2700      	movs	r7, #0
 8021d98:	e979 0102 	ldrd	r0, r1, [r9, #-8]!
 8021d9c:	4632      	mov	r2, r6
 8021d9e:	463b      	mov	r3, r7
 8021da0:	46c2      	mov	sl, r8
 8021da2:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
 8021da6:	f7de fe97 	bl	8000ad8 <__aeabi_dcmpeq>
 8021daa:	2800      	cmp	r0, #0
 8021dac:	d1f4      	bne.n	8021d98 <__ieee754_rem_pio2+0x3a0>
 8021dae:	4b0f      	ldr	r3, [pc, #60]	@ (8021dec <__ieee754_rem_pio2+0x3f4>)
 8021db0:	9301      	str	r3, [sp, #4]
 8021db2:	2302      	movs	r3, #2
 8021db4:	9300      	str	r3, [sp, #0]
 8021db6:	462a      	mov	r2, r5
 8021db8:	4653      	mov	r3, sl
 8021dba:	4621      	mov	r1, r4
 8021dbc:	a806      	add	r0, sp, #24
 8021dbe:	f000 ff7b 	bl	8022cb8 <__kernel_rem_pio2>
 8021dc2:	9b04      	ldr	r3, [sp, #16]
 8021dc4:	2b00      	cmp	r3, #0
 8021dc6:	4605      	mov	r5, r0
 8021dc8:	f6bf ae53 	bge.w	8021a72 <__ieee754_rem_pio2+0x7a>
 8021dcc:	e9d4 2100 	ldrd	r2, r1, [r4]
 8021dd0:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8021dd4:	e9c4 2300 	strd	r2, r3, [r4]
 8021dd8:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
 8021ddc:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8021de0:	e9c4 2302 	strd	r2, r3, [r4, #8]
 8021de4:	e740      	b.n	8021c68 <__ieee754_rem_pio2+0x270>
 8021de6:	bf00      	nop
 8021de8:	41700000 	.word	0x41700000
 8021dec:	08023e98 	.word	0x08023e98

08021df0 <atan>:
 8021df0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021df4:	ec55 4b10 	vmov	r4, r5, d0
 8021df8:	4bbf      	ldr	r3, [pc, #764]	@ (80220f8 <atan+0x308>)
 8021dfa:	f025 4600 	bic.w	r6, r5, #2147483648	@ 0x80000000
 8021dfe:	429e      	cmp	r6, r3
 8021e00:	46ab      	mov	fp, r5
 8021e02:	d918      	bls.n	8021e36 <atan+0x46>
 8021e04:	4bbd      	ldr	r3, [pc, #756]	@ (80220fc <atan+0x30c>)
 8021e06:	429e      	cmp	r6, r3
 8021e08:	d801      	bhi.n	8021e0e <atan+0x1e>
 8021e0a:	d109      	bne.n	8021e20 <atan+0x30>
 8021e0c:	b144      	cbz	r4, 8021e20 <atan+0x30>
 8021e0e:	4622      	mov	r2, r4
 8021e10:	462b      	mov	r3, r5
 8021e12:	4620      	mov	r0, r4
 8021e14:	4629      	mov	r1, r5
 8021e16:	f7de fa41 	bl	800029c <__adddf3>
 8021e1a:	4604      	mov	r4, r0
 8021e1c:	460d      	mov	r5, r1
 8021e1e:	e006      	b.n	8021e2e <atan+0x3e>
 8021e20:	f1bb 0f00 	cmp.w	fp, #0
 8021e24:	f340 812b 	ble.w	802207e <atan+0x28e>
 8021e28:	a597      	add	r5, pc, #604	@ (adr r5, 8022088 <atan+0x298>)
 8021e2a:	e9d5 4500 	ldrd	r4, r5, [r5]
 8021e2e:	ec45 4b10 	vmov	d0, r4, r5
 8021e32:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8021e36:	4bb2      	ldr	r3, [pc, #712]	@ (8022100 <atan+0x310>)
 8021e38:	429e      	cmp	r6, r3
 8021e3a:	d813      	bhi.n	8021e64 <atan+0x74>
 8021e3c:	f1a3 73de 	sub.w	r3, r3, #29097984	@ 0x1bc0000
 8021e40:	429e      	cmp	r6, r3
 8021e42:	d80c      	bhi.n	8021e5e <atan+0x6e>
 8021e44:	a392      	add	r3, pc, #584	@ (adr r3, 8022090 <atan+0x2a0>)
 8021e46:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021e4a:	4620      	mov	r0, r4
 8021e4c:	4629      	mov	r1, r5
 8021e4e:	f7de fa25 	bl	800029c <__adddf3>
 8021e52:	4bac      	ldr	r3, [pc, #688]	@ (8022104 <atan+0x314>)
 8021e54:	2200      	movs	r2, #0
 8021e56:	f7de fe67 	bl	8000b28 <__aeabi_dcmpgt>
 8021e5a:	2800      	cmp	r0, #0
 8021e5c:	d1e7      	bne.n	8021e2e <atan+0x3e>
 8021e5e:	f04f 3aff 	mov.w	sl, #4294967295	@ 0xffffffff
 8021e62:	e029      	b.n	8021eb8 <atan+0xc8>
 8021e64:	f7fd fc6c 	bl	801f740 <fabs>
 8021e68:	4ba7      	ldr	r3, [pc, #668]	@ (8022108 <atan+0x318>)
 8021e6a:	429e      	cmp	r6, r3
 8021e6c:	ec55 4b10 	vmov	r4, r5, d0
 8021e70:	f200 80bc 	bhi.w	8021fec <atan+0x1fc>
 8021e74:	f5a3 2350 	sub.w	r3, r3, #851968	@ 0xd0000
 8021e78:	429e      	cmp	r6, r3
 8021e7a:	f200 809e 	bhi.w	8021fba <atan+0x1ca>
 8021e7e:	4622      	mov	r2, r4
 8021e80:	462b      	mov	r3, r5
 8021e82:	4620      	mov	r0, r4
 8021e84:	4629      	mov	r1, r5
 8021e86:	f7de fa09 	bl	800029c <__adddf3>
 8021e8a:	4b9e      	ldr	r3, [pc, #632]	@ (8022104 <atan+0x314>)
 8021e8c:	2200      	movs	r2, #0
 8021e8e:	f7de fa03 	bl	8000298 <__aeabi_dsub>
 8021e92:	2200      	movs	r2, #0
 8021e94:	4606      	mov	r6, r0
 8021e96:	460f      	mov	r7, r1
 8021e98:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8021e9c:	4620      	mov	r0, r4
 8021e9e:	4629      	mov	r1, r5
 8021ea0:	f7de f9fc 	bl	800029c <__adddf3>
 8021ea4:	4602      	mov	r2, r0
 8021ea6:	460b      	mov	r3, r1
 8021ea8:	4630      	mov	r0, r6
 8021eaa:	4639      	mov	r1, r7
 8021eac:	f7de fcd6 	bl	800085c <__aeabi_ddiv>
 8021eb0:	f04f 0a00 	mov.w	sl, #0
 8021eb4:	4604      	mov	r4, r0
 8021eb6:	460d      	mov	r5, r1
 8021eb8:	4622      	mov	r2, r4
 8021eba:	462b      	mov	r3, r5
 8021ebc:	4620      	mov	r0, r4
 8021ebe:	4629      	mov	r1, r5
 8021ec0:	f7de fba2 	bl	8000608 <__aeabi_dmul>
 8021ec4:	4602      	mov	r2, r0
 8021ec6:	460b      	mov	r3, r1
 8021ec8:	4680      	mov	r8, r0
 8021eca:	4689      	mov	r9, r1
 8021ecc:	f7de fb9c 	bl	8000608 <__aeabi_dmul>
 8021ed0:	a371      	add	r3, pc, #452	@ (adr r3, 8022098 <atan+0x2a8>)
 8021ed2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021ed6:	4606      	mov	r6, r0
 8021ed8:	460f      	mov	r7, r1
 8021eda:	f7de fb95 	bl	8000608 <__aeabi_dmul>
 8021ede:	a370      	add	r3, pc, #448	@ (adr r3, 80220a0 <atan+0x2b0>)
 8021ee0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021ee4:	f7de f9da 	bl	800029c <__adddf3>
 8021ee8:	4632      	mov	r2, r6
 8021eea:	463b      	mov	r3, r7
 8021eec:	f7de fb8c 	bl	8000608 <__aeabi_dmul>
 8021ef0:	a36d      	add	r3, pc, #436	@ (adr r3, 80220a8 <atan+0x2b8>)
 8021ef2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021ef6:	f7de f9d1 	bl	800029c <__adddf3>
 8021efa:	4632      	mov	r2, r6
 8021efc:	463b      	mov	r3, r7
 8021efe:	f7de fb83 	bl	8000608 <__aeabi_dmul>
 8021f02:	a36b      	add	r3, pc, #428	@ (adr r3, 80220b0 <atan+0x2c0>)
 8021f04:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f08:	f7de f9c8 	bl	800029c <__adddf3>
 8021f0c:	4632      	mov	r2, r6
 8021f0e:	463b      	mov	r3, r7
 8021f10:	f7de fb7a 	bl	8000608 <__aeabi_dmul>
 8021f14:	a368      	add	r3, pc, #416	@ (adr r3, 80220b8 <atan+0x2c8>)
 8021f16:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f1a:	f7de f9bf 	bl	800029c <__adddf3>
 8021f1e:	4632      	mov	r2, r6
 8021f20:	463b      	mov	r3, r7
 8021f22:	f7de fb71 	bl	8000608 <__aeabi_dmul>
 8021f26:	a366      	add	r3, pc, #408	@ (adr r3, 80220c0 <atan+0x2d0>)
 8021f28:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f2c:	f7de f9b6 	bl	800029c <__adddf3>
 8021f30:	4642      	mov	r2, r8
 8021f32:	464b      	mov	r3, r9
 8021f34:	f7de fb68 	bl	8000608 <__aeabi_dmul>
 8021f38:	a363      	add	r3, pc, #396	@ (adr r3, 80220c8 <atan+0x2d8>)
 8021f3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f3e:	4680      	mov	r8, r0
 8021f40:	4689      	mov	r9, r1
 8021f42:	4630      	mov	r0, r6
 8021f44:	4639      	mov	r1, r7
 8021f46:	f7de fb5f 	bl	8000608 <__aeabi_dmul>
 8021f4a:	a361      	add	r3, pc, #388	@ (adr r3, 80220d0 <atan+0x2e0>)
 8021f4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f50:	f7de f9a2 	bl	8000298 <__aeabi_dsub>
 8021f54:	4632      	mov	r2, r6
 8021f56:	463b      	mov	r3, r7
 8021f58:	f7de fb56 	bl	8000608 <__aeabi_dmul>
 8021f5c:	a35e      	add	r3, pc, #376	@ (adr r3, 80220d8 <atan+0x2e8>)
 8021f5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f62:	f7de f999 	bl	8000298 <__aeabi_dsub>
 8021f66:	4632      	mov	r2, r6
 8021f68:	463b      	mov	r3, r7
 8021f6a:	f7de fb4d 	bl	8000608 <__aeabi_dmul>
 8021f6e:	a35c      	add	r3, pc, #368	@ (adr r3, 80220e0 <atan+0x2f0>)
 8021f70:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f74:	f7de f990 	bl	8000298 <__aeabi_dsub>
 8021f78:	4632      	mov	r2, r6
 8021f7a:	463b      	mov	r3, r7
 8021f7c:	f7de fb44 	bl	8000608 <__aeabi_dmul>
 8021f80:	a359      	add	r3, pc, #356	@ (adr r3, 80220e8 <atan+0x2f8>)
 8021f82:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021f86:	f7de f987 	bl	8000298 <__aeabi_dsub>
 8021f8a:	4632      	mov	r2, r6
 8021f8c:	463b      	mov	r3, r7
 8021f8e:	f7de fb3b 	bl	8000608 <__aeabi_dmul>
 8021f92:	4602      	mov	r2, r0
 8021f94:	460b      	mov	r3, r1
 8021f96:	4640      	mov	r0, r8
 8021f98:	4649      	mov	r1, r9
 8021f9a:	f7de f97f 	bl	800029c <__adddf3>
 8021f9e:	4622      	mov	r2, r4
 8021fa0:	462b      	mov	r3, r5
 8021fa2:	f7de fb31 	bl	8000608 <__aeabi_dmul>
 8021fa6:	f1ba 3fff 	cmp.w	sl, #4294967295	@ 0xffffffff
 8021faa:	4602      	mov	r2, r0
 8021fac:	460b      	mov	r3, r1
 8021fae:	d148      	bne.n	8022042 <atan+0x252>
 8021fb0:	4620      	mov	r0, r4
 8021fb2:	4629      	mov	r1, r5
 8021fb4:	f7de f970 	bl	8000298 <__aeabi_dsub>
 8021fb8:	e72f      	b.n	8021e1a <atan+0x2a>
 8021fba:	4b52      	ldr	r3, [pc, #328]	@ (8022104 <atan+0x314>)
 8021fbc:	2200      	movs	r2, #0
 8021fbe:	4620      	mov	r0, r4
 8021fc0:	4629      	mov	r1, r5
 8021fc2:	f7de f969 	bl	8000298 <__aeabi_dsub>
 8021fc6:	4b4f      	ldr	r3, [pc, #316]	@ (8022104 <atan+0x314>)
 8021fc8:	4606      	mov	r6, r0
 8021fca:	460f      	mov	r7, r1
 8021fcc:	2200      	movs	r2, #0
 8021fce:	4620      	mov	r0, r4
 8021fd0:	4629      	mov	r1, r5
 8021fd2:	f7de f963 	bl	800029c <__adddf3>
 8021fd6:	4602      	mov	r2, r0
 8021fd8:	460b      	mov	r3, r1
 8021fda:	4630      	mov	r0, r6
 8021fdc:	4639      	mov	r1, r7
 8021fde:	f7de fc3d 	bl	800085c <__aeabi_ddiv>
 8021fe2:	f04f 0a01 	mov.w	sl, #1
 8021fe6:	4604      	mov	r4, r0
 8021fe8:	460d      	mov	r5, r1
 8021fea:	e765      	b.n	8021eb8 <atan+0xc8>
 8021fec:	4b47      	ldr	r3, [pc, #284]	@ (802210c <atan+0x31c>)
 8021fee:	429e      	cmp	r6, r3
 8021ff0:	d21c      	bcs.n	802202c <atan+0x23c>
 8021ff2:	4b47      	ldr	r3, [pc, #284]	@ (8022110 <atan+0x320>)
 8021ff4:	2200      	movs	r2, #0
 8021ff6:	4620      	mov	r0, r4
 8021ff8:	4629      	mov	r1, r5
 8021ffa:	f7de f94d 	bl	8000298 <__aeabi_dsub>
 8021ffe:	4b44      	ldr	r3, [pc, #272]	@ (8022110 <atan+0x320>)
 8022000:	4606      	mov	r6, r0
 8022002:	460f      	mov	r7, r1
 8022004:	2200      	movs	r2, #0
 8022006:	4620      	mov	r0, r4
 8022008:	4629      	mov	r1, r5
 802200a:	f7de fafd 	bl	8000608 <__aeabi_dmul>
 802200e:	4b3d      	ldr	r3, [pc, #244]	@ (8022104 <atan+0x314>)
 8022010:	2200      	movs	r2, #0
 8022012:	f7de f943 	bl	800029c <__adddf3>
 8022016:	4602      	mov	r2, r0
 8022018:	460b      	mov	r3, r1
 802201a:	4630      	mov	r0, r6
 802201c:	4639      	mov	r1, r7
 802201e:	f7de fc1d 	bl	800085c <__aeabi_ddiv>
 8022022:	f04f 0a02 	mov.w	sl, #2
 8022026:	4604      	mov	r4, r0
 8022028:	460d      	mov	r5, r1
 802202a:	e745      	b.n	8021eb8 <atan+0xc8>
 802202c:	4622      	mov	r2, r4
 802202e:	462b      	mov	r3, r5
 8022030:	4938      	ldr	r1, [pc, #224]	@ (8022114 <atan+0x324>)
 8022032:	2000      	movs	r0, #0
 8022034:	f7de fc12 	bl	800085c <__aeabi_ddiv>
 8022038:	f04f 0a03 	mov.w	sl, #3
 802203c:	4604      	mov	r4, r0
 802203e:	460d      	mov	r5, r1
 8022040:	e73a      	b.n	8021eb8 <atan+0xc8>
 8022042:	4b35      	ldr	r3, [pc, #212]	@ (8022118 <atan+0x328>)
 8022044:	4e35      	ldr	r6, [pc, #212]	@ (802211c <atan+0x32c>)
 8022046:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 802204a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802204e:	f7de f923 	bl	8000298 <__aeabi_dsub>
 8022052:	4622      	mov	r2, r4
 8022054:	462b      	mov	r3, r5
 8022056:	f7de f91f 	bl	8000298 <__aeabi_dsub>
 802205a:	eb06 06ca 	add.w	r6, r6, sl, lsl #3
 802205e:	4602      	mov	r2, r0
 8022060:	460b      	mov	r3, r1
 8022062:	e9d6 0100 	ldrd	r0, r1, [r6]
 8022066:	f7de f917 	bl	8000298 <__aeabi_dsub>
 802206a:	f1bb 0f00 	cmp.w	fp, #0
 802206e:	4604      	mov	r4, r0
 8022070:	460d      	mov	r5, r1
 8022072:	f6bf aedc 	bge.w	8021e2e <atan+0x3e>
 8022076:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 802207a:	461d      	mov	r5, r3
 802207c:	e6d7      	b.n	8021e2e <atan+0x3e>
 802207e:	a51c      	add	r5, pc, #112	@ (adr r5, 80220f0 <atan+0x300>)
 8022080:	e9d5 4500 	ldrd	r4, r5, [r5]
 8022084:	e6d3      	b.n	8021e2e <atan+0x3e>
 8022086:	bf00      	nop
 8022088:	54442d18 	.word	0x54442d18
 802208c:	3ff921fb 	.word	0x3ff921fb
 8022090:	8800759c 	.word	0x8800759c
 8022094:	7e37e43c 	.word	0x7e37e43c
 8022098:	e322da11 	.word	0xe322da11
 802209c:	3f90ad3a 	.word	0x3f90ad3a
 80220a0:	24760deb 	.word	0x24760deb
 80220a4:	3fa97b4b 	.word	0x3fa97b4b
 80220a8:	a0d03d51 	.word	0xa0d03d51
 80220ac:	3fb10d66 	.word	0x3fb10d66
 80220b0:	c54c206e 	.word	0xc54c206e
 80220b4:	3fb745cd 	.word	0x3fb745cd
 80220b8:	920083ff 	.word	0x920083ff
 80220bc:	3fc24924 	.word	0x3fc24924
 80220c0:	5555550d 	.word	0x5555550d
 80220c4:	3fd55555 	.word	0x3fd55555
 80220c8:	2c6a6c2f 	.word	0x2c6a6c2f
 80220cc:	bfa2b444 	.word	0xbfa2b444
 80220d0:	52defd9a 	.word	0x52defd9a
 80220d4:	3fadde2d 	.word	0x3fadde2d
 80220d8:	af749a6d 	.word	0xaf749a6d
 80220dc:	3fb3b0f2 	.word	0x3fb3b0f2
 80220e0:	fe231671 	.word	0xfe231671
 80220e4:	3fbc71c6 	.word	0x3fbc71c6
 80220e8:	9998ebc4 	.word	0x9998ebc4
 80220ec:	3fc99999 	.word	0x3fc99999
 80220f0:	54442d18 	.word	0x54442d18
 80220f4:	bff921fb 	.word	0xbff921fb
 80220f8:	440fffff 	.word	0x440fffff
 80220fc:	7ff00000 	.word	0x7ff00000
 8022100:	3fdbffff 	.word	0x3fdbffff
 8022104:	3ff00000 	.word	0x3ff00000
 8022108:	3ff2ffff 	.word	0x3ff2ffff
 802210c:	40038000 	.word	0x40038000
 8022110:	3ff80000 	.word	0x3ff80000
 8022114:	bff00000 	.word	0xbff00000
 8022118:	08023fa0 	.word	0x08023fa0
 802211c:	08023fc0 	.word	0x08023fc0

08022120 <__kernel_cosf>:
 8022120:	ee10 3a10 	vmov	r3, s0
 8022124:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8022128:	f1b3 5f48 	cmp.w	r3, #838860800	@ 0x32000000
 802212c:	eef0 6a40 	vmov.f32	s13, s0
 8022130:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 8022134:	d204      	bcs.n	8022140 <__kernel_cosf+0x20>
 8022136:	eefd 7ae6 	vcvt.s32.f32	s15, s13
 802213a:	ee17 2a90 	vmov	r2, s15
 802213e:	b342      	cbz	r2, 8022192 <__kernel_cosf+0x72>
 8022140:	ee26 7aa6 	vmul.f32	s14, s13, s13
 8022144:	eddf 7a1a 	vldr	s15, [pc, #104]	@ 80221b0 <__kernel_cosf+0x90>
 8022148:	ed9f 6a1a 	vldr	s12, [pc, #104]	@ 80221b4 <__kernel_cosf+0x94>
 802214c:	4a1a      	ldr	r2, [pc, #104]	@ (80221b8 <__kernel_cosf+0x98>)
 802214e:	eea7 6a27 	vfma.f32	s12, s14, s15
 8022152:	4293      	cmp	r3, r2
 8022154:	eddf 7a19 	vldr	s15, [pc, #100]	@ 80221bc <__kernel_cosf+0x9c>
 8022158:	eee6 7a07 	vfma.f32	s15, s12, s14
 802215c:	ed9f 6a18 	vldr	s12, [pc, #96]	@ 80221c0 <__kernel_cosf+0xa0>
 8022160:	eea7 6a87 	vfma.f32	s12, s15, s14
 8022164:	eddf 7a17 	vldr	s15, [pc, #92]	@ 80221c4 <__kernel_cosf+0xa4>
 8022168:	eee6 7a07 	vfma.f32	s15, s12, s14
 802216c:	ed9f 6a16 	vldr	s12, [pc, #88]	@ 80221c8 <__kernel_cosf+0xa8>
 8022170:	eea7 6a87 	vfma.f32	s12, s15, s14
 8022174:	ee60 0ae6 	vnmul.f32	s1, s1, s13
 8022178:	ee26 6a07 	vmul.f32	s12, s12, s14
 802217c:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8022180:	eee7 0a06 	vfma.f32	s1, s14, s12
 8022184:	ee67 7a27 	vmul.f32	s15, s14, s15
 8022188:	d804      	bhi.n	8022194 <__kernel_cosf+0x74>
 802218a:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802218e:	ee30 0a67 	vsub.f32	s0, s0, s15
 8022192:	4770      	bx	lr
 8022194:	4a0d      	ldr	r2, [pc, #52]	@ (80221cc <__kernel_cosf+0xac>)
 8022196:	4293      	cmp	r3, r2
 8022198:	bf9a      	itte	ls
 802219a:	f103 437f 	addls.w	r3, r3, #4278190080	@ 0xff000000
 802219e:	ee07 3a10 	vmovls	s14, r3
 80221a2:	eeb5 7a02 	vmovhi.f32	s14, #82	@ 0x3e900000  0.2812500
 80221a6:	ee30 0a47 	vsub.f32	s0, s0, s14
 80221aa:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80221ae:	e7ec      	b.n	802218a <__kernel_cosf+0x6a>
 80221b0:	ad47d74e 	.word	0xad47d74e
 80221b4:	310f74f6 	.word	0x310f74f6
 80221b8:	3e999999 	.word	0x3e999999
 80221bc:	b493f27c 	.word	0xb493f27c
 80221c0:	37d00d01 	.word	0x37d00d01
 80221c4:	bab60b61 	.word	0xbab60b61
 80221c8:	3d2aaaab 	.word	0x3d2aaaab
 80221cc:	3f480000 	.word	0x3f480000

080221d0 <__kernel_sinf>:
 80221d0:	ee10 3a10 	vmov	r3, s0
 80221d4:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 80221d8:	f1b3 5f48 	cmp.w	r3, #838860800	@ 0x32000000
 80221dc:	d204      	bcs.n	80221e8 <__kernel_sinf+0x18>
 80221de:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80221e2:	ee17 3a90 	vmov	r3, s15
 80221e6:	b35b      	cbz	r3, 8022240 <__kernel_sinf+0x70>
 80221e8:	ee20 7a00 	vmul.f32	s14, s0, s0
 80221ec:	eddf 7a15 	vldr	s15, [pc, #84]	@ 8022244 <__kernel_sinf+0x74>
 80221f0:	ed9f 6a15 	vldr	s12, [pc, #84]	@ 8022248 <__kernel_sinf+0x78>
 80221f4:	eea7 6a27 	vfma.f32	s12, s14, s15
 80221f8:	eddf 7a14 	vldr	s15, [pc, #80]	@ 802224c <__kernel_sinf+0x7c>
 80221fc:	eee6 7a07 	vfma.f32	s15, s12, s14
 8022200:	ed9f 6a13 	vldr	s12, [pc, #76]	@ 8022250 <__kernel_sinf+0x80>
 8022204:	eea7 6a87 	vfma.f32	s12, s15, s14
 8022208:	eddf 7a12 	vldr	s15, [pc, #72]	@ 8022254 <__kernel_sinf+0x84>
 802220c:	ee60 6a07 	vmul.f32	s13, s0, s14
 8022210:	eee6 7a07 	vfma.f32	s15, s12, s14
 8022214:	b930      	cbnz	r0, 8022224 <__kernel_sinf+0x54>
 8022216:	ed9f 6a10 	vldr	s12, [pc, #64]	@ 8022258 <__kernel_sinf+0x88>
 802221a:	eea7 6a27 	vfma.f32	s12, s14, s15
 802221e:	eea6 0a26 	vfma.f32	s0, s12, s13
 8022222:	4770      	bx	lr
 8022224:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 8022228:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 802222c:	eee0 7a86 	vfma.f32	s15, s1, s12
 8022230:	eed7 0a87 	vfnms.f32	s1, s15, s14
 8022234:	eddf 7a09 	vldr	s15, [pc, #36]	@ 802225c <__kernel_sinf+0x8c>
 8022238:	eee6 0aa7 	vfma.f32	s1, s13, s15
 802223c:	ee30 0a60 	vsub.f32	s0, s0, s1
 8022240:	4770      	bx	lr
 8022242:	bf00      	nop
 8022244:	2f2ec9d3 	.word	0x2f2ec9d3
 8022248:	b2d72f34 	.word	0xb2d72f34
 802224c:	3638ef1b 	.word	0x3638ef1b
 8022250:	b9500d01 	.word	0xb9500d01
 8022254:	3c088889 	.word	0x3c088889
 8022258:	be2aaaab 	.word	0xbe2aaaab
 802225c:	3e2aaaab 	.word	0x3e2aaaab

08022260 <__kernel_tanf>:
 8022260:	b508      	push	{r3, lr}
 8022262:	ee10 3a10 	vmov	r3, s0
 8022266:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
 802226a:	f1b2 5f46 	cmp.w	r2, #830472192	@ 0x31800000
 802226e:	eef0 7a40 	vmov.f32	s15, s0
 8022272:	d217      	bcs.n	80222a4 <__kernel_tanf+0x44>
 8022274:	eebd 7ac0 	vcvt.s32.f32	s14, s0
 8022278:	ee17 1a10 	vmov	r1, s14
 802227c:	bb41      	cbnz	r1, 80222d0 <__kernel_tanf+0x70>
 802227e:	1c43      	adds	r3, r0, #1
 8022280:	4313      	orrs	r3, r2
 8022282:	d108      	bne.n	8022296 <__kernel_tanf+0x36>
 8022284:	f7fd fb5e 	bl	801f944 <fabsf>
 8022288:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 802228c:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8022290:	eeb0 0a67 	vmov.f32	s0, s15
 8022294:	bd08      	pop	{r3, pc}
 8022296:	2801      	cmp	r0, #1
 8022298:	d0fa      	beq.n	8022290 <__kernel_tanf+0x30>
 802229a:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 802229e:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80222a2:	e7f5      	b.n	8022290 <__kernel_tanf+0x30>
 80222a4:	494c      	ldr	r1, [pc, #304]	@ (80223d8 <__kernel_tanf+0x178>)
 80222a6:	428a      	cmp	r2, r1
 80222a8:	d312      	bcc.n	80222d0 <__kernel_tanf+0x70>
 80222aa:	2b00      	cmp	r3, #0
 80222ac:	ed9f 7a4b 	vldr	s14, [pc, #300]	@ 80223dc <__kernel_tanf+0x17c>
 80222b0:	bfb8      	it	lt
 80222b2:	eef1 7a40 	vneglt.f32	s15, s0
 80222b6:	ee37 7a67 	vsub.f32	s14, s14, s15
 80222ba:	eddf 7a49 	vldr	s15, [pc, #292]	@ 80223e0 <__kernel_tanf+0x180>
 80222be:	bfb8      	it	lt
 80222c0:	eef1 0a60 	vneglt.f32	s1, s1
 80222c4:	ee77 7ae0 	vsub.f32	s15, s15, s1
 80222c8:	eddf 0a46 	vldr	s1, [pc, #280]	@ 80223e4 <__kernel_tanf+0x184>
 80222cc:	ee77 7a87 	vadd.f32	s15, s15, s14
 80222d0:	ee67 6aa7 	vmul.f32	s13, s15, s15
 80222d4:	eddf 5a44 	vldr	s11, [pc, #272]	@ 80223e8 <__kernel_tanf+0x188>
 80222d8:	ed9f 6a44 	vldr	s12, [pc, #272]	@ 80223ec <__kernel_tanf+0x18c>
 80222dc:	ed9f 5a44 	vldr	s10, [pc, #272]	@ 80223f0 <__kernel_tanf+0x190>
 80222e0:	493d      	ldr	r1, [pc, #244]	@ (80223d8 <__kernel_tanf+0x178>)
 80222e2:	ee26 7aa6 	vmul.f32	s14, s13, s13
 80222e6:	428a      	cmp	r2, r1
 80222e8:	eea7 6a25 	vfma.f32	s12, s14, s11
 80222ec:	eddf 5a41 	vldr	s11, [pc, #260]	@ 80223f4 <__kernel_tanf+0x194>
 80222f0:	eee6 5a07 	vfma.f32	s11, s12, s14
 80222f4:	ed9f 6a40 	vldr	s12, [pc, #256]	@ 80223f8 <__kernel_tanf+0x198>
 80222f8:	eea5 6a87 	vfma.f32	s12, s11, s14
 80222fc:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 80223fc <__kernel_tanf+0x19c>
 8022300:	eee6 5a07 	vfma.f32	s11, s12, s14
 8022304:	ed9f 6a3e 	vldr	s12, [pc, #248]	@ 8022400 <__kernel_tanf+0x1a0>
 8022308:	eea5 6a87 	vfma.f32	s12, s11, s14
 802230c:	eddf 5a3d 	vldr	s11, [pc, #244]	@ 8022404 <__kernel_tanf+0x1a4>
 8022310:	eee7 5a05 	vfma.f32	s11, s14, s10
 8022314:	ed9f 5a3c 	vldr	s10, [pc, #240]	@ 8022408 <__kernel_tanf+0x1a8>
 8022318:	eea5 5a87 	vfma.f32	s10, s11, s14
 802231c:	eddf 5a3b 	vldr	s11, [pc, #236]	@ 802240c <__kernel_tanf+0x1ac>
 8022320:	eee5 5a07 	vfma.f32	s11, s10, s14
 8022324:	ed9f 5a3a 	vldr	s10, [pc, #232]	@ 8022410 <__kernel_tanf+0x1b0>
 8022328:	eea5 5a87 	vfma.f32	s10, s11, s14
 802232c:	eddf 5a39 	vldr	s11, [pc, #228]	@ 8022414 <__kernel_tanf+0x1b4>
 8022330:	eee5 5a07 	vfma.f32	s11, s10, s14
 8022334:	eeb0 7a46 	vmov.f32	s14, s12
 8022338:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802233c:	ee27 5aa6 	vmul.f32	s10, s15, s13
 8022340:	eeb0 6a60 	vmov.f32	s12, s1
 8022344:	eea7 6a05 	vfma.f32	s12, s14, s10
 8022348:	ed9f 7a33 	vldr	s14, [pc, #204]	@ 8022418 <__kernel_tanf+0x1b8>
 802234c:	eee6 0a26 	vfma.f32	s1, s12, s13
 8022350:	eee5 0a07 	vfma.f32	s1, s10, s14
 8022354:	ee37 6aa0 	vadd.f32	s12, s15, s1
 8022358:	d31d      	bcc.n	8022396 <__kernel_tanf+0x136>
 802235a:	ee07 0a10 	vmov	s14, r0
 802235e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8022362:	ee26 5a06 	vmul.f32	s10, s12, s12
 8022366:	ee36 6a07 	vadd.f32	s12, s12, s14
 802236a:	179b      	asrs	r3, r3, #30
 802236c:	eec5 5a06 	vdiv.f32	s11, s10, s12
 8022370:	f003 0302 	and.w	r3, r3, #2
 8022374:	f1c3 0301 	rsb	r3, r3, #1
 8022378:	ee06 3a90 	vmov	s13, r3
 802237c:	ee35 6ae0 	vsub.f32	s12, s11, s1
 8022380:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8022384:	ee77 7ac6 	vsub.f32	s15, s15, s12
 8022388:	eeb0 6a00 	vmov.f32	s12, #0	@ 0x40000000  2.0
 802238c:	eea7 7ac6 	vfms.f32	s14, s15, s12
 8022390:	ee66 7a87 	vmul.f32	s15, s13, s14
 8022394:	e77c      	b.n	8022290 <__kernel_tanf+0x30>
 8022396:	2801      	cmp	r0, #1
 8022398:	d01b      	beq.n	80223d2 <__kernel_tanf+0x172>
 802239a:	4b20      	ldr	r3, [pc, #128]	@ (802241c <__kernel_tanf+0x1bc>)
 802239c:	ee16 2a10 	vmov	r2, s12
 80223a0:	401a      	ands	r2, r3
 80223a2:	ee05 2a90 	vmov	s11, r2
 80223a6:	ee75 7ae7 	vsub.f32	s15, s11, s15
 80223aa:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80223ae:	ee70 0ae7 	vsub.f32	s1, s1, s15
 80223b2:	eeff 7a00 	vmov.f32	s15, #240	@ 0xbf800000 -1.0
 80223b6:	eec7 6a86 	vdiv.f32	s13, s15, s12
 80223ba:	ee16 2a90 	vmov	r2, s13
 80223be:	4013      	ands	r3, r2
 80223c0:	ee07 3a90 	vmov	s15, r3
 80223c4:	eea5 7aa7 	vfma.f32	s14, s11, s15
 80223c8:	eea0 7aa7 	vfma.f32	s14, s1, s15
 80223cc:	eee7 7a26 	vfma.f32	s15, s14, s13
 80223d0:	e75e      	b.n	8022290 <__kernel_tanf+0x30>
 80223d2:	eef0 7a46 	vmov.f32	s15, s12
 80223d6:	e75b      	b.n	8022290 <__kernel_tanf+0x30>
 80223d8:	3f2ca140 	.word	0x3f2ca140
 80223dc:	3f490fda 	.word	0x3f490fda
 80223e0:	33222168 	.word	0x33222168
 80223e4:	00000000 	.word	0x00000000
 80223e8:	b79bae5f 	.word	0xb79bae5f
 80223ec:	38a3f445 	.word	0x38a3f445
 80223f0:	37d95384 	.word	0x37d95384
 80223f4:	3a1a26c8 	.word	0x3a1a26c8
 80223f8:	3b6b6916 	.word	0x3b6b6916
 80223fc:	3cb327a4 	.word	0x3cb327a4
 8022400:	3e088889 	.word	0x3e088889
 8022404:	3895c07a 	.word	0x3895c07a
 8022408:	398137b9 	.word	0x398137b9
 802240c:	3abede48 	.word	0x3abede48
 8022410:	3c11371f 	.word	0x3c11371f
 8022414:	3d5d0dd1 	.word	0x3d5d0dd1
 8022418:	3eaaaaab 	.word	0x3eaaaaab
 802241c:	fffff000 	.word	0xfffff000

08022420 <__ieee754_asinf>:
 8022420:	b538      	push	{r3, r4, r5, lr}
 8022422:	ee10 5a10 	vmov	r5, s0
 8022426:	f025 4400 	bic.w	r4, r5, #2147483648	@ 0x80000000
 802242a:	f1b4 5f7e 	cmp.w	r4, #1065353216	@ 0x3f800000
 802242e:	ed2d 8b04 	vpush	{d8-d9}
 8022432:	d10c      	bne.n	802244e <__ieee754_asinf+0x2e>
 8022434:	eddf 7a5d 	vldr	s15, [pc, #372]	@ 80225ac <__ieee754_asinf+0x18c>
 8022438:	ed9f 7a5d 	vldr	s14, [pc, #372]	@ 80225b0 <__ieee754_asinf+0x190>
 802243c:	ee60 7a27 	vmul.f32	s15, s0, s15
 8022440:	eee0 7a07 	vfma.f32	s15, s0, s14
 8022444:	eeb0 0a67 	vmov.f32	s0, s15
 8022448:	ecbd 8b04 	vpop	{d8-d9}
 802244c:	bd38      	pop	{r3, r4, r5, pc}
 802244e:	d904      	bls.n	802245a <__ieee754_asinf+0x3a>
 8022450:	ee70 7a40 	vsub.f32	s15, s0, s0
 8022454:	ee87 0aa7 	vdiv.f32	s0, s15, s15
 8022458:	e7f6      	b.n	8022448 <__ieee754_asinf+0x28>
 802245a:	f1b4 5f7c 	cmp.w	r4, #1056964608	@ 0x3f000000
 802245e:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 8022462:	d20b      	bcs.n	802247c <__ieee754_asinf+0x5c>
 8022464:	f1b4 5f48 	cmp.w	r4, #838860800	@ 0x32000000
 8022468:	d252      	bcs.n	8022510 <__ieee754_asinf+0xf0>
 802246a:	eddf 7a52 	vldr	s15, [pc, #328]	@ 80225b4 <__ieee754_asinf+0x194>
 802246e:	ee70 7a27 	vadd.f32	s15, s0, s15
 8022472:	eef4 7ae8 	vcmpe.f32	s15, s17
 8022476:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802247a:	dce5      	bgt.n	8022448 <__ieee754_asinf+0x28>
 802247c:	f7fd fa62 	bl	801f944 <fabsf>
 8022480:	ee38 8ac0 	vsub.f32	s16, s17, s0
 8022484:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8022488:	ee28 8a27 	vmul.f32	s16, s16, s15
 802248c:	ed9f 7a4a 	vldr	s14, [pc, #296]	@ 80225b8 <__ieee754_asinf+0x198>
 8022490:	eddf 7a4a 	vldr	s15, [pc, #296]	@ 80225bc <__ieee754_asinf+0x19c>
 8022494:	ed9f 9a4a 	vldr	s18, [pc, #296]	@ 80225c0 <__ieee754_asinf+0x1a0>
 8022498:	eea8 7a27 	vfma.f32	s14, s16, s15
 802249c:	eddf 7a49 	vldr	s15, [pc, #292]	@ 80225c4 <__ieee754_asinf+0x1a4>
 80224a0:	eee7 7a08 	vfma.f32	s15, s14, s16
 80224a4:	ed9f 7a48 	vldr	s14, [pc, #288]	@ 80225c8 <__ieee754_asinf+0x1a8>
 80224a8:	eea7 7a88 	vfma.f32	s14, s15, s16
 80224ac:	eddf 7a47 	vldr	s15, [pc, #284]	@ 80225cc <__ieee754_asinf+0x1ac>
 80224b0:	eee7 7a08 	vfma.f32	s15, s14, s16
 80224b4:	ed9f 7a46 	vldr	s14, [pc, #280]	@ 80225d0 <__ieee754_asinf+0x1b0>
 80224b8:	eea7 9a88 	vfma.f32	s18, s15, s16
 80224bc:	eddf 7a45 	vldr	s15, [pc, #276]	@ 80225d4 <__ieee754_asinf+0x1b4>
 80224c0:	eee8 7a07 	vfma.f32	s15, s16, s14
 80224c4:	ed9f 7a44 	vldr	s14, [pc, #272]	@ 80225d8 <__ieee754_asinf+0x1b8>
 80224c8:	eea7 7a88 	vfma.f32	s14, s15, s16
 80224cc:	eddf 7a43 	vldr	s15, [pc, #268]	@ 80225dc <__ieee754_asinf+0x1bc>
 80224d0:	eee7 7a08 	vfma.f32	s15, s14, s16
 80224d4:	eeb0 0a48 	vmov.f32	s0, s16
 80224d8:	eee7 8a88 	vfma.f32	s17, s15, s16
 80224dc:	f000 fbe8 	bl	8022cb0 <__ieee754_sqrtf>
 80224e0:	4b3f      	ldr	r3, [pc, #252]	@ (80225e0 <__ieee754_asinf+0x1c0>)
 80224e2:	ee29 9a08 	vmul.f32	s18, s18, s16
 80224e6:	429c      	cmp	r4, r3
 80224e8:	ee89 6a28 	vdiv.f32	s12, s18, s17
 80224ec:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
 80224f0:	d93d      	bls.n	802256e <__ieee754_asinf+0x14e>
 80224f2:	eea0 0a06 	vfma.f32	s0, s0, s12
 80224f6:	eddf 7a3b 	vldr	s15, [pc, #236]	@ 80225e4 <__ieee754_asinf+0x1c4>
 80224fa:	eee0 7a26 	vfma.f32	s15, s0, s13
 80224fe:	ed9f 0a2c 	vldr	s0, [pc, #176]	@ 80225b0 <__ieee754_asinf+0x190>
 8022502:	ee30 0a67 	vsub.f32	s0, s0, s15
 8022506:	2d00      	cmp	r5, #0
 8022508:	bfd8      	it	le
 802250a:	eeb1 0a40 	vnegle.f32	s0, s0
 802250e:	e79b      	b.n	8022448 <__ieee754_asinf+0x28>
 8022510:	ee60 7a00 	vmul.f32	s15, s0, s0
 8022514:	eddf 6a29 	vldr	s13, [pc, #164]	@ 80225bc <__ieee754_asinf+0x19c>
 8022518:	ed9f 7a27 	vldr	s14, [pc, #156]	@ 80225b8 <__ieee754_asinf+0x198>
 802251c:	ed9f 6a2c 	vldr	s12, [pc, #176]	@ 80225d0 <__ieee754_asinf+0x1b0>
 8022520:	eea7 7aa6 	vfma.f32	s14, s15, s13
 8022524:	eddf 6a27 	vldr	s13, [pc, #156]	@ 80225c4 <__ieee754_asinf+0x1a4>
 8022528:	eee7 6a27 	vfma.f32	s13, s14, s15
 802252c:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 80225c8 <__ieee754_asinf+0x1a8>
 8022530:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8022534:	eddf 6a25 	vldr	s13, [pc, #148]	@ 80225cc <__ieee754_asinf+0x1ac>
 8022538:	eee7 6a27 	vfma.f32	s13, s14, s15
 802253c:	ed9f 7a20 	vldr	s14, [pc, #128]	@ 80225c0 <__ieee754_asinf+0x1a0>
 8022540:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8022544:	eddf 6a23 	vldr	s13, [pc, #140]	@ 80225d4 <__ieee754_asinf+0x1b4>
 8022548:	eee7 6a86 	vfma.f32	s13, s15, s12
 802254c:	ed9f 6a22 	vldr	s12, [pc, #136]	@ 80225d8 <__ieee754_asinf+0x1b8>
 8022550:	eea6 6aa7 	vfma.f32	s12, s13, s15
 8022554:	eddf 6a21 	vldr	s13, [pc, #132]	@ 80225dc <__ieee754_asinf+0x1bc>
 8022558:	eee6 6a27 	vfma.f32	s13, s12, s15
 802255c:	ee27 7a27 	vmul.f32	s14, s14, s15
 8022560:	eee6 8aa7 	vfma.f32	s17, s13, s15
 8022564:	eec7 7a28 	vdiv.f32	s15, s14, s17
 8022568:	eea0 0a27 	vfma.f32	s0, s0, s15
 802256c:	e76c      	b.n	8022448 <__ieee754_asinf+0x28>
 802256e:	ee10 3a10 	vmov	r3, s0
 8022572:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
 8022576:	f023 030f 	bic.w	r3, r3, #15
 802257a:	ee07 3a10 	vmov	s14, r3
 802257e:	eea7 8a47 	vfms.f32	s16, s14, s14
 8022582:	ee70 5a00 	vadd.f32	s11, s0, s0
 8022586:	ee30 0a07 	vadd.f32	s0, s0, s14
 802258a:	eddf 7a08 	vldr	s15, [pc, #32]	@ 80225ac <__ieee754_asinf+0x18c>
 802258e:	ee88 5a00 	vdiv.f32	s10, s16, s0
 8022592:	ed9f 0a15 	vldr	s0, [pc, #84]	@ 80225e8 <__ieee754_asinf+0x1c8>
 8022596:	eee5 7a66 	vfms.f32	s15, s10, s13
 802259a:	eed5 7a86 	vfnms.f32	s15, s11, s12
 802259e:	eeb0 6a40 	vmov.f32	s12, s0
 80225a2:	eea7 6a66 	vfms.f32	s12, s14, s13
 80225a6:	ee77 7ac6 	vsub.f32	s15, s15, s12
 80225aa:	e7aa      	b.n	8022502 <__ieee754_asinf+0xe2>
 80225ac:	b33bbd2e 	.word	0xb33bbd2e
 80225b0:	3fc90fdb 	.word	0x3fc90fdb
 80225b4:	7149f2ca 	.word	0x7149f2ca
 80225b8:	3a4f7f04 	.word	0x3a4f7f04
 80225bc:	3811ef08 	.word	0x3811ef08
 80225c0:	3e2aaaab 	.word	0x3e2aaaab
 80225c4:	bd241146 	.word	0xbd241146
 80225c8:	3e4e0aa8 	.word	0x3e4e0aa8
 80225cc:	bea6b090 	.word	0xbea6b090
 80225d0:	3d9dc62e 	.word	0x3d9dc62e
 80225d4:	bf303361 	.word	0xbf303361
 80225d8:	4001572d 	.word	0x4001572d
 80225dc:	c019d139 	.word	0xc019d139
 80225e0:	3f799999 	.word	0x3f799999
 80225e4:	333bbd2e 	.word	0x333bbd2e
 80225e8:	3f490fdb 	.word	0x3f490fdb

080225ec <__ieee754_atan2f>:
 80225ec:	ee10 2a90 	vmov	r2, s1
 80225f0:	f022 4100 	bic.w	r1, r2, #2147483648	@ 0x80000000
 80225f4:	f1b1 4fff 	cmp.w	r1, #2139095040	@ 0x7f800000
 80225f8:	b510      	push	{r4, lr}
 80225fa:	eef0 7a40 	vmov.f32	s15, s0
 80225fe:	d806      	bhi.n	802260e <__ieee754_atan2f+0x22>
 8022600:	ee10 0a10 	vmov	r0, s0
 8022604:	f020 4300 	bic.w	r3, r0, #2147483648	@ 0x80000000
 8022608:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 802260c:	d904      	bls.n	8022618 <__ieee754_atan2f+0x2c>
 802260e:	ee77 7aa0 	vadd.f32	s15, s15, s1
 8022612:	eeb0 0a67 	vmov.f32	s0, s15
 8022616:	bd10      	pop	{r4, pc}
 8022618:	f1b2 5f7e 	cmp.w	r2, #1065353216	@ 0x3f800000
 802261c:	d103      	bne.n	8022626 <__ieee754_atan2f+0x3a>
 802261e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8022622:	f000 b9b3 	b.w	802298c <atanf>
 8022626:	1794      	asrs	r4, r2, #30
 8022628:	f004 0402 	and.w	r4, r4, #2
 802262c:	ea44 74d0 	orr.w	r4, r4, r0, lsr #31
 8022630:	b943      	cbnz	r3, 8022644 <__ieee754_atan2f+0x58>
 8022632:	2c02      	cmp	r4, #2
 8022634:	d05e      	beq.n	80226f4 <__ieee754_atan2f+0x108>
 8022636:	ed9f 7a34 	vldr	s14, [pc, #208]	@ 8022708 <__ieee754_atan2f+0x11c>
 802263a:	2c03      	cmp	r4, #3
 802263c:	bf08      	it	eq
 802263e:	eef0 7a47 	vmoveq.f32	s15, s14
 8022642:	e7e6      	b.n	8022612 <__ieee754_atan2f+0x26>
 8022644:	b941      	cbnz	r1, 8022658 <__ieee754_atan2f+0x6c>
 8022646:	eddf 7a31 	vldr	s15, [pc, #196]	@ 802270c <__ieee754_atan2f+0x120>
 802264a:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 8022710 <__ieee754_atan2f+0x124>
 802264e:	2800      	cmp	r0, #0
 8022650:	bfb8      	it	lt
 8022652:	eef0 7a47 	vmovlt.f32	s15, s14
 8022656:	e7dc      	b.n	8022612 <__ieee754_atan2f+0x26>
 8022658:	f1b1 4fff 	cmp.w	r1, #2139095040	@ 0x7f800000
 802265c:	d110      	bne.n	8022680 <__ieee754_atan2f+0x94>
 802265e:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 8022662:	f104 34ff 	add.w	r4, r4, #4294967295	@ 0xffffffff
 8022666:	d107      	bne.n	8022678 <__ieee754_atan2f+0x8c>
 8022668:	2c02      	cmp	r4, #2
 802266a:	d846      	bhi.n	80226fa <__ieee754_atan2f+0x10e>
 802266c:	4b29      	ldr	r3, [pc, #164]	@ (8022714 <__ieee754_atan2f+0x128>)
 802266e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8022672:	edd3 7a00 	vldr	s15, [r3]
 8022676:	e7cc      	b.n	8022612 <__ieee754_atan2f+0x26>
 8022678:	2c02      	cmp	r4, #2
 802267a:	d841      	bhi.n	8022700 <__ieee754_atan2f+0x114>
 802267c:	4b26      	ldr	r3, [pc, #152]	@ (8022718 <__ieee754_atan2f+0x12c>)
 802267e:	e7f6      	b.n	802266e <__ieee754_atan2f+0x82>
 8022680:	f1b3 4fff 	cmp.w	r3, #2139095040	@ 0x7f800000
 8022684:	d0df      	beq.n	8022646 <__ieee754_atan2f+0x5a>
 8022686:	1a5b      	subs	r3, r3, r1
 8022688:	f1b3 5ff4 	cmp.w	r3, #511705088	@ 0x1e800000
 802268c:	ea4f 51e3 	mov.w	r1, r3, asr #23
 8022690:	da1a      	bge.n	80226c8 <__ieee754_atan2f+0xdc>
 8022692:	2a00      	cmp	r2, #0
 8022694:	da01      	bge.n	802269a <__ieee754_atan2f+0xae>
 8022696:	313c      	adds	r1, #60	@ 0x3c
 8022698:	db19      	blt.n	80226ce <__ieee754_atan2f+0xe2>
 802269a:	ee87 0aa0 	vdiv.f32	s0, s15, s1
 802269e:	f7fd f951 	bl	801f944 <fabsf>
 80226a2:	f000 f973 	bl	802298c <atanf>
 80226a6:	eef0 7a40 	vmov.f32	s15, s0
 80226aa:	2c01      	cmp	r4, #1
 80226ac:	d012      	beq.n	80226d4 <__ieee754_atan2f+0xe8>
 80226ae:	2c02      	cmp	r4, #2
 80226b0:	d017      	beq.n	80226e2 <__ieee754_atan2f+0xf6>
 80226b2:	2c00      	cmp	r4, #0
 80226b4:	d0ad      	beq.n	8022612 <__ieee754_atan2f+0x26>
 80226b6:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 802271c <__ieee754_atan2f+0x130>
 80226ba:	ee77 7a87 	vadd.f32	s15, s15, s14
 80226be:	ed9f 7a18 	vldr	s14, [pc, #96]	@ 8022720 <__ieee754_atan2f+0x134>
 80226c2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80226c6:	e7a4      	b.n	8022612 <__ieee754_atan2f+0x26>
 80226c8:	eddf 7a10 	vldr	s15, [pc, #64]	@ 802270c <__ieee754_atan2f+0x120>
 80226cc:	e7ed      	b.n	80226aa <__ieee754_atan2f+0xbe>
 80226ce:	eddf 7a15 	vldr	s15, [pc, #84]	@ 8022724 <__ieee754_atan2f+0x138>
 80226d2:	e7ea      	b.n	80226aa <__ieee754_atan2f+0xbe>
 80226d4:	ee17 3a90 	vmov	r3, s15
 80226d8:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 80226dc:	ee07 3a90 	vmov	s15, r3
 80226e0:	e797      	b.n	8022612 <__ieee754_atan2f+0x26>
 80226e2:	ed9f 7a0e 	vldr	s14, [pc, #56]	@ 802271c <__ieee754_atan2f+0x130>
 80226e6:	ee77 7a87 	vadd.f32	s15, s15, s14
 80226ea:	ed9f 7a0d 	vldr	s14, [pc, #52]	@ 8022720 <__ieee754_atan2f+0x134>
 80226ee:	ee77 7a67 	vsub.f32	s15, s14, s15
 80226f2:	e78e      	b.n	8022612 <__ieee754_atan2f+0x26>
 80226f4:	eddf 7a0a 	vldr	s15, [pc, #40]	@ 8022720 <__ieee754_atan2f+0x134>
 80226f8:	e78b      	b.n	8022612 <__ieee754_atan2f+0x26>
 80226fa:	eddf 7a0b 	vldr	s15, [pc, #44]	@ 8022728 <__ieee754_atan2f+0x13c>
 80226fe:	e788      	b.n	8022612 <__ieee754_atan2f+0x26>
 8022700:	eddf 7a08 	vldr	s15, [pc, #32]	@ 8022724 <__ieee754_atan2f+0x138>
 8022704:	e785      	b.n	8022612 <__ieee754_atan2f+0x26>
 8022706:	bf00      	nop
 8022708:	c0490fdb 	.word	0xc0490fdb
 802270c:	3fc90fdb 	.word	0x3fc90fdb
 8022710:	bfc90fdb 	.word	0xbfc90fdb
 8022714:	08023fec 	.word	0x08023fec
 8022718:	08023fe0 	.word	0x08023fe0
 802271c:	33bbbd2e 	.word	0x33bbbd2e
 8022720:	40490fdb 	.word	0x40490fdb
 8022724:	00000000 	.word	0x00000000
 8022728:	3f490fdb 	.word	0x3f490fdb

0802272c <__ieee754_rem_pio2f>:
 802272c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802272e:	ee10 6a10 	vmov	r6, s0
 8022732:	4b88      	ldr	r3, [pc, #544]	@ (8022954 <__ieee754_rem_pio2f+0x228>)
 8022734:	f026 4500 	bic.w	r5, r6, #2147483648	@ 0x80000000
 8022738:	429d      	cmp	r5, r3
 802273a:	b087      	sub	sp, #28
 802273c:	4604      	mov	r4, r0
 802273e:	d805      	bhi.n	802274c <__ieee754_rem_pio2f+0x20>
 8022740:	2300      	movs	r3, #0
 8022742:	ed80 0a00 	vstr	s0, [r0]
 8022746:	6043      	str	r3, [r0, #4]
 8022748:	2000      	movs	r0, #0
 802274a:	e022      	b.n	8022792 <__ieee754_rem_pio2f+0x66>
 802274c:	4b82      	ldr	r3, [pc, #520]	@ (8022958 <__ieee754_rem_pio2f+0x22c>)
 802274e:	429d      	cmp	r5, r3
 8022750:	d83a      	bhi.n	80227c8 <__ieee754_rem_pio2f+0x9c>
 8022752:	f026 4300 	bic.w	r3, r6, #2147483648	@ 0x80000000
 8022756:	2e00      	cmp	r6, #0
 8022758:	ed9f 7a80 	vldr	s14, [pc, #512]	@ 802295c <__ieee754_rem_pio2f+0x230>
 802275c:	4a80      	ldr	r2, [pc, #512]	@ (8022960 <__ieee754_rem_pio2f+0x234>)
 802275e:	f023 030f 	bic.w	r3, r3, #15
 8022762:	dd18      	ble.n	8022796 <__ieee754_rem_pio2f+0x6a>
 8022764:	4293      	cmp	r3, r2
 8022766:	ee70 7a47 	vsub.f32	s15, s0, s14
 802276a:	bf09      	itett	eq
 802276c:	ed9f 7a7d 	vldreq	s14, [pc, #500]	@ 8022964 <__ieee754_rem_pio2f+0x238>
 8022770:	eddf 6a7d 	vldrne	s13, [pc, #500]	@ 8022968 <__ieee754_rem_pio2f+0x23c>
 8022774:	eddf 6a7d 	vldreq	s13, [pc, #500]	@ 802296c <__ieee754_rem_pio2f+0x240>
 8022778:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 802277c:	ee37 7ae6 	vsub.f32	s14, s15, s13
 8022780:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8022784:	ed80 7a00 	vstr	s14, [r0]
 8022788:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802278c:	edc0 7a01 	vstr	s15, [r0, #4]
 8022790:	2001      	movs	r0, #1
 8022792:	b007      	add	sp, #28
 8022794:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022796:	4293      	cmp	r3, r2
 8022798:	ee70 7a07 	vadd.f32	s15, s0, s14
 802279c:	bf09      	itett	eq
 802279e:	ed9f 7a71 	vldreq	s14, [pc, #452]	@ 8022964 <__ieee754_rem_pio2f+0x238>
 80227a2:	eddf 6a71 	vldrne	s13, [pc, #452]	@ 8022968 <__ieee754_rem_pio2f+0x23c>
 80227a6:	eddf 6a71 	vldreq	s13, [pc, #452]	@ 802296c <__ieee754_rem_pio2f+0x240>
 80227aa:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 80227ae:	ee37 7aa6 	vadd.f32	s14, s15, s13
 80227b2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80227b6:	ed80 7a00 	vstr	s14, [r0]
 80227ba:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80227be:	edc0 7a01 	vstr	s15, [r0, #4]
 80227c2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80227c6:	e7e4      	b.n	8022792 <__ieee754_rem_pio2f+0x66>
 80227c8:	4b69      	ldr	r3, [pc, #420]	@ (8022970 <__ieee754_rem_pio2f+0x244>)
 80227ca:	429d      	cmp	r5, r3
 80227cc:	d873      	bhi.n	80228b6 <__ieee754_rem_pio2f+0x18a>
 80227ce:	f7fd f8b9 	bl	801f944 <fabsf>
 80227d2:	ed9f 7a68 	vldr	s14, [pc, #416]	@ 8022974 <__ieee754_rem_pio2f+0x248>
 80227d6:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 80227da:	eee0 7a07 	vfma.f32	s15, s0, s14
 80227de:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80227e2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80227e6:	ee17 0a90 	vmov	r0, s15
 80227ea:	eddf 7a5c 	vldr	s15, [pc, #368]	@ 802295c <__ieee754_rem_pio2f+0x230>
 80227ee:	eea7 0a67 	vfms.f32	s0, s14, s15
 80227f2:	281f      	cmp	r0, #31
 80227f4:	eddf 7a5c 	vldr	s15, [pc, #368]	@ 8022968 <__ieee754_rem_pio2f+0x23c>
 80227f8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80227fc:	eeb1 6a47 	vneg.f32	s12, s14
 8022800:	ee70 6a67 	vsub.f32	s13, s0, s15
 8022804:	ee16 1a90 	vmov	r1, s13
 8022808:	dc09      	bgt.n	802281e <__ieee754_rem_pio2f+0xf2>
 802280a:	4a5b      	ldr	r2, [pc, #364]	@ (8022978 <__ieee754_rem_pio2f+0x24c>)
 802280c:	1e47      	subs	r7, r0, #1
 802280e:	f026 4300 	bic.w	r3, r6, #2147483648	@ 0x80000000
 8022812:	f852 2027 	ldr.w	r2, [r2, r7, lsl #2]
 8022816:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 802281a:	4293      	cmp	r3, r2
 802281c:	d107      	bne.n	802282e <__ieee754_rem_pio2f+0x102>
 802281e:	f3c1 52c7 	ubfx	r2, r1, #23, #8
 8022822:	ebc2 52d5 	rsb	r2, r2, r5, lsr #23
 8022826:	2a08      	cmp	r2, #8
 8022828:	ea4f 53e5 	mov.w	r3, r5, asr #23
 802282c:	dc14      	bgt.n	8022858 <__ieee754_rem_pio2f+0x12c>
 802282e:	6021      	str	r1, [r4, #0]
 8022830:	ed94 7a00 	vldr	s14, [r4]
 8022834:	ee30 0a47 	vsub.f32	s0, s0, s14
 8022838:	2e00      	cmp	r6, #0
 802283a:	ee30 0a67 	vsub.f32	s0, s0, s15
 802283e:	ed84 0a01 	vstr	s0, [r4, #4]
 8022842:	daa6      	bge.n	8022792 <__ieee754_rem_pio2f+0x66>
 8022844:	eeb1 7a47 	vneg.f32	s14, s14
 8022848:	eeb1 0a40 	vneg.f32	s0, s0
 802284c:	ed84 7a00 	vstr	s14, [r4]
 8022850:	ed84 0a01 	vstr	s0, [r4, #4]
 8022854:	4240      	negs	r0, r0
 8022856:	e79c      	b.n	8022792 <__ieee754_rem_pio2f+0x66>
 8022858:	eddf 5a42 	vldr	s11, [pc, #264]	@ 8022964 <__ieee754_rem_pio2f+0x238>
 802285c:	eef0 6a40 	vmov.f32	s13, s0
 8022860:	eee6 6a25 	vfma.f32	s13, s12, s11
 8022864:	ee70 7a66 	vsub.f32	s15, s0, s13
 8022868:	eee6 7a25 	vfma.f32	s15, s12, s11
 802286c:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 802296c <__ieee754_rem_pio2f+0x240>
 8022870:	eed7 7a25 	vfnms.f32	s15, s14, s11
 8022874:	ee76 5ae7 	vsub.f32	s11, s13, s15
 8022878:	ee15 2a90 	vmov	r2, s11
 802287c:	f3c2 51c7 	ubfx	r1, r2, #23, #8
 8022880:	1a5b      	subs	r3, r3, r1
 8022882:	2b19      	cmp	r3, #25
 8022884:	dc04      	bgt.n	8022890 <__ieee754_rem_pio2f+0x164>
 8022886:	edc4 5a00 	vstr	s11, [r4]
 802288a:	eeb0 0a66 	vmov.f32	s0, s13
 802288e:	e7cf      	b.n	8022830 <__ieee754_rem_pio2f+0x104>
 8022890:	eddf 5a3a 	vldr	s11, [pc, #232]	@ 802297c <__ieee754_rem_pio2f+0x250>
 8022894:	eeb0 0a66 	vmov.f32	s0, s13
 8022898:	eea6 0a25 	vfma.f32	s0, s12, s11
 802289c:	ee76 7ac0 	vsub.f32	s15, s13, s0
 80228a0:	eddf 6a37 	vldr	s13, [pc, #220]	@ 8022980 <__ieee754_rem_pio2f+0x254>
 80228a4:	eee6 7a25 	vfma.f32	s15, s12, s11
 80228a8:	eed7 7a26 	vfnms.f32	s15, s14, s13
 80228ac:	ee30 7a67 	vsub.f32	s14, s0, s15
 80228b0:	ed84 7a00 	vstr	s14, [r4]
 80228b4:	e7bc      	b.n	8022830 <__ieee754_rem_pio2f+0x104>
 80228b6:	f1b5 4fff 	cmp.w	r5, #2139095040	@ 0x7f800000
 80228ba:	d306      	bcc.n	80228ca <__ieee754_rem_pio2f+0x19e>
 80228bc:	ee70 7a40 	vsub.f32	s15, s0, s0
 80228c0:	edc0 7a01 	vstr	s15, [r0, #4]
 80228c4:	edc0 7a00 	vstr	s15, [r0]
 80228c8:	e73e      	b.n	8022748 <__ieee754_rem_pio2f+0x1c>
 80228ca:	15ea      	asrs	r2, r5, #23
 80228cc:	3a86      	subs	r2, #134	@ 0x86
 80228ce:	eba5 53c2 	sub.w	r3, r5, r2, lsl #23
 80228d2:	ee07 3a90 	vmov	s15, r3
 80228d6:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 80228da:	eddf 6a2a 	vldr	s13, [pc, #168]	@ 8022984 <__ieee754_rem_pio2f+0x258>
 80228de:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80228e2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80228e6:	ed8d 7a03 	vstr	s14, [sp, #12]
 80228ea:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80228ee:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 80228f2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80228f6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80228fa:	ed8d 7a04 	vstr	s14, [sp, #16]
 80228fe:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8022902:	eef5 7a40 	vcmp.f32	s15, #0.0
 8022906:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802290a:	edcd 7a05 	vstr	s15, [sp, #20]
 802290e:	d11e      	bne.n	802294e <__ieee754_rem_pio2f+0x222>
 8022910:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8022914:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022918:	bf0c      	ite	eq
 802291a:	2301      	moveq	r3, #1
 802291c:	2302      	movne	r3, #2
 802291e:	491a      	ldr	r1, [pc, #104]	@ (8022988 <__ieee754_rem_pio2f+0x25c>)
 8022920:	9101      	str	r1, [sp, #4]
 8022922:	2102      	movs	r1, #2
 8022924:	9100      	str	r1, [sp, #0]
 8022926:	a803      	add	r0, sp, #12
 8022928:	4621      	mov	r1, r4
 802292a:	f000 fd1d 	bl	8023368 <__kernel_rem_pio2f>
 802292e:	2e00      	cmp	r6, #0
 8022930:	f6bf af2f 	bge.w	8022792 <__ieee754_rem_pio2f+0x66>
 8022934:	edd4 7a00 	vldr	s15, [r4]
 8022938:	eef1 7a67 	vneg.f32	s15, s15
 802293c:	edc4 7a00 	vstr	s15, [r4]
 8022940:	edd4 7a01 	vldr	s15, [r4, #4]
 8022944:	eef1 7a67 	vneg.f32	s15, s15
 8022948:	edc4 7a01 	vstr	s15, [r4, #4]
 802294c:	e782      	b.n	8022854 <__ieee754_rem_pio2f+0x128>
 802294e:	2303      	movs	r3, #3
 8022950:	e7e5      	b.n	802291e <__ieee754_rem_pio2f+0x1f2>
 8022952:	bf00      	nop
 8022954:	3f490fd8 	.word	0x3f490fd8
 8022958:	4016cbe3 	.word	0x4016cbe3
 802295c:	3fc90f80 	.word	0x3fc90f80
 8022960:	3fc90fd0 	.word	0x3fc90fd0
 8022964:	37354400 	.word	0x37354400
 8022968:	37354443 	.word	0x37354443
 802296c:	2e85a308 	.word	0x2e85a308
 8022970:	43490f80 	.word	0x43490f80
 8022974:	3f22f984 	.word	0x3f22f984
 8022978:	08023ff8 	.word	0x08023ff8
 802297c:	2e85a300 	.word	0x2e85a300
 8022980:	248d3132 	.word	0x248d3132
 8022984:	43800000 	.word	0x43800000
 8022988:	08024078 	.word	0x08024078

0802298c <atanf>:
 802298c:	b538      	push	{r3, r4, r5, lr}
 802298e:	ee10 5a10 	vmov	r5, s0
 8022992:	f025 4400 	bic.w	r4, r5, #2147483648	@ 0x80000000
 8022996:	f1b4 4fa1 	cmp.w	r4, #1350565888	@ 0x50800000
 802299a:	eef0 7a40 	vmov.f32	s15, s0
 802299e:	d310      	bcc.n	80229c2 <atanf+0x36>
 80229a0:	f1b4 4fff 	cmp.w	r4, #2139095040	@ 0x7f800000
 80229a4:	d904      	bls.n	80229b0 <atanf+0x24>
 80229a6:	ee70 7a00 	vadd.f32	s15, s0, s0
 80229aa:	eeb0 0a67 	vmov.f32	s0, s15
 80229ae:	bd38      	pop	{r3, r4, r5, pc}
 80229b0:	eddf 7a4d 	vldr	s15, [pc, #308]	@ 8022ae8 <atanf+0x15c>
 80229b4:	ed9f 7a4d 	vldr	s14, [pc, #308]	@ 8022aec <atanf+0x160>
 80229b8:	2d00      	cmp	r5, #0
 80229ba:	bfc8      	it	gt
 80229bc:	eef0 7a47 	vmovgt.f32	s15, s14
 80229c0:	e7f3      	b.n	80229aa <atanf+0x1e>
 80229c2:	4b4b      	ldr	r3, [pc, #300]	@ (8022af0 <atanf+0x164>)
 80229c4:	429c      	cmp	r4, r3
 80229c6:	d810      	bhi.n	80229ea <atanf+0x5e>
 80229c8:	f1b4 5f44 	cmp.w	r4, #822083584	@ 0x31000000
 80229cc:	d20a      	bcs.n	80229e4 <atanf+0x58>
 80229ce:	ed9f 7a49 	vldr	s14, [pc, #292]	@ 8022af4 <atanf+0x168>
 80229d2:	ee30 7a07 	vadd.f32	s14, s0, s14
 80229d6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80229da:	eeb4 7ae6 	vcmpe.f32	s14, s13
 80229de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80229e2:	dce2      	bgt.n	80229aa <atanf+0x1e>
 80229e4:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
 80229e8:	e013      	b.n	8022a12 <atanf+0x86>
 80229ea:	f7fc ffab 	bl	801f944 <fabsf>
 80229ee:	4b42      	ldr	r3, [pc, #264]	@ (8022af8 <atanf+0x16c>)
 80229f0:	429c      	cmp	r4, r3
 80229f2:	d84f      	bhi.n	8022a94 <atanf+0x108>
 80229f4:	f5a3 03d0 	sub.w	r3, r3, #6815744	@ 0x680000
 80229f8:	429c      	cmp	r4, r3
 80229fa:	d841      	bhi.n	8022a80 <atanf+0xf4>
 80229fc:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
 8022a00:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8022a04:	eea0 7a27 	vfma.f32	s14, s0, s15
 8022a08:	2300      	movs	r3, #0
 8022a0a:	ee30 0a27 	vadd.f32	s0, s0, s15
 8022a0e:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8022a12:	1c5a      	adds	r2, r3, #1
 8022a14:	ee27 6aa7 	vmul.f32	s12, s15, s15
 8022a18:	ed9f 7a38 	vldr	s14, [pc, #224]	@ 8022afc <atanf+0x170>
 8022a1c:	eddf 5a38 	vldr	s11, [pc, #224]	@ 8022b00 <atanf+0x174>
 8022a20:	ed9f 5a38 	vldr	s10, [pc, #224]	@ 8022b04 <atanf+0x178>
 8022a24:	ee66 6a06 	vmul.f32	s13, s12, s12
 8022a28:	eee6 5a87 	vfma.f32	s11, s13, s14
 8022a2c:	ed9f 7a36 	vldr	s14, [pc, #216]	@ 8022b08 <atanf+0x17c>
 8022a30:	eea5 7aa6 	vfma.f32	s14, s11, s13
 8022a34:	eddf 5a35 	vldr	s11, [pc, #212]	@ 8022b0c <atanf+0x180>
 8022a38:	eee7 5a26 	vfma.f32	s11, s14, s13
 8022a3c:	ed9f 7a34 	vldr	s14, [pc, #208]	@ 8022b10 <atanf+0x184>
 8022a40:	eea5 7aa6 	vfma.f32	s14, s11, s13
 8022a44:	eddf 5a33 	vldr	s11, [pc, #204]	@ 8022b14 <atanf+0x188>
 8022a48:	eee7 5a26 	vfma.f32	s11, s14, s13
 8022a4c:	ed9f 7a32 	vldr	s14, [pc, #200]	@ 8022b18 <atanf+0x18c>
 8022a50:	eea6 5a87 	vfma.f32	s10, s13, s14
 8022a54:	ed9f 7a31 	vldr	s14, [pc, #196]	@ 8022b1c <atanf+0x190>
 8022a58:	eea5 7a26 	vfma.f32	s14, s10, s13
 8022a5c:	ed9f 5a30 	vldr	s10, [pc, #192]	@ 8022b20 <atanf+0x194>
 8022a60:	eea7 5a26 	vfma.f32	s10, s14, s13
 8022a64:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 8022b24 <atanf+0x198>
 8022a68:	eea5 7a26 	vfma.f32	s14, s10, s13
 8022a6c:	ee27 7a26 	vmul.f32	s14, s14, s13
 8022a70:	eea5 7a86 	vfma.f32	s14, s11, s12
 8022a74:	ee27 7a87 	vmul.f32	s14, s15, s14
 8022a78:	d121      	bne.n	8022abe <atanf+0x132>
 8022a7a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8022a7e:	e794      	b.n	80229aa <atanf+0x1e>
 8022a80:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8022a84:	ee30 7a67 	vsub.f32	s14, s0, s15
 8022a88:	ee30 0a27 	vadd.f32	s0, s0, s15
 8022a8c:	2301      	movs	r3, #1
 8022a8e:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8022a92:	e7be      	b.n	8022a12 <atanf+0x86>
 8022a94:	4b24      	ldr	r3, [pc, #144]	@ (8022b28 <atanf+0x19c>)
 8022a96:	429c      	cmp	r4, r3
 8022a98:	d80b      	bhi.n	8022ab2 <atanf+0x126>
 8022a9a:	eef7 7a08 	vmov.f32	s15, #120	@ 0x3fc00000  1.5
 8022a9e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8022aa2:	eea0 7a27 	vfma.f32	s14, s0, s15
 8022aa6:	2302      	movs	r3, #2
 8022aa8:	ee70 6a67 	vsub.f32	s13, s0, s15
 8022aac:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8022ab0:	e7af      	b.n	8022a12 <atanf+0x86>
 8022ab2:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8022ab6:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8022aba:	2303      	movs	r3, #3
 8022abc:	e7a9      	b.n	8022a12 <atanf+0x86>
 8022abe:	4a1b      	ldr	r2, [pc, #108]	@ (8022b2c <atanf+0x1a0>)
 8022ac0:	491b      	ldr	r1, [pc, #108]	@ (8022b30 <atanf+0x1a4>)
 8022ac2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8022ac6:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8022aca:	edd3 6a00 	vldr	s13, [r3]
 8022ace:	ee37 7a66 	vsub.f32	s14, s14, s13
 8022ad2:	2d00      	cmp	r5, #0
 8022ad4:	ee37 7a67 	vsub.f32	s14, s14, s15
 8022ad8:	edd2 7a00 	vldr	s15, [r2]
 8022adc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8022ae0:	bfb8      	it	lt
 8022ae2:	eef1 7a67 	vneglt.f32	s15, s15
 8022ae6:	e760      	b.n	80229aa <atanf+0x1e>
 8022ae8:	bfc90fdb 	.word	0xbfc90fdb
 8022aec:	3fc90fdb 	.word	0x3fc90fdb
 8022af0:	3edfffff 	.word	0x3edfffff
 8022af4:	7149f2ca 	.word	0x7149f2ca
 8022af8:	3f97ffff 	.word	0x3f97ffff
 8022afc:	3c8569d7 	.word	0x3c8569d7
 8022b00:	3d4bda59 	.word	0x3d4bda59
 8022b04:	bd6ef16b 	.word	0xbd6ef16b
 8022b08:	3d886b35 	.word	0x3d886b35
 8022b0c:	3dba2e6e 	.word	0x3dba2e6e
 8022b10:	3e124925 	.word	0x3e124925
 8022b14:	3eaaaaab 	.word	0x3eaaaaab
 8022b18:	bd15a221 	.word	0xbd15a221
 8022b1c:	bd9d8795 	.word	0xbd9d8795
 8022b20:	bde38e38 	.word	0xbde38e38
 8022b24:	be4ccccd 	.word	0xbe4ccccd
 8022b28:	401bffff 	.word	0x401bffff
 8022b2c:	080243a0 	.word	0x080243a0
 8022b30:	08024390 	.word	0x08024390
 8022b34:	00000000 	.word	0x00000000

08022b38 <scalbn>:
 8022b38:	b570      	push	{r4, r5, r6, lr}
 8022b3a:	ec55 4b10 	vmov	r4, r5, d0
 8022b3e:	f3c5 510a 	ubfx	r1, r5, #20, #11
 8022b42:	4606      	mov	r6, r0
 8022b44:	462b      	mov	r3, r5
 8022b46:	b991      	cbnz	r1, 8022b6e <scalbn+0x36>
 8022b48:	f025 4300 	bic.w	r3, r5, #2147483648	@ 0x80000000
 8022b4c:	4323      	orrs	r3, r4
 8022b4e:	d03d      	beq.n	8022bcc <scalbn+0x94>
 8022b50:	4b35      	ldr	r3, [pc, #212]	@ (8022c28 <scalbn+0xf0>)
 8022b52:	4620      	mov	r0, r4
 8022b54:	4629      	mov	r1, r5
 8022b56:	2200      	movs	r2, #0
 8022b58:	f7dd fd56 	bl	8000608 <__aeabi_dmul>
 8022b5c:	4b33      	ldr	r3, [pc, #204]	@ (8022c2c <scalbn+0xf4>)
 8022b5e:	429e      	cmp	r6, r3
 8022b60:	4604      	mov	r4, r0
 8022b62:	460d      	mov	r5, r1
 8022b64:	da0f      	bge.n	8022b86 <scalbn+0x4e>
 8022b66:	a328      	add	r3, pc, #160	@ (adr r3, 8022c08 <scalbn+0xd0>)
 8022b68:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022b6c:	e01e      	b.n	8022bac <scalbn+0x74>
 8022b6e:	f240 72ff 	movw	r2, #2047	@ 0x7ff
 8022b72:	4291      	cmp	r1, r2
 8022b74:	d10b      	bne.n	8022b8e <scalbn+0x56>
 8022b76:	4622      	mov	r2, r4
 8022b78:	4620      	mov	r0, r4
 8022b7a:	4629      	mov	r1, r5
 8022b7c:	f7dd fb8e 	bl	800029c <__adddf3>
 8022b80:	4604      	mov	r4, r0
 8022b82:	460d      	mov	r5, r1
 8022b84:	e022      	b.n	8022bcc <scalbn+0x94>
 8022b86:	460b      	mov	r3, r1
 8022b88:	f3c1 510a 	ubfx	r1, r1, #20, #11
 8022b8c:	3936      	subs	r1, #54	@ 0x36
 8022b8e:	f24c 3250 	movw	r2, #50000	@ 0xc350
 8022b92:	4296      	cmp	r6, r2
 8022b94:	dd0d      	ble.n	8022bb2 <scalbn+0x7a>
 8022b96:	2d00      	cmp	r5, #0
 8022b98:	a11d      	add	r1, pc, #116	@ (adr r1, 8022c10 <scalbn+0xd8>)
 8022b9a:	e9d1 0100 	ldrd	r0, r1, [r1]
 8022b9e:	da02      	bge.n	8022ba6 <scalbn+0x6e>
 8022ba0:	a11d      	add	r1, pc, #116	@ (adr r1, 8022c18 <scalbn+0xe0>)
 8022ba2:	e9d1 0100 	ldrd	r0, r1, [r1]
 8022ba6:	a31a      	add	r3, pc, #104	@ (adr r3, 8022c10 <scalbn+0xd8>)
 8022ba8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8022bac:	f7dd fd2c 	bl	8000608 <__aeabi_dmul>
 8022bb0:	e7e6      	b.n	8022b80 <scalbn+0x48>
 8022bb2:	1872      	adds	r2, r6, r1
 8022bb4:	f240 71fe 	movw	r1, #2046	@ 0x7fe
 8022bb8:	428a      	cmp	r2, r1
 8022bba:	dcec      	bgt.n	8022b96 <scalbn+0x5e>
 8022bbc:	2a00      	cmp	r2, #0
 8022bbe:	dd08      	ble.n	8022bd2 <scalbn+0x9a>
 8022bc0:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 8022bc4:	f423 03e0 	bic.w	r3, r3, #7340032	@ 0x700000
 8022bc8:	ea43 5502 	orr.w	r5, r3, r2, lsl #20
 8022bcc:	ec45 4b10 	vmov	d0, r4, r5
 8022bd0:	bd70      	pop	{r4, r5, r6, pc}
 8022bd2:	f112 0f35 	cmn.w	r2, #53	@ 0x35
 8022bd6:	da08      	bge.n	8022bea <scalbn+0xb2>
 8022bd8:	2d00      	cmp	r5, #0
 8022bda:	a10b      	add	r1, pc, #44	@ (adr r1, 8022c08 <scalbn+0xd0>)
 8022bdc:	e9d1 0100 	ldrd	r0, r1, [r1]
 8022be0:	dac1      	bge.n	8022b66 <scalbn+0x2e>
 8022be2:	a10f      	add	r1, pc, #60	@ (adr r1, 8022c20 <scalbn+0xe8>)
 8022be4:	e9d1 0100 	ldrd	r0, r1, [r1]
 8022be8:	e7bd      	b.n	8022b66 <scalbn+0x2e>
 8022bea:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 8022bee:	3236      	adds	r2, #54	@ 0x36
 8022bf0:	f423 03e0 	bic.w	r3, r3, #7340032	@ 0x700000
 8022bf4:	ea43 5502 	orr.w	r5, r3, r2, lsl #20
 8022bf8:	4620      	mov	r0, r4
 8022bfa:	4b0d      	ldr	r3, [pc, #52]	@ (8022c30 <scalbn+0xf8>)
 8022bfc:	4629      	mov	r1, r5
 8022bfe:	2200      	movs	r2, #0
 8022c00:	e7d4      	b.n	8022bac <scalbn+0x74>
 8022c02:	bf00      	nop
 8022c04:	f3af 8000 	nop.w
 8022c08:	c2f8f359 	.word	0xc2f8f359
 8022c0c:	01a56e1f 	.word	0x01a56e1f
 8022c10:	8800759c 	.word	0x8800759c
 8022c14:	7e37e43c 	.word	0x7e37e43c
 8022c18:	8800759c 	.word	0x8800759c
 8022c1c:	fe37e43c 	.word	0xfe37e43c
 8022c20:	c2f8f359 	.word	0xc2f8f359
 8022c24:	81a56e1f 	.word	0x81a56e1f
 8022c28:	43500000 	.word	0x43500000
 8022c2c:	ffff3cb0 	.word	0xffff3cb0
 8022c30:	3c900000 	.word	0x3c900000

08022c34 <with_errno>:
 8022c34:	b510      	push	{r4, lr}
 8022c36:	ed2d 8b02 	vpush	{d8}
 8022c3a:	eeb0 8a40 	vmov.f32	s16, s0
 8022c3e:	eef0 8a60 	vmov.f32	s17, s1
 8022c42:	4604      	mov	r4, r0
 8022c44:	f7fa fd52 	bl	801d6ec <__errno>
 8022c48:	eeb0 0a48 	vmov.f32	s0, s16
 8022c4c:	eef0 0a68 	vmov.f32	s1, s17
 8022c50:	ecbd 8b02 	vpop	{d8}
 8022c54:	6004      	str	r4, [r0, #0]
 8022c56:	bd10      	pop	{r4, pc}

08022c58 <xflow>:
 8022c58:	4603      	mov	r3, r0
 8022c5a:	b507      	push	{r0, r1, r2, lr}
 8022c5c:	ec51 0b10 	vmov	r0, r1, d0
 8022c60:	b183      	cbz	r3, 8022c84 <xflow+0x2c>
 8022c62:	4602      	mov	r2, r0
 8022c64:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8022c68:	e9cd 2300 	strd	r2, r3, [sp]
 8022c6c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8022c70:	f7dd fcca 	bl	8000608 <__aeabi_dmul>
 8022c74:	ec41 0b10 	vmov	d0, r0, r1
 8022c78:	2022      	movs	r0, #34	@ 0x22
 8022c7a:	b003      	add	sp, #12
 8022c7c:	f85d eb04 	ldr.w	lr, [sp], #4
 8022c80:	f7ff bfd8 	b.w	8022c34 <with_errno>
 8022c84:	4602      	mov	r2, r0
 8022c86:	460b      	mov	r3, r1
 8022c88:	e7ee      	b.n	8022c68 <xflow+0x10>
 8022c8a:	0000      	movs	r0, r0
 8022c8c:	0000      	movs	r0, r0
	...

08022c90 <__math_uflow>:
 8022c90:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 8022c98 <__math_uflow+0x8>
 8022c94:	f7ff bfe0 	b.w	8022c58 <xflow>
 8022c98:	00000000 	.word	0x00000000
 8022c9c:	10000000 	.word	0x10000000

08022ca0 <__math_oflow>:
 8022ca0:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 8022ca8 <__math_oflow+0x8>
 8022ca4:	f7ff bfd8 	b.w	8022c58 <xflow>
 8022ca8:	00000000 	.word	0x00000000
 8022cac:	70000000 	.word	0x70000000

08022cb0 <__ieee754_sqrtf>:
 8022cb0:	eeb1 0ac0 	vsqrt.f32	s0, s0
 8022cb4:	4770      	bx	lr
	...

08022cb8 <__kernel_rem_pio2>:
 8022cb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022cbc:	ed2d 8b02 	vpush	{d8}
 8022cc0:	f5ad 7d19 	sub.w	sp, sp, #612	@ 0x264
 8022cc4:	f112 0f14 	cmn.w	r2, #20
 8022cc8:	9306      	str	r3, [sp, #24]
 8022cca:	9104      	str	r1, [sp, #16]
 8022ccc:	4bbe      	ldr	r3, [pc, #760]	@ (8022fc8 <__kernel_rem_pio2+0x310>)
 8022cce:	99a4      	ldr	r1, [sp, #656]	@ 0x290
 8022cd0:	9008      	str	r0, [sp, #32]
 8022cd2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8022cd6:	9300      	str	r3, [sp, #0]
 8022cd8:	9b06      	ldr	r3, [sp, #24]
 8022cda:	f103 33ff 	add.w	r3, r3, #4294967295	@ 0xffffffff
 8022cde:	bfa8      	it	ge
 8022ce0:	1ed4      	subge	r4, r2, #3
 8022ce2:	9305      	str	r3, [sp, #20]
 8022ce4:	bfb2      	itee	lt
 8022ce6:	2400      	movlt	r4, #0
 8022ce8:	2318      	movge	r3, #24
 8022cea:	fb94 f4f3 	sdivge	r4, r4, r3
 8022cee:	f06f 0317 	mvn.w	r3, #23
 8022cf2:	fb04 3303 	mla	r3, r4, r3, r3
 8022cf6:	eb03 0b02 	add.w	fp, r3, r2
 8022cfa:	9b00      	ldr	r3, [sp, #0]
 8022cfc:	9a05      	ldr	r2, [sp, #20]
 8022cfe:	ed9f 8bae 	vldr	d8, [pc, #696]	@ 8022fb8 <__kernel_rem_pio2+0x300>
 8022d02:	eb03 0802 	add.w	r8, r3, r2
 8022d06:	9ba5      	ldr	r3, [sp, #660]	@ 0x294
 8022d08:	1aa7      	subs	r7, r4, r2
 8022d0a:	ae20      	add	r6, sp, #128	@ 0x80
 8022d0c:	eb03 0987 	add.w	r9, r3, r7, lsl #2
 8022d10:	2500      	movs	r5, #0
 8022d12:	4545      	cmp	r5, r8
 8022d14:	dd13      	ble.n	8022d3e <__kernel_rem_pio2+0x86>
 8022d16:	9b06      	ldr	r3, [sp, #24]
 8022d18:	aa20      	add	r2, sp, #128	@ 0x80
 8022d1a:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 8022d1e:	f50d 7ae0 	add.w	sl, sp, #448	@ 0x1c0
 8022d22:	f04f 0800 	mov.w	r8, #0
 8022d26:	9b00      	ldr	r3, [sp, #0]
 8022d28:	4598      	cmp	r8, r3
 8022d2a:	dc31      	bgt.n	8022d90 <__kernel_rem_pio2+0xd8>
 8022d2c:	ed9f 7ba2 	vldr	d7, [pc, #648]	@ 8022fb8 <__kernel_rem_pio2+0x300>
 8022d30:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8022d34:	ed8d 7b02 	vstr	d7, [sp, #8]
 8022d38:	462f      	mov	r7, r5
 8022d3a:	2600      	movs	r6, #0
 8022d3c:	e01b      	b.n	8022d76 <__kernel_rem_pio2+0xbe>
 8022d3e:	42ef      	cmn	r7, r5
 8022d40:	d407      	bmi.n	8022d52 <__kernel_rem_pio2+0x9a>
 8022d42:	f859 0025 	ldr.w	r0, [r9, r5, lsl #2]
 8022d46:	f7dd fbf5 	bl	8000534 <__aeabi_i2d>
 8022d4a:	e8e6 0102 	strd	r0, r1, [r6], #8
 8022d4e:	3501      	adds	r5, #1
 8022d50:	e7df      	b.n	8022d12 <__kernel_rem_pio2+0x5a>
 8022d52:	ec51 0b18 	vmov	r0, r1, d8
 8022d56:	e7f8      	b.n	8022d4a <__kernel_rem_pio2+0x92>
 8022d58:	e9d7 2300 	ldrd	r2, r3, [r7]
 8022d5c:	e8f9 0102 	ldrd	r0, r1, [r9], #8
 8022d60:	f7dd fc52 	bl	8000608 <__aeabi_dmul>
 8022d64:	4602      	mov	r2, r0
 8022d66:	460b      	mov	r3, r1
 8022d68:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8022d6c:	f7dd fa96 	bl	800029c <__adddf3>
 8022d70:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8022d74:	3601      	adds	r6, #1
 8022d76:	9b05      	ldr	r3, [sp, #20]
 8022d78:	429e      	cmp	r6, r3
 8022d7a:	f1a7 0708 	sub.w	r7, r7, #8
 8022d7e:	ddeb      	ble.n	8022d58 <__kernel_rem_pio2+0xa0>
 8022d80:	ed9d 7b02 	vldr	d7, [sp, #8]
 8022d84:	f108 0801 	add.w	r8, r8, #1
 8022d88:	ecaa 7b02 	vstmia	sl!, {d7}
 8022d8c:	3508      	adds	r5, #8
 8022d8e:	e7ca      	b.n	8022d26 <__kernel_rem_pio2+0x6e>
 8022d90:	9b00      	ldr	r3, [sp, #0]
 8022d92:	f8dd 8000 	ldr.w	r8, [sp]
 8022d96:	aa0c      	add	r2, sp, #48	@ 0x30
 8022d98:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8022d9c:	930a      	str	r3, [sp, #40]	@ 0x28
 8022d9e:	9ba5      	ldr	r3, [sp, #660]	@ 0x294
 8022da0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8022da4:	9309      	str	r3, [sp, #36]	@ 0x24
 8022da6:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 8022daa:	930b      	str	r3, [sp, #44]	@ 0x2c
 8022dac:	ab98      	add	r3, sp, #608	@ 0x260
 8022dae:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 8022db2:	ed13 7b28 	vldr	d7, [r3, #-160]	@ 0xffffff60
 8022db6:	ed8d 7b02 	vstr	d7, [sp, #8]
 8022dba:	ac0c      	add	r4, sp, #48	@ 0x30
 8022dbc:	ab70      	add	r3, sp, #448	@ 0x1c0
 8022dbe:	eb03 05c8 	add.w	r5, r3, r8, lsl #3
 8022dc2:	46a1      	mov	r9, r4
 8022dc4:	46c2      	mov	sl, r8
 8022dc6:	f1ba 0f00 	cmp.w	sl, #0
 8022dca:	f1a5 0508 	sub.w	r5, r5, #8
 8022dce:	dc77      	bgt.n	8022ec0 <__kernel_rem_pio2+0x208>
 8022dd0:	4658      	mov	r0, fp
 8022dd2:	ed9d 0b02 	vldr	d0, [sp, #8]
 8022dd6:	f7ff feaf 	bl	8022b38 <scalbn>
 8022dda:	ec57 6b10 	vmov	r6, r7, d0
 8022dde:	2200      	movs	r2, #0
 8022de0:	f04f 537f 	mov.w	r3, #1069547520	@ 0x3fc00000
 8022de4:	4630      	mov	r0, r6
 8022de6:	4639      	mov	r1, r7
 8022de8:	f7dd fc0e 	bl	8000608 <__aeabi_dmul>
 8022dec:	ec41 0b10 	vmov	d0, r0, r1
 8022df0:	f7fc ff92 	bl	801fd18 <floor>
 8022df4:	4b75      	ldr	r3, [pc, #468]	@ (8022fcc <__kernel_rem_pio2+0x314>)
 8022df6:	ec51 0b10 	vmov	r0, r1, d0
 8022dfa:	2200      	movs	r2, #0
 8022dfc:	f7dd fc04 	bl	8000608 <__aeabi_dmul>
 8022e00:	4602      	mov	r2, r0
 8022e02:	460b      	mov	r3, r1
 8022e04:	4630      	mov	r0, r6
 8022e06:	4639      	mov	r1, r7
 8022e08:	f7dd fa46 	bl	8000298 <__aeabi_dsub>
 8022e0c:	460f      	mov	r7, r1
 8022e0e:	4606      	mov	r6, r0
 8022e10:	f7dd feaa 	bl	8000b68 <__aeabi_d2iz>
 8022e14:	9002      	str	r0, [sp, #8]
 8022e16:	f7dd fb8d 	bl	8000534 <__aeabi_i2d>
 8022e1a:	4602      	mov	r2, r0
 8022e1c:	460b      	mov	r3, r1
 8022e1e:	4630      	mov	r0, r6
 8022e20:	4639      	mov	r1, r7
 8022e22:	f7dd fa39 	bl	8000298 <__aeabi_dsub>
 8022e26:	f1bb 0f00 	cmp.w	fp, #0
 8022e2a:	4606      	mov	r6, r0
 8022e2c:	460f      	mov	r7, r1
 8022e2e:	dd6c      	ble.n	8022f0a <__kernel_rem_pio2+0x252>
 8022e30:	f108 31ff 	add.w	r1, r8, #4294967295	@ 0xffffffff
 8022e34:	ab0c      	add	r3, sp, #48	@ 0x30
 8022e36:	9d02      	ldr	r5, [sp, #8]
 8022e38:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8022e3c:	f1cb 0018 	rsb	r0, fp, #24
 8022e40:	fa43 f200 	asr.w	r2, r3, r0
 8022e44:	4415      	add	r5, r2
 8022e46:	4082      	lsls	r2, r0
 8022e48:	1a9b      	subs	r3, r3, r2
 8022e4a:	aa0c      	add	r2, sp, #48	@ 0x30
 8022e4c:	9502      	str	r5, [sp, #8]
 8022e4e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8022e52:	f1cb 0217 	rsb	r2, fp, #23
 8022e56:	fa43 f902 	asr.w	r9, r3, r2
 8022e5a:	f1b9 0f00 	cmp.w	r9, #0
 8022e5e:	dd64      	ble.n	8022f2a <__kernel_rem_pio2+0x272>
 8022e60:	9b02      	ldr	r3, [sp, #8]
 8022e62:	2200      	movs	r2, #0
 8022e64:	3301      	adds	r3, #1
 8022e66:	9302      	str	r3, [sp, #8]
 8022e68:	4615      	mov	r5, r2
 8022e6a:	f06f 417f 	mvn.w	r1, #4278190080	@ 0xff000000
 8022e6e:	4590      	cmp	r8, r2
 8022e70:	f300 80b8 	bgt.w	8022fe4 <__kernel_rem_pio2+0x32c>
 8022e74:	f1bb 0f00 	cmp.w	fp, #0
 8022e78:	dd07      	ble.n	8022e8a <__kernel_rem_pio2+0x1d2>
 8022e7a:	f1bb 0f01 	cmp.w	fp, #1
 8022e7e:	f000 80bf 	beq.w	8023000 <__kernel_rem_pio2+0x348>
 8022e82:	f1bb 0f02 	cmp.w	fp, #2
 8022e86:	f000 80c6 	beq.w	8023016 <__kernel_rem_pio2+0x35e>
 8022e8a:	f1b9 0f02 	cmp.w	r9, #2
 8022e8e:	d14c      	bne.n	8022f2a <__kernel_rem_pio2+0x272>
 8022e90:	4632      	mov	r2, r6
 8022e92:	463b      	mov	r3, r7
 8022e94:	494e      	ldr	r1, [pc, #312]	@ (8022fd0 <__kernel_rem_pio2+0x318>)
 8022e96:	2000      	movs	r0, #0
 8022e98:	f7dd f9fe 	bl	8000298 <__aeabi_dsub>
 8022e9c:	4606      	mov	r6, r0
 8022e9e:	460f      	mov	r7, r1
 8022ea0:	2d00      	cmp	r5, #0
 8022ea2:	d042      	beq.n	8022f2a <__kernel_rem_pio2+0x272>
 8022ea4:	4658      	mov	r0, fp
 8022ea6:	ed9f 0b46 	vldr	d0, [pc, #280]	@ 8022fc0 <__kernel_rem_pio2+0x308>
 8022eaa:	f7ff fe45 	bl	8022b38 <scalbn>
 8022eae:	4630      	mov	r0, r6
 8022eb0:	4639      	mov	r1, r7
 8022eb2:	ec53 2b10 	vmov	r2, r3, d0
 8022eb6:	f7dd f9ef 	bl	8000298 <__aeabi_dsub>
 8022eba:	4606      	mov	r6, r0
 8022ebc:	460f      	mov	r7, r1
 8022ebe:	e034      	b.n	8022f2a <__kernel_rem_pio2+0x272>
 8022ec0:	4b44      	ldr	r3, [pc, #272]	@ (8022fd4 <__kernel_rem_pio2+0x31c>)
 8022ec2:	2200      	movs	r2, #0
 8022ec4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8022ec8:	f7dd fb9e 	bl	8000608 <__aeabi_dmul>
 8022ecc:	f7dd fe4c 	bl	8000b68 <__aeabi_d2iz>
 8022ed0:	f7dd fb30 	bl	8000534 <__aeabi_i2d>
 8022ed4:	4b40      	ldr	r3, [pc, #256]	@ (8022fd8 <__kernel_rem_pio2+0x320>)
 8022ed6:	2200      	movs	r2, #0
 8022ed8:	4606      	mov	r6, r0
 8022eda:	460f      	mov	r7, r1
 8022edc:	f7dd fb94 	bl	8000608 <__aeabi_dmul>
 8022ee0:	4602      	mov	r2, r0
 8022ee2:	460b      	mov	r3, r1
 8022ee4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8022ee8:	f7dd f9d6 	bl	8000298 <__aeabi_dsub>
 8022eec:	f7dd fe3c 	bl	8000b68 <__aeabi_d2iz>
 8022ef0:	e9d5 2300 	ldrd	r2, r3, [r5]
 8022ef4:	f849 0b04 	str.w	r0, [r9], #4
 8022ef8:	4639      	mov	r1, r7
 8022efa:	4630      	mov	r0, r6
 8022efc:	f7dd f9ce 	bl	800029c <__adddf3>
 8022f00:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
 8022f04:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8022f08:	e75d      	b.n	8022dc6 <__kernel_rem_pio2+0x10e>
 8022f0a:	d107      	bne.n	8022f1c <__kernel_rem_pio2+0x264>
 8022f0c:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
 8022f10:	aa0c      	add	r2, sp, #48	@ 0x30
 8022f12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8022f16:	ea4f 59e3 	mov.w	r9, r3, asr #23
 8022f1a:	e79e      	b.n	8022e5a <__kernel_rem_pio2+0x1a2>
 8022f1c:	4b2f      	ldr	r3, [pc, #188]	@ (8022fdc <__kernel_rem_pio2+0x324>)
 8022f1e:	2200      	movs	r2, #0
 8022f20:	f7dd fdf8 	bl	8000b14 <__aeabi_dcmpge>
 8022f24:	2800      	cmp	r0, #0
 8022f26:	d143      	bne.n	8022fb0 <__kernel_rem_pio2+0x2f8>
 8022f28:	4681      	mov	r9, r0
 8022f2a:	2200      	movs	r2, #0
 8022f2c:	2300      	movs	r3, #0
 8022f2e:	4630      	mov	r0, r6
 8022f30:	4639      	mov	r1, r7
 8022f32:	f7dd fdd1 	bl	8000ad8 <__aeabi_dcmpeq>
 8022f36:	2800      	cmp	r0, #0
 8022f38:	f000 80bf 	beq.w	80230ba <__kernel_rem_pio2+0x402>
 8022f3c:	f108 33ff 	add.w	r3, r8, #4294967295	@ 0xffffffff
 8022f40:	2200      	movs	r2, #0
 8022f42:	9900      	ldr	r1, [sp, #0]
 8022f44:	428b      	cmp	r3, r1
 8022f46:	da6e      	bge.n	8023026 <__kernel_rem_pio2+0x36e>
 8022f48:	2a00      	cmp	r2, #0
 8022f4a:	f000 8089 	beq.w	8023060 <__kernel_rem_pio2+0x3a8>
 8022f4e:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
 8022f52:	ab0c      	add	r3, sp, #48	@ 0x30
 8022f54:	f1ab 0b18 	sub.w	fp, fp, #24
 8022f58:	f853 3028 	ldr.w	r3, [r3, r8, lsl #2]
 8022f5c:	2b00      	cmp	r3, #0
 8022f5e:	d0f6      	beq.n	8022f4e <__kernel_rem_pio2+0x296>
 8022f60:	4658      	mov	r0, fp
 8022f62:	ed9f 0b17 	vldr	d0, [pc, #92]	@ 8022fc0 <__kernel_rem_pio2+0x308>
 8022f66:	f7ff fde7 	bl	8022b38 <scalbn>
 8022f6a:	f108 0301 	add.w	r3, r8, #1
 8022f6e:	00da      	lsls	r2, r3, #3
 8022f70:	9205      	str	r2, [sp, #20]
 8022f72:	ec55 4b10 	vmov	r4, r5, d0
 8022f76:	aa70      	add	r2, sp, #448	@ 0x1c0
 8022f78:	f8df b058 	ldr.w	fp, [pc, #88]	@ 8022fd4 <__kernel_rem_pio2+0x31c>
 8022f7c:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8022f80:	4646      	mov	r6, r8
 8022f82:	f04f 0a00 	mov.w	sl, #0
 8022f86:	2e00      	cmp	r6, #0
 8022f88:	f280 80cf 	bge.w	802312a <__kernel_rem_pio2+0x472>
 8022f8c:	4644      	mov	r4, r8
 8022f8e:	2c00      	cmp	r4, #0
 8022f90:	f2c0 80fd 	blt.w	802318e <__kernel_rem_pio2+0x4d6>
 8022f94:	4b12      	ldr	r3, [pc, #72]	@ (8022fe0 <__kernel_rem_pio2+0x328>)
 8022f96:	461f      	mov	r7, r3
 8022f98:	ab70      	add	r3, sp, #448	@ 0x1c0
 8022f9a:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8022f9e:	9306      	str	r3, [sp, #24]
 8022fa0:	f04f 0a00 	mov.w	sl, #0
 8022fa4:	f04f 0b00 	mov.w	fp, #0
 8022fa8:	2600      	movs	r6, #0
 8022faa:	eba8 0504 	sub.w	r5, r8, r4
 8022fae:	e0e2      	b.n	8023176 <__kernel_rem_pio2+0x4be>
 8022fb0:	f04f 0902 	mov.w	r9, #2
 8022fb4:	e754      	b.n	8022e60 <__kernel_rem_pio2+0x1a8>
 8022fb6:	bf00      	nop
	...
 8022fc4:	3ff00000 	.word	0x3ff00000
 8022fc8:	080243f0 	.word	0x080243f0
 8022fcc:	40200000 	.word	0x40200000
 8022fd0:	3ff00000 	.word	0x3ff00000
 8022fd4:	3e700000 	.word	0x3e700000
 8022fd8:	41700000 	.word	0x41700000
 8022fdc:	3fe00000 	.word	0x3fe00000
 8022fe0:	080243b0 	.word	0x080243b0
 8022fe4:	f854 3b04 	ldr.w	r3, [r4], #4
 8022fe8:	b945      	cbnz	r5, 8022ffc <__kernel_rem_pio2+0x344>
 8022fea:	b123      	cbz	r3, 8022ff6 <__kernel_rem_pio2+0x33e>
 8022fec:	f1c3 7380 	rsb	r3, r3, #16777216	@ 0x1000000
 8022ff0:	f844 3c04 	str.w	r3, [r4, #-4]
 8022ff4:	2301      	movs	r3, #1
 8022ff6:	3201      	adds	r2, #1
 8022ff8:	461d      	mov	r5, r3
 8022ffa:	e738      	b.n	8022e6e <__kernel_rem_pio2+0x1b6>
 8022ffc:	1acb      	subs	r3, r1, r3
 8022ffe:	e7f7      	b.n	8022ff0 <__kernel_rem_pio2+0x338>
 8023000:	f108 32ff 	add.w	r2, r8, #4294967295	@ 0xffffffff
 8023004:	ab0c      	add	r3, sp, #48	@ 0x30
 8023006:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802300a:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802300e:	a90c      	add	r1, sp, #48	@ 0x30
 8023010:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8023014:	e739      	b.n	8022e8a <__kernel_rem_pio2+0x1d2>
 8023016:	f108 32ff 	add.w	r2, r8, #4294967295	@ 0xffffffff
 802301a:	ab0c      	add	r3, sp, #48	@ 0x30
 802301c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8023020:	f3c3 0315 	ubfx	r3, r3, #0, #22
 8023024:	e7f3      	b.n	802300e <__kernel_rem_pio2+0x356>
 8023026:	a90c      	add	r1, sp, #48	@ 0x30
 8023028:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
 802302c:	3b01      	subs	r3, #1
 802302e:	430a      	orrs	r2, r1
 8023030:	e787      	b.n	8022f42 <__kernel_rem_pio2+0x28a>
 8023032:	3401      	adds	r4, #1
 8023034:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8023038:	2a00      	cmp	r2, #0
 802303a:	d0fa      	beq.n	8023032 <__kernel_rem_pio2+0x37a>
 802303c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 802303e:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8023042:	eb0d 0503 	add.w	r5, sp, r3
 8023046:	9b06      	ldr	r3, [sp, #24]
 8023048:	aa20      	add	r2, sp, #128	@ 0x80
 802304a:	4443      	add	r3, r8
 802304c:	f108 0701 	add.w	r7, r8, #1
 8023050:	3d98      	subs	r5, #152	@ 0x98
 8023052:	eb02 06c3 	add.w	r6, r2, r3, lsl #3
 8023056:	4444      	add	r4, r8
 8023058:	42bc      	cmp	r4, r7
 802305a:	da04      	bge.n	8023066 <__kernel_rem_pio2+0x3ae>
 802305c:	46a0      	mov	r8, r4
 802305e:	e6a2      	b.n	8022da6 <__kernel_rem_pio2+0xee>
 8023060:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8023062:	2401      	movs	r4, #1
 8023064:	e7e6      	b.n	8023034 <__kernel_rem_pio2+0x37c>
 8023066:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8023068:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
 802306c:	f7dd fa62 	bl	8000534 <__aeabi_i2d>
 8023070:	ed9f 7bb1 	vldr	d7, [pc, #708]	@ 8023338 <__kernel_rem_pio2+0x680>
 8023074:	e8e6 0102 	strd	r0, r1, [r6], #8
 8023078:	ed8d 7b02 	vstr	d7, [sp, #8]
 802307c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8023080:	46b2      	mov	sl, r6
 8023082:	f04f 0800 	mov.w	r8, #0
 8023086:	9b05      	ldr	r3, [sp, #20]
 8023088:	4598      	cmp	r8, r3
 802308a:	dd05      	ble.n	8023098 <__kernel_rem_pio2+0x3e0>
 802308c:	ed9d 7b02 	vldr	d7, [sp, #8]
 8023090:	3701      	adds	r7, #1
 8023092:	eca5 7b02 	vstmia	r5!, {d7}
 8023096:	e7df      	b.n	8023058 <__kernel_rem_pio2+0x3a0>
 8023098:	e97a 2302 	ldrd	r2, r3, [sl, #-8]!
 802309c:	e8f9 0102 	ldrd	r0, r1, [r9], #8
 80230a0:	f7dd fab2 	bl	8000608 <__aeabi_dmul>
 80230a4:	4602      	mov	r2, r0
 80230a6:	460b      	mov	r3, r1
 80230a8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80230ac:	f7dd f8f6 	bl	800029c <__adddf3>
 80230b0:	f108 0801 	add.w	r8, r8, #1
 80230b4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80230b8:	e7e5      	b.n	8023086 <__kernel_rem_pio2+0x3ce>
 80230ba:	f1cb 0000 	rsb	r0, fp, #0
 80230be:	ec47 6b10 	vmov	d0, r6, r7
 80230c2:	f7ff fd39 	bl	8022b38 <scalbn>
 80230c6:	ec55 4b10 	vmov	r4, r5, d0
 80230ca:	4b9d      	ldr	r3, [pc, #628]	@ (8023340 <__kernel_rem_pio2+0x688>)
 80230cc:	2200      	movs	r2, #0
 80230ce:	4620      	mov	r0, r4
 80230d0:	4629      	mov	r1, r5
 80230d2:	f7dd fd1f 	bl	8000b14 <__aeabi_dcmpge>
 80230d6:	b300      	cbz	r0, 802311a <__kernel_rem_pio2+0x462>
 80230d8:	4b9a      	ldr	r3, [pc, #616]	@ (8023344 <__kernel_rem_pio2+0x68c>)
 80230da:	2200      	movs	r2, #0
 80230dc:	4620      	mov	r0, r4
 80230de:	4629      	mov	r1, r5
 80230e0:	f7dd fa92 	bl	8000608 <__aeabi_dmul>
 80230e4:	f7dd fd40 	bl	8000b68 <__aeabi_d2iz>
 80230e8:	4606      	mov	r6, r0
 80230ea:	f7dd fa23 	bl	8000534 <__aeabi_i2d>
 80230ee:	4b94      	ldr	r3, [pc, #592]	@ (8023340 <__kernel_rem_pio2+0x688>)
 80230f0:	2200      	movs	r2, #0
 80230f2:	f7dd fa89 	bl	8000608 <__aeabi_dmul>
 80230f6:	460b      	mov	r3, r1
 80230f8:	4602      	mov	r2, r0
 80230fa:	4629      	mov	r1, r5
 80230fc:	4620      	mov	r0, r4
 80230fe:	f7dd f8cb 	bl	8000298 <__aeabi_dsub>
 8023102:	f7dd fd31 	bl	8000b68 <__aeabi_d2iz>
 8023106:	ab0c      	add	r3, sp, #48	@ 0x30
 8023108:	f10b 0b18 	add.w	fp, fp, #24
 802310c:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 8023110:	f108 0801 	add.w	r8, r8, #1
 8023114:	f843 6028 	str.w	r6, [r3, r8, lsl #2]
 8023118:	e722      	b.n	8022f60 <__kernel_rem_pio2+0x2a8>
 802311a:	4620      	mov	r0, r4
 802311c:	4629      	mov	r1, r5
 802311e:	f7dd fd23 	bl	8000b68 <__aeabi_d2iz>
 8023122:	ab0c      	add	r3, sp, #48	@ 0x30
 8023124:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 8023128:	e71a      	b.n	8022f60 <__kernel_rem_pio2+0x2a8>
 802312a:	ab0c      	add	r3, sp, #48	@ 0x30
 802312c:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 8023130:	f7dd fa00 	bl	8000534 <__aeabi_i2d>
 8023134:	4622      	mov	r2, r4
 8023136:	462b      	mov	r3, r5
 8023138:	f7dd fa66 	bl	8000608 <__aeabi_dmul>
 802313c:	4652      	mov	r2, sl
 802313e:	e967 0102 	strd	r0, r1, [r7, #-8]!
 8023142:	465b      	mov	r3, fp
 8023144:	4620      	mov	r0, r4
 8023146:	4629      	mov	r1, r5
 8023148:	f7dd fa5e 	bl	8000608 <__aeabi_dmul>
 802314c:	3e01      	subs	r6, #1
 802314e:	4604      	mov	r4, r0
 8023150:	460d      	mov	r5, r1
 8023152:	e718      	b.n	8022f86 <__kernel_rem_pio2+0x2ce>
 8023154:	9906      	ldr	r1, [sp, #24]
 8023156:	e8f1 2302 	ldrd	r2, r3, [r1], #8
 802315a:	9106      	str	r1, [sp, #24]
 802315c:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 8023160:	f7dd fa52 	bl	8000608 <__aeabi_dmul>
 8023164:	4602      	mov	r2, r0
 8023166:	460b      	mov	r3, r1
 8023168:	4650      	mov	r0, sl
 802316a:	4659      	mov	r1, fp
 802316c:	f7dd f896 	bl	800029c <__adddf3>
 8023170:	3601      	adds	r6, #1
 8023172:	4682      	mov	sl, r0
 8023174:	468b      	mov	fp, r1
 8023176:	9b00      	ldr	r3, [sp, #0]
 8023178:	429e      	cmp	r6, r3
 802317a:	dc01      	bgt.n	8023180 <__kernel_rem_pio2+0x4c8>
 802317c:	42b5      	cmp	r5, r6
 802317e:	dae9      	bge.n	8023154 <__kernel_rem_pio2+0x49c>
 8023180:	ab48      	add	r3, sp, #288	@ 0x120
 8023182:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
 8023186:	e9c5 ab00 	strd	sl, fp, [r5]
 802318a:	3c01      	subs	r4, #1
 802318c:	e6ff      	b.n	8022f8e <__kernel_rem_pio2+0x2d6>
 802318e:	9ba4      	ldr	r3, [sp, #656]	@ 0x290
 8023190:	2b02      	cmp	r3, #2
 8023192:	dc0b      	bgt.n	80231ac <__kernel_rem_pio2+0x4f4>
 8023194:	2b00      	cmp	r3, #0
 8023196:	dc39      	bgt.n	802320c <__kernel_rem_pio2+0x554>
 8023198:	d05d      	beq.n	8023256 <__kernel_rem_pio2+0x59e>
 802319a:	9b02      	ldr	r3, [sp, #8]
 802319c:	f003 0007 	and.w	r0, r3, #7
 80231a0:	f50d 7d19 	add.w	sp, sp, #612	@ 0x264
 80231a4:	ecbd 8b02 	vpop	{d8}
 80231a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80231ac:	9ba4      	ldr	r3, [sp, #656]	@ 0x290
 80231ae:	2b03      	cmp	r3, #3
 80231b0:	d1f3      	bne.n	802319a <__kernel_rem_pio2+0x4e2>
 80231b2:	9b05      	ldr	r3, [sp, #20]
 80231b4:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 80231b8:	eb0d 0403 	add.w	r4, sp, r3
 80231bc:	f5a4 74a4 	sub.w	r4, r4, #328	@ 0x148
 80231c0:	4625      	mov	r5, r4
 80231c2:	46c2      	mov	sl, r8
 80231c4:	f1ba 0f00 	cmp.w	sl, #0
 80231c8:	f1a5 0508 	sub.w	r5, r5, #8
 80231cc:	dc6b      	bgt.n	80232a6 <__kernel_rem_pio2+0x5ee>
 80231ce:	4645      	mov	r5, r8
 80231d0:	2d01      	cmp	r5, #1
 80231d2:	f1a4 0408 	sub.w	r4, r4, #8
 80231d6:	f300 8087 	bgt.w	80232e8 <__kernel_rem_pio2+0x630>
 80231da:	9c05      	ldr	r4, [sp, #20]
 80231dc:	ab48      	add	r3, sp, #288	@ 0x120
 80231de:	441c      	add	r4, r3
 80231e0:	2000      	movs	r0, #0
 80231e2:	2100      	movs	r1, #0
 80231e4:	f1b8 0f01 	cmp.w	r8, #1
 80231e8:	f300 809c 	bgt.w	8023324 <__kernel_rem_pio2+0x66c>
 80231ec:	e9dd 7848 	ldrd	r7, r8, [sp, #288]	@ 0x120
 80231f0:	e9dd 564a 	ldrd	r5, r6, [sp, #296]	@ 0x128
 80231f4:	f1b9 0f00 	cmp.w	r9, #0
 80231f8:	f040 80a6 	bne.w	8023348 <__kernel_rem_pio2+0x690>
 80231fc:	9b04      	ldr	r3, [sp, #16]
 80231fe:	e9c3 7800 	strd	r7, r8, [r3]
 8023202:	e9c3 5602 	strd	r5, r6, [r3, #8]
 8023206:	e9c3 0104 	strd	r0, r1, [r3, #16]
 802320a:	e7c6      	b.n	802319a <__kernel_rem_pio2+0x4e2>
 802320c:	9d05      	ldr	r5, [sp, #20]
 802320e:	ab48      	add	r3, sp, #288	@ 0x120
 8023210:	441d      	add	r5, r3
 8023212:	4644      	mov	r4, r8
 8023214:	2000      	movs	r0, #0
 8023216:	2100      	movs	r1, #0
 8023218:	2c00      	cmp	r4, #0
 802321a:	da35      	bge.n	8023288 <__kernel_rem_pio2+0x5d0>
 802321c:	f1b9 0f00 	cmp.w	r9, #0
 8023220:	d038      	beq.n	8023294 <__kernel_rem_pio2+0x5dc>
 8023222:	4602      	mov	r2, r0
 8023224:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8023228:	9c04      	ldr	r4, [sp, #16]
 802322a:	e9c4 2300 	strd	r2, r3, [r4]
 802322e:	4602      	mov	r2, r0
 8023230:	460b      	mov	r3, r1
 8023232:	e9dd 0148 	ldrd	r0, r1, [sp, #288]	@ 0x120
 8023236:	f7dd f82f 	bl	8000298 <__aeabi_dsub>
 802323a:	ad4a      	add	r5, sp, #296	@ 0x128
 802323c:	2401      	movs	r4, #1
 802323e:	45a0      	cmp	r8, r4
 8023240:	da2b      	bge.n	802329a <__kernel_rem_pio2+0x5e2>
 8023242:	f1b9 0f00 	cmp.w	r9, #0
 8023246:	d002      	beq.n	802324e <__kernel_rem_pio2+0x596>
 8023248:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 802324c:	4619      	mov	r1, r3
 802324e:	9b04      	ldr	r3, [sp, #16]
 8023250:	e9c3 0102 	strd	r0, r1, [r3, #8]
 8023254:	e7a1      	b.n	802319a <__kernel_rem_pio2+0x4e2>
 8023256:	9c05      	ldr	r4, [sp, #20]
 8023258:	ab48      	add	r3, sp, #288	@ 0x120
 802325a:	441c      	add	r4, r3
 802325c:	2000      	movs	r0, #0
 802325e:	2100      	movs	r1, #0
 8023260:	f1b8 0f00 	cmp.w	r8, #0
 8023264:	da09      	bge.n	802327a <__kernel_rem_pio2+0x5c2>
 8023266:	f1b9 0f00 	cmp.w	r9, #0
 802326a:	d002      	beq.n	8023272 <__kernel_rem_pio2+0x5ba>
 802326c:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8023270:	4619      	mov	r1, r3
 8023272:	9b04      	ldr	r3, [sp, #16]
 8023274:	e9c3 0100 	strd	r0, r1, [r3]
 8023278:	e78f      	b.n	802319a <__kernel_rem_pio2+0x4e2>
 802327a:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 802327e:	f7dd f80d 	bl	800029c <__adddf3>
 8023282:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
 8023286:	e7eb      	b.n	8023260 <__kernel_rem_pio2+0x5a8>
 8023288:	e975 2302 	ldrd	r2, r3, [r5, #-8]!
 802328c:	f7dd f806 	bl	800029c <__adddf3>
 8023290:	3c01      	subs	r4, #1
 8023292:	e7c1      	b.n	8023218 <__kernel_rem_pio2+0x560>
 8023294:	4602      	mov	r2, r0
 8023296:	460b      	mov	r3, r1
 8023298:	e7c6      	b.n	8023228 <__kernel_rem_pio2+0x570>
 802329a:	e8f5 2302 	ldrd	r2, r3, [r5], #8
 802329e:	f7dc fffd 	bl	800029c <__adddf3>
 80232a2:	3401      	adds	r4, #1
 80232a4:	e7cb      	b.n	802323e <__kernel_rem_pio2+0x586>
 80232a6:	ed95 7b00 	vldr	d7, [r5]
 80232aa:	ed8d 7b00 	vstr	d7, [sp]
 80232ae:	ed95 7b02 	vldr	d7, [r5, #8]
 80232b2:	e9dd 0100 	ldrd	r0, r1, [sp]
 80232b6:	ec53 2b17 	vmov	r2, r3, d7
 80232ba:	ed8d 7b06 	vstr	d7, [sp, #24]
 80232be:	f7dc ffed 	bl	800029c <__adddf3>
 80232c2:	4602      	mov	r2, r0
 80232c4:	460b      	mov	r3, r1
 80232c6:	4606      	mov	r6, r0
 80232c8:	460f      	mov	r7, r1
 80232ca:	e9dd 0100 	ldrd	r0, r1, [sp]
 80232ce:	f7dc ffe3 	bl	8000298 <__aeabi_dsub>
 80232d2:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80232d6:	f7dc ffe1 	bl	800029c <__adddf3>
 80232da:	f10a 3aff 	add.w	sl, sl, #4294967295	@ 0xffffffff
 80232de:	e9c5 0102 	strd	r0, r1, [r5, #8]
 80232e2:	e9c5 6700 	strd	r6, r7, [r5]
 80232e6:	e76d      	b.n	80231c4 <__kernel_rem_pio2+0x50c>
 80232e8:	ed94 7b00 	vldr	d7, [r4]
 80232ec:	e9d4 ab02 	ldrd	sl, fp, [r4, #8]
 80232f0:	ec51 0b17 	vmov	r0, r1, d7
 80232f4:	4652      	mov	r2, sl
 80232f6:	465b      	mov	r3, fp
 80232f8:	ed8d 7b00 	vstr	d7, [sp]
 80232fc:	f7dc ffce 	bl	800029c <__adddf3>
 8023300:	4602      	mov	r2, r0
 8023302:	460b      	mov	r3, r1
 8023304:	4606      	mov	r6, r0
 8023306:	460f      	mov	r7, r1
 8023308:	e9dd 0100 	ldrd	r0, r1, [sp]
 802330c:	f7dc ffc4 	bl	8000298 <__aeabi_dsub>
 8023310:	4652      	mov	r2, sl
 8023312:	465b      	mov	r3, fp
 8023314:	f7dc ffc2 	bl	800029c <__adddf3>
 8023318:	3d01      	subs	r5, #1
 802331a:	e9c4 0102 	strd	r0, r1, [r4, #8]
 802331e:	e9c4 6700 	strd	r6, r7, [r4]
 8023322:	e755      	b.n	80231d0 <__kernel_rem_pio2+0x518>
 8023324:	e974 2302 	ldrd	r2, r3, [r4, #-8]!
 8023328:	f7dc ffb8 	bl	800029c <__adddf3>
 802332c:	f108 38ff 	add.w	r8, r8, #4294967295	@ 0xffffffff
 8023330:	e758      	b.n	80231e4 <__kernel_rem_pio2+0x52c>
 8023332:	bf00      	nop
 8023334:	f3af 8000 	nop.w
	...
 8023340:	41700000 	.word	0x41700000
 8023344:	3e700000 	.word	0x3e700000
 8023348:	9b04      	ldr	r3, [sp, #16]
 802334a:	9a04      	ldr	r2, [sp, #16]
 802334c:	601f      	str	r7, [r3, #0]
 802334e:	f108 4400 	add.w	r4, r8, #2147483648	@ 0x80000000
 8023352:	605c      	str	r4, [r3, #4]
 8023354:	609d      	str	r5, [r3, #8]
 8023356:	f106 4300 	add.w	r3, r6, #2147483648	@ 0x80000000
 802335a:	60d3      	str	r3, [r2, #12]
 802335c:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8023360:	6110      	str	r0, [r2, #16]
 8023362:	6153      	str	r3, [r2, #20]
 8023364:	e719      	b.n	802319a <__kernel_rem_pio2+0x4e2>
 8023366:	bf00      	nop

08023368 <__kernel_rem_pio2f>:
 8023368:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802336c:	ed2d 8b04 	vpush	{d8-d9}
 8023370:	b0d9      	sub	sp, #356	@ 0x164
 8023372:	4690      	mov	r8, r2
 8023374:	9001      	str	r0, [sp, #4]
 8023376:	4ab9      	ldr	r2, [pc, #740]	@ (802365c <__kernel_rem_pio2f+0x2f4>)
 8023378:	9866      	ldr	r0, [sp, #408]	@ 0x198
 802337a:	f118 0f04 	cmn.w	r8, #4
 802337e:	f852 a020 	ldr.w	sl, [r2, r0, lsl #2]
 8023382:	460f      	mov	r7, r1
 8023384:	f103 3bff 	add.w	fp, r3, #4294967295	@ 0xffffffff
 8023388:	db27      	blt.n	80233da <__kernel_rem_pio2f+0x72>
 802338a:	f1b8 0203 	subs.w	r2, r8, #3
 802338e:	bf48      	it	mi
 8023390:	f108 0204 	addmi.w	r2, r8, #4
 8023394:	10d2      	asrs	r2, r2, #3
 8023396:	1c55      	adds	r5, r2, #1
 8023398:	9967      	ldr	r1, [sp, #412]	@ 0x19c
 802339a:	ed9f 7ab4 	vldr	s14, [pc, #720]	@ 802366c <__kernel_rem_pio2f+0x304>
 802339e:	00e8      	lsls	r0, r5, #3
 80233a0:	eba2 060b 	sub.w	r6, r2, fp
 80233a4:	9002      	str	r0, [sp, #8]
 80233a6:	eba8 05c5 	sub.w	r5, r8, r5, lsl #3
 80233aa:	eb0a 0c0b 	add.w	ip, sl, fp
 80233ae:	ac1c      	add	r4, sp, #112	@ 0x70
 80233b0:	eb01 0e86 	add.w	lr, r1, r6, lsl #2
 80233b4:	2000      	movs	r0, #0
 80233b6:	4560      	cmp	r0, ip
 80233b8:	dd11      	ble.n	80233de <__kernel_rem_pio2f+0x76>
 80233ba:	a91c      	add	r1, sp, #112	@ 0x70
 80233bc:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 80233c0:	f50d 7988 	add.w	r9, sp, #272	@ 0x110
 80233c4:	f04f 0c00 	mov.w	ip, #0
 80233c8:	45d4      	cmp	ip, sl
 80233ca:	dc27      	bgt.n	802341c <__kernel_rem_pio2f+0xb4>
 80233cc:	f8dd e004 	ldr.w	lr, [sp, #4]
 80233d0:	eddf 7aa6 	vldr	s15, [pc, #664]	@ 802366c <__kernel_rem_pio2f+0x304>
 80233d4:	4606      	mov	r6, r0
 80233d6:	2400      	movs	r4, #0
 80233d8:	e016      	b.n	8023408 <__kernel_rem_pio2f+0xa0>
 80233da:	2200      	movs	r2, #0
 80233dc:	e7db      	b.n	8023396 <__kernel_rem_pio2f+0x2e>
 80233de:	42c6      	cmn	r6, r0
 80233e0:	bf5d      	ittte	pl
 80233e2:	f85e 1020 	ldrpl.w	r1, [lr, r0, lsl #2]
 80233e6:	ee07 1a90 	vmovpl	s15, r1
 80233ea:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 80233ee:	eef0 7a47 	vmovmi.f32	s15, s14
 80233f2:	ece4 7a01 	vstmia	r4!, {s15}
 80233f6:	3001      	adds	r0, #1
 80233f8:	e7dd      	b.n	80233b6 <__kernel_rem_pio2f+0x4e>
 80233fa:	ecfe 6a01 	vldmia	lr!, {s13}
 80233fe:	ed96 7a00 	vldr	s14, [r6]
 8023402:	eee6 7a87 	vfma.f32	s15, s13, s14
 8023406:	3401      	adds	r4, #1
 8023408:	455c      	cmp	r4, fp
 802340a:	f1a6 0604 	sub.w	r6, r6, #4
 802340e:	ddf4      	ble.n	80233fa <__kernel_rem_pio2f+0x92>
 8023410:	ece9 7a01 	vstmia	r9!, {s15}
 8023414:	f10c 0c01 	add.w	ip, ip, #1
 8023418:	3004      	adds	r0, #4
 802341a:	e7d5      	b.n	80233c8 <__kernel_rem_pio2f+0x60>
 802341c:	a908      	add	r1, sp, #32
 802341e:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8023422:	9104      	str	r1, [sp, #16]
 8023424:	9967      	ldr	r1, [sp, #412]	@ 0x19c
 8023426:	eddf 8a90 	vldr	s17, [pc, #576]	@ 8023668 <__kernel_rem_pio2f+0x300>
 802342a:	ed9f 9a8e 	vldr	s18, [pc, #568]	@ 8023664 <__kernel_rem_pio2f+0x2fc>
 802342e:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 8023432:	9203      	str	r2, [sp, #12]
 8023434:	4654      	mov	r4, sl
 8023436:	00a2      	lsls	r2, r4, #2
 8023438:	9205      	str	r2, [sp, #20]
 802343a:	aa58      	add	r2, sp, #352	@ 0x160
 802343c:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8023440:	ed12 0a14 	vldr	s0, [r2, #-80]	@ 0xffffffb0
 8023444:	a944      	add	r1, sp, #272	@ 0x110
 8023446:	aa08      	add	r2, sp, #32
 8023448:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 802344c:	4694      	mov	ip, r2
 802344e:	4626      	mov	r6, r4
 8023450:	2e00      	cmp	r6, #0
 8023452:	f1a0 0004 	sub.w	r0, r0, #4
 8023456:	dc4c      	bgt.n	80234f2 <__kernel_rem_pio2f+0x18a>
 8023458:	4628      	mov	r0, r5
 802345a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802345e:	f000 f9f5 	bl	802384c <scalbnf>
 8023462:	eeb0 8a40 	vmov.f32	s16, s0
 8023466:	eeb4 0a00 	vmov.f32	s0, #64	@ 0x3e000000  0.125
 802346a:	ee28 0a00 	vmul.f32	s0, s16, s0
 802346e:	f000 fa53 	bl	8023918 <floorf>
 8023472:	eef2 7a00 	vmov.f32	s15, #32	@ 0x41000000  8.0
 8023476:	eea0 8a67 	vfms.f32	s16, s0, s15
 802347a:	2d00      	cmp	r5, #0
 802347c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8023480:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 8023484:	ee17 9a90 	vmov	r9, s15
 8023488:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802348c:	ee38 8a67 	vsub.f32	s16, s16, s15
 8023490:	dd41      	ble.n	8023516 <__kernel_rem_pio2f+0x1ae>
 8023492:	f104 3cff 	add.w	ip, r4, #4294967295	@ 0xffffffff
 8023496:	a908      	add	r1, sp, #32
 8023498:	f1c5 0e08 	rsb	lr, r5, #8
 802349c:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
 80234a0:	fa46 f00e 	asr.w	r0, r6, lr
 80234a4:	4481      	add	r9, r0
 80234a6:	fa00 f00e 	lsl.w	r0, r0, lr
 80234aa:	1a36      	subs	r6, r6, r0
 80234ac:	f1c5 0007 	rsb	r0, r5, #7
 80234b0:	f841 602c 	str.w	r6, [r1, ip, lsl #2]
 80234b4:	4106      	asrs	r6, r0
 80234b6:	2e00      	cmp	r6, #0
 80234b8:	dd3c      	ble.n	8023534 <__kernel_rem_pio2f+0x1cc>
 80234ba:	f04f 0e00 	mov.w	lr, #0
 80234be:	f109 0901 	add.w	r9, r9, #1
 80234c2:	4670      	mov	r0, lr
 80234c4:	4574      	cmp	r4, lr
 80234c6:	dc68      	bgt.n	802359a <__kernel_rem_pio2f+0x232>
 80234c8:	2d00      	cmp	r5, #0
 80234ca:	dd03      	ble.n	80234d4 <__kernel_rem_pio2f+0x16c>
 80234cc:	2d01      	cmp	r5, #1
 80234ce:	d074      	beq.n	80235ba <__kernel_rem_pio2f+0x252>
 80234d0:	2d02      	cmp	r5, #2
 80234d2:	d07d      	beq.n	80235d0 <__kernel_rem_pio2f+0x268>
 80234d4:	2e02      	cmp	r6, #2
 80234d6:	d12d      	bne.n	8023534 <__kernel_rem_pio2f+0x1cc>
 80234d8:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 80234dc:	ee30 8a48 	vsub.f32	s16, s0, s16
 80234e0:	b340      	cbz	r0, 8023534 <__kernel_rem_pio2f+0x1cc>
 80234e2:	4628      	mov	r0, r5
 80234e4:	9306      	str	r3, [sp, #24]
 80234e6:	f000 f9b1 	bl	802384c <scalbnf>
 80234ea:	9b06      	ldr	r3, [sp, #24]
 80234ec:	ee38 8a40 	vsub.f32	s16, s16, s0
 80234f0:	e020      	b.n	8023534 <__kernel_rem_pio2f+0x1cc>
 80234f2:	ee60 7a28 	vmul.f32	s15, s0, s17
 80234f6:	3e01      	subs	r6, #1
 80234f8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80234fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8023500:	eea7 0ac9 	vfms.f32	s0, s15, s18
 8023504:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8023508:	ecac 0a01 	vstmia	ip!, {s0}
 802350c:	ed90 0a00 	vldr	s0, [r0]
 8023510:	ee37 0a80 	vadd.f32	s0, s15, s0
 8023514:	e79c      	b.n	8023450 <__kernel_rem_pio2f+0xe8>
 8023516:	d105      	bne.n	8023524 <__kernel_rem_pio2f+0x1bc>
 8023518:	1e60      	subs	r0, r4, #1
 802351a:	a908      	add	r1, sp, #32
 802351c:	f851 6020 	ldr.w	r6, [r1, r0, lsl #2]
 8023520:	11f6      	asrs	r6, r6, #7
 8023522:	e7c8      	b.n	80234b6 <__kernel_rem_pio2f+0x14e>
 8023524:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 8023528:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802352c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023530:	da31      	bge.n	8023596 <__kernel_rem_pio2f+0x22e>
 8023532:	2600      	movs	r6, #0
 8023534:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8023538:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802353c:	f040 8098 	bne.w	8023670 <__kernel_rem_pio2f+0x308>
 8023540:	1e60      	subs	r0, r4, #1
 8023542:	2200      	movs	r2, #0
 8023544:	4550      	cmp	r0, sl
 8023546:	da4b      	bge.n	80235e0 <__kernel_rem_pio2f+0x278>
 8023548:	2a00      	cmp	r2, #0
 802354a:	d065      	beq.n	8023618 <__kernel_rem_pio2f+0x2b0>
 802354c:	3c01      	subs	r4, #1
 802354e:	ab08      	add	r3, sp, #32
 8023550:	3d08      	subs	r5, #8
 8023552:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8023556:	2b00      	cmp	r3, #0
 8023558:	d0f8      	beq.n	802354c <__kernel_rem_pio2f+0x1e4>
 802355a:	4628      	mov	r0, r5
 802355c:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 8023560:	f000 f974 	bl	802384c <scalbnf>
 8023564:	1c63      	adds	r3, r4, #1
 8023566:	aa44      	add	r2, sp, #272	@ 0x110
 8023568:	ed9f 7a3f 	vldr	s14, [pc, #252]	@ 8023668 <__kernel_rem_pio2f+0x300>
 802356c:	0099      	lsls	r1, r3, #2
 802356e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8023572:	4623      	mov	r3, r4
 8023574:	2b00      	cmp	r3, #0
 8023576:	f280 80a9 	bge.w	80236cc <__kernel_rem_pio2f+0x364>
 802357a:	4623      	mov	r3, r4
 802357c:	2b00      	cmp	r3, #0
 802357e:	f2c0 80c7 	blt.w	8023710 <__kernel_rem_pio2f+0x3a8>
 8023582:	aa44      	add	r2, sp, #272	@ 0x110
 8023584:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 8023588:	f8df c0d4 	ldr.w	ip, [pc, #212]	@ 8023660 <__kernel_rem_pio2f+0x2f8>
 802358c:	eddf 7a37 	vldr	s15, [pc, #220]	@ 802366c <__kernel_rem_pio2f+0x304>
 8023590:	2000      	movs	r0, #0
 8023592:	1ae2      	subs	r2, r4, r3
 8023594:	e0b1      	b.n	80236fa <__kernel_rem_pio2f+0x392>
 8023596:	2602      	movs	r6, #2
 8023598:	e78f      	b.n	80234ba <__kernel_rem_pio2f+0x152>
 802359a:	f852 1b04 	ldr.w	r1, [r2], #4
 802359e:	b948      	cbnz	r0, 80235b4 <__kernel_rem_pio2f+0x24c>
 80235a0:	b121      	cbz	r1, 80235ac <__kernel_rem_pio2f+0x244>
 80235a2:	f5c1 7180 	rsb	r1, r1, #256	@ 0x100
 80235a6:	f842 1c04 	str.w	r1, [r2, #-4]
 80235aa:	2101      	movs	r1, #1
 80235ac:	f10e 0e01 	add.w	lr, lr, #1
 80235b0:	4608      	mov	r0, r1
 80235b2:	e787      	b.n	80234c4 <__kernel_rem_pio2f+0x15c>
 80235b4:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 80235b8:	e7f5      	b.n	80235a6 <__kernel_rem_pio2f+0x23e>
 80235ba:	f104 3cff 	add.w	ip, r4, #4294967295	@ 0xffffffff
 80235be:	aa08      	add	r2, sp, #32
 80235c0:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 80235c4:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 80235c8:	a908      	add	r1, sp, #32
 80235ca:	f841 202c 	str.w	r2, [r1, ip, lsl #2]
 80235ce:	e781      	b.n	80234d4 <__kernel_rem_pio2f+0x16c>
 80235d0:	f104 3cff 	add.w	ip, r4, #4294967295	@ 0xffffffff
 80235d4:	aa08      	add	r2, sp, #32
 80235d6:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 80235da:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
 80235de:	e7f3      	b.n	80235c8 <__kernel_rem_pio2f+0x260>
 80235e0:	a908      	add	r1, sp, #32
 80235e2:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 80235e6:	3801      	subs	r0, #1
 80235e8:	430a      	orrs	r2, r1
 80235ea:	e7ab      	b.n	8023544 <__kernel_rem_pio2f+0x1dc>
 80235ec:	3201      	adds	r2, #1
 80235ee:	f850 6d04 	ldr.w	r6, [r0, #-4]!
 80235f2:	2e00      	cmp	r6, #0
 80235f4:	d0fa      	beq.n	80235ec <__kernel_rem_pio2f+0x284>
 80235f6:	9905      	ldr	r1, [sp, #20]
 80235f8:	f501 71b0 	add.w	r1, r1, #352	@ 0x160
 80235fc:	eb0d 0001 	add.w	r0, sp, r1
 8023600:	18e6      	adds	r6, r4, r3
 8023602:	a91c      	add	r1, sp, #112	@ 0x70
 8023604:	f104 0c01 	add.w	ip, r4, #1
 8023608:	384c      	subs	r0, #76	@ 0x4c
 802360a:	eb01 0686 	add.w	r6, r1, r6, lsl #2
 802360e:	4422      	add	r2, r4
 8023610:	4562      	cmp	r2, ip
 8023612:	da04      	bge.n	802361e <__kernel_rem_pio2f+0x2b6>
 8023614:	4614      	mov	r4, r2
 8023616:	e70e      	b.n	8023436 <__kernel_rem_pio2f+0xce>
 8023618:	9804      	ldr	r0, [sp, #16]
 802361a:	2201      	movs	r2, #1
 802361c:	e7e7      	b.n	80235ee <__kernel_rem_pio2f+0x286>
 802361e:	9903      	ldr	r1, [sp, #12]
 8023620:	f8dd e004 	ldr.w	lr, [sp, #4]
 8023624:	f851 102c 	ldr.w	r1, [r1, ip, lsl #2]
 8023628:	9105      	str	r1, [sp, #20]
 802362a:	ee07 1a90 	vmov	s15, r1
 802362e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8023632:	2400      	movs	r4, #0
 8023634:	ece6 7a01 	vstmia	r6!, {s15}
 8023638:	eddf 7a0c 	vldr	s15, [pc, #48]	@ 802366c <__kernel_rem_pio2f+0x304>
 802363c:	46b1      	mov	r9, r6
 802363e:	455c      	cmp	r4, fp
 8023640:	dd04      	ble.n	802364c <__kernel_rem_pio2f+0x2e4>
 8023642:	ece0 7a01 	vstmia	r0!, {s15}
 8023646:	f10c 0c01 	add.w	ip, ip, #1
 802364a:	e7e1      	b.n	8023610 <__kernel_rem_pio2f+0x2a8>
 802364c:	ecfe 6a01 	vldmia	lr!, {s13}
 8023650:	ed39 7a01 	vldmdb	r9!, {s14}
 8023654:	3401      	adds	r4, #1
 8023656:	eee6 7a87 	vfma.f32	s15, s13, s14
 802365a:	e7f0      	b.n	802363e <__kernel_rem_pio2f+0x2d6>
 802365c:	0802442c 	.word	0x0802442c
 8023660:	08024400 	.word	0x08024400
 8023664:	43800000 	.word	0x43800000
 8023668:	3b800000 	.word	0x3b800000
 802366c:	00000000 	.word	0x00000000
 8023670:	9b02      	ldr	r3, [sp, #8]
 8023672:	eeb0 0a48 	vmov.f32	s0, s16
 8023676:	eba3 0008 	sub.w	r0, r3, r8
 802367a:	f000 f8e7 	bl	802384c <scalbnf>
 802367e:	ed1f 7a07 	vldr	s14, [pc, #-28]	@ 8023664 <__kernel_rem_pio2f+0x2fc>
 8023682:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8023686:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802368a:	db19      	blt.n	80236c0 <__kernel_rem_pio2f+0x358>
 802368c:	ed5f 7a0a 	vldr	s15, [pc, #-40]	@ 8023668 <__kernel_rem_pio2f+0x300>
 8023690:	ee60 7a27 	vmul.f32	s15, s0, s15
 8023694:	aa08      	add	r2, sp, #32
 8023696:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802369a:	3508      	adds	r5, #8
 802369c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80236a0:	eea7 0ac7 	vfms.f32	s0, s15, s14
 80236a4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80236a8:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80236ac:	ee10 3a10 	vmov	r3, s0
 80236b0:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 80236b4:	ee17 3a90 	vmov	r3, s15
 80236b8:	3401      	adds	r4, #1
 80236ba:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
 80236be:	e74c      	b.n	802355a <__kernel_rem_pio2f+0x1f2>
 80236c0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80236c4:	aa08      	add	r2, sp, #32
 80236c6:	ee10 3a10 	vmov	r3, s0
 80236ca:	e7f6      	b.n	80236ba <__kernel_rem_pio2f+0x352>
 80236cc:	a808      	add	r0, sp, #32
 80236ce:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 80236d2:	9001      	str	r0, [sp, #4]
 80236d4:	ee07 0a90 	vmov	s15, r0
 80236d8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80236dc:	3b01      	subs	r3, #1
 80236de:	ee67 7a80 	vmul.f32	s15, s15, s0
 80236e2:	ee20 0a07 	vmul.f32	s0, s0, s14
 80236e6:	ed62 7a01 	vstmdb	r2!, {s15}
 80236ea:	e743      	b.n	8023574 <__kernel_rem_pio2f+0x20c>
 80236ec:	ecfc 6a01 	vldmia	ip!, {s13}
 80236f0:	ecb5 7a01 	vldmia	r5!, {s14}
 80236f4:	eee6 7a87 	vfma.f32	s15, s13, s14
 80236f8:	3001      	adds	r0, #1
 80236fa:	4550      	cmp	r0, sl
 80236fc:	dc01      	bgt.n	8023702 <__kernel_rem_pio2f+0x39a>
 80236fe:	4282      	cmp	r2, r0
 8023700:	daf4      	bge.n	80236ec <__kernel_rem_pio2f+0x384>
 8023702:	a858      	add	r0, sp, #352	@ 0x160
 8023704:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8023708:	ed42 7a28 	vstr	s15, [r2, #-160]	@ 0xffffff60
 802370c:	3b01      	subs	r3, #1
 802370e:	e735      	b.n	802357c <__kernel_rem_pio2f+0x214>
 8023710:	9b66      	ldr	r3, [sp, #408]	@ 0x198
 8023712:	2b02      	cmp	r3, #2
 8023714:	dc09      	bgt.n	802372a <__kernel_rem_pio2f+0x3c2>
 8023716:	2b00      	cmp	r3, #0
 8023718:	dc2b      	bgt.n	8023772 <__kernel_rem_pio2f+0x40a>
 802371a:	d044      	beq.n	80237a6 <__kernel_rem_pio2f+0x43e>
 802371c:	f009 0007 	and.w	r0, r9, #7
 8023720:	b059      	add	sp, #356	@ 0x164
 8023722:	ecbd 8b04 	vpop	{d8-d9}
 8023726:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802372a:	9b66      	ldr	r3, [sp, #408]	@ 0x198
 802372c:	2b03      	cmp	r3, #3
 802372e:	d1f5      	bne.n	802371c <__kernel_rem_pio2f+0x3b4>
 8023730:	aa30      	add	r2, sp, #192	@ 0xc0
 8023732:	1f0b      	subs	r3, r1, #4
 8023734:	4413      	add	r3, r2
 8023736:	461a      	mov	r2, r3
 8023738:	4620      	mov	r0, r4
 802373a:	2800      	cmp	r0, #0
 802373c:	f1a2 0204 	sub.w	r2, r2, #4
 8023740:	dc52      	bgt.n	80237e8 <__kernel_rem_pio2f+0x480>
 8023742:	4622      	mov	r2, r4
 8023744:	2a01      	cmp	r2, #1
 8023746:	f1a3 0304 	sub.w	r3, r3, #4
 802374a:	dc5d      	bgt.n	8023808 <__kernel_rem_pio2f+0x4a0>
 802374c:	ab30      	add	r3, sp, #192	@ 0xc0
 802374e:	ed5f 7a39 	vldr	s15, [pc, #-228]	@ 802366c <__kernel_rem_pio2f+0x304>
 8023752:	440b      	add	r3, r1
 8023754:	2c01      	cmp	r4, #1
 8023756:	dc67      	bgt.n	8023828 <__kernel_rem_pio2f+0x4c0>
 8023758:	eddd 6a30 	vldr	s13, [sp, #192]	@ 0xc0
 802375c:	ed9d 7a31 	vldr	s14, [sp, #196]	@ 0xc4
 8023760:	2e00      	cmp	r6, #0
 8023762:	d167      	bne.n	8023834 <__kernel_rem_pio2f+0x4cc>
 8023764:	edc7 6a00 	vstr	s13, [r7]
 8023768:	ed87 7a01 	vstr	s14, [r7, #4]
 802376c:	edc7 7a02 	vstr	s15, [r7, #8]
 8023770:	e7d4      	b.n	802371c <__kernel_rem_pio2f+0x3b4>
 8023772:	ab30      	add	r3, sp, #192	@ 0xc0
 8023774:	ed1f 7a43 	vldr	s14, [pc, #-268]	@ 802366c <__kernel_rem_pio2f+0x304>
 8023778:	440b      	add	r3, r1
 802377a:	4622      	mov	r2, r4
 802377c:	2a00      	cmp	r2, #0
 802377e:	da24      	bge.n	80237ca <__kernel_rem_pio2f+0x462>
 8023780:	b34e      	cbz	r6, 80237d6 <__kernel_rem_pio2f+0x46e>
 8023782:	eef1 7a47 	vneg.f32	s15, s14
 8023786:	edc7 7a00 	vstr	s15, [r7]
 802378a:	eddd 7a30 	vldr	s15, [sp, #192]	@ 0xc0
 802378e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8023792:	aa31      	add	r2, sp, #196	@ 0xc4
 8023794:	2301      	movs	r3, #1
 8023796:	429c      	cmp	r4, r3
 8023798:	da20      	bge.n	80237dc <__kernel_rem_pio2f+0x474>
 802379a:	b10e      	cbz	r6, 80237a0 <__kernel_rem_pio2f+0x438>
 802379c:	eef1 7a67 	vneg.f32	s15, s15
 80237a0:	edc7 7a01 	vstr	s15, [r7, #4]
 80237a4:	e7ba      	b.n	802371c <__kernel_rem_pio2f+0x3b4>
 80237a6:	ab30      	add	r3, sp, #192	@ 0xc0
 80237a8:	ed5f 7a50 	vldr	s15, [pc, #-320]	@ 802366c <__kernel_rem_pio2f+0x304>
 80237ac:	440b      	add	r3, r1
 80237ae:	2c00      	cmp	r4, #0
 80237b0:	da05      	bge.n	80237be <__kernel_rem_pio2f+0x456>
 80237b2:	b10e      	cbz	r6, 80237b8 <__kernel_rem_pio2f+0x450>
 80237b4:	eef1 7a67 	vneg.f32	s15, s15
 80237b8:	edc7 7a00 	vstr	s15, [r7]
 80237bc:	e7ae      	b.n	802371c <__kernel_rem_pio2f+0x3b4>
 80237be:	ed33 7a01 	vldmdb	r3!, {s14}
 80237c2:	3c01      	subs	r4, #1
 80237c4:	ee77 7a87 	vadd.f32	s15, s15, s14
 80237c8:	e7f1      	b.n	80237ae <__kernel_rem_pio2f+0x446>
 80237ca:	ed73 7a01 	vldmdb	r3!, {s15}
 80237ce:	3a01      	subs	r2, #1
 80237d0:	ee37 7a27 	vadd.f32	s14, s14, s15
 80237d4:	e7d2      	b.n	802377c <__kernel_rem_pio2f+0x414>
 80237d6:	eef0 7a47 	vmov.f32	s15, s14
 80237da:	e7d4      	b.n	8023786 <__kernel_rem_pio2f+0x41e>
 80237dc:	ecb2 7a01 	vldmia	r2!, {s14}
 80237e0:	3301      	adds	r3, #1
 80237e2:	ee77 7a87 	vadd.f32	s15, s15, s14
 80237e6:	e7d6      	b.n	8023796 <__kernel_rem_pio2f+0x42e>
 80237e8:	edd2 7a00 	vldr	s15, [r2]
 80237ec:	edd2 6a01 	vldr	s13, [r2, #4]
 80237f0:	ee37 7aa6 	vadd.f32	s14, s15, s13
 80237f4:	3801      	subs	r0, #1
 80237f6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80237fa:	ed82 7a00 	vstr	s14, [r2]
 80237fe:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8023802:	edc2 7a01 	vstr	s15, [r2, #4]
 8023806:	e798      	b.n	802373a <__kernel_rem_pio2f+0x3d2>
 8023808:	edd3 7a00 	vldr	s15, [r3]
 802380c:	edd3 6a01 	vldr	s13, [r3, #4]
 8023810:	ee37 7aa6 	vadd.f32	s14, s15, s13
 8023814:	3a01      	subs	r2, #1
 8023816:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802381a:	ed83 7a00 	vstr	s14, [r3]
 802381e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8023822:	edc3 7a01 	vstr	s15, [r3, #4]
 8023826:	e78d      	b.n	8023744 <__kernel_rem_pio2f+0x3dc>
 8023828:	ed33 7a01 	vldmdb	r3!, {s14}
 802382c:	3c01      	subs	r4, #1
 802382e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8023832:	e78f      	b.n	8023754 <__kernel_rem_pio2f+0x3ec>
 8023834:	eef1 6a66 	vneg.f32	s13, s13
 8023838:	eeb1 7a47 	vneg.f32	s14, s14
 802383c:	edc7 6a00 	vstr	s13, [r7]
 8023840:	ed87 7a01 	vstr	s14, [r7, #4]
 8023844:	eef1 7a67 	vneg.f32	s15, s15
 8023848:	e790      	b.n	802376c <__kernel_rem_pio2f+0x404>
 802384a:	bf00      	nop

0802384c <scalbnf>:
 802384c:	ee10 3a10 	vmov	r3, s0
 8023850:	f033 4200 	bics.w	r2, r3, #2147483648	@ 0x80000000
 8023854:	d02b      	beq.n	80238ae <scalbnf+0x62>
 8023856:	f1b2 4fff 	cmp.w	r2, #2139095040	@ 0x7f800000
 802385a:	d302      	bcc.n	8023862 <scalbnf+0x16>
 802385c:	ee30 0a00 	vadd.f32	s0, s0, s0
 8023860:	4770      	bx	lr
 8023862:	f013 4fff 	tst.w	r3, #2139095040	@ 0x7f800000
 8023866:	d123      	bne.n	80238b0 <scalbnf+0x64>
 8023868:	4b24      	ldr	r3, [pc, #144]	@ (80238fc <scalbnf+0xb0>)
 802386a:	eddf 7a25 	vldr	s15, [pc, #148]	@ 8023900 <scalbnf+0xb4>
 802386e:	4298      	cmp	r0, r3
 8023870:	ee20 0a27 	vmul.f32	s0, s0, s15
 8023874:	db17      	blt.n	80238a6 <scalbnf+0x5a>
 8023876:	ee10 3a10 	vmov	r3, s0
 802387a:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802387e:	3a19      	subs	r2, #25
 8023880:	f24c 3150 	movw	r1, #50000	@ 0xc350
 8023884:	4288      	cmp	r0, r1
 8023886:	dd15      	ble.n	80238b4 <scalbnf+0x68>
 8023888:	eddf 7a1e 	vldr	s15, [pc, #120]	@ 8023904 <scalbnf+0xb8>
 802388c:	eddf 6a1e 	vldr	s13, [pc, #120]	@ 8023908 <scalbnf+0xbc>
 8023890:	ee10 3a10 	vmov	r3, s0
 8023894:	eeb0 7a67 	vmov.f32	s14, s15
 8023898:	2b00      	cmp	r3, #0
 802389a:	bfb8      	it	lt
 802389c:	eef0 7a66 	vmovlt.f32	s15, s13
 80238a0:	ee27 0a87 	vmul.f32	s0, s15, s14
 80238a4:	4770      	bx	lr
 80238a6:	eddf 7a19 	vldr	s15, [pc, #100]	@ 802390c <scalbnf+0xc0>
 80238aa:	ee27 0a80 	vmul.f32	s0, s15, s0
 80238ae:	4770      	bx	lr
 80238b0:	0dd2      	lsrs	r2, r2, #23
 80238b2:	e7e5      	b.n	8023880 <scalbnf+0x34>
 80238b4:	4410      	add	r0, r2
 80238b6:	28fe      	cmp	r0, #254	@ 0xfe
 80238b8:	dce6      	bgt.n	8023888 <scalbnf+0x3c>
 80238ba:	2800      	cmp	r0, #0
 80238bc:	dd06      	ble.n	80238cc <scalbnf+0x80>
 80238be:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 80238c2:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 80238c6:	ee00 3a10 	vmov	s0, r3
 80238ca:	4770      	bx	lr
 80238cc:	f110 0f16 	cmn.w	r0, #22
 80238d0:	da09      	bge.n	80238e6 <scalbnf+0x9a>
 80238d2:	eddf 7a0e 	vldr	s15, [pc, #56]	@ 802390c <scalbnf+0xc0>
 80238d6:	eddf 6a0e 	vldr	s13, [pc, #56]	@ 8023910 <scalbnf+0xc4>
 80238da:	ee10 3a10 	vmov	r3, s0
 80238de:	eeb0 7a67 	vmov.f32	s14, s15
 80238e2:	2b00      	cmp	r3, #0
 80238e4:	e7d9      	b.n	802389a <scalbnf+0x4e>
 80238e6:	3019      	adds	r0, #25
 80238e8:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
 80238ec:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
 80238f0:	ed9f 0a08 	vldr	s0, [pc, #32]	@ 8023914 <scalbnf+0xc8>
 80238f4:	ee07 3a90 	vmov	s15, r3
 80238f8:	e7d7      	b.n	80238aa <scalbnf+0x5e>
 80238fa:	bf00      	nop
 80238fc:	ffff3cb0 	.word	0xffff3cb0
 8023900:	4c000000 	.word	0x4c000000
 8023904:	7149f2ca 	.word	0x7149f2ca
 8023908:	f149f2ca 	.word	0xf149f2ca
 802390c:	0da24260 	.word	0x0da24260
 8023910:	8da24260 	.word	0x8da24260
 8023914:	33000000 	.word	0x33000000

08023918 <floorf>:
 8023918:	ee10 3a10 	vmov	r3, s0
 802391c:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 8023920:	3a7f      	subs	r2, #127	@ 0x7f
 8023922:	2a16      	cmp	r2, #22
 8023924:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 8023928:	dc2b      	bgt.n	8023982 <floorf+0x6a>
 802392a:	2a00      	cmp	r2, #0
 802392c:	da12      	bge.n	8023954 <floorf+0x3c>
 802392e:	eddf 7a19 	vldr	s15, [pc, #100]	@ 8023994 <floorf+0x7c>
 8023932:	ee30 0a27 	vadd.f32	s0, s0, s15
 8023936:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802393a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802393e:	dd06      	ble.n	802394e <floorf+0x36>
 8023940:	2b00      	cmp	r3, #0
 8023942:	da24      	bge.n	802398e <floorf+0x76>
 8023944:	2900      	cmp	r1, #0
 8023946:	4b14      	ldr	r3, [pc, #80]	@ (8023998 <floorf+0x80>)
 8023948:	bf08      	it	eq
 802394a:	f04f 4300 	moveq.w	r3, #2147483648	@ 0x80000000
 802394e:	ee00 3a10 	vmov	s0, r3
 8023952:	4770      	bx	lr
 8023954:	4911      	ldr	r1, [pc, #68]	@ (802399c <floorf+0x84>)
 8023956:	4111      	asrs	r1, r2
 8023958:	420b      	tst	r3, r1
 802395a:	d0fa      	beq.n	8023952 <floorf+0x3a>
 802395c:	eddf 7a0d 	vldr	s15, [pc, #52]	@ 8023994 <floorf+0x7c>
 8023960:	ee30 0a27 	vadd.f32	s0, s0, s15
 8023964:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8023968:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802396c:	ddef      	ble.n	802394e <floorf+0x36>
 802396e:	2b00      	cmp	r3, #0
 8023970:	bfbe      	ittt	lt
 8023972:	f44f 0000 	movlt.w	r0, #8388608	@ 0x800000
 8023976:	fa40 f202 	asrlt.w	r2, r0, r2
 802397a:	189b      	addlt	r3, r3, r2
 802397c:	ea23 0301 	bic.w	r3, r3, r1
 8023980:	e7e5      	b.n	802394e <floorf+0x36>
 8023982:	f1b1 4fff 	cmp.w	r1, #2139095040	@ 0x7f800000
 8023986:	d3e4      	bcc.n	8023952 <floorf+0x3a>
 8023988:	ee30 0a00 	vadd.f32	s0, s0, s0
 802398c:	4770      	bx	lr
 802398e:	2300      	movs	r3, #0
 8023990:	e7dd      	b.n	802394e <floorf+0x36>
 8023992:	bf00      	nop
 8023994:	7149f2ca 	.word	0x7149f2ca
 8023998:	bf800000 	.word	0xbf800000
 802399c:	007fffff 	.word	0x007fffff

080239a0 <_init>:
 80239a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80239a2:	bf00      	nop
 80239a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80239a6:	bc08      	pop	{r3}
 80239a8:	469e      	mov	lr, r3
 80239aa:	4770      	bx	lr

080239ac <_fini>:
 80239ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80239ae:	bf00      	nop
 80239b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80239b2:	bc08      	pop	{r3}
 80239b4:	469e      	mov	lr, r3
 80239b6:	4770      	bx	lr
